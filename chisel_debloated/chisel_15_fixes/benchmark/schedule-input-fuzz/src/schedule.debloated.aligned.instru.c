/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker
{
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  int _pos;
};
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
};
struct _job
{
  struct _job *next;
  struct _job *prev;
  int val;
  short priority;
};
typedef struct _job Ele;
struct list
{
  Ele *first;
  Ele *last;
  int mem_count;
};
typedef struct list List;
#pragma merger("0", "/tmp/cil-CCtPIRzp.i", "")
#pragma merger("0", "/tmp/cil-8u09MzPP.i", "")
extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern int fprintf(FILE *__restrict __stream, char const *__restrict __format, ...);
extern int fscanf(FILE *__restrict __stream, char const *__restrict __format, ...) __asm__("__isoc99_fscanf");
extern int malloc();
Ele *new_ele(int new_num)
{
  printf("\nFUNC_CALL;new_ele(int);\n");
printf("\nSTMT_EXEC;;73\n");
Ele *ele;
  printf("\nSTMT_EXEC;;74\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;78\n");
printf("\nFUNC_CALL;malloc();\n");
tmp = malloc(sizeof(Ele));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;79\n");
ele = (Ele *)tmp;


      printf("\nSTMT_EXEC;;82\n");
ele->val = new_num;
    }
    printf("\nSTMT_EXEC;;84\n");
printf("\nFUNC_RETURN;;\n");
return (ele);
  }
printf("\nFUNC_RETURN;;\n");
}
List *new_list(void)
{
  printf("\nFUNC_CALL;new_list();\n");
printf("\nSTMT_EXEC;;89\n");
List *list;
  printf("\nSTMT_EXEC;;90\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;94\n");
printf("\nFUNC_CALL;malloc();\n");
tmp = malloc(sizeof(List));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;95\n");
list = (List *)tmp;



    }
    printf("\nSTMT_EXEC;;100\n");
printf("\nFUNC_RETURN;;\n");
return (list);
  }
printf("\nFUNC_RETURN;;\n");
}
List *append_ele(List *a_list, Ele *a_ele)
{


  printf("\nFUNC_CALL;append_ele(List *,Ele *);\n");
printf("\nSTMT_EXEC;;107\n");
if (!a_list)
  {

    printf("\nSTMT_EXEC;;110\n");
a_list = new_list();

  }
  printf("\nSTMT_EXEC;;113\n");
a_ele->prev = a_list->last;
  printf("\nSTMT_EXEC;;114\n");
if (a_list->last)
  {
    printf("\nSTMT_EXEC;;116\n");
(a_list->last)->next = a_ele;
  }
  else
  {
    printf("\nSTMT_EXEC;;120\n");
a_list->first = a_ele;
  }
  printf("\nSTMT_EXEC;;122\n");
a_list->last = a_ele;
  printf("\nSTMT_EXEC;;123\n");
a_ele->next = (struct _job *)0;
  printf("\nSTMT_EXEC;;124\n");
(a_list->mem_count)++;
  printf("\nSTMT_EXEC;;125\n");
printf("\nFUNC_RETURN;;\n");
return (a_list);



printf("\nFUNC_RETURN;;\n");
}
Ele *find_nth(List *f_list, int n)
{
  printf("\nFUNC_CALL;find_nth(List *,int);\n");
printf("\nSTMT_EXEC;;132\n");
Ele *f_ele;
  printf("\nSTMT_EXEC;;133\n");
int i;

  {




    printf("\nSTMT_EXEC;;140\n");
f_ele = f_list->first;
    printf("\nSTMT_EXEC;;141\n");
i = 1;
    {
      printf("\nSTMT_EXEC;;143\n");
while (1)
      {
        ;

        {
          printf("\nSTMT_EXEC;;148\n");
if (!(i < n))
          {
            printf("\nSTMT_EXEC;;150\n");
goto while_break;
          }
        }








        printf("\nSTMT_EXEC;;161\n");
f_ele = f_ele->next;
        printf("\nSTMT_EXEC;;162\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;166\n");
printf("\nFUNC_RETURN;;\n");
return (f_ele);
  }
printf("\nFUNC_RETURN;;\n");
}
List *del_ele(List *d_list, Ele *d_ele)
{













  printf("\nFUNC_CALL;del_ele(List *,Ele *);\n");
printf("\nSTMT_EXEC;;184\n");
if (d_ele->next)
  {
    printf("\nSTMT_EXEC;;186\n");
(d_ele->next)->prev = d_ele->prev;
  }
  else
  {
    printf("\nSTMT_EXEC;;190\n");
d_list->last = d_ele->prev;
  }
  printf("\nSTMT_EXEC;;192\n");
if (d_ele->prev)
  {
    printf("\nSTMT_EXEC;;194\n");
(d_ele->prev)->next = d_ele->next;
  }
  else
  {
    printf("\nSTMT_EXEC;;198\n");
d_list->first = d_ele->next;
  }
  printf("\nSTMT_EXEC;;200\n");
(d_list->mem_count)--;
  printf("\nSTMT_EXEC;;201\n");
printf("\nFUNC_RETURN;;\n");
return (d_list);













printf("\nFUNC_RETURN;;\n");
}
extern int free();










int alloc_proc_num;
int num_processes;
Ele *cur_proc;
List *prio_queue[4];
List *block_queue;
void schedule(void);
void finish_process(void)
{

  printf("\nFUNC_CALL;finish_process();\n");
{

    printf("\nSTMT_EXEC;;238\n");
schedule();
  }
  printf("\nSTMT_EXEC;;240\n");
if (cur_proc)
  {

    printf("\nSTMT_EXEC;;243\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE *__restrict)stdout, (char const *__restrict)"%d ", cur_proc->val);printf("\nFUNC_RETURN;;\n");







  }
printf("\nFUNC_RETURN;;\n");
}
void finish_all_processes(void)
{
  printf("\nFUNC_CALL;finish_all_processes();\n");
printf("\nSTMT_EXEC;;254\n");
int i;
  printf("\nSTMT_EXEC;;255\n");
int total;

  {
    printf("\nSTMT_EXEC;;258\n");
total = num_processes;
    printf("\nSTMT_EXEC;;259\n");
i = 0;
    {
      printf("\nSTMT_EXEC;;261\n");
while (1)
      {
        ;
        printf("\nSTMT_EXEC;;264\n");
if (!(i < total))
        {
          printf("\nSTMT_EXEC;;266\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;269\n");
finish_process();
          printf("\nSTMT_EXEC;;270\n");
i++;
        }
      }
    while_break: /* CIL Label */;
    }

  }
printf("\nFUNC_RETURN;;\n");
}
void schedule(void)
{
  printf("\nFUNC_CALL;schedule();\n");
printf("\nSTMT_EXEC;;280\n");
int i;

  {
    printf("\nSTMT_EXEC;;283\n");
cur_proc = (Ele *)0;
    printf("\nSTMT_EXEC;;284\n");
i = 3;
    {
      printf("\nSTMT_EXEC;;286\n");
while (1)
      {
        ;
        printf("\nSTMT_EXEC;;289\n");
if (!(i > 0))
        {
          printf("\nSTMT_EXEC;;291\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;293\n");
if ((prio_queue[i])->mem_count > 0)
        {
          {
            printf("\nSTMT_EXEC;;296\n");
cur_proc = (prio_queue[i])->first;
            printf("\nSTMT_EXEC;;297\n");
prio_queue[i] = del_ele(prio_queue[i], cur_proc);
          }
          printf("\nSTMT_EXEC;;299\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
        printf("\nSTMT_EXEC;;301\n");
i--;
      }
    while_break: /* CIL Label */;
    }

  }
printf("\nFUNC_RETURN;;\n");
}
void upgrade_process_prio(int prio, float ratio)
{
  printf("\nFUNC_CALL;upgrade_process_prio(int,float);\n");
printf("\nSTMT_EXEC;;310\n");
int count;
  printf("\nSTMT_EXEC;;311\n");
int n;
  printf("\nSTMT_EXEC;;312\n");
Ele *proc;
  printf("\nSTMT_EXEC;;313\n");
List *src_queue;
  printf("\nSTMT_EXEC;;314\n");
List *dest_queue;

  {




    printf("\nSTMT_EXEC;;321\n");
src_queue = prio_queue[prio];
    printf("\nSTMT_EXEC;;322\n");
dest_queue = prio_queue[prio + 1];
    printf("\nSTMT_EXEC;;323\n");
count = src_queue->mem_count;

    {
      {
        printf("\nSTMT_EXEC;;327\n");
n = (int)((float)count * ratio + (float)1);
        printf("\nSTMT_EXEC;;328\n");
proc = find_nth(src_queue, n);
      }
      printf("\nSTMT_EXEC;;330\n");
if (proc)
      {

        printf("\nSTMT_EXEC;;333\n");
src_queue = del_ele(src_queue, proc);

        printf("\nSTMT_EXEC;;335\n");
dest_queue = append_ele(dest_queue, proc);
      }
    }






  }
printf("\nFUNC_RETURN;;\n");
}
void unblock_process(float ratio)
{
  printf("\nFUNC_CALL;unblock_process(float);\n");
printf("\nSTMT_EXEC;;348\n");
int count;
  printf("\nSTMT_EXEC;;349\n");
int n;
  printf("\nSTMT_EXEC;;350\n");
Ele *proc;
  printf("\nSTMT_EXEC;;351\n");
int prio;

  {
    printf("\nSTMT_EXEC;;354\n");
if (block_queue)
    {
      {
        printf("\nSTMT_EXEC;;357\n");
count = block_queue->mem_count;
        printf("\nSTMT_EXEC;;358\n");
n = (int)((float)count * ratio + (float)1);
        printf("\nSTMT_EXEC;;359\n");
proc = find_nth(block_queue, n);
      }
      printf("\nSTMT_EXEC;;361\n");
if (proc)
      {

        printf("\nSTMT_EXEC;;364\n");
block_queue = del_ele(block_queue, proc);
        printf("\nSTMT_EXEC;;365\n");
prio = (int)proc->priority;
        printf("\nSTMT_EXEC;;366\n");
prio_queue[prio] = append_ele(prio_queue[prio], proc);
      }
    }


  }
printf("\nFUNC_RETURN;;\n");
}
void quantum_expire(void)
{
  printf("\nFUNC_CALL;quantum_expire();\n");
printf("\nSTMT_EXEC;;375\n");
int prio;

  {
    {
      printf("\nSTMT_EXEC;;379\n");
schedule();
    }
    printf("\nSTMT_EXEC;;381\n");
if (cur_proc)
    {

      printf("\nSTMT_EXEC;;384\n");
prio = (int)cur_proc->priority;
      printf("\nSTMT_EXEC;;385\n");
prio_queue[prio] = append_ele(prio_queue[prio], cur_proc);
    }


  }
printf("\nFUNC_RETURN;;\n");
}
void block_process(void)
{

  printf("\nFUNC_CALL;block_process();\n");
{

    printf("\nSTMT_EXEC;;396\n");
schedule();
  }
  printf("\nSTMT_EXEC;;398\n");
if (cur_proc)
  {

    printf("\nSTMT_EXEC;;401\n");
block_queue = append_ele(block_queue, cur_proc);




  }
printf("\nFUNC_RETURN;;\n");
}
Ele *new_process(int prio)
{
  printf("\nFUNC_CALL;new_process(int);\n");
printf("\nSTMT_EXEC;;410\n");
Ele *proc;
  printf("\nSTMT_EXEC;;411\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;415\n");
tmp = alloc_proc_num;
      printf("\nSTMT_EXEC;;416\n");
alloc_proc_num++;
      printf("\nSTMT_EXEC;;417\n");
proc = new_ele(tmp);
      printf("\nSTMT_EXEC;;418\n");
proc->priority = (short)prio;
      printf("\nSTMT_EXEC;;419\n");
num_processes++;
    }
    printf("\nSTMT_EXEC;;421\n");
printf("\nFUNC_RETURN;;\n");
return (proc);
  }
printf("\nFUNC_RETURN;;\n");
}
void add_process(int prio)
{
  printf("\nFUNC_CALL;add_process(int);\n");
printf("\nSTMT_EXEC;;426\n");
Ele *proc;

  {

    printf("\nSTMT_EXEC;;430\n");
proc = new_process(prio);
    printf("\nSTMT_EXEC;;431\n");
prio_queue[prio] = append_ele(prio_queue[prio], proc);


  }
printf("\nFUNC_RETURN;;\n");
}
void init_prio_queue(int prio, int num_proc)
{
  printf("\nFUNC_CALL;init_prio_queue(int,int);\n");
printf("\nSTMT_EXEC;;438\n");
List *queue;
  printf("\nSTMT_EXEC;;439\n");
Ele *proc;
  printf("\nSTMT_EXEC;;440\n");
int i;

  {
    {
      printf("\nSTMT_EXEC;;444\n");
queue = new_list();
      printf("\nSTMT_EXEC;;445\n");
i = 0;
    }
    {
      printf("\nSTMT_EXEC;;448\n");
while (1)
      {
        ;
        printf("\nSTMT_EXEC;;451\n");
if (!(i < num_proc))
        {
          printf("\nSTMT_EXEC;;453\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;456\n");
proc = new_process(prio);
          printf("\nSTMT_EXEC;;457\n");
queue = append_ele(queue, proc);
          printf("\nSTMT_EXEC;;458\n");
i++;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;463\n");
prio_queue[prio] = queue;

  }
printf("\nFUNC_RETURN;;\n");
}










extern int atoi();
void main(int argc, char **argv)
{
  printf("\nFUNC_CALL;main(int,char **);\n");
printf("\nSTMT_EXEC;;480\n");
int command;
  printf("\nSTMT_EXEC;;481\n");
int prio;
  printf("\nSTMT_EXEC;;482\n");
float ratio;
  printf("\nSTMT_EXEC;;483\n");
int status;
  printf("\nSTMT_EXEC;;484\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;487\n");
if (argc < 4)
    {
      {
        printf("\nSTMT_EXEC;;490\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE *__restrict)stdout, (char const *__restrict)"incorrect usage\n");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;492\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {

      printf("\nSTMT_EXEC;;496\n");
prio = 3;
    }
    {
      printf("\nSTMT_EXEC;;499\n");
while (1)
      {
        ;
        printf("\nSTMT_EXEC;;502\n");
if (!(prio >= 1))
        {
          printf("\nSTMT_EXEC;;504\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;507\n");
printf("\nFUNC_CALL;atoi();\n");
tmp = atoi(*(argv + prio));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;508\n");
init_prio_queue(prio, tmp);
          printf("\nSTMT_EXEC;;509\n");
prio--;
        }
      }
    while_break: /* CIL Label */;
    }



    {
      printf("\nSTMT_EXEC;;518\n");
while (1)
      {
        ;
        printf("\nSTMT_EXEC;;521\n");
if (status != -1)
        {




        }
        else
        {
          printf("\nSTMT_EXEC;;530\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;533\n");
if (command == 6)
          {
            printf("\nSTMT_EXEC;;535\n");
goto case_6;
          }
          printf("\nSTMT_EXEC;;537\n");
if (command == 3)
          {
            printf("\nSTMT_EXEC;;539\n");
goto case_3;
          }
          printf("\nSTMT_EXEC;;541\n");
if (command == 5)
          {
            printf("\nSTMT_EXEC;;543\n");
goto case_5;
          }
          printf("\nSTMT_EXEC;;545\n");
if (command == 4)
          {
            printf("\nSTMT_EXEC;;547\n");
goto case_4;
          }
          printf("\nSTMT_EXEC;;549\n");
if (command == 2)
          {
            printf("\nSTMT_EXEC;;551\n");
goto case_2;
          }
          printf("\nSTMT_EXEC;;553\n");
if (command == 1)
          {
            printf("\nSTMT_EXEC;;555\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;557\n");
if (command == 7)
          {
            printf("\nSTMT_EXEC;;559\n");
goto case_7;
          }
          printf("\nSTMT_EXEC;;561\n");
goto switch_break;
        case_6: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;564\n");
finish_process();
        }
          printf("\nSTMT_EXEC;;566\n");
goto switch_break;
        case_3: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;569\n");
block_process();
        }
          printf("\nSTMT_EXEC;;571\n");
goto switch_break;
        case_5: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;574\n");
quantum_expire();
        }
          printf("\nSTMT_EXEC;;576\n");
goto switch_break;
        case_4: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;579\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
fscanf((FILE *__restrict)stdin, (char const *__restrict)"%f", &ratio);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;580\n");
unblock_process(ratio);
        }
          printf("\nSTMT_EXEC;;582\n");
goto switch_break;
        case_2: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;585\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
fscanf((FILE *__restrict)stdin, (char const *__restrict)"%d", &prio);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;586\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
fscanf((FILE *__restrict)stdin, (char const *__restrict)"%f", &ratio);printf("\nFUNC_RETURN;;\n");

        }

          {

















            printf("\nSTMT_EXEC;;607\n");
upgrade_process_prio(prio, ratio);


          }
          printf("\nSTMT_EXEC;;611\n");
goto switch_break;
        case_1: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;614\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
fscanf((FILE *__restrict)stdin, (char const *__restrict)"%d", &prio);printf("\nFUNC_RETURN;;\n");

        }

          {

















            printf("\nSTMT_EXEC;;635\n");
add_process(prio);


          }
          printf("\nSTMT_EXEC;;639\n");
goto switch_break;
        case_7: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;642\n");
finish_all_processes();
        }

        switch_break: /* CIL Label */;
        }
        {
          printf("\nSTMT_EXEC;;648\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
status = fscanf((FILE *__restrict)stdin, (char const *__restrict)"%d", &command);printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break___0: /* CIL Label */;
    }

  }
printf("\nFUNC_RETURN;;\n");
}










































