#include "argv-fuzz-inl.h"
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef int __clockid_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __mode_t mode_t;
typedef __off_t off_t;
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef unsigned long size_t;
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
struct stat
{
  __dev_t st_dev;
  __ino_t st_ino;
  __nlink_t st_nlink;
  __mode_t st_mode;
  __uid_t st_uid;
  __gid_t st_gid;
  int __pad0;
  __dev_t st_rdev;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt_t st_blocks;
  struct timespec st_atim;
  struct timespec st_mtim;
  struct timespec st_ctim;
  __syscall_slong_t __glibc_reserved[3];
};
struct mtop
{
  short mt_op;
  int mt_count;
};
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker
{
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  int _pos;
};
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
};
typedef unsigned long uintmax_t;
struct posix_header
{
  char name[100];
  char mode[8];
  char uid[8];
  char gid[8];
  char size[12];
  char mtime[12];
  char chksum[8];
  char typeflag;
  char linkname[100];
  char magic[6];
  char version[2];
  char uname[32];
  char gname[32];
  char devmajor[8];
  char devminor[8];
  char prefix[155];
};
struct sparse
{
  char offset[12];
  char numbytes[12];
};
struct sparse_header
{
  struct sparse sp[21];
  char isextended;
};
struct oldgnu_header
{
  char unused_pad1[345];
  char atime[12];
  char ctime[12];
  char offset[12];
  char longnames[4];
  char unused_pad2;
  struct sparse sp[4];
  char isextended;
  char realsize[12];
};
struct star_header
{
  char name[100];
  char mode[8];
  char uid[8];
  char gid[8];
  char size[12];
  char mtime[12];
  char chksum[8];
  char typeflag;
  char linkname[100];
  char magic[6];
  char version[2];
  char uname[32];
  char gname[32];
  char devmajor[8];
  char devminor[8];
  char prefix[131];
  char atime[12];
  char ctime[12];
};
struct star_in_header
{
  char fill[345];
  char prefix[1];
  char fill2;
  char fill3[8];
  char isextended;
  struct sparse sp[4];
  char realsize[12];
  char offset[12];
  char atime[12];
  char ctime[12];
  char mfill[8];
  char xmagic[4];
};
struct star_ext_header
{
  struct sparse sp[21];
  char isextended;
};
struct sp_array
{
  off_t offset;
  size_t numbytes;
};
struct tar_stat_info
{
  char *orig_file_name;
  char *file_name;
  int had_trailing_slash;
  char *link_name;
  unsigned int devminor;
  unsigned int devmajor;
  char *uname;
  char *gname;
  struct stat stat;
  unsigned long atime_nsec;
  unsigned long mtime_nsec;
  unsigned long ctime_nsec;
  off_t archive_file_size;
  _Bool is_sparse;
  size_t sparse_map_avail;
  size_t sparse_map_size;
  struct sp_array *sparse_map;
};
union block
{
  char buffer[512];
  struct posix_header header;
  struct star_header star_header;
  struct oldgnu_header oldgnu_header;
  struct sparse_header sparse_header;
  struct star_in_header star_in_header;
  struct star_ext_header star_ext_header;
};
typedef double tarlong;
enum subcommand
{
  UNKNOWN_SUBCOMMAND = 0,
  APPEND_SUBCOMMAND = 1,
  CAT_SUBCOMMAND = 2,
  CREATE_SUBCOMMAND = 3,
  DELETE_SUBCOMMAND = 4,
  DIFF_SUBCOMMAND = 5,
  EXTRACT_SUBCOMMAND = 6,
  LIST_SUBCOMMAND = 7,
  UPDATE_SUBCOMMAND = 8
};
enum access_mode
{
  ACCESS_READ = 0,
  ACCESS_WRITE = 1,
  ACCESS_UPDATE = 2
};
typedef __dev_t dev_t;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct utimbuf
{
  __time_t actime;
  __time_t modtime;
};
enum archive_format
{
  DEFAULT_FORMAT = 0,
  V7_FORMAT = 1,
  OLDGNU_FORMAT = 2,
  USTAR_FORMAT = 3,
  POSIX_FORMAT = 4,
  STAR_FORMAT = 5,
  GNU_FORMAT = 6
};
enum read_header
{
  HEADER_STILL_UNREAD = 0,
  HEADER_SUCCESS = 1,
  HEADER_SUCCESS_EXTENDED = 2,
  HEADER_ZERO_BLOCK = 3,
  HEADER_END_OF_FILE = 4,
  HEADER_FAILURE = 5
};
typedef __ino_t ino_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
struct obstack;
struct obstack;
struct mode_change
{
  char op;
  char flags;
  mode_t affected;
  mode_t value;
  struct mode_change *next;
};
struct name
{
  struct name *next;
  size_t length;
  uintmax_t found_count;
  int isdir;
  char firstch;
  char regexp;
  int change_dir;
  char const *dir_contents;
  char fake;
  char name[1];
};
enum dump_status
{
  dump_status_ok = 0,
  dump_status_short = 1,
  dump_status_fail = 2,
  dump_status_not_implemented = 3
};
struct xheader
{
  struct obstack *stk;
  size_t size;
  char *buffer;
};
struct hash_tuning
{
  float shrink_threshold;
  float shrink_factor;
  float growth_threshold;
  float growth_factor;
  _Bool is_n_buckets;
};
typedef struct hash_tuning Hash_tuning;
struct hash_table;
struct hash_table;
typedef struct hash_table Hash_table;
struct link
{
  dev_t dev;
  ino_t ino;
  size_t nlink;
  char name[1];
};
enum old_files
{
  DEFAULT_OLD_FILES = 0,
  NO_OVERWRITE_DIR_OLD_FILES = 1,
  OVERWRITE_OLD_FILES = 2,
  UNLINK_FIRST_OLD_FILES = 3,
  KEEP_OLD_FILES = 4,
  KEEP_NEWER_FILES = 5
};
enum remove_option
{
  ORDINARY_REMOVE_OPTION = 0,
  RECURSIVE_REMOVE_OPTION = 1,
  WANT_DIRECTORY_REMOVE_OPTION = 2
};
enum permstatus
{
  UNKNOWN_PERMSTATUS = 0,
  ARCHIVED_PERMSTATUS = 1,
  INTERDIR_PERMSTATUS = 2
};
struct delayed_set_stat
{
  struct delayed_set_stat *next;
  struct stat stat_info;
  size_t file_name_len;
  mode_t invert_permissions;
  enum permstatus permstatus;
  _Bool after_symlinks;
  char file_name[1];
};
struct string_list;
struct string_list;
struct delayed_symlink
{
  struct delayed_symlink *next;
  dev_t dev;
  ino_t ino;
  time_t mtime;
  uid_t uid;
  gid_t gid;
  struct string_list *sources;
  char target[1];
};
struct string_list
{
  struct string_list *next;
  char string[1];
};
enum strtol_error
{
  LONGINT_OK = 0,
  LONGINT_OVERFLOW = 1,
  LONGINT_INVALID_SUFFIX_CHAR = 2,
  LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  LONGINT_INVALID = 4
};
typedef enum strtol_error strtol_error;
struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};
struct obstack
{
  long chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  long temp;
  int alignment_mask;
  struct _obstack_chunk *(*chunkfun)(void *, long);
  void (*freefun)(void *, struct _obstack_chunk *);
  void *extra_arg;
  unsigned int use_extra_arg : 1;
  unsigned int maybe_empty_object : 1;
  unsigned int alloc_failed : 1;
};
struct keyword_list
{
  struct keyword_list *next;
  char *pattern;
  char *value;
};
struct xhdr_tab
{
  char const *keyword;
  void (*coder)(struct tar_stat_info const *, char const *, struct xheader *, void *data);
  void (*decoder)(struct tar_stat_info *, char const *);
  _Bool protect;
};
enum children
{
  NO_CHILDREN = 0,
  CHANGED_CHILDREN = 1,
  ALL_CHILDREN = 2
};
struct directory
{
  dev_t device_number;
  ino_t inode_number;
  enum children children;
  _Bool nfs;
  _Bool found;
  char name[1];
};
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long tm_gmtoff;
  char const *tm_zone;
};
enum quoting_style
{
  literal_quoting_style = 0,
  shell_quoting_style = 1,
  shell_always_quoting_style = 2,
  c_quoting_style = 3,
  escape_quoting_style = 4,
  locale_quoting_style = 5,
  clocale_quoting_style = 6
};
struct quoting_options;
struct quoting_options;
enum backup_type
{
  none = 0,
  simple = 1,
  numbered_existing = 2,
  numbered = 3
};
struct saved_cwd
{
  int desc;
  char *name;
};
struct wd
{
  char const *name;
  int saved;
  struct saved_cwd saved_cwd;
};
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
struct group
{
  char *gr_name;
  char *gr_passwd;
  __gid_t gr_gid;
  char **gr_mem;
};
struct exclude;
struct exclude;
typedef int __daddr_t;
typedef void (*__sighandler_t)(int);
struct mtget
{
  long mt_type;
  long mt_resid;
  long mt_dsreg;
  long mt_gstat;
  long mt_erreg;
  __daddr_t mt_fileno;
  __daddr_t mt_blkno;
};
struct tar_sparse_file;
struct tar_sparse_file;
enum sparse_scan_state
{
  scan_begin = 0,
  scan_block = 1,
  scan_end = 2
};
struct tar_sparse_optab
{
  _Bool (*init)(struct tar_sparse_file *);
  _Bool (*done)(struct tar_sparse_file *);
  _Bool (*sparse_member_p)(struct tar_sparse_file *);
  _Bool (*dump_header)(struct tar_sparse_file *);
  _Bool (*fixup_header)(struct tar_sparse_file *);
  _Bool (*decode_header)(struct tar_sparse_file *);
  _Bool (*scan_block)(struct tar_sparse_file *, enum sparse_scan_state, void *);
  _Bool (*dump_region)(struct tar_sparse_file *, size_t);
  _Bool (*extract_region)(struct tar_sparse_file *, size_t);
};
struct tar_sparse_file
{
  int fd;
  size_t dumped_size;
  struct tar_stat_info *stat_info;
  struct tar_sparse_optab *optab;
  void *closure;
};
enum oldgnu_add_status
{
  add_ok = 0,
  add_finish = 1,
  add_fail = 2
};
union __anonunion_56
{
  int __in;
  int __i;
};
union __anonunion_57
{
  int __in;
  int __i;
};
union __anonunion_58
{
  int __in;
  int __i;
};
union __anonunion_59
{
  int __in;
  int __i;
};
union __anonunion_60
{
  int __in;
  int __i;
};
union __anonunion_61
{
  int __in;
  int __i;
};
union __anonunion_62
{
  int __in;
  int __i;
};
union __anonunion_63
{
  int __in;
  int __i;
};
union __anonunion_64
{
  int __in;
  int __i;
};
union __anonunion_65
{
  int __in;
  int __i;
};
union __anonunion_66
{
  int __in;
  int __i;
};
union __anonunion_67
{
  int __in;
  int __i;
};
struct option
{
  char const *name;
  int has_arg;
  int *flag;
  int val;
};
struct fmttab
{
  char const *name;
  enum archive_format fmt;
};
typedef void *iconv_t;
struct dirent
{
  __ino_t d_ino;
  __off_t d_off;
  unsigned short d_reclen;
  unsigned char d_type;
  char d_name[256];
};
struct __dirstream;
struct __dirstream;
typedef struct __dirstream DIR;
struct patopts
{
  char const *pattern;
  int options;
};
struct exclude
{
  struct patopts *exclude;
  size_t exclude_alloc;
  size_t exclude_count;
};
struct __anonstruct_textint_27
{
  long value;
  size_t digits;
};
typedef struct __anonstruct_textint_27 textint;
struct __anonstruct_table_28
{
  char const *name;
  int type;
  int value;
};
typedef struct __anonstruct_table_28 table;
struct __anonstruct_parser_control_31
{
  char const *input;
  long day_ordinal;
  int day_number;
  int local_isdst;
  long time_zone;
  int meridian;
  textint year;
  long month;
  long day;
  long hour;
  long minutes;
  struct timespec seconds;
  long rel_year;
  long rel_month;
  long rel_day;
  long rel_hour;
  long rel_minutes;
  long rel_seconds;
  long rel_ns;
  _Bool timespec_seen;
  size_t dates_seen;
  size_t days_seen;
  size_t local_zones_seen;
  size_t rels_seen;
  size_t times_seen;
  size_t zones_seen;
  table local_time_zone_table[3];
};
typedef struct __anonstruct_parser_control_31 parser_control;
union __anonunion_YYSTYPE_32
{
  long intval;
  textint textintval;
  struct timespec timespec;
};
typedef union __anonunion_YYSTYPE_32 YYSTYPE;
typedef long __suseconds_t;
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};
typedef struct timezone *__restrict __timezone_ptr_t;
struct hash_entry
{
  void *data;
  struct hash_entry *next;
};
typedef long ptrdiff_t;
struct hash_table
{
  struct hash_entry *bucket;
  struct hash_entry const *bucket_limit;
  size_t n_buckets;
  size_t n_buckets_used;
  size_t n_entries;
  Hash_tuning const *tuning;
  size_t (*hasher)(void const *, size_t);
  _Bool (*comparator)(void const *, void const *);
  void (*data_freer)(void *);
  struct hash_entry *free_entry_list;
};
struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
  char int_p_cs_precedes;
  char int_p_sep_by_space;
  char int_n_cs_precedes;
  char int_n_sep_by_space;
  char int_p_sign_posn;
  char int_n_sign_posn;
};
typedef int wchar_t;
union __anonunion___value_23
{
  unsigned int __wch;
  char __wchb[4];
};
struct __anonstruct___mbstate_t_22
{
  int __count;
  union __anonunion___value_23 __value;
};
typedef struct __anonstruct___mbstate_t_22 __mbstate_t;
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
struct quoting_options
{
  enum quoting_style style;
  int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
};
struct slotvec
{
  size_t size;
  char *val;
};
/* #pragma merger("0","000.buffer.o.i","") */
extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2), __leaf__)) memcpy)(void *__restrict __dest, void const *__restrict __src, size_t __n);
extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1), __leaf__)) memset)(void *__s, int __c, size_t __n);
extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1), __leaf__)) memchr)(void const *__s, int __c, size_t __n) __attribute__((__pure__));
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1, 2), __leaf__)) strcpy)(char *__restrict __dest, char const *__restrict __src);
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1, 2), __leaf__)) strcat)(char *__restrict __dest, char const *__restrict __src);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s, int __c) __attribute__((__pure__));
extern __attribute__((__nothrow__)) size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s) __attribute__((__pure__));
extern __attribute__((__nothrow__)) int *(__attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
extern int(__attribute__((__nonnull__(1))) open)(char const *__file, int __oflag, ...);
extern int(__attribute__((__nonnull__(1))) creat)(char const *__file, mode_t __mode);
extern __attribute__((__nothrow__)) __off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset, int __whence);
extern int close(int __fd);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) ioctl)(int __fd, unsigned long __request, ...);
extern __attribute__((__nothrow__)) void(__attribute__((__leaf__)) free)(void *__ptr);
extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) valloc)(size_t __size) __attribute__((__malloc__));
extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__)) abort)(void);
extern int system(char const *__command);
extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;
extern int fclose(FILE *__stream);
extern int fflush_unlocked(FILE *__stream);
extern FILE *fopen(char const *__restrict __filename, char const *__restrict __modes);
extern int fprintf(FILE *__restrict __stream, char const *__restrict __format, ...);
extern __attribute__((__nothrow__)) int sprintf(char *__restrict __s, char const *__restrict __format, ...);
extern int fscanf(FILE *__restrict __stream, char const *__restrict __format, ...);
extern int fputc_unlocked(int __c, FILE *__stream);
extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) ferror_unlocked)(FILE *__stream);
extern __attribute__((__nothrow__)) time_t(__attribute__((__leaf__)) time)(time_t *__timer);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id, struct timespec *__tp);
int strip_trailing_slashes(char *path);
extern void error(int __status, int __errnum, char const *__format, ...);
void *xmalloc(size_t n);
char *xstrdup(char const *string);
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) gettext)(char const *__msgid) __attribute__((__format_arg__(1)));
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) ngettext)(char const *__msgid1, char const *__msgid2, unsigned long __n) __attribute__((__format_arg__(1), __format_arg__(2)));
extern int fnmatch(char const *__pattern, char const *__name, int __flags);
char *human_readable(uintmax_t n, char *buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size);
char *quotearg_colon(char const *arg);
char const *quote_n(int n, char const *name);
char const *quote(char const *name);
size_t safe_read(int fd, void *buf, size_t count);
enum subcommand subcommand_option;
int blocking_factor;
size_t record_size;
_Bool backup_option;
_Bool checkpoint_option;
char const *use_compress_program_option;
_Bool force_local_option;
char const *info_script_option;
_Bool multi_volume_option;
_Bool read_full_records_option;
char const *rsh_command_option;
tarlong tape_length_option;
_Bool to_stdout_option;
_Bool totals_option;
int verbose_option;
_Bool verify_option;
char const *volno_file_option;
char const *volume_label_option;
int archive;
_Bool dev_null_output;
struct timespec start_timespec;
struct tar_stat_info current_stat_info;
char const **archive_name_array;
int archive_names;
char const **archive_name_cursor;
char const *index_file_name;
enum access_mode access_mode;
FILE *stdlis;
char *save_name;
off_t save_sizeleft;
off_t save_totsize;
_Bool write_archive_to_stdout;
size_t available_space_after(union block *pointer);
off_t current_block_ordinal(void);
void close_archive(void);
void closeout_volume_number(void);
union block *find_next_block(void);
void flush_read(void);
void flush_write(void);
void flush_archive(void);
void init_volume_number(void);
void open_archive(enum access_mode wanted_access);
void print_total_written(void);
void reset_eof(void);
void set_next_block_after(union block *block);
void clear_read_error_count(void);
void xclose(int fd);
__attribute__((__noreturn__)) void archive_write_error(ssize_t status);
void archive_read_error(void);
void finish_header(struct tar_stat_info *st, union block *header, off_t block_ordinal);
void off_to_chars(off_t v, char *p, size_t s);
void time_to_chars(time_t v, char *p, size_t s);
_Bool now_verifying;
void verify_volume(void);
__attribute__((__noreturn__)) void fatal_exit(void);
char *stringify_uintmax_t_backwards(uintmax_t o___0, char *buf);
off_t off_from_header(char const *p, size_t s);
uintmax_t uintmax_from_header(char const *p, size_t s);
void assign_string(char **string, char const *value);
_Bool maybe_backup_file(char const *path, int this_is_the_archive);
void undo_last_backup(void);
void close_error(char const *name);
void close_warn(char const *name);
void open_error(char const *name);
__attribute__((__noreturn__)) void open_fatal(char const *name);
void open_warn(char const *name);
void read_error(char const *name);
void write_error(char const *name);
__attribute__((__noreturn__)) void write_fatal_details(char const *name, ssize_t status, size_t size);
char *safer_name_suffix(char const *file_name, _Bool link_target);
void tar_stat_destroy(struct tar_stat_info *st);
char *output_start;
void sys_detect_dev_null_output(void);
void sys_save_archive_dev_ino(void);
void sys_drain_input_pipe(void);
void sys_wait_for_child(pid_t child_pid___0);
void sys_spawn_shell(void);
pid_t sys_child_open_for_compress(void);
pid_t sys_child_open_for_uncompress(void);
size_t sys_write_archive_buffer(void);
_Bool sys_get_archive_stat(void);
char *rmt_path__;
int rmt_open__(char const *path, int open_mode, int bias, char const *remote_shell);
int rmt_close__(int handle);
size_t rmt_read__(int handle, char *buffer___2, size_t length);
off_t rmt_lseek__(int handle, off_t offset, int whence);
int rmt_ioctl__(int handle, int operation, char *argument);
static tarlong prev_written;
static tarlong bytes_written;
union block *record_start;
union block *record_end;
union block *current_block;
off_t records_read;
off_t records_written;
static off_t record_start_block;
static void backspace_output(void);
static _Bool new_volume(enum access_mode mode);
static pid_t child_pid;
static int read_error_count;
static int hit_eof;
static int checkpoint;
_Bool time_to_start_writing;
static int volno = 1;
static int global_volno = 1;
static char *real_s_name;
static off_t real_s_totsize;
static off_t real_s_sizeleft;
void clear_read_error_count(void)
{

  printf("\nFUNC_CALL;clear_read_error_count();\n");
{
    printf("\nSTMT_EXEC;;917\n");
read_error_count = 0;
    printf("\nSTMT_EXEC;;918\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void print_total_written(void)
{
  printf("\nFUNC_CALL;print_total_written();\n");
printf("\nSTMT_EXEC;;923\n");
tarlong written;
  printf("\nSTMT_EXEC;;924\n");
char bytes[sizeof(tarlong) * 8UL];
  printf("\nSTMT_EXEC;;925\n");
char abbr[((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) * 17UL - 16UL) + 3UL) + 1UL];
  printf("\nSTMT_EXEC;;926\n");
char rate[((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) * 17UL - 16UL) + 3UL) + 1UL];
  printf("\nSTMT_EXEC;;927\n");
double seconds;
  printf("\nSTMT_EXEC;;928\n");
int human_opts;
  printf("\nSTMT_EXEC;;929\n");
struct timespec now;
  printf("\nSTMT_EXEC;;930\n");
time_t tmp;
  printf("\nSTMT_EXEC;;931\n");
int tmp___0;
  printf("\nSTMT_EXEC;;932\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;933\n");
char const *tmp___2;
  printf("\nSTMT_EXEC;;934\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;935\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;936\n");
void *__cil_tmp14;
  printf("\nSTMT_EXEC;;937\n");
void *__cil_tmp15;
  printf("\nSTMT_EXEC;;938\n");
void *__cil_tmp16;
  printf("\nSTMT_EXEC;;939\n");
char *__cil_tmp17;
  printf("\nSTMT_EXEC;;940\n");
char *__cil_tmp18;
  printf("\nSTMT_EXEC;;941\n");
char *__cil_tmp19;
  printf("\nSTMT_EXEC;;942\n");
char *__cil_tmp20;

  {
    {
      printf("\nSTMT_EXEC;;946\n");
written = prev_written + bytes_written;
      printf("\nSTMT_EXEC;;947\n");
human_opts = 240;
      printf("\nSTMT_EXEC;;948\n");
printf("\nFUNC_CALL;clock_gettime(clockid_t,struct timespec *);\n");
tmp___0 = clock_gettime(0, &now);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;950\n");
if (tmp___0 == 0)
    {
      printf("\nSTMT_EXEC;;952\n");
seconds = (double)(now.tv_sec - start_timespec.tv_sec) + (double)(now.tv_nsec - start_timespec.tv_nsec) / 1e9;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;957\n");
printf("\nFUNC_CALL;time(time_t *);\n");
tmp = time((time_t *)0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;958\n");
seconds = (double)(tmp - start_timespec.tv_sec);
      }
    }
    {
      printf("\nSTMT_EXEC;;962\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(bytes), (char const * /* __restrict  */) "%.0f", written);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;964\n");
if ((double)0 < seconds)
    {
      printf("\nSTMT_EXEC;;966\n");
if (written / seconds < (tarlong)0xffffffffffffffffUL)
      {
        {
          printf("\nSTMT_EXEC;;969\n");
tmp___1 = human_readable((uintmax_t)(written / seconds), rate, human_opts, (uintmax_t)1, (uintmax_t)1);
          printf("\nSTMT_EXEC;;970\n");
tmp___2 = (char const *)tmp___1;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;975\n");
tmp___2 = "?";
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;980\n");
tmp___2 = "?";
    }
    {
      printf("\nSTMT_EXEC;;983\n");
tmp___3 = human_readable((uintmax_t)written, abbr, human_opts, (uintmax_t)1, (uintmax_t)1);
      printf("\nSTMT_EXEC;;984\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Total bytes written: %s (%s, %s/s)\n");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;985\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */)tmp___4, bytes, tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;987\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
off_t current_block_ordinal(void)
{

  printf("\nFUNC_CALL;current_block_ordinal();\n");
{
    printf("\nSTMT_EXEC;;994\n");
printf("\nFUNC_RETURN;;\n");
return (record_start_block + (current_block - record_start));
  }
printf("\nFUNC_RETURN;;\n");
}
void reset_eof(void)
{

  printf("\nFUNC_CALL;reset_eof();\n");
{
    printf("\nSTMT_EXEC;;1001\n");
if (hit_eof)
    {
      printf("\nSTMT_EXEC;;1003\n");
hit_eof = 0;
      printf("\nSTMT_EXEC;;1004\n");
current_block = record_start;
      printf("\nSTMT_EXEC;;1005\n");
record_end = record_start + blocking_factor;
      printf("\nSTMT_EXEC;;1006\n");
access_mode = (enum access_mode)1;
    }
    printf("\nSTMT_EXEC;;1008\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}

union block *find_next_block(void)
{

  printf("\nFUNC_CALL;find_next_block();\n");
{
    printf("\nSTMT_EXEC;;1016\n");
if ((unsigned long)current_block == (unsigned long)record_end)
    {
      printf("\nSTMT_EXEC;;1018\n");
if (hit_eof)
      {
        printf("\nSTMT_EXEC;;1020\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)0);
      }
      {
        printf("\nSTMT_EXEC;;1023\n");
flush_archive();
      }
      printf("\nSTMT_EXEC;;1025\n");
if ((unsigned long)current_block == (unsigned long)record_end)
      {
        printf("\nSTMT_EXEC;;1027\n");
hit_eof = 1;
        printf("\nSTMT_EXEC;;1028\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)0);
      }
    }
    printf("\nSTMT_EXEC;;1031\n");
printf("\nFUNC_RETURN;;\n");
return (current_block);
  }











printf("\nFUNC_RETURN;;\n");
}
void set_next_block_after(union block *block)
{

  printf("\nFUNC_CALL;set_next_block_after(union block *);\n");
{
    {
      printf("\nSTMT_EXEC;;1050\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;1053\n");
if (!((unsigned long)block >= (unsigned long)current_block))
        {
          printf("\nSTMT_EXEC;;1055\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;1057\n");
current_block++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;1061\n");
if ((unsigned long)current_block > (unsigned long)record_end)
    {
      {
        printf("\nSTMT_EXEC;;1064\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;1067\n");
printf("\nFUNC_RETURN;;\n");
return;
  }






printf("\nFUNC_RETURN;;\n");
}
size_t available_space_after(union block *pointer)
{

  printf("\nFUNC_CALL;available_space_after(union block *);\n");
{
    printf("\nSTMT_EXEC;;1080\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)(record_end->buffer - pointer->buffer));
  }
printf("\nFUNC_RETURN;;\n");
}
void xclose(int fd)
{
  printf("\nFUNC_CALL;xclose(int);\n");
printf("\nSTMT_EXEC;;1085\n");
char *tmp;
  printf("\nSTMT_EXEC;;1086\n");
int tmp___0;
  printf("\nSTMT_EXEC;;1087\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;1091\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___0 = close(fd);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;1093\n");
if (tmp___0 != 0)
    {
      {
        printf("\nSTMT_EXEC;;1096\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("(pipe)");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1097\n");
close_error((char const *)tmp);
      }
    }
    printf("\nSTMT_EXEC;;1100\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool check_label_pattern(union block *label)
{
  printf("\nFUNC_CALL;check_label_pattern(union block *);\n");
printf("\nSTMT_EXEC;;1105\n");
char *string;
  printf("\nSTMT_EXEC;;1106\n");
_Bool result;
  printf("\nSTMT_EXEC;;1107\n");
void *tmp;
  printf("\nSTMT_EXEC;;1108\n");
int tmp___0;
  printf("\nSTMT_EXEC;;1109\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;1110\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;1111\n");
int tmp___3;
  printf("\nSTMT_EXEC;;1112\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;1113\n");
char *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;1117\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp = memchr((void const *)(label->header.name), '\000', sizeof(label->header.name));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;1119\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;1121\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;1124\n");
printf("\nFUNC_CALL;fnmatch(const char *,const char *,int);\n");
tmp___0 = fnmatch(volume_label_option, (char const *)(label->header.name), 0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;1126\n");
if (tmp___0 == 0)
    {
      printf("\nSTMT_EXEC;;1128\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    printf("\nSTMT_EXEC;;1130\n");
if (!multi_volume_option)
    {
      printf("\nSTMT_EXEC;;1132\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;1135\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen(volume_label_option);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;1136\n");
tmp___2 = xmalloc((tmp___1 + sizeof(" Volume [1-9]*")) + 1UL);
      printf("\nSTMT_EXEC;;1137\n");
string = (char *)tmp___2;
      printf("\nSTMT_EXEC;;1138\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)string, (char const * /* __restrict  */)volume_label_option);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;1139\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)string, (char const * /* __restrict  */) " Volume [1-9]*");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;1140\n");
printf("\nFUNC_CALL;fnmatch(const char *,const char *,int);\n");
tmp___3 = fnmatch((char const *)string, (char const *)(label->header.name), 0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;1141\n");
result = (_Bool)(tmp___3 == 0);
      printf("\nSTMT_EXEC;;1142\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)string);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;1144\n");
printf("\nFUNC_RETURN;;\n");
return (result);
  }
printf("\nFUNC_RETURN;;\n");
}

void open_archive(enum access_mode wanted_access)
{
  printf("\nFUNC_CALL;open_archive(enum access_mode);\n");
printf("\nSTMT_EXEC;;1150\n");
int backed_up_flag;
  printf("\nSTMT_EXEC;;1151\n");
char *tmp;
  printf("\nSTMT_EXEC;;1152\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;1153\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;1154\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;1155\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;1156\n");
int tmp___4;
  printf("\nSTMT_EXEC;;1157\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;1158\n");
int tmp___7;
  printf("\nSTMT_EXEC;;1159\n");
int tmp___8;
  printf("\nSTMT_EXEC;;1160\n");
void *tmp___9;
  printf("\nSTMT_EXEC;;1161\n");
int tmp___11;
  printf("\nSTMT_EXEC;;1162\n");
int tmp___12;
  printf("\nSTMT_EXEC;;1163\n");
void *tmp___13;
  printf("\nSTMT_EXEC;;1164\n");
int tmp___15;
  printf("\nSTMT_EXEC;;1165\n");
int tmp___16;
  printf("\nSTMT_EXEC;;1166\n");
void *tmp___17;
  printf("\nSTMT_EXEC;;1167\n");
int tmp___19;
  printf("\nSTMT_EXEC;;1168\n");
int tmp___20;
  printf("\nSTMT_EXEC;;1169\n");
void *tmp___21;
  printf("\nSTMT_EXEC;;1170\n");
int tmp___22;
  printf("\nSTMT_EXEC;;1171\n");
int saved_errno;
  printf("\nSTMT_EXEC;;1172\n");
int *tmp___23;
  printf("\nSTMT_EXEC;;1173\n");
int *tmp___24;
  printf("\nSTMT_EXEC;;1174\n");
_Bool tmp___25;
  printf("\nSTMT_EXEC;;1175\n");
union block *label;
  printf("\nSTMT_EXEC;;1176\n");
union block *tmp___26;
  printf("\nSTMT_EXEC;;1177\n");
char const *tmp___27;
  printf("\nSTMT_EXEC;;1178\n");
char *tmp___28;
  printf("\nSTMT_EXEC;;1179\n");
char const *tmp___29;
  printf("\nSTMT_EXEC;;1180\n");
char const *tmp___30;
  printf("\nSTMT_EXEC;;1181\n");
char *tmp___31;
  printf("\nSTMT_EXEC;;1182\n");
_Bool tmp___32;
  printf("\nSTMT_EXEC;;1183\n");
unsigned int tmp___33;
  printf("\nSTMT_EXEC;;1184\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;1185\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;1186\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;1187\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;1188\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;1189\n");
char *__cil_tmp41;
  printf("\nSTMT_EXEC;;1190\n");
char *__cil_tmp42;

  {
    printf("\nSTMT_EXEC;;1193\n");
backed_up_flag = 0;
    printf("\nSTMT_EXEC;;1194\n");
if (index_file_name)
    {
      {
        printf("\nSTMT_EXEC;;1197\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
stdlis = fopen((char const * /* __restrict  */)index_file_name, (char const * /* __restrict  */) "w");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;1199\n");
if (!stdlis)
      {
        {
          printf("\nSTMT_EXEC;;1202\n");
open_error(index_file_name);
        }
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;1208\n");
if (to_stdout_option)
      {
        printf("\nSTMT_EXEC;;1210\n");
stdlis = stderr;
      }
      else




















      {
        printf("\nSTMT_EXEC;;1234\n");
stdlis = stdout;
      }
    }
    printf("\nSTMT_EXEC;;1237\n");
if (record_size == 0UL)
    {
      {
        printf("\nSTMT_EXEC;;1240\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Invalid value for record_size");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1241\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1242\n");
fatal_exit();
      }
    }
    printf("\nSTMT_EXEC;;1245\n");
if (archive_names == 0)
    {
      {
        printf("\nSTMT_EXEC;;1248\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("No archive name given");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1249\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1250\n");
fatal_exit();
      }
    }
    {
      printf("\nSTMT_EXEC;;1254\n");
tar_stat_destroy(&current_stat_info);
      printf("\nSTMT_EXEC;;1255\n");
save_name = (char *)0;
      printf("\nSTMT_EXEC;;1256\n");
real_s_name = (char *)0;
    }
    printf("\nSTMT_EXEC;;1258\n");
if (multi_volume_option)
    {
      {
        printf("\nSTMT_EXEC;;1261\n");
printf("\nFUNC_CALL;valloc(size_t);\n");
tmp___1 = valloc(record_size + 1024UL);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1262\n");
record_start = (union block *)tmp___1;
      }
      printf("\nSTMT_EXEC;;1264\n");
if (record_start)
      {
        printf("\nSTMT_EXEC;;1266\n");
record_start += 2;
      }
    }
    else
    {
      {

        printf("\nSTMT_EXEC;;1273\n");
printf("\nFUNC_CALL;valloc(size_t);\n");
tmp___2 = valloc(record_size);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1274\n");
record_start = (union block *)tmp___2;
      }
    }
    printf("\nSTMT_EXEC;;1277\n");
if (!record_start)
    {
      {
        printf("\nSTMT_EXEC;;1280\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Cannot allocate memory for blocking factor %d");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1281\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, blocking_factor);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;1282\n");
fatal_exit();
      }
    }
    printf("\nSTMT_EXEC;;1285\n");
current_block = record_start;
    printf("\nSTMT_EXEC;;1286\n");
record_end = record_start + blocking_factor;
    printf("\nSTMT_EXEC;;1287\n");
if ((unsigned int)wanted_access == 2U)
    {
      printf("\nSTMT_EXEC;;1289\n");
tmp___33 = 0U;
    }
    else
    {
      printf("\nSTMT_EXEC;;1293\n");
tmp___33 = (unsigned int)wanted_access;
    }
    printf("\nSTMT_EXEC;;1295\n");
access_mode = (enum access_mode)tmp___33;
    printf("\nSTMT_EXEC;;1296\n");
if (use_compress_program_option)
    {
      {
        printf("\nSTMT_EXEC;;1299\n");
if ((unsigned int)wanted_access == 0U)
        {
          printf("\nSTMT_EXEC;;1301\n");
goto case_0;
        }
        printf("\nSTMT_EXEC;;1303\n");
if ((unsigned int)wanted_access == 1U)
        {
          printf("\nSTMT_EXEC;;1305\n");
goto case_1;
        }
        printf("\nSTMT_EXEC;;1307\n");
if ((unsigned int)wanted_access == 2U)
        {
          printf("\nSTMT_EXEC;;1309\n");
goto case_2;
        }
        printf("\nSTMT_EXEC;;1311\n");
goto switch_break;
      case_0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;1314\n");
child_pid = sys_child_open_for_uncompress();
        printf("\nSTMT_EXEC;;1315\n");
read_full_records_option = (_Bool)0;
      }
        printf("\nSTMT_EXEC;;1317\n");
goto switch_break;
      case_1: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;1320\n");
child_pid = sys_child_open_for_compress();
      }
        printf("\nSTMT_EXEC;;1322\n");
goto switch_break;
      case_2: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;1325\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;1327\n");
goto switch_break;
      switch_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;1330\n");
if ((unsigned int)wanted_access == 1U)
      {
        {
          printf("\nSTMT_EXEC;;1333\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___4 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;1335\n");
if (tmp___4 == 0)
        {
          printf("\nSTMT_EXEC;;1337\n");
stdlis = stderr;
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;1344\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___22 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;1346\n");
if (tmp___22 == 0)
      {
        printf("\nSTMT_EXEC;;1348\n");
read_full_records_option = (_Bool)1;
        printf("\nSTMT_EXEC;;1349\n");
if (verify_option)
        {
          {
            printf("\nSTMT_EXEC;;1352\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("Cannot verify stdin/stdout archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1353\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___5);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1354\n");
fatal_exit();
          }
        }
        {
          printf("\nSTMT_EXEC;;1358\n");
if ((unsigned int)wanted_access == 0U)
          {
            printf("\nSTMT_EXEC;;1360\n");
goto case_0___0;
          }
          printf("\nSTMT_EXEC;;1362\n");
if ((unsigned int)wanted_access == 1U)
          {
            printf("\nSTMT_EXEC;;1364\n");
goto case_1___0;
          }
          printf("\nSTMT_EXEC;;1366\n");
if ((unsigned int)wanted_access == 2U)
          {
            printf("\nSTMT_EXEC;;1368\n");
goto case_2___0;
          }
          printf("\nSTMT_EXEC;;1370\n");
goto switch_break___0;
        case_0___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;1372\n");
archive = 0;
}

          printf("\nSTMT_EXEC;;1373\n");
goto switch_break___0;
        case_1___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;1375\n");
archive = 1;
}

          printf("\nSTMT_EXEC;;1376\n");
stdlis = stderr;
          printf("\nSTMT_EXEC;;1377\n");
goto switch_break___0;
        case_2___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;1379\n");
archive = 0;
}

          printf("\nSTMT_EXEC;;1380\n");
stdlis = stderr;
          printf("\nSTMT_EXEC;;1381\n");
write_archive_to_stdout = (_Bool)1;
          printf("\nSTMT_EXEC;;1382\n");
goto switch_break___0;
        switch_break___0: /* CIL Label */;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;1388\n");
if (verify_option)
        {
          printf("\nSTMT_EXEC;;1390\n");
if (!force_local_option)
          {
            {
              printf("\nSTMT_EXEC;;1393\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;1395\n");
if (rmt_path__)
            {
              printf("\nSTMT_EXEC;;1397\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
              {
                {
                  printf("\nSTMT_EXEC;;1400\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___9 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;1402\n");
if (tmp___9)
                {
                  {
                    printf("\nSTMT_EXEC;;1405\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___8 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;1406\n");
archive = tmp___8;
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;1412\n");
tmp___7 = rmt_open__(*(archive_name_array + 0), 66, 1 << 30, rsh_command_option);
                    printf("\nSTMT_EXEC;;1413\n");
archive = tmp___7;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;1420\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___8 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;1421\n");
archive = tmp___8;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;1428\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___8 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;1429\n");
archive = tmp___8;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;1436\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___8 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;1437\n");
archive = tmp___8;
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;1444\n");
if ((unsigned int)wanted_access == 0U)
            {
              printf("\nSTMT_EXEC;;1446\n");
goto case_0___1;
            }
            printf("\nSTMT_EXEC;;1448\n");
if ((unsigned int)wanted_access == 1U)
            {
              printf("\nSTMT_EXEC;;1450\n");
goto case_1___1;
            }
            printf("\nSTMT_EXEC;;1452\n");
if ((unsigned int)wanted_access == 2U)
            {
              printf("\nSTMT_EXEC;;1454\n");
goto case_2___1;
            }
            printf("\nSTMT_EXEC;;1456\n");
goto switch_break___1;
          case_0___1: /* CIL Label */
            {
printf("\nSTMT_EXEC;;1458\n");
if (!force_local_option)
            {
              {
                printf("\nSTMT_EXEC;;1461\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;1463\n");
if (rmt_path__)
              {
                printf("\nSTMT_EXEC;;1465\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
                {
                  {
                    printf("\nSTMT_EXEC;;1468\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___13 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;1470\n");
if (tmp___13)
                  {
                    {
                      printf("\nSTMT_EXEC;;1473\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___12 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;1474\n");
archive = tmp___12;
                    }
                  }
                  else
                  {
                    {
                      printf("\nSTMT_EXEC;;1480\n");
tmp___11 = rmt_open__(*(archive_name_array + 0), 0, 1 << 30, rsh_command_option);
                      printf("\nSTMT_EXEC;;1481\n");
archive = tmp___11;
                    }
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;1488\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___12 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;1489\n");
archive = tmp___12;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;1496\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___12 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;1497\n");
archive = tmp___12;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;1504\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___12 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;1505\n");
archive = tmp___12;
              }
            }
}

            printf("\nSTMT_EXEC;;1508\n");
goto switch_break___1;
          case_1___1: /* CIL Label */
            {
printf("\nSTMT_EXEC;;1510\n");
if (backup_option)
            {
              {
                printf("\nSTMT_EXEC;;1513\n");
maybe_backup_file(*(archive_name_array + 0), 1);
                printf("\nSTMT_EXEC;;1514\n");
backed_up_flag = 1;
              }
            }
}

            printf("\nSTMT_EXEC;;1517\n");
if (!force_local_option)
            {
              {
                printf("\nSTMT_EXEC;;1520\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;1522\n");
if (rmt_path__)
              {
                printf("\nSTMT_EXEC;;1524\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
                {
                  {
                    printf("\nSTMT_EXEC;;1527\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___17 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;1529\n");
if (tmp___17)
                  {
                    {
                      printf("\nSTMT_EXEC;;1532\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___16 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;1533\n");
archive = tmp___16;
                    }
                  }
                  else
                  {
                    {
                      printf("\nSTMT_EXEC;;1539\n");
tmp___15 = rmt_open__(*(archive_name_array + 0), 65, 1 << 30, rsh_command_option);
                      printf("\nSTMT_EXEC;;1540\n");
archive = tmp___15;
                    }
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;1547\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___16 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;1548\n");
archive = tmp___16;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;1555\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___16 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;1556\n");
archive = tmp___16;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;1563\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___16 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;1564\n");
archive = tmp___16;
              }
            }
            printf("\nSTMT_EXEC;;1567\n");
goto switch_break___1;
          case_2___1: /* CIL Label */
            {
printf("\nSTMT_EXEC;;1569\n");
if (!force_local_option)
            {
              {
                printf("\nSTMT_EXEC;;1572\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;1574\n");
if (rmt_path__)
              {
                printf("\nSTMT_EXEC;;1576\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
                {
                  {
                    printf("\nSTMT_EXEC;;1579\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___21 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;1581\n");
if (tmp___21)
                  {
                    {
                      printf("\nSTMT_EXEC;;1584\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;1585\n");
archive = tmp___20;
                    }
                  }
                  else
                  {
                    {
                      printf("\nSTMT_EXEC;;1591\n");
tmp___19 = rmt_open__(*(archive_name_array + 0), 66, 1 << 30, rsh_command_option);
                      printf("\nSTMT_EXEC;;1592\n");
archive = tmp___19;
                    }
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;1599\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;1600\n");
archive = tmp___20;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;1607\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;1608\n");
archive = tmp___20;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;1615\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___20 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;1616\n");
archive = tmp___20;
              }
            }
}

            printf("\nSTMT_EXEC;;1619\n");
goto switch_break___1;
          switch_break___1: /* CIL Label */;
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;1625\n");
if (archive < 0)
    {
      printf("\nSTMT_EXEC;;1627\n");
goto _L;
    }
    else
    {
      printf("\nSTMT_EXEC;;1631\n");
if (!(archive >= 1 << 30))
      {
        {
          printf("\nSTMT_EXEC;;1634\n");
tmp___25 = sys_get_archive_stat();
        }
        printf("\nSTMT_EXEC;;1636\n");
if (!tmp___25)
        {
        _L:
        {
          printf("\nSTMT_EXEC;;1640\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___23 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;1641\n");
saved_errno = *tmp___23;
        }
          printf("\nSTMT_EXEC;;1643\n");
if (backed_up_flag)
          {
            {
              printf("\nSTMT_EXEC;;1646\n");
undo_last_backup();
            }
          }
          {
            printf("\nSTMT_EXEC;;1650\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___24 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1651\n");
*tmp___24 = saved_errno;
            printf("\nSTMT_EXEC;;1652\n");
open_fatal(*(archive_name_array + 0));
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;1658\n");
sys_detect_dev_null_output();
      printf("\nSTMT_EXEC;;1659\n");
sys_save_archive_dev_ino();
    }
    {
      printf("\nSTMT_EXEC;;1662\n");
if ((unsigned int)wanted_access == 2U)
      {
        printf("\nSTMT_EXEC;;1664\n");
goto case_2___2;
      }
      printf("\nSTMT_EXEC;;1666\n");
if ((unsigned int)wanted_access == 0U)
      {
        printf("\nSTMT_EXEC;;1668\n");
goto case_0___2;
      }
      printf("\nSTMT_EXEC;;1670\n");
if ((unsigned int)wanted_access == 1U)
      {
        printf("\nSTMT_EXEC;;1672\n");
goto case_1___2;
      }
      printf("\nSTMT_EXEC;;1674\n");
goto switch_break___2;
    case_2___2: /* CIL Label */
      {
printf("\nSTMT_EXEC;;1676\n");
records_written = (off_t)0;
}

    case_0___2: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;1679\n");
records_read = (off_t)0;



      printf("\nSTMT_EXEC;;1683\n");
record_end = record_start;
      printf("\nSTMT_EXEC;;1684\n");
find_next_block();
    }
      printf("\nSTMT_EXEC;;1686\n");
if (volume_label_option)
      {
        {
          printf("\nSTMT_EXEC;;1689\n");
tmp___26 = find_next_block();
          printf("\nSTMT_EXEC;;1690\n");
label = tmp___26;
        }
        printf("\nSTMT_EXEC;;1692\n");
if (!label)
        {
          {
            printf("\nSTMT_EXEC;;1695\n");
tmp___27 = quote(volume_label_option);
            printf("\nSTMT_EXEC;;1696\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___28 = gettext("Archive not labeled to match %s");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1697\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___28, tmp___27);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1698\n");
fatal_exit();
          }
        }
        {
          printf("\nSTMT_EXEC;;1702\n");
tmp___32 = check_label_pattern(label);
        }
        printf("\nSTMT_EXEC;;1704\n");
if (!tmp___32)
        {
          {
            printf("\nSTMT_EXEC;;1707\n");
tmp___29 = quote_n(1, volume_label_option);
            printf("\nSTMT_EXEC;;1708\n");
tmp___30 = quote_n(0, (char const *)(label->header.name));
            printf("\nSTMT_EXEC;;1709\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___31 = gettext("Volume %s does not match %s");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1710\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___31, tmp___30, tmp___29);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;1711\n");
fatal_exit();
          }
        }
      }
      printf("\nSTMT_EXEC;;1715\n");
goto switch_break___2;

    case_1___2: /* CIL Label */
      {
printf("\nSTMT_EXEC;;1718\n");
records_written = (off_t)0;
}

      printf("\nSTMT_EXEC;;1719\n");
if (volume_label_option)
      {
        {
          printf("\nSTMT_EXEC;;1722\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)record_start, 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;1724\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;1727\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(record_start->header.name), (char const * /* __restrict  */) "%s Volume 1", volume_label_option);printf("\nFUNC_RETURN;;\n");

          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;1733\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(record_start->header.name), (char const * /* __restrict  */)volume_label_option);printf("\nFUNC_RETURN;;\n");

          }
        }
        {
          printf("\nSTMT_EXEC;;1737\n");
assign_string(&current_stat_info.file_name, (char const *)(record_start->header.name));
          printf("\nSTMT_EXEC;;1738\n");
current_stat_info.had_trailing_slash = strip_trailing_slashes(current_stat_info.file_name);
          printf("\nSTMT_EXEC;;1739\n");
record_start->header.typeflag = (char)'V';
          printf("\nSTMT_EXEC;;1740\n");
time_to_chars(start_timespec.tv_sec, record_start->header.mtime, sizeof(record_start->header.mtime));
          printf("\nSTMT_EXEC;;1741\n");
finish_header(&current_stat_info, record_start, (off_t)-1);
        }
      }
      printf("\nSTMT_EXEC;;1744\n");
goto switch_break___2;
    switch_break___2: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;1747\n");
printf("\nFUNC_RETURN;;\n");
return;


















































































































































































































































































































































































































































































































  }
printf("\nFUNC_RETURN;;\n");
}
void flush_write(void)
{
  printf("\nFUNC_CALL;flush_write();\n");
printf("\nSTMT_EXEC;;2250\n");
int copy_back;
  printf("\nSTMT_EXEC;;2251\n");
ssize_t status;
  printf("\nSTMT_EXEC;;2252\n");
char *tmp;
  printf("\nSTMT_EXEC;;2253\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;2254\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;2255\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;2256\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;2257\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;2258\n");
int *tmp___5;
  printf("\nSTMT_EXEC;;2259\n");
_Bool tmp___6;
  printf("\nSTMT_EXEC;;2260\n");
int tmp___7;
  printf("\nSTMT_EXEC;;2261\n");
size_t tmp___8;
  printf("\nSTMT_EXEC;;2262\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;2263\n");
char *__cil_tmp14;
  printf("\nSTMT_EXEC;;2264\n");
char *__cil_tmp15;

  {
    printf("\nSTMT_EXEC;;2267\n");
if (checkpoint_option)
    {
      printf("\nSTMT_EXEC;;2269\n");
checkpoint++;
      printf("\nSTMT_EXEC;;2270\n");
if (!(checkpoint % 10))
      {
        {
          printf("\nSTMT_EXEC;;2273\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Write checkpoint %d");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;2274\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, checkpoint);printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    printf("\nSTMT_EXEC;;2278\n");
if (tape_length_option)
    {
      printf("\nSTMT_EXEC;;2280\n");
if (tape_length_option <= bytes_written)
      {
        {
          printf("\nSTMT_EXEC;;2283\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;2284\n");
*tmp___0 = 28;
          printf("\nSTMT_EXEC;;2285\n");
status = (ssize_t)0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;2290\n");
goto _L___0;
      }
    }
    else
    {
    _L___0: /* CIL Label */
      {
printf("\nSTMT_EXEC;;2296\n");
if (dev_null_output)
      {
        printf("\nSTMT_EXEC;;2298\n");
status = (ssize_t)record_size;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;2303\n");
tmp___1 = sys_write_archive_buffer();
          printf("\nSTMT_EXEC;;2304\n");
status = (ssize_t)tmp___1;
        }
      }
}

    }
    printf("\nSTMT_EXEC;;2308\n");
if ((size_t)status != record_size)
    {
      printf("\nSTMT_EXEC;;2310\n");
if (!multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;2313\n");
archive_write_error(status);
        }
      }
    }
    printf("\nSTMT_EXEC;;2317\n");
if (status > 0L)
    {
      printf("\nSTMT_EXEC;;2319\n");
records_written++;
      printf("\nSTMT_EXEC;;2320\n");
bytes_written += (tarlong)status;
    }
    printf("\nSTMT_EXEC;;2322\n");
if ((size_t)status == record_size)
    {
      printf("\nSTMT_EXEC;;2324\n");
if (multi_volume_option)
      {
        printf("\nSTMT_EXEC;;2326\n");
if (save_name)
        {
          {
            printf("\nSTMT_EXEC;;2329\n");
tmp___2 = safer_name_suffix((char const *)save_name, (_Bool)0);
            printf("\nSTMT_EXEC;;2330\n");
assign_string(&real_s_name, (char const *)tmp___2);
            printf("\nSTMT_EXEC;;2331\n");
real_s_totsize = save_totsize;
            printf("\nSTMT_EXEC;;2332\n");
real_s_sizeleft = save_sizeleft;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;2338\n");
assign_string(&real_s_name, (char const *)0);
            printf("\nSTMT_EXEC;;2339\n");
real_s_totsize = (off_t)0;
            printf("\nSTMT_EXEC;;2340\n");
real_s_sizeleft = (off_t)0;
          }
        }
      }
      printf("\nSTMT_EXEC;;2344\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;2346\n");
if (status < 0L)
    {
      {
        printf("\nSTMT_EXEC;;2349\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;2351\n");
if (*tmp___3 != 28)
      {
        {
          printf("\nSTMT_EXEC;;2354\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;2356\n");
if (*tmp___4 != 5)
        {
          {
            printf("\nSTMT_EXEC;;2359\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___5 = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;2361\n");
if (*tmp___5 != 6)
          {
            {
              printf("\nSTMT_EXEC;;2364\n");
archive_write_error(status);
            }
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;2371\n");
tmp___6 = new_volume((enum access_mode)1);
    }
    printf("\nSTMT_EXEC;;2373\n");
if (!tmp___6)
    {
      printf("\nSTMT_EXEC;;2375\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;2377\n");
if (totals_option)
    {
      printf("\nSTMT_EXEC;;2379\n");
prev_written += bytes_written;
    }
    printf("\nSTMT_EXEC;;2381\n");
bytes_written = (tarlong)0;
    printf("\nSTMT_EXEC;;2382\n");
if (volume_label_option)
    {
      printf("\nSTMT_EXEC;;2384\n");
if (real_s_name)
      {
        printf("\nSTMT_EXEC;;2386\n");
copy_back = 2;
        printf("\nSTMT_EXEC;;2387\n");
record_start -= 2;
      }
      else
      {
        printf("\nSTMT_EXEC;;2391\n");
goto _L___1;
      }
    }
    else
    {
    _L___1: /* CIL Label */
      {
printf("\nSTMT_EXEC;;2397\n");
if (volume_label_option)
      {
        printf("\nSTMT_EXEC;;2399\n");
copy_back = 1;
        printf("\nSTMT_EXEC;;2400\n");
record_start--;
      }
      else
      {
        printf("\nSTMT_EXEC;;2404\n");
if (real_s_name)
        {
          printf("\nSTMT_EXEC;;2406\n");
copy_back = 1;
          printf("\nSTMT_EXEC;;2407\n");
record_start--;
        }
        else
        {
          printf("\nSTMT_EXEC;;2411\n");
copy_back = 0;
        }
      }
}

    }
    printf("\nSTMT_EXEC;;2415\n");
if (volume_label_option)
    {
      {
        printf("\nSTMT_EXEC;;2418\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)record_start, 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2419\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(record_start->header.name), (char const * /* __restrict  */) "%s Volume %d", volume_label_option, volno);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2420\n");
time_to_chars(start_timespec.tv_sec, record_start->header.mtime, sizeof(record_start->header.mtime));
        printf("\nSTMT_EXEC;;2421\n");
record_start->header.typeflag = (char)'V';
        printf("\nSTMT_EXEC;;2422\n");
finish_header(&current_stat_info, record_start, (off_t)-1);
      }
    }
    printf("\nSTMT_EXEC;;2425\n");
if (real_s_name)
    {
      printf("\nSTMT_EXEC;;2427\n");
if (volume_label_option)
      {
        printf("\nSTMT_EXEC;;2429\n");
record_start++;
      }
      {
        printf("\nSTMT_EXEC;;2432\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)record_start, 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2433\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(record_start->header.name), (char const * /* __restrict  */)real_s_name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2434\n");
record_start->header.typeflag = (char)'M';
        printf("\nSTMT_EXEC;;2435\n");
off_to_chars(real_s_sizeleft, record_start->header.size, sizeof(record_start->header.size));
        printf("\nSTMT_EXEC;;2436\n");
off_to_chars(real_s_totsize - real_s_sizeleft, record_start->oldgnu_header.offset, sizeof(record_start->oldgnu_header.offset));
        printf("\nSTMT_EXEC;;2437\n");
tmp___7 = verbose_option;
        printf("\nSTMT_EXEC;;2438\n");
verbose_option = 0;
        printf("\nSTMT_EXEC;;2439\n");
finish_header(&current_stat_info, record_start, (off_t)-1);
        printf("\nSTMT_EXEC;;2440\n");
verbose_option = tmp___7;
      }
      printf("\nSTMT_EXEC;;2442\n");
if (volume_label_option)
      {
        printf("\nSTMT_EXEC;;2444\n");
record_start--;
      }
    }
    {
      printf("\nSTMT_EXEC;;2448\n");
tmp___8 = sys_write_archive_buffer();
      printf("\nSTMT_EXEC;;2449\n");
status = (ssize_t)tmp___8;
    }
    printf("\nSTMT_EXEC;;2451\n");
if ((size_t)status != record_size)
    {
      {
        printf("\nSTMT_EXEC;;2454\n");
archive_write_error(status);
      }
    }
    printf("\nSTMT_EXEC;;2457\n");
bytes_written += (tarlong)status;
    printf("\nSTMT_EXEC;;2458\n");
if (copy_back)
    {
      {
        printf("\nSTMT_EXEC;;2461\n");
record_start += copy_back;
        printf("\nSTMT_EXEC;;2462\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)current_block, (void const * /* __restrict  */)((record_start + blocking_factor) - copy_back), (size_t)(copy_back * 512));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2463\n");
current_block += copy_back;
      }
      printf("\nSTMT_EXEC;;2465\n");
if (real_s_sizeleft >= (off_t)(copy_back * 512))
      {
        printf("\nSTMT_EXEC;;2467\n");
real_s_sizeleft -= (off_t)(copy_back * 512);
      }
      else
      {
        printf("\nSTMT_EXEC;;2471\n");
if (((real_s_sizeleft + 512L) - 1L) / 512L <= (off_t)copy_back)
        {
          {
            printf("\nSTMT_EXEC;;2474\n");
assign_string(&real_s_name, (char const *)0);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;2480\n");
tmp___9 = safer_name_suffix((char const *)save_name, (_Bool)0);
            printf("\nSTMT_EXEC;;2481\n");
assign_string(&real_s_name, (char const *)tmp___9);
            printf("\nSTMT_EXEC;;2482\n");
real_s_sizeleft = save_sizeleft;
            printf("\nSTMT_EXEC;;2483\n");
real_s_totsize = save_totsize;
          }
        }
      }
      printf("\nSTMT_EXEC;;2487\n");
copy_back = 0;
    }
    printf("\nSTMT_EXEC;;2489\n");
printf("\nFUNC_RETURN;;\n");
return;


































































































































































































  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void archive_write_error(ssize_t status);
void archive_write_error(ssize_t status)
{
  printf("\nFUNC_CALL;archive_write_error(ssize_t);\n");
printf("\nSTMT_EXEC;;2689\n");
int e;
  printf("\nSTMT_EXEC;;2690\n");
int *tmp;
  printf("\nSTMT_EXEC;;2691\n");
int *tmp___0;

  {
    printf("\nSTMT_EXEC;;2694\n");
if (totals_option)
    {
      {
        printf("\nSTMT_EXEC;;2697\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2698\n");
e = *tmp;
        printf("\nSTMT_EXEC;;2699\n");
print_total_written();
        printf("\nSTMT_EXEC;;2700\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2701\n");
*tmp___0 = e;
      }
    }
    {
      printf("\nSTMT_EXEC;;2705\n");
write_fatal_details(*archive_name_cursor, status, record_size);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void archive_read_error(void)
{
  printf("\nFUNC_CALL;archive_read_error();\n");
printf("\nSTMT_EXEC;;2711\n");
char *tmp;
  printf("\nSTMT_EXEC;;2712\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;2713\n");
int tmp___1;
  printf("\nSTMT_EXEC;;2714\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;2715\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;2719\n");
read_error(*archive_name_cursor);
    }
    printf("\nSTMT_EXEC;;2721\n");
if (record_start_block == 0L)
    {
      {
        printf("\nSTMT_EXEC;;2724\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("At beginning of tape, quitting now");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2725\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2726\n");
fatal_exit();
      }
    }
    printf("\nSTMT_EXEC;;2729\n");
tmp___1 = read_error_count;
    printf("\nSTMT_EXEC;;2730\n");
read_error_count++;
    printf("\nSTMT_EXEC;;2731\n");
if (tmp___1 > 10)
    {
      {
        printf("\nSTMT_EXEC;;2734\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("Too many errors, quitting");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2735\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;2736\n");
fatal_exit();
      }
    }
    printf("\nSTMT_EXEC;;2739\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void short_read(size_t status)
{
  printf("\nFUNC_CALL;short_read(size_t);\n");
printf("\nSTMT_EXEC;;2744\n");
size_t left;
  printf("\nSTMT_EXEC;;2745\n");
char *more;
  printf("\nSTMT_EXEC;;2746\n");
size_t tmp;
  printf("\nSTMT_EXEC;;2747\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;2748\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;2749\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;2750\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;2751\n");
unsigned long rest;
  printf("\nSTMT_EXEC;;2752\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;2753\n");
unsigned long rsize;
  printf("\nSTMT_EXEC;;2754\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;2755\n");
void *__cil_tmp13;
  printf("\nSTMT_EXEC;;2756\n");
char *__cil_tmp14;

  {
    printf("\nSTMT_EXEC;;2759\n");
more = record_start->buffer + status;
    printf("\nSTMT_EXEC;;2760\n");
left = record_size - status;
    {
      printf("\nSTMT_EXEC;;2762\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;2765\n");
if (!(left % 512UL != 0UL))
        {
          printf("\nSTMT_EXEC;;2767\n");
if (left)
          {
            printf("\nSTMT_EXEC;;2769\n");
if (status)
            {
              printf("\nSTMT_EXEC;;2771\n");
if (!read_full_records_option)
              {
                printf("\nSTMT_EXEC;;2773\n");
goto while_break;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;2778\n");
goto while_break;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;2783\n");
goto while_break;
          }
        }
        printf("\nSTMT_EXEC;;2786\n");
if (status)
        {
          {
            printf("\nSTMT_EXEC;;2789\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;2792\n");
if (archive >= 1 << 30)
              {
                {
                  printf("\nSTMT_EXEC;;2795\n");
tmp = rmt_read__(archive - (1 << 30), more, left);
                  printf("\nSTMT_EXEC;;2796\n");
status = tmp;
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;2802\n");
tmp___0 = safe_read(archive, (void *)more, left);
                  printf("\nSTMT_EXEC;;2803\n");
status = tmp___0;
                }
              }
              printf("\nSTMT_EXEC;;2806\n");
if (!(status == 0xffffffffffffffffUL))
              {
                printf("\nSTMT_EXEC;;2808\n");
goto while_break___0;
              }
              {
                printf("\nSTMT_EXEC;;2811\n");
archive_read_error();
              }
            }
          while_break___0: /* CIL Label */;
          }
        }
        printf("\nSTMT_EXEC;;2817\n");
if (status == 0UL)
        {
          {
            printf("\nSTMT_EXEC;;2820\n");
tmp___1 = stringify_uintmax_t_backwards(record_size - left, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
            printf("\nSTMT_EXEC;;2821\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Read %s bytes from %s");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;2822\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, tmp___1, *archive_name_cursor);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;2824\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;2826\n");
if (!read_full_records_option)
        {
          {
            printf("\nSTMT_EXEC;;2829\n");
rest = record_size - left;
            printf("\nSTMT_EXEC;;2830\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___3 = ngettext("Unaligned block (%lu byte) in archive", "Unaligned block (%lu bytes) in archive", rest);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;2831\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, rest);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;2832\n");
fatal_exit();
          }
        }
        printf("\nSTMT_EXEC;;2835\n");
left -= status;
        printf("\nSTMT_EXEC;;2836\n");
more += status;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;2840\n");
if (!read_full_records_option)
    {
      printf("\nSTMT_EXEC;;2842\n");
if (verbose_option > 1)
      {
        printf("\nSTMT_EXEC;;2844\n");
if (record_start_block == 0L)
        {
          printf("\nSTMT_EXEC;;2846\n");
if (status != 0UL)
          {
            {
              printf("\nSTMT_EXEC;;2849\n");
rsize = (record_size - left) / 512UL;
              printf("\nSTMT_EXEC;;2850\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___4 = ngettext("Record size = %lu block", "Record size = %lu blocks", rsize);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;2851\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4, rsize);printf("\nFUNC_RETURN;;\n");

            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;2857\n");
record_end = record_start + (record_size - left) / 512UL;
    printf("\nSTMT_EXEC;;2858\n");
records_read++;
    printf("\nSTMT_EXEC;;2859\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void flush_read(void)
{
  printf("\nFUNC_CALL;flush_read();\n");
printf("\nSTMT_EXEC;;2864\n");
size_t status;
  printf("\nSTMT_EXEC;;2865\n");
char *tmp;
  printf("\nSTMT_EXEC;;2866\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;2867\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;2868\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;2869\n");
union block *cursor;
  printf("\nSTMT_EXEC;;2870\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;2871\n");
_Bool tmp___4;
  printf("\nSTMT_EXEC;;2872\n");
size_t tmp___5;
  printf("\nSTMT_EXEC;;2873\n");
size_t tmp___6;
  printf("\nSTMT_EXEC;;2874\n");
char const *tmp___7;
  printf("\nSTMT_EXEC;;2875\n");
char const *tmp___8;
  printf("\nSTMT_EXEC;;2876\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;2877\n");
_Bool tmp___10;
  printf("\nSTMT_EXEC;;2878\n");
char const *tmp___11;
  printf("\nSTMT_EXEC;;2879\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;2880\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;2881\n");
uintmax_t s1;
  printf("\nSTMT_EXEC;;2882\n");
uintmax_t s2;
  printf("\nSTMT_EXEC;;2883\n");
char const *tmp___14;
  printf("\nSTMT_EXEC;;2884\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;2885\n");
int tmp___16;
  printf("\nSTMT_EXEC;;2886\n");
char totsizebuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;2887\n");
char s1buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;2888\n");
char s2buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;2889\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;2890\n");
char *tmp___18;
  printf("\nSTMT_EXEC;;2891\n");
char *tmp___19;
  printf("\nSTMT_EXEC;;2892\n");
char const *tmp___20;
  printf("\nSTMT_EXEC;;2893\n");
char *tmp___21;
  printf("\nSTMT_EXEC;;2894\n");
char *tmp___22;
  printf("\nSTMT_EXEC;;2895\n");
off_t tmp___23;
  printf("\nSTMT_EXEC;;2896\n");
int *tmp___24;
  printf("\nSTMT_EXEC;;2897\n");
void *__cil_tmp34;
  printf("\nSTMT_EXEC;;2898\n");
void *__cil_tmp35;
  printf("\nSTMT_EXEC;;2899\n");
void *__cil_tmp36;
  printf("\nSTMT_EXEC;;2900\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;2901\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;2902\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;2903\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;2904\n");
char *__cil_tmp41;
  printf("\nSTMT_EXEC;;2905\n");
char *__cil_tmp42;
  printf("\nSTMT_EXEC;;2906\n");
char *__cil_tmp43;

  {
    printf("\nSTMT_EXEC;;2909\n");
if (checkpoint_option)
    {
      printf("\nSTMT_EXEC;;2911\n");
checkpoint++;
      printf("\nSTMT_EXEC;;2912\n");
if (!(checkpoint % 10))
      {
        {
          printf("\nSTMT_EXEC;;2915\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Read checkpoint %d");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;2916\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, checkpoint);printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    printf("\nSTMT_EXEC;;2920\n");
read_error_count = 0;
    printf("\nSTMT_EXEC;;2921\n");
if (write_archive_to_stdout)
    {
      printf("\nSTMT_EXEC;;2923\n");
if (record_start_block != 0L)
      {
        {
          printf("\nSTMT_EXEC;;2926\n");
archive = 1;
          printf("\nSTMT_EXEC;;2927\n");
status = sys_write_archive_buffer();
          printf("\nSTMT_EXEC;;2928\n");
archive = 0;
        }
        printf("\nSTMT_EXEC;;2930\n");
if (status != record_size)
        {
          {
            printf("\nSTMT_EXEC;;2933\n");
archive_write_error((ssize_t)status);
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;2938\n");
if (multi_volume_option)
    {
      printf("\nSTMT_EXEC;;2940\n");
if (save_name)
      {
        {
          printf("\nSTMT_EXEC;;2943\n");
tmp___0 = safer_name_suffix((char const *)save_name, (_Bool)0);
          printf("\nSTMT_EXEC;;2944\n");
assign_string(&real_s_name, (char const *)tmp___0);
          printf("\nSTMT_EXEC;;2945\n");
real_s_sizeleft = save_sizeleft;
          printf("\nSTMT_EXEC;;2946\n");
real_s_totsize = save_totsize;
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;2952\n");
assign_string(&real_s_name, (char const *)0);
          printf("\nSTMT_EXEC;;2953\n");
real_s_totsize = (off_t)0;
          printf("\nSTMT_EXEC;;2954\n");
real_s_sizeleft = (off_t)0;
        }
      }
    }
  error_loop:
    {
printf("\nSTMT_EXEC;;2959\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;2962\n");
tmp___1 = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
        printf("\nSTMT_EXEC;;2963\n");
status = tmp___1;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;2969\n");
tmp___2 = safe_read(archive, (void *)(record_start->buffer), record_size);
        printf("\nSTMT_EXEC;;2970\n");
status = tmp___2;
      }
    }
}

    printf("\nSTMT_EXEC;;2973\n");
if (status == record_size)
    {
      printf("\nSTMT_EXEC;;2975\n");
records_read++;
      printf("\nSTMT_EXEC;;2976\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;2978\n");
if (status == 0UL)
    {
      printf("\nSTMT_EXEC;;2980\n");
goto _L___1;
    }
    else
    {
      printf("\nSTMT_EXEC;;2984\n");
if (status == 0xffffffffffffffffUL)
      {
        {
          printf("\nSTMT_EXEC;;2987\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___24 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;2989\n");
if (*tmp___24 == 28)
        {
        _L___1:
          {
printf("\nSTMT_EXEC;;2992\n");
if (multi_volume_option)
          {
          try_volume:
          {
            printf("\nSTMT_EXEC;;2996\n");
if ((unsigned int)subcommand_option == 1U)
            {
              printf("\nSTMT_EXEC;;2998\n");
goto case_1;
            }
            printf("\nSTMT_EXEC;;3000\n");
if ((unsigned int)subcommand_option == 2U)
            {
              printf("\nSTMT_EXEC;;3002\n");
goto case_1;
            }
            printf("\nSTMT_EXEC;;3004\n");
if ((unsigned int)subcommand_option == 8U)
            {
              printf("\nSTMT_EXEC;;3006\n");
goto case_1;
            }
            printf("\nSTMT_EXEC;;3008\n");
goto switch_default;
          case_1: /* CIL Label */
          case_2: /* CIL Label */
          case_8: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;3013\n");
tmp___3 = new_volume((enum access_mode)2);
          }
            printf("\nSTMT_EXEC;;3015\n");
if (!tmp___3)
            {
              printf("\nSTMT_EXEC;;3017\n");
printf("\nFUNC_RETURN;;\n");
return;
            }
            printf("\nSTMT_EXEC;;3019\n");
goto switch_break;
          switch_default: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;3022\n");
tmp___4 = new_volume((enum access_mode)0);
          }
            printf("\nSTMT_EXEC;;3024\n");
if (!tmp___4)
            {
              printf("\nSTMT_EXEC;;3026\n");
printf("\nFUNC_RETURN;;\n");
return;
            }
            printf("\nSTMT_EXEC;;3028\n");
goto switch_break;
          switch_break: /* CIL Label */;
          }
            {
              printf("\nSTMT_EXEC;;3032\n");
while (1)
              {
              while_continue: /* CIL Label */;
                printf("\nSTMT_EXEC;;3035\n");
if (archive >= 1 << 30)
                {
                  {
                    printf("\nSTMT_EXEC;;3038\n");
tmp___5 = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
                    printf("\nSTMT_EXEC;;3039\n");
status = tmp___5;
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;3045\n");
tmp___6 = safe_read(archive, (void *)(record_start->buffer), record_size);
                    printf("\nSTMT_EXEC;;3046\n");
status = tmp___6;
                  }
                }
                printf("\nSTMT_EXEC;;3049\n");
if (!(status == 0xffffffffffffffffUL))
                {
                  printf("\nSTMT_EXEC;;3051\n");
goto while_break;
                }
                {
                  printf("\nSTMT_EXEC;;3054\n");
archive_read_error();
                }
              }
            while_break: /* CIL Label */;
            }
            printf("\nSTMT_EXEC;;3059\n");
if (status != record_size)
            {
              {
                printf("\nSTMT_EXEC;;3062\n");
short_read(status);
              }
            }
            printf("\nSTMT_EXEC;;3065\n");
cursor = record_start;
            printf("\nSTMT_EXEC;;3066\n");
if ((int)cursor->header.typeflag == 86)
            {
              printf("\nSTMT_EXEC;;3068\n");
if (volume_label_option)
              {
                {
                  printf("\nSTMT_EXEC;;3071\n");
tmp___10 = check_label_pattern(cursor);
                }
                printf("\nSTMT_EXEC;;3073\n");
if (!tmp___10)
                {
                  {
                    printf("\nSTMT_EXEC;;3076\n");
tmp___7 = quote_n(1, volume_label_option);
                    printf("\nSTMT_EXEC;;3077\n");
tmp___8 = quote_n(0, (char const *)(cursor->header.name));
                    printf("\nSTMT_EXEC;;3078\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("Volume %s does not match %s");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;3079\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9, tmp___8, tmp___7);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;3080\n");
volno--;
                    printf("\nSTMT_EXEC;;3081\n");
global_volno--;
                  }
                  printf("\nSTMT_EXEC;;3083\n");
goto try_volume;
                }
              }
              printf("\nSTMT_EXEC;;3086\n");
if (verbose_option)
              {
                {
                  printf("\nSTMT_EXEC;;3089\n");
tmp___11 = quote((char const *)(cursor->header.name));
                  printf("\nSTMT_EXEC;;3090\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___12 = gettext("Reading %s\n");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3091\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___12, tmp___11);printf("\nFUNC_RETURN;;\n");

                }
              }
              printf("\nSTMT_EXEC;;3094\n");
cursor++;
            }
            else
            {
              printf("\nSTMT_EXEC;;3098\n");
if (volume_label_option)
              {
                {
                  printf("\nSTMT_EXEC;;3101\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("WARNING: No volume header");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3102\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___13);printf("\nFUNC_RETURN;;\n");

                }
              }
            }
            printf("\nSTMT_EXEC;;3106\n");
if (real_s_name)
            {
              printf("\nSTMT_EXEC;;3108\n");
if ((int)cursor->header.typeflag != 77)
              {
                printf("\nSTMT_EXEC;;3110\n");
goto _L;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;3115\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___16 = strcmp((char const *)(cursor->header.name), (char const *)real_s_name);printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;3117\n");
if (tmp___16)
                {
                _L:
                {
                  printf("\nSTMT_EXEC;;3121\n");
tmp___14 = quote((char const *)real_s_name);
                  printf("\nSTMT_EXEC;;3122\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___15 = gettext("%s is not continued on this volume");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3123\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___15, tmp___14);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3124\n");
volno--;
                  printf("\nSTMT_EXEC;;3125\n");
global_volno--;
                }
                  printf("\nSTMT_EXEC;;3127\n");
goto try_volume;
                }
              }
              {
                printf("\nSTMT_EXEC;;3131\n");
s1 = uintmax_from_header((char const *)(cursor->header.size), sizeof(cursor->header.size));
                printf("\nSTMT_EXEC;;3132\n");
s2 = uintmax_from_header((char const *)(cursor->oldgnu_header.offset), sizeof(cursor->oldgnu_header.offset));
              }
              printf("\nSTMT_EXEC;;3134\n");
if ((uintmax_t)real_s_totsize != s1 + s2)
              {
                printf("\nSTMT_EXEC;;3136\n");
goto _L___3;
              }
              else
              {
                printf("\nSTMT_EXEC;;3140\n");
if (s1 + s2 < s2)
                {
                _L___3: /* CIL Label */
                {
                  printf("\nSTMT_EXEC;;3144\n");
tmp___17 = stringify_uintmax_t_backwards(s2, s2buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
                  printf("\nSTMT_EXEC;;3145\n");
tmp___18 = stringify_uintmax_t_backwards(s1, s1buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
                  printf("\nSTMT_EXEC;;3146\n");
tmp___19 = stringify_uintmax_t_backwards((uintmax_t)save_totsize, totsizebuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
                  printf("\nSTMT_EXEC;;3147\n");
tmp___20 = quote((char const *)(cursor->header.name));
                  printf("\nSTMT_EXEC;;3148\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___21 = gettext("%s is the wrong size (%s != %s + %s)");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3149\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___21, tmp___20, tmp___19, tmp___18, tmp___17);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3150\n");
volno--;
                  printf("\nSTMT_EXEC;;3151\n");
global_volno--;
                }
                  printf("\nSTMT_EXEC;;3153\n");
goto try_volume;
                }
              }
              {
                printf("\nSTMT_EXEC;;3157\n");
tmp___23 = off_from_header((char const *)(cursor->oldgnu_header.offset), sizeof(cursor->oldgnu_header.offset));
              }
              printf("\nSTMT_EXEC;;3159\n");
if (real_s_totsize - real_s_sizeleft != tmp___23)
              {
                {
                  printf("\nSTMT_EXEC;;3162\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___22 = gettext("This volume is out of sequence");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3163\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___22);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;3164\n");
volno--;
                  printf("\nSTMT_EXEC;;3165\n");
global_volno--;
                }
                printf("\nSTMT_EXEC;;3167\n");
goto try_volume;
              }
              printf("\nSTMT_EXEC;;3169\n");
cursor++;
            }
            printf("\nSTMT_EXEC;;3171\n");
current_block = cursor;
            printf("\nSTMT_EXEC;;3172\n");
records_read++;
            printf("\nSTMT_EXEC;;3173\n");
printf("\nFUNC_RETURN;;\n");
return;
          }
          else
          {
            printf("\nSTMT_EXEC;;3177\n");
goto _L___2;
          }
}

        }
        else
        {
          printf("\nSTMT_EXEC;;3182\n");
goto _L___2;
        }
      }
      else
      {
      _L___2:
        {
printf("\nSTMT_EXEC;;3188\n");
if (status == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;3191\n");
archive_read_error();
          }
          printf("\nSTMT_EXEC;;3193\n");
goto error_loop;
        }
}

      }
    }
    {
      printf("\nSTMT_EXEC;;3198\n");
short_read(status);
    }
    printf("\nSTMT_EXEC;;3200\n");
printf("\nFUNC_RETURN;;\n");
return;





































































































  }
printf("\nFUNC_RETURN;;\n");
}
void flush_archive(void)
{

  printf("\nFUNC_CALL;flush_archive();\n");
{
    printf("\nSTMT_EXEC;;3308\n");
record_start_block += record_end - record_start;
    printf("\nSTMT_EXEC;;3309\n");
current_block = record_start;
    printf("\nSTMT_EXEC;;3310\n");
record_end = record_start + blocking_factor;
    printf("\nSTMT_EXEC;;3311\n");
if ((unsigned int)access_mode == 0U)
    {
      printf("\nSTMT_EXEC;;3313\n");
if (time_to_start_writing)
      {
        {
          printf("\nSTMT_EXEC;;3316\n");
access_mode = (enum access_mode)1;
          printf("\nSTMT_EXEC;;3317\n");
time_to_start_writing = (_Bool)0;
          printf("\nSTMT_EXEC;;3318\n");
backspace_output();
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;3323\n");
if ((unsigned int)access_mode == 0U)
      {
        printf("\nSTMT_EXEC;;3325\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;3327\n");
if ((unsigned int)access_mode == 1U)
      {
        printf("\nSTMT_EXEC;;3329\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;3331\n");
if ((unsigned int)access_mode == 2U)
      {
        printf("\nSTMT_EXEC;;3333\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;3335\n");
goto switch_break;
    case_0: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;3338\n");
flush_read();
    }
      printf("\nSTMT_EXEC;;3340\n");
goto switch_break;
    case_1: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;3343\n");
flush_write();
    }
      printf("\nSTMT_EXEC;;3345\n");
goto switch_break;
    case_2: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;3348\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;3352\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void backspace_output(void)
{
  printf("\nFUNC_CALL;backspace_output();\n");
printf("\nSTMT_EXEC;;3357\n");
struct mtop operation;
  printf("\nSTMT_EXEC;;3358\n");
int tmp;
  printf("\nSTMT_EXEC;;3359\n");
int tmp___0;
  printf("\nSTMT_EXEC;;3360\n");
int tmp___1;
  printf("\nSTMT_EXEC;;3361\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;3362\n");
int tmp___3;
  printf("\nSTMT_EXEC;;3363\n");
int tmp___4;
  printf("\nSTMT_EXEC;;3364\n");
int tmp___5;
  printf("\nSTMT_EXEC;;3365\n");
off_t position;
  printf("\nSTMT_EXEC;;3366\n");
off_t tmp___6;
  printf("\nSTMT_EXEC;;3367\n");
__off_t tmp___7;
  printf("\nSTMT_EXEC;;3368\n");
off_t tmp___8;
  printf("\nSTMT_EXEC;;3369\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;3370\n");
off_t tmp___10;
  printf("\nSTMT_EXEC;;3371\n");
__off_t tmp___11;
  printf("\nSTMT_EXEC;;3372\n");
off_t tmp___12;
  printf("\nSTMT_EXEC;;3373\n");
char *__cil_tmp17;

  {
    printf("\nSTMT_EXEC;;3376\n");
operation.mt_op = (short)4;
    printf("\nSTMT_EXEC;;3377\n");
operation.mt_count = 1;
    printf("\nSTMT_EXEC;;3378\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;3381\n");
tmp = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
        printf("\nSTMT_EXEC;;3382\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3388\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___0 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3389\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;3392\n");
if (tmp___1 >= 0)
    {
      printf("\nSTMT_EXEC;;3394\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;3397\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;3399\n");
if (*tmp___2 == 5)
    {
      printf("\nSTMT_EXEC;;3401\n");
if (archive >= 1 << 30)
      {
        {
          printf("\nSTMT_EXEC;;3404\n");
tmp___3 = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
          printf("\nSTMT_EXEC;;3405\n");
tmp___5 = tmp___3;
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;3411\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___4 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;3412\n");
tmp___5 = tmp___4;
        }
      }
      printf("\nSTMT_EXEC;;3415\n");
if (tmp___5 >= 0)
      {
        printf("\nSTMT_EXEC;;3417\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    printf("\nSTMT_EXEC;;3420\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;3423\n");
tmp___6 = rmt_lseek__(archive - (1 << 30), (off_t)0, 1);
        printf("\nSTMT_EXEC;;3424\n");
tmp___8 = tmp___6;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3430\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___7 = lseek(archive, (off_t)0, 1);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3431\n");
tmp___8 = tmp___7;
      }
    }
    printf("\nSTMT_EXEC;;3434\n");
position = tmp___8;
    printf("\nSTMT_EXEC;;3435\n");
position = (off_t)((size_t)position - record_size);
    printf("\nSTMT_EXEC;;3436\n");
if (position < 0L)
    {
      printf("\nSTMT_EXEC;;3438\n");
position = (off_t)0;
    }
    printf("\nSTMT_EXEC;;3440\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;3443\n");
tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
        printf("\nSTMT_EXEC;;3444\n");
tmp___12 = tmp___10;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3450\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___11 = lseek(archive, position, 0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3451\n");
tmp___12 = tmp___11;
      }
    }
    printf("\nSTMT_EXEC;;3454\n");
if (tmp___12 != position)
    {
      {
        printf("\nSTMT_EXEC;;3457\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("Cannot backspace archive file; it may be unreadable without -i");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3458\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3460\n");
if ((unsigned long)(record_start->buffer) != (unsigned long)output_start)
      {
        {
          printf("\nSTMT_EXEC;;3463\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(record_start->buffer), 0, (size_t)(output_start - record_start->buffer));printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    printf("\nSTMT_EXEC;;3467\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}



































void close_archive(void)
{
  printf("\nFUNC_CALL;close_archive();\n");
printf("\nSTMT_EXEC;;3507\n");
int tmp;
  printf("\nSTMT_EXEC;;3508\n");
int tmp___0;
  printf("\nSTMT_EXEC;;3509\n");
int tmp___1;
  printf("\nSTMT_EXEC;;3510\n");
union block *tmp___2;

  {
    printf("\nSTMT_EXEC;;3513\n");
if (time_to_start_writing)
    {
      {
        printf("\nSTMT_EXEC;;3516\n");
flush_archive();
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;3521\n");
if ((unsigned int)access_mode == 1U)
      {
        {
          printf("\nSTMT_EXEC;;3524\n");
flush_archive();
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;3529\n");
sys_drain_input_pipe();
    }
    printf("\nSTMT_EXEC;;3531\n");
if (verify_option)
    {
      {
        printf("\nSTMT_EXEC;;3534\n");
verify_volume();
      }
    }
    printf("\nSTMT_EXEC;;3537\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;3540\n");
tmp = rmt_close__(archive - (1 << 30));
        printf("\nSTMT_EXEC;;3541\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3547\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___0 = close(archive);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3548\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;3551\n");
if (tmp___1 != 0)
    {
      {
        printf("\nSTMT_EXEC;;3554\n");
close_warn(*archive_name_cursor);
      }
    }
    {
      printf("\nSTMT_EXEC;;3558\n");
sys_wait_for_child(child_pid);
      printf("\nSTMT_EXEC;;3559\n");
tar_stat_destroy(&current_stat_info);
    }
    printf("\nSTMT_EXEC;;3561\n");
if (save_name)
    {
      {
        printf("\nSTMT_EXEC;;3564\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)save_name);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;3567\n");
if (real_s_name)
    {
      {
        printf("\nSTMT_EXEC;;3570\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)real_s_name);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;3573\n");
if (multi_volume_option)
    {
      printf("\nSTMT_EXEC;;3575\n");
tmp___2 = record_start - 2;
    }
    else
    {
      printf("\nSTMT_EXEC;;3579\n");
tmp___2 = record_start;
    }
    {
      printf("\nSTMT_EXEC;;3582\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)tmp___2);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;3584\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void init_volume_number(void)
{
  printf("\nFUNC_CALL;init_volume_number();\n");
printf("\nSTMT_EXEC;;3589\n");
FILE *file;
  printf("\nSTMT_EXEC;;3590\n");
FILE *tmp;
  printf("\nSTMT_EXEC;;3591\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;3592\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;3593\n");
int tmp___2;
  printf("\nSTMT_EXEC;;3594\n");
int tmp___3;
  printf("\nSTMT_EXEC;;3595\n");
int tmp___4;
  printf("\nSTMT_EXEC;;3596\n");
int *tmp___5;
  printf("\nSTMT_EXEC;;3597\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;3598\n");
char *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;3602\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
tmp = fopen((char const * /* __restrict  */)volno_file_option, (char const * /* __restrict  */) "r");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;3603\n");
file = tmp;
    }
    printf("\nSTMT_EXEC;;3605\n");
if (file)
    {
      {
        printf("\nSTMT_EXEC;;3608\n");
printf("\nFUNC_CALL;fscanf(FILE *__restrict,const char *__restrict);\n");
tmp___2 = fscanf((FILE * /* __restrict  */) file, (char const * /* __restrict  */) "%d", &global_volno);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3610\n");
if (tmp___2 != 1)
      {
        {
          printf("\nSTMT_EXEC;;3613\n");
tmp___0 = quotearg_colon(volno_file_option);
          printf("\nSTMT_EXEC;;3614\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: contains invalid volume number");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;3615\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;3616\n");
fatal_exit();
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;3621\n");
if (global_volno < 0)
        {
          {
            printf("\nSTMT_EXEC;;3624\n");
tmp___0 = quotearg_colon(volno_file_option);
            printf("\nSTMT_EXEC;;3625\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: contains invalid volume number");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;3626\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;3627\n");
fatal_exit();
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;3632\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___3 = ferror_unlocked(file);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3634\n");
if (tmp___3)
      {
        {
          printf("\nSTMT_EXEC;;3637\n");
read_error(volno_file_option);
        }
      }
      {
        printf("\nSTMT_EXEC;;3641\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___4 = fclose(file);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3643\n");
if (tmp___4 != 0)
      {
        {
          printf("\nSTMT_EXEC;;3646\n");
close_error(volno_file_option);
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3653\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___5 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3655\n");
if (*tmp___5 != 2)
      {
        {
          printf("\nSTMT_EXEC;;3658\n");
open_error(volno_file_option);
        }
      }
    }
    printf("\nSTMT_EXEC;;3662\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void closeout_volume_number(void)
{
  printf("\nFUNC_CALL;closeout_volume_number();\n");
printf("\nSTMT_EXEC;;3667\n");
FILE *file;
  printf("\nSTMT_EXEC;;3668\n");
FILE *tmp;
  printf("\nSTMT_EXEC;;3669\n");
int tmp___0;
  printf("\nSTMT_EXEC;;3670\n");
int tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;3674\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
tmp = fopen((char const * /* __restrict  */)volno_file_option, (char const * /* __restrict  */) "w");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;3675\n");
file = tmp;
    }
    printf("\nSTMT_EXEC;;3677\n");
if (file)
    {
      {
        printf("\nSTMT_EXEC;;3680\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) file, (char const * /* __restrict  */) "%d\n", global_volno);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3681\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___0 = ferror_unlocked(file);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3683\n");
if (tmp___0)
      {
        {
          printf("\nSTMT_EXEC;;3686\n");
write_error(volno_file_option);
        }
      }
      {
        printf("\nSTMT_EXEC;;3690\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___1 = fclose(file);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;3692\n");
if (tmp___1 != 0)
      {
        {
          printf("\nSTMT_EXEC;;3695\n");
close_error(volno_file_option);
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3702\n");
open_error(volno_file_option);
      }
    }
    printf("\nSTMT_EXEC;;3705\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static FILE *read_file;
static int looped;
static _Bool new_volume(enum access_mode mode)
{
  printf("\nFUNC_CALL;new_volume(enum access_mode);\n");
printf("\nSTMT_EXEC;;3712\n");
FILE *tmp;
  printf("\nSTMT_EXEC;;3713\n");
int tmp___0;
  printf("\nSTMT_EXEC;;3714\n");
int tmp___1;
  printf("\nSTMT_EXEC;;3715\n");
int tmp___2;
  printf("\nSTMT_EXEC;;3716\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;3717\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;3718\n");
int tmp___5;
  printf("\nSTMT_EXEC;;3719\n");
char input_buffer[80];
  printf("\nSTMT_EXEC;;3720\n");
char const *tmp___6;
  printf("\nSTMT_EXEC;;3721\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;3722\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;3723\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;3724\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;3725\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;3726\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;3727\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;3728\n");
char *name;
  printf("\nSTMT_EXEC;;3729\n");
char *cursor;
  printf("\nSTMT_EXEC;;3730\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;3731\n");
int tmp___16;
  printf("\nSTMT_EXEC;;3732\n");
int tmp___17;
  printf("\nSTMT_EXEC;;3733\n");
void *tmp___18;
  printf("\nSTMT_EXEC;;3734\n");
int tmp___20;
  printf("\nSTMT_EXEC;;3735\n");
int tmp___21;
  printf("\nSTMT_EXEC;;3736\n");
void *tmp___22;
  printf("\nSTMT_EXEC;;3737\n");
int tmp___24;
  printf("\nSTMT_EXEC;;3738\n");
int tmp___25;
  printf("\nSTMT_EXEC;;3739\n");
void *tmp___26;
  printf("\nSTMT_EXEC;;3740\n");
int tmp___28;
  printf("\nSTMT_EXEC;;3741\n");
int tmp___29;
  printf("\nSTMT_EXEC;;3742\n");
void *tmp___30;
  printf("\nSTMT_EXEC;;3743\n");
int tmp___31;
  printf("\nSTMT_EXEC;;3744\n");
void *__cil_tmp34;
  printf("\nSTMT_EXEC;;3745\n");
char *__cil_tmp35;
  printf("\nSTMT_EXEC;;3746\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;3747\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;3748\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;3749\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;3750\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;3751\n");
char *__cil_tmp41;
  printf("\nSTMT_EXEC;;3752\n");
char *__cil_tmp42;

  {
    printf("\nSTMT_EXEC;;3755\n");
if (!read_file)
    {
      printf("\nSTMT_EXEC;;3757\n");
if (!info_script_option)
      {
        printf("\nSTMT_EXEC;;3759\n");
if (archive == 0)
        {
          {
            printf("\nSTMT_EXEC;;3762\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
tmp = fopen((char const * /* __restrict  */) "/dev/tty", (char const * /* __restrict  */) "r");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;3763\n");
read_file = tmp;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;3768\n");
read_file = stdin;
        }
      }
    }
    printf("\nSTMT_EXEC;;3772\n");
if (now_verifying)
    {
      printf("\nSTMT_EXEC;;3774\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;3776\n");
if (verify_option)
    {
      {
        printf("\nSTMT_EXEC;;3779\n");
verify_volume();
      }
    }
    printf("\nSTMT_EXEC;;3782\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;3785\n");
tmp___0 = rmt_close__(archive - (1 << 30));
        printf("\nSTMT_EXEC;;3786\n");
tmp___2 = tmp___0;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;3792\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___1 = close(archive);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3793\n");
tmp___2 = tmp___1;
      }
    }
    printf("\nSTMT_EXEC;;3796\n");
if (tmp___2 != 0)
    {
      {
        printf("\nSTMT_EXEC;;3799\n");
close_warn(*archive_name_cursor);
      }
    }
    printf("\nSTMT_EXEC;;3802\n");
global_volno++;
    printf("\nSTMT_EXEC;;3803\n");
if (global_volno < 0)
    {
      {
        printf("\nSTMT_EXEC;;3806\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Volume number overflow");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3807\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;3808\n");
fatal_exit();
      }
    }
    printf("\nSTMT_EXEC;;3811\n");
volno++;
    printf("\nSTMT_EXEC;;3812\n");
archive_name_cursor++;
    printf("\nSTMT_EXEC;;3813\n");
if ((unsigned long)archive_name_cursor == (unsigned long)(archive_name_array + archive_names))
    {
      printf("\nSTMT_EXEC;;3815\n");
archive_name_cursor = archive_name_array;
      printf("\nSTMT_EXEC;;3816\n");
looped = 1;
    }
  tryagain:
    {
printf("\nSTMT_EXEC;;3819\n");
if (looped)
    {
      printf("\nSTMT_EXEC;;3821\n");
if (info_script_option)
      {
        printf("\nSTMT_EXEC;;3823\n");
if (volno_file_option)
        {
          {
            printf("\nSTMT_EXEC;;3826\n");
closeout_volume_number();
          }
        }
        {
          printf("\nSTMT_EXEC;;3830\n");
printf("\nFUNC_CALL;system(const char *);\n");
tmp___5 = system(info_script_option);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;3832\n");
if (tmp___5 != 0)
        {
          {
            printf("\nSTMT_EXEC;;3835\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("`%s\' command failed");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;3836\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4, info_script_option);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;3837\n");
fatal_exit();
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;3844\n");
while (1)
          {
          while_continue: /* CIL Label */;
            {
              printf("\nSTMT_EXEC;;3848\n");
printf("\nFUNC_CALL;fputc_unlocked(int,FILE *);\n");
fputc_unlocked('\a', stderr);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3849\n");
tmp___6 = quote(*archive_name_cursor);
              printf("\nSTMT_EXEC;;3850\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("Prepare volume #%d for %s and hit return: ");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3851\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */)tmp___7, global_volno, tmp___6);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3852\n");
printf("\nFUNC_CALL;fflush_unlocked(FILE *);\n");
fflush_unlocked(stderr);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3853\n");
printf("\nFUNC_CALL;fgets_unlocked(char *__restrict,int,FILE *__restrict);\n");
tmp___10 = fgets_unlocked((char * /* __restrict  */)(input_buffer), (int)sizeof(input_buffer), (FILE * /* __restrict  */) read_file);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;3855\n");
if ((unsigned long)tmp___10 == (unsigned long)((char *)0))
            {
              {
                printf("\nSTMT_EXEC;;3858\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("EOF where user reply was expected");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;3859\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;3861\n");
if ((unsigned int)subcommand_option != 6U)
              {
                printf("\nSTMT_EXEC;;3863\n");
if ((unsigned int)subcommand_option != 7U)
                {
                  printf("\nSTMT_EXEC;;3865\n");
if ((unsigned int)subcommand_option != 5U)
                  {
                    {
                      printf("\nSTMT_EXEC;;3868\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("WARNING: Archive is incomplete");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;3869\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9);printf("\nFUNC_RETURN;;\n");

                    }
                  }
                }
              }
              {
                printf("\nSTMT_EXEC;;3875\n");
fatal_exit();
              }
            }
            printf("\nSTMT_EXEC;;3878\n");
if ((int)input_buffer[0] == 10)
            {
              printf("\nSTMT_EXEC;;3880\n");
goto while_break;
            }
            else
            {
              printf("\nSTMT_EXEC;;3884\n");
if ((int)input_buffer[0] == 121)
              {
                printf("\nSTMT_EXEC;;3886\n");
goto while_break;
              }
              else
              {
                printf("\nSTMT_EXEC;;3890\n");
if ((int)input_buffer[0] == 89)
                {
                  printf("\nSTMT_EXEC;;3892\n");
goto while_break;
                }
              }
            }
            {
              printf("\nSTMT_EXEC;;3897\n");
if ((int)input_buffer[0] == 63)
              {
                printf("\nSTMT_EXEC;;3899\n");
goto case_63;
              }
              printf("\nSTMT_EXEC;;3901\n");
if ((int)input_buffer[0] == 113)
              {
                printf("\nSTMT_EXEC;;3903\n");
goto case_113;
              }
              printf("\nSTMT_EXEC;;3905\n");
if ((int)input_buffer[0] == 110)
              {
                printf("\nSTMT_EXEC;;3907\n");
goto case_110;
              }
              printf("\nSTMT_EXEC;;3909\n");
if ((int)input_buffer[0] == 33)
              {
                printf("\nSTMT_EXEC;;3911\n");
goto case_33;
              }
              printf("\nSTMT_EXEC;;3913\n");
goto switch_break;
            case_63: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;3916\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___11 = gettext(" n [name]   Give a new file name for the next (and "
                                 "subsequent) volume(s)\n q          Abort tar\n !          "
                                 "Spawn a subshell\n ?          Print this list\n");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3919\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */)tmp___11);printf("\nFUNC_RETURN;;\n");

            }
              printf("\nSTMT_EXEC;;3921\n");
goto switch_break;
            case_113: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;3924\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___12 = gettext("No new volume; exiting.\n");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;3925\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___12);printf("\nFUNC_RETURN;;\n");

            }
              printf("\nSTMT_EXEC;;3927\n");
if ((unsigned int)subcommand_option != 6U)
              {
                printf("\nSTMT_EXEC;;3929\n");
if ((unsigned int)subcommand_option != 7U)
                {
                  printf("\nSTMT_EXEC;;3931\n");
if ((unsigned int)subcommand_option != 5U)
                  {
                    {
                      printf("\nSTMT_EXEC;;3934\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("WARNING: Archive is incomplete");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;3935\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___13);printf("\nFUNC_RETURN;;\n");

                    }
                  }
                }
              }
              {
                printf("\nSTMT_EXEC;;3941\n");
fatal_exit();
              }
            case_110: /* CIL Label */
              {
printf("\nSTMT_EXEC;;3944\n");
name = &input_buffer[1];
}

              printf("\nSTMT_EXEC;;3945\n");
name = input_buffer + 1;
              {
                printf("\nSTMT_EXEC;;3947\n");
while (1)
                {
                while_continue___0: /* CIL Label */;
                  printf("\nSTMT_EXEC;;3950\n");
if (!((int)*name == 32))
                  {
                    printf("\nSTMT_EXEC;;3952\n");
if (!((int)*name == 9))
                    {
                      printf("\nSTMT_EXEC;;3954\n");
goto while_break___0;
                    }
                  }
                  printf("\nSTMT_EXEC;;3957\n");
name++;
                }
              while_break___0: /* CIL Label */;
              }
              printf("\nSTMT_EXEC;;3961\n");
cursor = name;
              {
                printf("\nSTMT_EXEC;;3963\n");
while (1)
                {
                while_continue___1: /* CIL Label */;
                  printf("\nSTMT_EXEC;;3966\n");
if (*cursor)
                  {
                    printf("\nSTMT_EXEC;;3968\n");
if (!((int)*cursor != 10))
                    {
                      printf("\nSTMT_EXEC;;3970\n");
goto while_break___1;
                    }
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;3975\n");
goto while_break___1;
                  }
                  printf("\nSTMT_EXEC;;3977\n");
cursor++;
                }
              while_break___1: /* CIL Label */;
              }
              {
                printf("\nSTMT_EXEC;;3982\n");
*cursor = (char)'\000';
                printf("\nSTMT_EXEC;;3983\n");
tmp___14 = xstrdup((char const *)name);
                printf("\nSTMT_EXEC;;3984\n");
*archive_name_cursor = (char const *)tmp___14;
              }
              printf("\nSTMT_EXEC;;3986\n");
goto switch_break;
            case_33: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;3989\n");
sys_spawn_shell();
            }
              printf("\nSTMT_EXEC;;3991\n");
goto switch_break;
            switch_break: /* CIL Label */;
            }
          }
        while_break: /* CIL Label */;
        }
      }
    }
}

    {
      printf("\nSTMT_EXEC;;4000\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___31 = strcmp(*(archive_name_cursor + 0), "-");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;4002\n");
if (tmp___31 == 0)
    {
      printf("\nSTMT_EXEC;;4004\n");
read_full_records_option = (_Bool)1;
      printf("\nSTMT_EXEC;;4005\n");
archive = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;4009\n");
if (verify_option)
      {
        printf("\nSTMT_EXEC;;4011\n");
if (!force_local_option)
        {
          {
            printf("\nSTMT_EXEC;;4014\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*archive_name_cursor, ':');printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;4016\n");
if (rmt_path__)
          {
            printf("\nSTMT_EXEC;;4018\n");
if ((unsigned long)rmt_path__ > (unsigned long)*archive_name_cursor)
            {
              {
                printf("\nSTMT_EXEC;;4021\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___18 = memchr((void const *)*archive_name_cursor, '/', (size_t)(rmt_path__ - (char *)*archive_name_cursor));printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;4023\n");
if (tmp___18)
              {
                {
                  printf("\nSTMT_EXEC;;4026\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___17 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;4027\n");
archive = tmp___17;
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;4033\n");
tmp___16 = rmt_open__(*archive_name_cursor, 66, 1 << 30, rsh_command_option);
                  printf("\nSTMT_EXEC;;4034\n");
archive = tmp___16;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;4041\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___17 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;4042\n");
archive = tmp___17;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;4049\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___17 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4050\n");
archive = tmp___17;
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;4057\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___17 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;4058\n");
archive = tmp___17;
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;4065\n");
if ((unsigned int)mode == 0U)
          {
            printf("\nSTMT_EXEC;;4067\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;4069\n");
if ((unsigned int)mode == 1U)
          {
            printf("\nSTMT_EXEC;;4071\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;4073\n");
if ((unsigned int)mode == 2U)
          {
            printf("\nSTMT_EXEC;;4075\n");
goto case_2;
          }
          printf("\nSTMT_EXEC;;4077\n");
goto switch_break___0;
        case_0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;4079\n");
if (!force_local_option)
          {
            {
              printf("\nSTMT_EXEC;;4082\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*archive_name_cursor, ':');printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;4084\n");
if (rmt_path__)
            {
              printf("\nSTMT_EXEC;;4086\n");
if ((unsigned long)rmt_path__ > (unsigned long)*archive_name_cursor)
              {
                {
                  printf("\nSTMT_EXEC;;4089\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___22 = memchr((void const *)*archive_name_cursor, '/', (size_t)(rmt_path__ - (char *)*archive_name_cursor));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;4091\n");
if (tmp___22)
                {
                  {
                    printf("\nSTMT_EXEC;;4094\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___21 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;4095\n");
archive = tmp___21;
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;4101\n");
tmp___20 = rmt_open__(*archive_name_cursor, 0, 1 << 30, rsh_command_option);
                    printf("\nSTMT_EXEC;;4102\n");
archive = tmp___20;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;4109\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___21 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;4110\n");
archive = tmp___21;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;4117\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___21 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;4118\n");
archive = tmp___21;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;4125\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___21 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4126\n");
archive = tmp___21;
            }
          }
}

          printf("\nSTMT_EXEC;;4129\n");
goto switch_break___0;
        case_1: /* CIL Label */
          {
printf("\nSTMT_EXEC;;4131\n");
if (backup_option)
          {
            {
              printf("\nSTMT_EXEC;;4134\n");
maybe_backup_file(*archive_name_cursor, 1);
            }
          }
}

          printf("\nSTMT_EXEC;;4137\n");
if (!force_local_option)
          {
            {
              printf("\nSTMT_EXEC;;4140\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*archive_name_cursor, ':');printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;4142\n");
if (rmt_path__)
            {
              printf("\nSTMT_EXEC;;4144\n");
if ((unsigned long)rmt_path__ > (unsigned long)*archive_name_cursor)
              {
                {
                  printf("\nSTMT_EXEC;;4147\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___26 = memchr((void const *)*archive_name_cursor, '/', (size_t)(rmt_path__ - (char *)*archive_name_cursor));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;4149\n");
if (tmp___26)
                {
                  {
                    printf("\nSTMT_EXEC;;4152\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___25 = creat(*archive_name_cursor, (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;4153\n");
archive = tmp___25;
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;4159\n");
tmp___24 = rmt_open__(*archive_name_cursor, 65, 1 << 30, rsh_command_option);
                    printf("\nSTMT_EXEC;;4160\n");
archive = tmp___24;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;4167\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___25 = creat(*archive_name_cursor, (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;4168\n");
archive = tmp___25;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;4175\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___25 = creat(*archive_name_cursor, (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;4176\n");
archive = tmp___25;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;4183\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___25 = creat(*archive_name_cursor, (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4184\n");
archive = tmp___25;
            }
          }
          printf("\nSTMT_EXEC;;4187\n");
goto switch_break___0;
        case_2: /* CIL Label */
          {
printf("\nSTMT_EXEC;;4189\n");
if (!force_local_option)
          {
            {
              printf("\nSTMT_EXEC;;4192\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*archive_name_cursor, ':');printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;4194\n");
if (rmt_path__)
            {
              printf("\nSTMT_EXEC;;4196\n");
if ((unsigned long)rmt_path__ > (unsigned long)*archive_name_cursor)
              {
                {
                  printf("\nSTMT_EXEC;;4199\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___30 = memchr((void const *)*archive_name_cursor, '/', (size_t)(rmt_path__ - (char *)*archive_name_cursor));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;4201\n");
if (tmp___30)
                {
                  {
                    printf("\nSTMT_EXEC;;4204\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___29 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;4205\n");
archive = tmp___29;
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;4211\n");
tmp___28 = rmt_open__(*archive_name_cursor, 66, 1 << 30, rsh_command_option);
                    printf("\nSTMT_EXEC;;4212\n");
archive = tmp___28;
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;4219\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___29 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;4220\n");
archive = tmp___29;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;4227\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___29 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;4228\n");
archive = tmp___29;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;4235\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___29 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4236\n");
archive = tmp___29;
            }
          }
}

          printf("\nSTMT_EXEC;;4239\n");
goto switch_break___0;
        switch_break___0: /* CIL Label */;
        }
      }
    }
    printf("\nSTMT_EXEC;;4244\n");
if (archive < 0)
    {
      {
        printf("\nSTMT_EXEC;;4247\n");
open_warn(*archive_name_cursor);
      }
      printf("\nSTMT_EXEC;;4249\n");
if (!verify_option)
      {
        printf("\nSTMT_EXEC;;4251\n");
if ((unsigned int)mode == 1U)
        {
          printf("\nSTMT_EXEC;;4253\n");
if (backup_option)
          {
            {
              printf("\nSTMT_EXEC;;4256\n");
undo_last_backup();
            }
          }
        }
      }
      printf("\nSTMT_EXEC;;4261\n");
goto tryagain;
    }
    printf("\nSTMT_EXEC;;4263\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}









/* #pragma merger("0","001.compare.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) memcmp)(void const *__s1, void const *__s2, size_t __n) __attribute__((__pure__));
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) strncmp)(char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
extern __attribute__((__nothrow__)) ssize_t(__attribute__((__nonnull__(1, 2), __leaf__)) readlink)(char const *__restrict __path, char *__restrict __buf, size_t __len);
extern int fsync(int __fd);
extern int vfprintf(FILE *__restrict __s, char const *__restrict __format, __gnuc_va_list __arg);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) utime)(char const *__file, struct utimbuf const *__file_times);
__attribute__((__noreturn__)) void xalloc_die(void);
int exit_status;
_Bool atime_preserve_option;
_Bool dereference_option;
void diff_archive(void);
void diff_init(void);
char *get_directory_contents(char *path, dev_t device);
union block *current_header;
enum archive_format current_format;
void decode_header(union block *header, struct tar_stat_info *stat_info, enum archive_format *format_pointer, int do_user_group);
void print_header(struct tar_stat_info *st, off_t block_ordinal);
enum read_header read_header(_Bool raw_extended_headers);
void skip_member(void);
int deref_stat(_Bool deref, char const *name, struct stat *buf);
void readlink_error(char const *name);
void readlink_warn(char const *name);
void seek_error_details(char const *name, off_t offset);
void seek_warn(char const *name);
void stat_error(char const *name);
void stat_warn(char const *name);
_Bool sys_compare_uid(struct stat *a, struct stat *b);
_Bool sys_compare_gid(struct stat *a, struct stat *b);
_Bool sys_compare_links(struct stat *link_data, struct stat *stat_data);
void report_difference(struct tar_stat_info *st __attribute__((__unused__)), char const *fmt, ...);
_Bool sparse_diff_file(int fd, struct tar_stat_info *st);
static int diff_handle;
static char *diff_buffer;
void diff_init(void)
{
  printf("\nFUNC_CALL;diff_init();\n");
printf("\nSTMT_EXEC;;4311\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;4315\n");
printf("\nFUNC_CALL;valloc(size_t);\n");
tmp = valloc(record_size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4316\n");
diff_buffer = (char *)tmp;
    }
    printf("\nSTMT_EXEC;;4318\n");
if (!diff_buffer)
    {
      {
        printf("\nSTMT_EXEC;;4321\n");
xalloc_die();
      }
    }
    printf("\nSTMT_EXEC;;4324\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void report_difference(struct tar_stat_info *st __attribute__((__unused__)), char const *fmt, ...)
{
  printf("\nFUNC_CALL;report_difference(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;4329\n");
va_list ap;
  printf("\nSTMT_EXEC;;4330\n");
char *tmp;

  {
    printf("\nSTMT_EXEC;;4333\n");
if (fmt)
    {
      {
        printf("\nSTMT_EXEC;;4336\n");
tmp = quotearg_colon((char const *)current_stat_info.file_name);
        printf("\nSTMT_EXEC;;4337\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "%s: ", tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4338\n");
printf("\nFUNC_CALL;__builtin_va_start(struct __va_list_tag *);\n");
__builtin_va_start(ap, fmt);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4339\n");
printf("\nFUNC_CALL;vfprintf(FILE *__restrict,const char *__restrict,struct __va_list_tag *);\n");
vfprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)fmt, ap);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4340\n");
printf("\nFUNC_CALL;__builtin_va_end(struct __va_list_tag *);\n");
__builtin_va_end(ap);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4341\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "\n");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;4344\n");
if (exit_status == 0)
    {
      printf("\nSTMT_EXEC;;4346\n");
exit_status = 1;
    }
    printf("\nSTMT_EXEC;;4348\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int process_noop(size_t size __attribute__((__unused__)), char *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;process_noop(size_t,char *);\n");
{
    printf("\nSTMT_EXEC;;4355\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static int process_rawdata(size_t bytes, char *buffer___2)
{
  printf("\nFUNC_CALL;process_rawdata(size_t,char *);\n");
printf("\nSTMT_EXEC;;4360\n");
size_t status;
  printf("\nSTMT_EXEC;;4361\n");
size_t tmp;
  printf("\nSTMT_EXEC;;4362\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;4363\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;4364\n");
int tmp___2;
  printf("\nSTMT_EXEC;;4365\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;4369\n");
tmp = safe_read(diff_handle, (void *)diff_buffer, bytes);
      printf("\nSTMT_EXEC;;4370\n");
status = tmp;
    }
    printf("\nSTMT_EXEC;;4372\n");
if (status != bytes)
    {
      printf("\nSTMT_EXEC;;4374\n");
if (status == 0xffffffffffffffffUL)
      {
        {
          printf("\nSTMT_EXEC;;4377\n");
read_error((char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;4378\n");
report_difference(&current_stat_info, (char const *)((void *)0));
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;4384\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___0 = ngettext("Could only read %lu of %lu byte", "Could only read %lu of %lu bytes", bytes);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4385\n");
report_difference(&current_stat_info, (char const *)tmp___0, status, bytes);
        }
      }
      printf("\nSTMT_EXEC;;4388\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;4391\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___2 = memcmp((void const *)buffer___2, (void const *)diff_buffer, bytes);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;4393\n");
if (tmp___2)
    {
      {
        printf("\nSTMT_EXEC;;4396\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Contents differ");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4397\n");
report_difference(&current_stat_info, (char const *)tmp___1);
      }
      printf("\nSTMT_EXEC;;4399\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    printf("\nSTMT_EXEC;;4401\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static char *dumpdir_cursor;
static int process_dumpdir(size_t bytes, char *buffer___2)
{
  printf("\nFUNC_CALL;process_dumpdir(size_t,char *);\n");
printf("\nSTMT_EXEC;;4407\n");
char *tmp;
  printf("\nSTMT_EXEC;;4408\n");
int tmp___0;
  printf("\nSTMT_EXEC;;4409\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;4413\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___0 = memcmp((void const *)buffer___2, (void const *)dumpdir_cursor, bytes);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;4415\n");
if (tmp___0)
    {
      {
        printf("\nSTMT_EXEC;;4418\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Contents differ");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;4419\n");
report_difference(&current_stat_info, (char const *)tmp);
      }
      printf("\nSTMT_EXEC;;4421\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    printf("\nSTMT_EXEC;;4423\n");
dumpdir_cursor += bytes;
    printf("\nSTMT_EXEC;;4424\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static void read_and_process(off_t size, int (*processor)(size_t, char *))
{
  printf("\nFUNC_CALL;read_and_process(off_t,int (*)(size_t, char *));\n");
printf("\nSTMT_EXEC;;4429\n");
union block *data_block;
  printf("\nSTMT_EXEC;;4430\n");
size_t data_size;
  printf("\nSTMT_EXEC;;4431\n");
char *tmp;
  printf("\nSTMT_EXEC;;4432\n");
int tmp___0;
  printf("\nSTMT_EXEC;;4433\n");
char *__cil_tmp7;

  {
    printf("\nSTMT_EXEC;;4436\n");
if (multi_volume_option)
    {
      printf("\nSTMT_EXEC;;4438\n");
save_sizeleft = size;
    }
    {
      printf("\nSTMT_EXEC;;4441\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;4444\n");
if (!size)
        {
          printf("\nSTMT_EXEC;;4446\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;4449\n");
data_block = find_next_block();
        }
        printf("\nSTMT_EXEC;;4451\n");
if (!data_block)
        {
          {
            printf("\nSTMT_EXEC;;4454\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;4455\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;4456\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;4458\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
        {
          printf("\nSTMT_EXEC;;4461\n");
data_size = available_space_after(data_block);
        }
        printf("\nSTMT_EXEC;;4463\n");
if (data_size > (size_t)size)
        {
          printf("\nSTMT_EXEC;;4465\n");
data_size = (size_t)size;
        }
        {
          printf("\nSTMT_EXEC;;4468\n");
tmp___0 = (*processor)(data_size, data_block->buffer);
        }
        printf("\nSTMT_EXEC;;4470\n");
if (!tmp___0)
        {
          printf("\nSTMT_EXEC;;4472\n");
processor = &process_noop;
        }
        {
          printf("\nSTMT_EXEC;;4475\n");
set_next_block_after((union block *)((data_block->buffer + data_size) - 1));
          printf("\nSTMT_EXEC;;4476\n");
size = (off_t)((size_t)size - data_size);
        }
        printf("\nSTMT_EXEC;;4478\n");
if (multi_volume_option)
        {
          printf("\nSTMT_EXEC;;4480\n");
save_sizeleft = (off_t)((size_t)save_sizeleft - data_size);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;4485\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int get_stat_data(char const *file_name, struct stat *stat_data)
{
  printf("\nFUNC_CALL;get_stat_data(const char *,struct stat *);\n");
printf("\nSTMT_EXEC;;4490\n");
int status;
  printf("\nSTMT_EXEC;;4491\n");
int tmp;
  printf("\nSTMT_EXEC;;4492\n");
int *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;4496\n");
tmp = deref_stat(dereference_option, file_name, stat_data);
      printf("\nSTMT_EXEC;;4497\n");
status = tmp;
    }
    printf("\nSTMT_EXEC;;4499\n");
if (status != 0)
    {
      {
        printf("\nSTMT_EXEC;;4502\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;4504\n");
if (*tmp___0 == 2)
      {
        {
          printf("\nSTMT_EXEC;;4507\n");
stat_warn(file_name);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;4513\n");
stat_error(file_name);
        }
      }
      {
        printf("\nSTMT_EXEC;;4517\n");
report_difference(&current_stat_info, (char const *)((void *)0));
      }
      printf("\nSTMT_EXEC;;4519\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    printf("\nSTMT_EXEC;;4521\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
void diff_archive(void)
{
  printf("\nFUNC_CALL;diff_archive();\n");
printf("\nSTMT_EXEC;;4526\n");
struct stat stat_data;
  printf("\nSTMT_EXEC;;4527\n");
int status;
  printf("\nSTMT_EXEC;;4528\n");
struct utimbuf restore_times;
  printf("\nSTMT_EXEC;;4529\n");
char *tmp;
  printf("\nSTMT_EXEC;;4530\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;4531\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;4532\n");
int tmp___2;
  printf("\nSTMT_EXEC;;4533\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;4534\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;4535\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;4536\n");
_Bool tmp___6;
  printf("\nSTMT_EXEC;;4537\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;4538\n");
_Bool tmp___8;
  printf("\nSTMT_EXEC;;4539\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;4540\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;4541\n");
struct stat file_data;
  printf("\nSTMT_EXEC;;4542\n");
struct stat link_data;
  printf("\nSTMT_EXEC;;4543\n");
int tmp___11;
  printf("\nSTMT_EXEC;;4544\n");
int tmp___12;
  printf("\nSTMT_EXEC;;4545\n");
char const *tmp___13;
  printf("\nSTMT_EXEC;;4546\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;4547\n");
_Bool tmp___15;
  printf("\nSTMT_EXEC;;4548\n");
size_t len;
  printf("\nSTMT_EXEC;;4549\n");
size_t tmp___16;
  printf("\nSTMT_EXEC;;4550\n");
char *linkbuf;
  printf("\nSTMT_EXEC;;4551\n");
void *tmp___17;
  printf("\nSTMT_EXEC;;4552\n");
ssize_t tmp___18;
  printf("\nSTMT_EXEC;;4553\n");
int *tmp___19;
  printf("\nSTMT_EXEC;;4554\n");
char *tmp___20;
  printf("\nSTMT_EXEC;;4555\n");
int tmp___21;
  printf("\nSTMT_EXEC;;4556\n");
int tmp___22;
  printf("\nSTMT_EXEC;;4557\n");
char *tmp___23;
  printf("\nSTMT_EXEC;;4558\n");
char *tmp___24;
  printf("\nSTMT_EXEC;;4559\n");
char *tmp___25;
  printf("\nSTMT_EXEC;;4560\n");
char *dumpdir_buffer;
  printf("\nSTMT_EXEC;;4561\n");
char *tmp___26;
  printf("\nSTMT_EXEC;;4562\n");
int tmp___27;
  printf("\nSTMT_EXEC;;4563\n");
char *tmp___28;
  printf("\nSTMT_EXEC;;4564\n");
char *tmp___29;
  printf("\nSTMT_EXEC;;4565\n");
off_t offset;
  printf("\nSTMT_EXEC;;4566\n");
int tmp___30;
  printf("\nSTMT_EXEC;;4567\n");
char *tmp___31;
  printf("\nSTMT_EXEC;;4568\n");
char *tmp___32;
  printf("\nSTMT_EXEC;;4569\n");
__off_t tmp___33;
  printf("\nSTMT_EXEC;;4570\n");
int tmp___34;
  printf("\nSTMT_EXEC;;4571\n");
int tmp___35;
  printf("\nSTMT_EXEC;;4572\n");
void *__cil_tmp47;
  printf("\nSTMT_EXEC;;4573\n");
void *__cil_tmp48;
  printf("\nSTMT_EXEC;;4574\n");
void *__cil_tmp49;
  printf("\nSTMT_EXEC;;4575\n");
char *__cil_tmp50;
  printf("\nSTMT_EXEC;;4576\n");
char *__cil_tmp51;
  printf("\nSTMT_EXEC;;4577\n");
char *__cil_tmp52;
  printf("\nSTMT_EXEC;;4578\n");
char *__cil_tmp53;
  printf("\nSTMT_EXEC;;4579\n");
char *__cil_tmp54;
  printf("\nSTMT_EXEC;;4580\n");
char *__cil_tmp55;
  printf("\nSTMT_EXEC;;4581\n");
char *__cil_tmp56;
  printf("\nSTMT_EXEC;;4582\n");
char *__cil_tmp57;
  printf("\nSTMT_EXEC;;4583\n");
char *__cil_tmp58;
  printf("\nSTMT_EXEC;;4584\n");
char *__cil_tmp59;
  printf("\nSTMT_EXEC;;4585\n");
char *__cil_tmp60;
  printf("\nSTMT_EXEC;;4586\n");
char *__cil_tmp61;
  printf("\nSTMT_EXEC;;4587\n");
char *__cil_tmp62;
  printf("\nSTMT_EXEC;;4588\n");
char *__cil_tmp63;
  printf("\nSTMT_EXEC;;4589\n");
char *__cil_tmp64;
  printf("\nSTMT_EXEC;;4590\n");
char *__cil_tmp65;
  printf("\nSTMT_EXEC;;4591\n");
char *__cil_tmp66;
  printf("\nSTMT_EXEC;;4592\n");
char *__cil_tmp67;

  {
    {
      printf("\nSTMT_EXEC;;4596\n");
set_next_block_after(current_header);
      printf("\nSTMT_EXEC;;4597\n");
decode_header(current_header, &current_stat_info, &current_format, 1);
    }
    printf("\nSTMT_EXEC;;4599\n");
if (verbose_option)
    {
      printf("\nSTMT_EXEC;;4601\n");
if (now_verifying)
      {
        {
          printf("\nSTMT_EXEC;;4604\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Verify ");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4605\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;4609\n");
print_header(&current_stat_info, (off_t)-1);
      }
    }
    {
      printf("\nSTMT_EXEC;;4613\n");
if ((int)current_header->header.typeflag == 0)
      {
        printf("\nSTMT_EXEC;;4615\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;4617\n");
if ((int)current_header->header.typeflag == 48)
      {
        printf("\nSTMT_EXEC;;4619\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;4621\n");
if ((int)current_header->header.typeflag == 83)
      {
        printf("\nSTMT_EXEC;;4623\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;4625\n");
if ((int)current_header->header.typeflag == 55)
      {
        printf("\nSTMT_EXEC;;4627\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;4629\n");
if ((int)current_header->header.typeflag == 49)
      {
        printf("\nSTMT_EXEC;;4631\n");
goto case_49;
      }
      printf("\nSTMT_EXEC;;4633\n");
if ((int)current_header->header.typeflag == 50)
      {
        printf("\nSTMT_EXEC;;4635\n");
goto case_50;
      }
      printf("\nSTMT_EXEC;;4637\n");
if ((int)current_header->header.typeflag == 51)
      {
        printf("\nSTMT_EXEC;;4639\n");
goto case_51;
      }
      printf("\nSTMT_EXEC;;4641\n");
if ((int)current_header->header.typeflag == 52)
      {
        printf("\nSTMT_EXEC;;4643\n");
goto case_51;
      }
      printf("\nSTMT_EXEC;;4645\n");
if ((int)current_header->header.typeflag == 54)
      {
        printf("\nSTMT_EXEC;;4647\n");
goto case_51;
      }
      printf("\nSTMT_EXEC;;4649\n");
if ((int)current_header->header.typeflag == 68)
      {
        printf("\nSTMT_EXEC;;4651\n");
goto case_68;
      }
      printf("\nSTMT_EXEC;;4653\n");
if ((int)current_header->header.typeflag == 53)
      {
        printf("\nSTMT_EXEC;;4655\n");
goto really_dir;
      }
      printf("\nSTMT_EXEC;;4657\n");
if ((int)current_header->header.typeflag == 86)
      {
        printf("\nSTMT_EXEC;;4659\n");
goto case_86;
      }
      printf("\nSTMT_EXEC;;4661\n");
if ((int)current_header->header.typeflag == 77)
      {
        printf("\nSTMT_EXEC;;4663\n");
goto case_77;
      }
      printf("\nSTMT_EXEC;;4665\n");
goto switch_default;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4668\n");
tmp___0 = quotearg_colon((char const *)current_stat_info.file_name);
      printf("\nSTMT_EXEC;;4669\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Unknown file type \'%c\', diffed as normal file");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4670\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, tmp___0, (int)current_header->header.typeflag);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4671\n");
exit_status = 2;
    }
    case_0:  /* CIL Label */
    case_48: /* CIL Label */
    case_83: /* CIL Label */
    case_55: /* CIL Label */
      {
printf("\nSTMT_EXEC;;4677\n");
if (current_stat_info.had_trailing_slash)
      {
        printf("\nSTMT_EXEC;;4679\n");
goto really_dir;
      }
}

      {
        printf("\nSTMT_EXEC;;4682\n");
tmp___2 = get_stat_data((char const *)current_stat_info.file_name, &stat_data);
      }
      printf("\nSTMT_EXEC;;4684\n");
if (!tmp___2)
      {
        {
          printf("\nSTMT_EXEC;;4687\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;4689\n");
goto quit;
      }
      printf("\nSTMT_EXEC;;4691\n");
if (!((stat_data.st_mode & 61440U) == 32768U))
      {
        {
          printf("\nSTMT_EXEC;;4694\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("File type differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4695\n");
report_difference(&current_stat_info, (char const *)tmp___3);
          printf("\nSTMT_EXEC;;4696\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;4698\n");
goto quit;
      }
      printf("\nSTMT_EXEC;;4700\n");
if ((current_stat_info.stat.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))))
      {
        {
          printf("\nSTMT_EXEC;;4703\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Mode differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4704\n");
report_difference(&current_stat_info, (char const *)tmp___4);
        }
      }
      {
        printf("\nSTMT_EXEC;;4708\n");
tmp___6 = sys_compare_uid(&stat_data, &current_stat_info.stat);
      }
      printf("\nSTMT_EXEC;;4710\n");
if (!tmp___6)
      {
        {
          printf("\nSTMT_EXEC;;4713\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("Uid differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4714\n");
report_difference(&current_stat_info, (char const *)tmp___5);
        }
      }
      {
        printf("\nSTMT_EXEC;;4718\n");
tmp___8 = sys_compare_gid(&stat_data, &current_stat_info.stat);
      }
      printf("\nSTMT_EXEC;;4720\n");
if (!tmp___8)
      {
        {
          printf("\nSTMT_EXEC;;4723\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("Gid differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4724\n");
report_difference(&current_stat_info, (char const *)tmp___7);
        }
      }
      printf("\nSTMT_EXEC;;4727\n");
if (stat_data.st_mtim.tv_sec != current_stat_info.stat.st_mtim.tv_sec)
      {
        {
          printf("\nSTMT_EXEC;;4730\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("Mod time differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4731\n");
report_difference(&current_stat_info, (char const *)tmp___9);
        }
      }
      printf("\nSTMT_EXEC;;4734\n");
if ((int)current_header->header.typeflag != 83)
      {
        printf("\nSTMT_EXEC;;4736\n");
if (stat_data.st_size != current_stat_info.stat.st_size)
        {
          {
            printf("\nSTMT_EXEC;;4739\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___10 = gettext("Size differs");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;4740\n");
report_difference(&current_stat_info, (char const *)tmp___10);
            printf("\nSTMT_EXEC;;4741\n");
skip_member();
          }
          printf("\nSTMT_EXEC;;4743\n");
goto quit;
        }
      }
      {
        printf("\nSTMT_EXEC;;4747\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
diff_handle = open((char const *)current_stat_info.file_name, 0);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;4749\n");
if (diff_handle < 0)
      {
        {
          printf("\nSTMT_EXEC;;4752\n");
open_error((char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;4753\n");
skip_member();
          printf("\nSTMT_EXEC;;4754\n");
report_difference(&current_stat_info, (char const *)((void *)0));
        }
        printf("\nSTMT_EXEC;;4756\n");
goto quit;
      }
      printf("\nSTMT_EXEC;;4758\n");
restore_times.actime = stat_data.st_atim.tv_sec;
      printf("\nSTMT_EXEC;;4759\n");
restore_times.modtime = stat_data.st_mtim.tv_sec;
      printf("\nSTMT_EXEC;;4760\n");
if (current_stat_info.is_sparse)
      {
        {
          printf("\nSTMT_EXEC;;4763\n");
sparse_diff_file(diff_handle, &current_stat_info);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;4768\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;4771\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
            printf("\nSTMT_EXEC;;4772\n");
save_totsize = current_stat_info.stat.st_size;
          }
        }
        {
          printf("\nSTMT_EXEC;;4776\n");
read_and_process(current_stat_info.stat.st_size, &process_rawdata);
        }
        printf("\nSTMT_EXEC;;4778\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;4781\n");
assign_string(&save_name, (char const *)0);
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;4786\n");
printf("\nFUNC_CALL;close(int);\n");
status = close(diff_handle);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;4788\n");
if (status != 0)
      {
        {
          printf("\nSTMT_EXEC;;4791\n");
close_error((char const *)current_stat_info.file_name);
        }
      }
      printf("\nSTMT_EXEC;;4794\n");
if (atime_preserve_option)
      {
        {
          printf("\nSTMT_EXEC;;4797\n");
printf("\nFUNC_CALL;utime(const char *,const struct utimbuf *);\n");
utime((char const *)current_stat_info.file_name, (struct utimbuf const *)(&restore_times));printf("\nFUNC_RETURN;;\n");

        }
      }
    quit:
      {
printf("\nSTMT_EXEC;;4801\n");
goto switch_break;
}

    case_49: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4804\n");
tmp___11 = get_stat_data((char const *)current_stat_info.file_name, &file_data);
    }
      printf("\nSTMT_EXEC;;4806\n");
if (!tmp___11)
      {
        printf("\nSTMT_EXEC;;4808\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;4811\n");
tmp___12 = get_stat_data((char const *)current_stat_info.link_name, &link_data);
      }
      printf("\nSTMT_EXEC;;4813\n");
if (!tmp___12)
      {
        printf("\nSTMT_EXEC;;4815\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;4818\n");
tmp___15 = sys_compare_links(&file_data, &link_data);
      }
      printf("\nSTMT_EXEC;;4820\n");
if (!tmp___15)
      {
        {
          printf("\nSTMT_EXEC;;4823\n");
tmp___13 = quote((char const *)current_stat_info.link_name);
          printf("\nSTMT_EXEC;;4824\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___14 = gettext("Not linked to %s");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4825\n");
report_difference(&current_stat_info, (char const *)tmp___14, tmp___13);
        }
      }
      printf("\nSTMT_EXEC;;4828\n");
goto switch_break;
    case_50: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4831\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___16 = strlen((char const *)current_stat_info.link_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4832\n");
len = tmp___16;
      printf("\nSTMT_EXEC;;4833\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___17 = __builtin_alloca(len + 1UL);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4834\n");
linkbuf = (char *)tmp___17;
      printf("\nSTMT_EXEC;;4835\n");
printf("\nFUNC_CALL;readlink(const char *__restrict,char *__restrict,size_t);\n");
tmp___18 = readlink((char const * /* __restrict  */)current_stat_info.file_name, (char * /* __restrict  */)linkbuf, len + 1UL);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;4836\n");
status = (int)tmp___18;
    }
      printf("\nSTMT_EXEC;;4838\n");
if (status < 0)
      {
        {
          printf("\nSTMT_EXEC;;4841\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___19 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;4843\n");
if (*tmp___19 == 2)
        {
          {
            printf("\nSTMT_EXEC;;4846\n");
readlink_warn((char const *)current_stat_info.file_name);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;4852\n");
readlink_error((char const *)current_stat_info.file_name);
          }
        }
        {
          printf("\nSTMT_EXEC;;4856\n");
report_difference(&current_stat_info, (char const *)((void *)0));
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;4861\n");
if ((size_t)status != len)
        {
          {
            printf("\nSTMT_EXEC;;4864\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___20 = gettext("Symlink differs");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;4865\n");
report_difference(&current_stat_info, (char const *)tmp___20);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;4871\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___21 = strncmp((char const *)current_stat_info.link_name, (char const *)linkbuf, len);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;4873\n");
if (tmp___21 != 0)
          {
            {
              printf("\nSTMT_EXEC;;4876\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___20 = gettext("Symlink differs");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4877\n");
report_difference(&current_stat_info, (char const *)tmp___20);
            }
          }
        }
      }
      printf("\nSTMT_EXEC;;4882\n");
goto switch_break;
    case_51: /* CIL Label */
    case_52: /* CIL Label */
    case_54: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4887\n");
tmp___22 = get_stat_data((char const *)current_stat_info.file_name, &stat_data);
    }
      printf("\nSTMT_EXEC;;4889\n");
if (!tmp___22)
      {
        printf("\nSTMT_EXEC;;4891\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;4893\n");
if ((int)current_header->header.typeflag == 51)
      {
        printf("\nSTMT_EXEC;;4895\n");
tmp___35 = !((stat_data.st_mode & 61440U) == 8192U);
      }
      else
      {
        printf("\nSTMT_EXEC;;4899\n");
if ((int)current_header->header.typeflag == 52)
        {
          printf("\nSTMT_EXEC;;4901\n");
tmp___34 = !((stat_data.st_mode & 61440U) == 24576U);
        }
        else
        {
          printf("\nSTMT_EXEC;;4905\n");
tmp___34 = !((stat_data.st_mode & 61440U) == 4096U);
        }
        printf("\nSTMT_EXEC;;4907\n");
tmp___35 = tmp___34;
      }
      printf("\nSTMT_EXEC;;4909\n");
if (tmp___35)
      {
        {
          printf("\nSTMT_EXEC;;4912\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___23 = gettext("File type differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4913\n");
report_difference(&current_stat_info, (char const *)tmp___23);
        }
        printf("\nSTMT_EXEC;;4915\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;4917\n");
if ((int)current_header->header.typeflag == 51)
      {
        printf("\nSTMT_EXEC;;4919\n");
goto _L___3;
      }
      else
      {
        printf("\nSTMT_EXEC;;4923\n");
if ((int)current_header->header.typeflag == 52)
        {
        _L___3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;4926\n");
if (current_stat_info.stat.st_rdev != stat_data.st_rdev)
          {
            {
              printf("\nSTMT_EXEC;;4929\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___24 = gettext("Device number differs");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;4930\n");
report_difference(&current_stat_info, (char const *)tmp___24);
            }
            printf("\nSTMT_EXEC;;4932\n");
goto switch_break;
          }
}

        }
      }
      printf("\nSTMT_EXEC;;4936\n");
if ((current_stat_info.stat.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))))
      {
        {
          printf("\nSTMT_EXEC;;4939\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___25 = gettext("Mode differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4940\n");
report_difference(&current_stat_info, (char const *)tmp___25);
        }
        printf("\nSTMT_EXEC;;4942\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;4944\n");
goto switch_break;
    case_68: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4947\n");
tmp___26 = get_directory_contents(current_stat_info.file_name, (dev_t)0);
      printf("\nSTMT_EXEC;;4948\n");
dumpdir_buffer = tmp___26;
    }
      printf("\nSTMT_EXEC;;4950\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;4953\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;4954\n");
save_totsize = current_stat_info.stat.st_size;
        }
      }
      printf("\nSTMT_EXEC;;4957\n");
if (dumpdir_buffer)
      {
        {
          printf("\nSTMT_EXEC;;4960\n");
dumpdir_cursor = dumpdir_buffer;
          printf("\nSTMT_EXEC;;4961\n");
read_and_process(current_stat_info.stat.st_size, &process_dumpdir);
          printf("\nSTMT_EXEC;;4962\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)dumpdir_buffer);printf("\nFUNC_RETURN;;\n");

        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;4968\n");
read_and_process(current_stat_info.stat.st_size, &process_noop);
        }
      }
      printf("\nSTMT_EXEC;;4971\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;4974\n");
assign_string(&save_name, (char const *)0);
        }
      }
    really_dir:
    case_53: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;4980\n");
tmp___27 = get_stat_data((char const *)current_stat_info.file_name, &stat_data);
    }
      printf("\nSTMT_EXEC;;4982\n");
if (!tmp___27)
      {
        printf("\nSTMT_EXEC;;4984\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;4986\n");
if (!((stat_data.st_mode & 61440U) == 16384U))
      {
        {
          printf("\nSTMT_EXEC;;4989\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___28 = gettext("File type differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4990\n");
report_difference(&current_stat_info, (char const *)tmp___28);
        }
        printf("\nSTMT_EXEC;;4992\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;4994\n");
if ((current_stat_info.stat.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))))
      {
        {
          printf("\nSTMT_EXEC;;4997\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___29 = gettext("Mode differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;4998\n");
report_difference(&current_stat_info, (char const *)tmp___29);
        }
        printf("\nSTMT_EXEC;;5000\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;5002\n");
goto switch_break;
    case_86: /* CIL Label */
      {
printf("\nSTMT_EXEC;;5004\n");
goto switch_break;
}

    case_77: /* CIL Label */
      {
printf("\nSTMT_EXEC;;5006\n");
if (current_stat_info.had_trailing_slash)
      {
        printf("\nSTMT_EXEC;;5008\n");
goto really_dir;
      }
}

      {
        printf("\nSTMT_EXEC;;5011\n");
tmp___30 = get_stat_data((char const *)current_stat_info.file_name, &stat_data);
      }
      printf("\nSTMT_EXEC;;5013\n");
if (!tmp___30)
      {
        printf("\nSTMT_EXEC;;5015\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;5017\n");
if (!((stat_data.st_mode & 61440U) == 32768U))
      {
        {
          printf("\nSTMT_EXEC;;5020\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___31 = gettext("File type differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;5021\n");
report_difference(&current_stat_info, (char const *)tmp___31);
          printf("\nSTMT_EXEC;;5022\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;5024\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;5027\n");
offset = off_from_header((char const *)(current_header->oldgnu_header.offset), sizeof(current_header->oldgnu_header.offset));
      }
      printf("\nSTMT_EXEC;;5029\n");
if (stat_data.st_size != current_stat_info.stat.st_size + offset)
      {
        {
          printf("\nSTMT_EXEC;;5032\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___32 = gettext("Size differs");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;5033\n");
report_difference(&current_stat_info, (char const *)tmp___32);
          printf("\nSTMT_EXEC;;5034\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;5036\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;5039\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
diff_handle = open((char const *)current_stat_info.file_name, 0);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;5041\n");
if (diff_handle < 0)
      {
        {
          printf("\nSTMT_EXEC;;5044\n");
open_error((char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;5045\n");
report_difference(&current_stat_info, (char const *)((void *)0));
          printf("\nSTMT_EXEC;;5046\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;5048\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;5051\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___33 = lseek(diff_handle, offset, 0);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;5053\n");
if (tmp___33 < 0L)
      {
        {
          printf("\nSTMT_EXEC;;5056\n");
seek_error_details((char const *)current_stat_info.file_name, offset);
          printf("\nSTMT_EXEC;;5057\n");
report_difference(&current_stat_info, (char const *)((void *)0));
        }
        printf("\nSTMT_EXEC;;5059\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;5061\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;5064\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;5065\n");
save_totsize = stat_data.st_size;
        }
      }
      {
        printf("\nSTMT_EXEC;;5069\n");
read_and_process(current_stat_info.stat.st_size, &process_rawdata);
      }
      printf("\nSTMT_EXEC;;5071\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;5074\n");
assign_string(&save_name, (char const *)0);
        }
      }
      {
        printf("\nSTMT_EXEC;;5078\n");
printf("\nFUNC_CALL;close(int);\n");
status = close(diff_handle);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;5080\n");
if (status != 0)
      {
        {
          printf("\nSTMT_EXEC;;5083\n");
close_error((char const *)current_stat_info.file_name);
        }
      }
      printf("\nSTMT_EXEC;;5086\n");
goto switch_break;
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;5089\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void verify_volume(void)
{
  printf("\nFUNC_CALL;verify_volume();\n");
printf("\nSTMT_EXEC;;5094\n");
struct mtop operation;
  printf("\nSTMT_EXEC;;5095\n");
int status;
  printf("\nSTMT_EXEC;;5096\n");
off_t tmp;
  printf("\nSTMT_EXEC;;5097\n");
__off_t tmp___0;
  printf("\nSTMT_EXEC;;5098\n");
off_t tmp___1;
  printf("\nSTMT_EXEC;;5099\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;5100\n");
int tmp___3;
  printf("\nSTMT_EXEC;;5101\n");
int tmp___4;
  printf("\nSTMT_EXEC;;5102\n");
int tmp___5;
  printf("\nSTMT_EXEC;;5103\n");
int tmp___6;
  printf("\nSTMT_EXEC;;5104\n");
enum read_header status___0;
  printf("\nSTMT_EXEC;;5105\n");
enum read_header tmp___7;
  printf("\nSTMT_EXEC;;5106\n");
int counter;
  printf("\nSTMT_EXEC;;5107\n");
char *tmp___8;

  {
    printf("\nSTMT_EXEC;;5110\n");
if (!diff_buffer)
    {
      {
        printf("\nSTMT_EXEC;;5113\n");
diff_init();
      }
    }
    {
      printf("\nSTMT_EXEC;;5117\n");
printf("\nFUNC_CALL;fsync(int);\n");
fsync(archive);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;5118\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
ioctl(archive, (unsigned long)((unsigned int)(2 << 8) | 75U));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;5119\n");
operation.mt_op = (short)2;
      printf("\nSTMT_EXEC;;5120\n");
operation.mt_count = 1;
    }
    printf("\nSTMT_EXEC;;5122\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;5125\n");
tmp___5 = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
        printf("\nSTMT_EXEC;;5126\n");
status = tmp___5;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;5132\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___6 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;5133\n");
status = tmp___6;
      }
    }
    printf("\nSTMT_EXEC;;5136\n");
if (status < 0)
    {
      {
        printf("\nSTMT_EXEC;;5139\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;5141\n");
if (*tmp___2 != 5)
      {
        printf("\nSTMT_EXEC;;5143\n");
goto _L;
      }
      else
      {
        printf("\nSTMT_EXEC;;5147\n");
if (archive >= 1 << 30)
        {
          {
            printf("\nSTMT_EXEC;;5150\n");
tmp___3 = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
            printf("\nSTMT_EXEC;;5151\n");
status = tmp___3;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;5157\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___4 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;5158\n");
status = tmp___4;
          }
        }
        printf("\nSTMT_EXEC;;5161\n");
if (status < 0)
        {
        _L:
          {
printf("\nSTMT_EXEC;;5164\n");
if (archive >= 1 << 30)
          {
            {
              printf("\nSTMT_EXEC;;5167\n");
tmp = rmt_lseek__(archive - (1 << 30), (off_t)0, 0);
              printf("\nSTMT_EXEC;;5168\n");
tmp___1 = tmp;
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;5174\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___0 = lseek(archive, (off_t)0, 0);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;5175\n");
tmp___1 = tmp___0;
            }
          }
}

          printf("\nSTMT_EXEC;;5178\n");
if (tmp___1 != 0L)
          {
            {
              printf("\nSTMT_EXEC;;5181\n");
seek_warn(*(archive_name_array + 0));
            }
            printf("\nSTMT_EXEC;;5183\n");
printf("\nFUNC_RETURN;;\n");
return;
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;5189\n");
access_mode = (enum access_mode)0;
      printf("\nSTMT_EXEC;;5190\n");
now_verifying = (_Bool)1;
      printf("\nSTMT_EXEC;;5191\n");
flush_read();
    }
    {
      printf("\nSTMT_EXEC;;5194\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;5198\n");
tmp___7 = read_header((_Bool)0);
          printf("\nSTMT_EXEC;;5199\n");
status___0 = tmp___7;
        }
        printf("\nSTMT_EXEC;;5201\n");
if ((unsigned int)status___0 == 5U)
        {
          printf("\nSTMT_EXEC;;5203\n");
counter = 0;
          {
            printf("\nSTMT_EXEC;;5205\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              {
                printf("\nSTMT_EXEC;;5209\n");
counter++;
                printf("\nSTMT_EXEC;;5210\n");
status___0 = read_header((_Bool)0);
              }
              printf("\nSTMT_EXEC;;5212\n");
if (!((unsigned int)status___0 == 5U))
              {
                printf("\nSTMT_EXEC;;5214\n");
goto while_break___0;
              }
            }
          while_break___0: /* CIL Label */;
          }
          {
            printf("\nSTMT_EXEC;;5220\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___8 = ngettext("VERIFY FAILURE: %d invalid header detected", "VERIFY FAILURE: %d invalid headers detected", (unsigned long)counter);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;5221\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8, counter);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;5222\n");
exit_status = 2;
          }
        }
        printf("\nSTMT_EXEC;;5225\n");
if ((unsigned int)status___0 == 3U)
        {
          printf("\nSTMT_EXEC;;5227\n");
goto while_break;
        }
        else
        {
          printf("\nSTMT_EXEC;;5231\n");
if ((unsigned int)status___0 == 4U)
          {
            printf("\nSTMT_EXEC;;5233\n");
goto while_break;
          }
        }
        {
          printf("\nSTMT_EXEC;;5237\n");
diff_archive();
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;5242\n");
access_mode = (enum access_mode)1;
    printf("\nSTMT_EXEC;;5243\n");
now_verifying = (_Bool)0;
    printf("\nSTMT_EXEC;;5244\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","002.create.o.i","") */
extern __attribute__((__nothrow__)) unsigned int(__attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev) __attribute__((__const__));
extern __attribute__((__nothrow__)) unsigned int(__attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev) __attribute__((__const__));
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1, 2), __leaf__)) strncpy)(char *__restrict __dest, char const *__restrict __src, size_t __n);
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1), __leaf__)) strdup)(char const *__s) __attribute__((__malloc__));
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd, struct stat *__buf);
extern __attribute__((__nothrow__)) __uid_t(__attribute__((__leaf__)) getuid)(void);
extern __attribute__((__nothrow__)) __gid_t(__attribute__((__leaf__)) getgid)(void);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) unlink)(char const *__name);
char *savedir(char const *dir);
void *xrealloc(void *p, size_t n);
mode_t mode_adjust(mode_t oldmode, struct mode_change const *changes);
enum archive_format archive_format;
int after_date_option;
gid_t group_option;
_Bool ignore_failed_read_option;
_Bool incremental_option;
_Bool interactive_option;
char const *listed_incremental_option;
struct mode_change *mode_option;
struct timespec newer_mtime_option;
int recursion_option;
_Bool numeric_owner_option;
_Bool one_file_system_option;
uid_t owner_option;
_Bool remove_files_option;
_Bool sparse_option;
_Bool file_dumpable_p(struct tar_stat_info *st);
void create_archive(void);
void pad_archive(off_t size_left);
void dump_file(char *p, int top_level, dev_t parent_device);
union block *start_header(struct tar_stat_info *st);
void simple_finish_header(union block *header);
union block *start_private_header(char const *name, size_t size);
void write_eot(void);
void check_links(void);
void gid_to_chars(gid_t v, char *p, size_t s);
void major_to_chars(int v, char *p, size_t s);
void minor_to_chars(int v, char *p, size_t s);
void mode_to_chars(mode_t v, char *p, size_t s);
void size_to_chars(size_t v, char *p, size_t s);
void uid_to_chars(uid_t v, char *p, size_t s);
void uintmax_to_chars(uintmax_t v, char *p, size_t s);
void string_to_chars(char *str, char *p, size_t s);
void write_directory_file(void);
struct xheader extended_header;
void close_diag(char const *name);
void open_diag(char const *name);
void read_diag_details(char const *name, off_t offset, size_t size);
void readlink_diag(char const *name);
void savedir_diag(char const *name);
void stat_diag(char const *name);
void unlink_error(char const *name);
struct name *gnu_list_name;
void gid_to_gname(gid_t gid, char **gname);
int gname_to_gid(char const *gname, gid_t *gidp);
void uid_to_uname(uid_t uid, char **uname);
int uname_to_uid(char const *uname, uid_t *uidp);
char *name_next(int change_dirs);
void collect_and_sort_names(void);
char *name_from_list(void);
void blank_name_list(void);
_Bool excluded_name(char const *name);
_Bool is_avoided_name(char const *name);
int confirm(char const *message_action, char const *message_name);
void tar_stat_init(struct tar_stat_info *st);
void xheader_store(char const *keyword, struct tar_stat_info const *st, void *data);
void xheader_write(char type, char *name, struct xheader *xhdr);
void xheader_write_global(void);
void xheader_finish(struct xheader *xhdr);
char *xheader_xhdr_name(struct tar_stat_info *st);
void sys_stat_nanoseconds(struct tar_stat_info *st);
_Bool sys_file_is_archive(struct tar_stat_info *p);
_Bool sparse_file_p(struct tar_stat_info *st);
enum dump_status sparse_dump_file(int fd, struct tar_stat_info *st);
_Bool string_ascii_p(char const *str);
void *hash_lookup(Hash_table const *table___0, void const *entry);
void *hash_get_first(Hash_table const *table___0);
void *hash_get_next(Hash_table const *table___0, void const *entry);
Hash_table *hash_initialize(size_t candidate, Hash_tuning const *tuning, size_t (*hasher)(void const *, size_t), _Bool (*comparator)(void const *, void const *), void (*data_freer)(void *));
void *hash_insert(Hash_table *table___0, void const *entry);
static void to_octal(uintmax_t value, char *where, size_t size)
{
  printf("\nFUNC_CALL;to_octal(uintmax_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5330\n");
uintmax_t v;
  printf("\nSTMT_EXEC;;5331\n");
size_t i;

  {
    printf("\nSTMT_EXEC;;5334\n");
v = value;
    printf("\nSTMT_EXEC;;5335\n");
i = size;
    {
      printf("\nSTMT_EXEC;;5337\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;5340\n");
i--;
        printf("\nSTMT_EXEC;;5341\n");
*(where + i) = (char)(48UL + (v & (unsigned long)((1 << 3) - 1)));
        printf("\nSTMT_EXEC;;5342\n");
v >>= 3;
        printf("\nSTMT_EXEC;;5343\n");
if (!i)
        {
          printf("\nSTMT_EXEC;;5345\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;5350\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void to_base256(int negative, uintmax_t value, char *where, size_t size)
{
  printf("\nFUNC_CALL;to_base256(int,uintmax_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5355\n");
uintmax_t v;
  printf("\nSTMT_EXEC;;5356\n");
uintmax_t propagated_sign_bits;
  printf("\nSTMT_EXEC;;5357\n");
size_t i;

  {
    printf("\nSTMT_EXEC;;5360\n");
v = value;
    printf("\nSTMT_EXEC;;5361\n");
propagated_sign_bits = (uintmax_t)(-negative) << (8UL * sizeof(v) - 8UL);
    printf("\nSTMT_EXEC;;5362\n");
i = size;
    {
      printf("\nSTMT_EXEC;;5364\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;5367\n");
i--;
        printf("\nSTMT_EXEC;;5368\n");
*(where + i) = (char)(v & (unsigned long)((1 << 8) - 1));
        printf("\nSTMT_EXEC;;5369\n");
v = propagated_sign_bits | (v >> 8);
        printf("\nSTMT_EXEC;;5370\n");
if (!i)
        {
          printf("\nSTMT_EXEC;;5372\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;5377\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int warned_once;

static void to_chars(int negative, uintmax_t value, size_t valsize, uintmax_t (*substitute)(int *), char *where, size_t size, char const *type)
{
  printf("\nFUNC_CALL;to_chars(int,uintmax_t,size_t,uintmax_t (*)(int *),char *,size_t,const char *);\n");
printf("\nSTMT_EXEC;;5384\n");
int base256_allowed;
  printf("\nSTMT_EXEC;;5385\n");
char *tmp;
  printf("\nSTMT_EXEC;;5386\n");
uintmax_t maxval;
  printf("\nSTMT_EXEC;;5387\n");
char valbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;5388\n");
char maxbuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;5389\n");
char minbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;5390\n");
char const *minval_string;
  printf("\nSTMT_EXEC;;5391\n");
char const *maxval_string;
  printf("\nSTMT_EXEC;;5392\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;5393\n");
char const *value_string;
  printf("\nSTMT_EXEC;;5394\n");
uintmax_t m;
  printf("\nSTMT_EXEC;;5395\n");
char *p;
  printf("\nSTMT_EXEC;;5396\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;5397\n");
char *p___0;
  printf("\nSTMT_EXEC;;5398\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;5399\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;5400\n");
int negsub;
  printf("\nSTMT_EXEC;;5401\n");
uintmax_t sub;
  printf("\nSTMT_EXEC;;5402\n");
uintmax_t tmp___4;
  printf("\nSTMT_EXEC;;5403\n");
uintmax_t s;
  printf("\nSTMT_EXEC;;5404\n");
char subbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;5405\n");
char *sub_string;
  printf("\nSTMT_EXEC;;5406\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;5407\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;5408\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;5409\n");
int tmp___8;
  printf("\nSTMT_EXEC;;5410\n");
int tmp___9;
  printf("\nSTMT_EXEC;;5411\n");
unsigned long tmp___10;
  printf("\nSTMT_EXEC;;5412\n");
unsigned long tmp___11;
  printf("\nSTMT_EXEC;;5413\n");
unsigned long tmp___12;
  printf("\nSTMT_EXEC;;5414\n");
unsigned long tmp___13;
  printf("\nSTMT_EXEC;;5415\n");
unsigned long tmp___14;
  printf("\nSTMT_EXEC;;5416\n");
unsigned long tmp___15;
  printf("\nSTMT_EXEC;;5417\n");
void *__cil_tmp41;
  printf("\nSTMT_EXEC;;5418\n");
void *__cil_tmp42;
  printf("\nSTMT_EXEC;;5419\n");
void *__cil_tmp43;
  printf("\nSTMT_EXEC;;5420\n");
void *__cil_tmp44;
  printf("\nSTMT_EXEC;;5421\n");
char *__cil_tmp45;
  printf("\nSTMT_EXEC;;5422\n");
char *__cil_tmp46;
  printf("\nSTMT_EXEC;;5423\n");
char *__cil_tmp47;
  printf("\nSTMT_EXEC;;5424\n");
char *__cil_tmp48;

  {
    printf("\nSTMT_EXEC;;5427\n");
if ((unsigned int)archive_format == 6U)
    {
      printf("\nSTMT_EXEC;;5429\n");
tmp___8 = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;5433\n");
if ((unsigned int)archive_format == 2U)
      {
        printf("\nSTMT_EXEC;;5435\n");
tmp___8 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;5439\n");
tmp___8 = 0;
      }
    }
    printf("\nSTMT_EXEC;;5442\n");
base256_allowed = tmp___8;
    printf("\nSTMT_EXEC;;5443\n");
if (!negative)
    {
      printf("\nSTMT_EXEC;;5445\n");
if ((size - 1UL) * 3UL < sizeof(uintmax_t) * 8UL)
      {
        printf("\nSTMT_EXEC;;5447\n");
tmp___15 = (1UL << (size - 1UL) * 3UL) - 1UL;
      }
      else
      {
        printf("\nSTMT_EXEC;;5451\n");
tmp___15 = (uintmax_t)-1;
      }
      printf("\nSTMT_EXEC;;5453\n");
if (value <= tmp___15)
      {
        {
          printf("\nSTMT_EXEC;;5456\n");
*(where + (size - 1UL)) = (char)'\000';
          printf("\nSTMT_EXEC;;5457\n");
to_octal(value, where, size - 1UL);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;5462\n");
goto _L___5;
      }
    }
    else
    {
    _L___5: /* CIL Label */
      {
printf("\nSTMT_EXEC;;5468\n");
if (negative)
      {
        printf("\nSTMT_EXEC;;5470\n");
tmp___13 = 0xffffffffffffffffUL - value;
      }
      else
      {
        printf("\nSTMT_EXEC;;5474\n");
tmp___13 = value;
      }
}

      printf("\nSTMT_EXEC;;5476\n");
if ((size - 1UL) * 8UL < sizeof(uintmax_t) * 8UL)
      {
        printf("\nSTMT_EXEC;;5478\n");
tmp___14 = (1UL << (size - 1UL) * 8UL) - 1UL;
      }
      else
      {
        printf("\nSTMT_EXEC;;5482\n");
tmp___14 = (uintmax_t)-1;
      }
      printf("\nSTMT_EXEC;;5484\n");
if (tmp___13 <= tmp___14)
      {
        printf("\nSTMT_EXEC;;5486\n");
if (base256_allowed)
        {
          printf("\nSTMT_EXEC;;5488\n");
if (negative)
          {
            printf("\nSTMT_EXEC;;5490\n");
tmp___9 = -1;
          }
          else
          {
            printf("\nSTMT_EXEC;;5494\n");
tmp___9 = 1 << 7;
          }
          {
            printf("\nSTMT_EXEC;;5497\n");
*(where + 0) = (char)tmp___9;
            printf("\nSTMT_EXEC;;5498\n");
to_base256(negative, value, where + 1, size - 1UL);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;5503\n");
goto _L___4;
        }
      }
      else
      {
      _L___4: /* CIL Label */
        {
printf("\nSTMT_EXEC;;5509\n");
if (negative)
        {
          printf("\nSTMT_EXEC;;5511\n");
if (valsize * 8UL <= (size - 1UL) * 3UL)
          {
            printf("\nSTMT_EXEC;;5513\n");
if (!warned_once)
            {
              {
                printf("\nSTMT_EXEC;;5516\n");
warned_once = 1;
                printf("\nSTMT_EXEC;;5517\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Generating negative octal headers");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;5518\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

              }
            }
            printf("\nSTMT_EXEC;;5521\n");
*(where + (size - 1UL)) = (char)'\000';
            printf("\nSTMT_EXEC;;5522\n");
if (valsize * 8UL < sizeof(uintmax_t) * 8UL)
            {
              printf("\nSTMT_EXEC;;5524\n");
tmp___10 = (1UL << valsize * 8UL) - 1UL;
            }
            else
            {
              printf("\nSTMT_EXEC;;5528\n");
tmp___10 = (uintmax_t)-1;
            }
            {
              printf("\nSTMT_EXEC;;5531\n");
to_octal(value & tmp___10, where, size - 1UL);
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;5536\n");
goto _L___3;
          }
        }
        else
        {
        _L___3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;5542\n");
if (base256_allowed)
          {
            printf("\nSTMT_EXEC;;5544\n");
if ((size - 1UL) * 8UL < sizeof(uintmax_t) * 8UL)
            {
              printf("\nSTMT_EXEC;;5546\n");
tmp___11 = (1UL << (size - 1UL) * 8UL) - 1UL;
            }
            else
            {
              printf("\nSTMT_EXEC;;5550\n");
tmp___11 = (uintmax_t)-1;
            }
            printf("\nSTMT_EXEC;;5552\n");
maxval = tmp___11;
          }
          else
          {
            printf("\nSTMT_EXEC;;5556\n");
if ((size - 1UL) * 3UL < sizeof(uintmax_t) * 8UL)
            {
              printf("\nSTMT_EXEC;;5558\n");
tmp___12 = (1UL << (size - 1UL) * 3UL) - 1UL;
            }
            else
            {
              printf("\nSTMT_EXEC;;5562\n");
tmp___12 = (uintmax_t)-1;
            }
            printf("\nSTMT_EXEC;;5564\n");
maxval = tmp___12;
          }
}

          {
            printf("\nSTMT_EXEC;;5567\n");
tmp___0 = stringify_uintmax_t_backwards(maxval, maxbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
            printf("\nSTMT_EXEC;;5568\n");
maxval_string = (char const *)tmp___0;
          }
          printf("\nSTMT_EXEC;;5570\n");
if (base256_allowed)
          {
            printf("\nSTMT_EXEC;;5572\n");
if (maxval + 1UL)
            {
              printf("\nSTMT_EXEC;;5574\n");
m = maxval + 1UL;
            }
            else
            {
              printf("\nSTMT_EXEC;;5578\n");
m = maxval / 2UL + 1UL;
            }
            {
              printf("\nSTMT_EXEC;;5581\n");
tmp___1 = stringify_uintmax_t_backwards(m, (minbuf + 1) + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;5582\n");
p = tmp___1;
              printf("\nSTMT_EXEC;;5583\n");
p--;
              printf("\nSTMT_EXEC;;5584\n");
*p = (char)'-';
              printf("\nSTMT_EXEC;;5585\n");
minval_string = (char const *)p;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;5590\n");
minval_string = "0";
          }
          printf("\nSTMT_EXEC;;5592\n");
if (negative)
          {
            {
              printf("\nSTMT_EXEC;;5595\n");
tmp___2 = stringify_uintmax_t_backwards(-value, (valbuf + 1) + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;5596\n");
p___0 = tmp___2;
              printf("\nSTMT_EXEC;;5597\n");
p___0--;
              printf("\nSTMT_EXEC;;5598\n");
*p___0 = (char)'-';
              printf("\nSTMT_EXEC;;5599\n");
value_string = (char const *)p___0;
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;5605\n");
tmp___3 = stringify_uintmax_t_backwards(value, valbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;5606\n");
value_string = (char const *)tmp___3;
            }
          }
          printf("\nSTMT_EXEC;;5609\n");
if (substitute)
          {
            {
              printf("\nSTMT_EXEC;;5612\n");
tmp___4 = (*substitute)(&negsub);
              printf("\nSTMT_EXEC;;5613\n");
sub = tmp___4 & maxval;
              printf("\nSTMT_EXEC;;5614\n");
negsub &= (unsigned int)archive_format == 6U;
            }
            printf("\nSTMT_EXEC;;5616\n");
if (negsub)
            {
              printf("\nSTMT_EXEC;;5618\n");
s = -sub;
            }
            else
            {
              printf("\nSTMT_EXEC;;5622\n");
s = sub;
            }
            {
              printf("\nSTMT_EXEC;;5625\n");
tmp___5 = stringify_uintmax_t_backwards(s, (subbuf + 1) + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;5626\n");
sub_string = tmp___5;
            }
            printf("\nSTMT_EXEC;;5628\n");
if (negsub)
            {
              printf("\nSTMT_EXEC;;5630\n");
sub_string--;
              printf("\nSTMT_EXEC;;5631\n");
*sub_string = (char)'-';
            }
            {
              printf("\nSTMT_EXEC;;5634\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("value %s out of %s range %s..%s; substituting %s");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;5635\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___6, value_string, type, minval_string, maxval_string, sub_string);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;5636\n");
to_chars(negsub, s, valsize, (uintmax_t(*)(int *))0, where, size, type);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;5642\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("value %s out of %s range %s..%s");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;5643\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___7, value_string, type, minval_string, maxval_string);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;5644\n");
exit_status = 2;
            }
          }
        }
}

      }
    }
    printf("\nSTMT_EXEC;;5650\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static gid_t gid_nobody;
static uintmax_t gid_substitute(int *negative)
{
  printf("\nFUNC_CALL;gid_substitute(int *);\n");
printf("\nSTMT_EXEC;;5656\n");
gid_t r;
  printf("\nSTMT_EXEC;;5657\n");
int tmp;
  printf("\nSTMT_EXEC;;5658\n");
char *__cil_tmp4;

  {
    printf("\nSTMT_EXEC;;5661\n");
if (!gid_nobody)
    {
      {
        printf("\nSTMT_EXEC;;5664\n");
tmp = gname_to_gid("nobody", &gid_nobody);
      }
      printf("\nSTMT_EXEC;;5666\n");
if (!tmp)
      {
        printf("\nSTMT_EXEC;;5668\n");
gid_nobody = (gid_t)-2;
      }
    }
    printf("\nSTMT_EXEC;;5671\n");
r = gid_nobody;
    printf("\nSTMT_EXEC;;5672\n");
*negative = r < 0U;
    printf("\nSTMT_EXEC;;5673\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)r);
  }
printf("\nFUNC_RETURN;;\n");
}
void gid_to_chars(gid_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;gid_to_chars(gid_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5678\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5682\n");
to_chars(v < 0U, (uintmax_t)v, sizeof(v), &gid_substitute, p, s, "gid_t");
    }
    printf("\nSTMT_EXEC;;5684\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void major_to_chars(int v, char *p, size_t s)
{
  printf("\nFUNC_CALL;major_to_chars(int,char *,size_t);\n");
printf("\nSTMT_EXEC;;5689\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5693\n");
to_chars(v < 0, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "major_t");
    }
    printf("\nSTMT_EXEC;;5695\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void minor_to_chars(int v, char *p, size_t s)
{
  printf("\nFUNC_CALL;minor_to_chars(int,char *,size_t);\n");
printf("\nSTMT_EXEC;;5700\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5704\n");
to_chars(v < 0, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "minor_t");
    }
    printf("\nSTMT_EXEC;;5706\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void mode_to_chars(mode_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;mode_to_chars(mode_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5711\n");
int negative;
  printf("\nSTMT_EXEC;;5712\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;5713\n");
int tmp;
  printf("\nSTMT_EXEC;;5714\n");
int tmp___0;
  printf("\nSTMT_EXEC;;5715\n");
int tmp___1;
  printf("\nSTMT_EXEC;;5716\n");
int tmp___2;
  printf("\nSTMT_EXEC;;5717\n");
int tmp___3;
  printf("\nSTMT_EXEC;;5718\n");
int tmp___4;
  printf("\nSTMT_EXEC;;5719\n");
int tmp___5;
  printf("\nSTMT_EXEC;;5720\n");
int tmp___6;
  printf("\nSTMT_EXEC;;5721\n");
int tmp___7;
  printf("\nSTMT_EXEC;;5722\n");
int tmp___8;
  printf("\nSTMT_EXEC;;5723\n");
int tmp___9;
  printf("\nSTMT_EXEC;;5724\n");
int tmp___10;
  printf("\nSTMT_EXEC;;5725\n");
char *__cil_tmp18;

  {
    printf("\nSTMT_EXEC;;5728\n");
if (256 >> 3 == 32)
    {
      printf("\nSTMT_EXEC;;5730\n");
if (128 >> 3 == 16)
      {
        printf("\nSTMT_EXEC;;5732\n");
if (64 >> 3 == 8)
        {
          printf("\nSTMT_EXEC;;5734\n");
if ((256 >> 3) >> 3 == 4)
          {
            printf("\nSTMT_EXEC;;5736\n");
if ((128 >> 3) >> 3 == 2)
            {
              printf("\nSTMT_EXEC;;5738\n");
if ((64 >> 3) >> 3 == 1)
              {
                printf("\nSTMT_EXEC;;5740\n");
if ((unsigned int)archive_format != 4U)
                {
                  printf("\nSTMT_EXEC;;5742\n");
if ((unsigned int)archive_format != 3U)
                  {
                    printf("\nSTMT_EXEC;;5744\n");
if ((unsigned int)archive_format != 6U)
                    {
                      printf("\nSTMT_EXEC;;5746\n");
negative = v < 0U;
                      printf("\nSTMT_EXEC;;5747\n");
u = (uintmax_t)v;
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;5751\n");
goto _L___10;
                    }
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;5756\n");
goto _L___10;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;5761\n");
goto _L___10;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;5766\n");
goto _L___10;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;5771\n");
goto _L___10;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;5776\n");
goto _L___10;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;5781\n");
goto _L___10;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;5786\n");
goto _L___10;
      }
    }
    else
    {
    _L___10: /* CIL Label */
      {
printf("\nSTMT_EXEC;;5792\n");
negative = 0;
}

      printf("\nSTMT_EXEC;;5793\n");
if (v & 2048U)
      {
        printf("\nSTMT_EXEC;;5795\n");
tmp = 2048;
      }
      else
      {
        printf("\nSTMT_EXEC;;5799\n");
tmp = 0;
      }
      printf("\nSTMT_EXEC;;5801\n");
if (v & 1024U)
      {
        printf("\nSTMT_EXEC;;5803\n");
tmp___0 = 1024;
      }
      else
      {
        printf("\nSTMT_EXEC;;5807\n");
tmp___0 = 0;
      }
      printf("\nSTMT_EXEC;;5809\n");
if (v & 512U)
      {
        printf("\nSTMT_EXEC;;5811\n");
tmp___1 = 512;
      }
      else
      {
        printf("\nSTMT_EXEC;;5815\n");
tmp___1 = 0;
      }
      printf("\nSTMT_EXEC;;5817\n");
if (v & 256U)
      {
        printf("\nSTMT_EXEC;;5819\n");
tmp___2 = 256;
      }
      else
      {
        printf("\nSTMT_EXEC;;5823\n");
tmp___2 = 0;
      }
      printf("\nSTMT_EXEC;;5825\n");
if (v & 128U)
      {
        printf("\nSTMT_EXEC;;5827\n");
tmp___3 = 128;
      }
      else
      {
        printf("\nSTMT_EXEC;;5831\n");
tmp___3 = 0;
      }
      printf("\nSTMT_EXEC;;5833\n");
if (v & 64U)
      {
        printf("\nSTMT_EXEC;;5835\n");
tmp___4 = 64;
      }
      else
      {
        printf("\nSTMT_EXEC;;5839\n");
tmp___4 = 0;
      }
      printf("\nSTMT_EXEC;;5841\n");
if (v & (unsigned int)(256 >> 3))
      {
        printf("\nSTMT_EXEC;;5843\n");
tmp___5 = 32;
      }
      else
      {
        printf("\nSTMT_EXEC;;5847\n");
tmp___5 = 0;
      }
      printf("\nSTMT_EXEC;;5849\n");
if (v & (unsigned int)(128 >> 3))
      {
        printf("\nSTMT_EXEC;;5851\n");
tmp___6 = 16;
      }
      else
      {
        printf("\nSTMT_EXEC;;5855\n");
tmp___6 = 0;
      }
      printf("\nSTMT_EXEC;;5857\n");
if (v & (unsigned int)(64 >> 3))
      {
        printf("\nSTMT_EXEC;;5859\n");
tmp___7 = 8;
      }
      else
      {
        printf("\nSTMT_EXEC;;5863\n");
tmp___7 = 0;
      }
      printf("\nSTMT_EXEC;;5865\n");
if (v & (unsigned int)((256 >> 3) >> 3))
      {
        printf("\nSTMT_EXEC;;5867\n");
tmp___8 = 4;
      }
      else
      {
        printf("\nSTMT_EXEC;;5871\n");
tmp___8 = 0;
      }
      printf("\nSTMT_EXEC;;5873\n");
if (v & (unsigned int)((128 >> 3) >> 3))
      {
        printf("\nSTMT_EXEC;;5875\n");
tmp___9 = 2;
      }
      else
      {
        printf("\nSTMT_EXEC;;5879\n");
tmp___9 = 0;
      }
      printf("\nSTMT_EXEC;;5881\n");
if (v & (unsigned int)((64 >> 3) >> 3))
      {
        printf("\nSTMT_EXEC;;5883\n");
tmp___10 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;5887\n");
tmp___10 = 0;
      }
      printf("\nSTMT_EXEC;;5889\n");
u = (uintmax_t)(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
    }
    {
      printf("\nSTMT_EXEC;;5892\n");
to_chars(negative, u, sizeof(v), (uintmax_t(*)(int *))0, p, s, "mode_t");
    }
    printf("\nSTMT_EXEC;;5894\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}








































































void off_to_chars(off_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;off_to_chars(off_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5971\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5975\n");
to_chars(v < 0L, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "off_t");
    }
    printf("\nSTMT_EXEC;;5977\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void size_to_chars(size_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;size_to_chars(size_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5982\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5986\n");
to_chars(0, v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "size_t");
    }
    printf("\nSTMT_EXEC;;5988\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void time_to_chars(time_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;time_to_chars(time_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;5993\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;5997\n");
to_chars(v < 0L, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "time_t");
    }
    printf("\nSTMT_EXEC;;5999\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static uid_t uid_nobody;
static uintmax_t uid_substitute(int *negative)
{
  printf("\nFUNC_CALL;uid_substitute(int *);\n");
printf("\nSTMT_EXEC;;6005\n");
uid_t r;
  printf("\nSTMT_EXEC;;6006\n");
int tmp;
  printf("\nSTMT_EXEC;;6007\n");
char *__cil_tmp4;

  {
    printf("\nSTMT_EXEC;;6010\n");
if (!uid_nobody)
    {
      {
        printf("\nSTMT_EXEC;;6013\n");
tmp = uname_to_uid("nobody", &uid_nobody);
      }
      printf("\nSTMT_EXEC;;6015\n");
if (!tmp)
      {
        printf("\nSTMT_EXEC;;6017\n");
uid_nobody = (uid_t)-2;
      }
    }
    printf("\nSTMT_EXEC;;6020\n");
r = uid_nobody;
    printf("\nSTMT_EXEC;;6021\n");
*negative = r < 0U;
    printf("\nSTMT_EXEC;;6022\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)r);
  }
printf("\nFUNC_RETURN;;\n");
}
void uid_to_chars(uid_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;uid_to_chars(uid_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;6027\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;6031\n");
to_chars(v < 0U, (uintmax_t)v, sizeof(v), &uid_substitute, p, s, "uid_t");
    }
    printf("\nSTMT_EXEC;;6033\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void uintmax_to_chars(uintmax_t v, char *p, size_t s)
{
  printf("\nFUNC_CALL;uintmax_to_chars(uintmax_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;6038\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;6042\n");
to_chars(0, v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "uintmax_t");
    }
    printf("\nSTMT_EXEC;;6044\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void string_to_chars(char *str, char *p, size_t s)
{

  printf("\nFUNC_CALL;string_to_chars(char *,char *,size_t);\n");
{
    {
      printf("\nSTMT_EXEC;;6052\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)p, (char const * /* __restrict  */)str, s);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6053\n");
*(p + (s - 1UL)) = (char)0;
    }
    printf("\nSTMT_EXEC;;6055\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool file_dumpable_p(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;file_dumpable_p(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6060\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;6063\n");
if (dev_null_output)
    {
      printf("\nSTMT_EXEC;;6065\n");
tmp = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;6069\n");
if (st->archive_file_size == 0L)
      {
        printf("\nSTMT_EXEC;;6071\n");
if ((st->stat.st_mode & (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3))) == (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3)))
        {
          printf("\nSTMT_EXEC;;6073\n");
tmp = 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;6077\n");
tmp = 1;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;6082\n");
tmp = 1;
      }
    }
    printf("\nSTMT_EXEC;;6085\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}



void write_eot(void)
{
  printf("\nFUNC_CALL;write_eot();\n");
printf("\nSTMT_EXEC;;6093\n");
union block *pointer;
  printf("\nSTMT_EXEC;;6094\n");
union block *tmp;
  printf("\nSTMT_EXEC;;6095\n");
size_t tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;6099\n");
tmp = find_next_block();
      printf("\nSTMT_EXEC;;6100\n");
pointer = tmp;
      printf("\nSTMT_EXEC;;6101\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(pointer->buffer), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6102\n");
set_next_block_after(pointer);
      printf("\nSTMT_EXEC;;6103\n");
pointer = find_next_block();
      printf("\nSTMT_EXEC;;6104\n");
tmp___0 = available_space_after(pointer);
      printf("\nSTMT_EXEC;;6105\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(pointer->buffer), 0, tmp___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6106\n");
set_next_block_after(pointer);
    }
    printf("\nSTMT_EXEC;;6108\n");
printf("\nFUNC_RETURN;;\n");
return;




  }
printf("\nFUNC_RETURN;;\n");
}
static void tar_copy_str(char *dst, char const *src, size_t len)
{

  printf("\nFUNC_CALL;tar_copy_str(char *,const char *,size_t);\n");
{
    {
      printf("\nSTMT_EXEC;;6120\n");
*(dst + (len - 1UL)) = (char)0;
      printf("\nSTMT_EXEC;;6121\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)dst, (char const * /* __restrict  */)src, len);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;6123\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
union block *start_private_header(char const *name, size_t size)
{
  printf("\nFUNC_CALL;start_private_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;6128\n");
time_t t;
  printf("\nSTMT_EXEC;;6129\n");
union block *header;
  printf("\nSTMT_EXEC;;6130\n");
union block *tmp;
  printf("\nSTMT_EXEC;;6131\n");
__uid_t tmp___0;
  printf("\nSTMT_EXEC;;6132\n");
__gid_t tmp___1;
  printf("\nSTMT_EXEC;;6133\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;6134\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;6138\n");
tmp = find_next_block();
      printf("\nSTMT_EXEC;;6139\n");
header = tmp;
      printf("\nSTMT_EXEC;;6140\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(header->buffer), 0, sizeof(union block));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6141\n");
tar_copy_str(header->header.name, name, (size_t)100);
      printf("\nSTMT_EXEC;;6142\n");
off_to_chars((off_t)size, header->header.size, sizeof(header->header.size));
      printf("\nSTMT_EXEC;;6143\n");
printf("\nFUNC_CALL;time(time_t *);\n");
time(&t);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6144\n");
time_to_chars(t, header->header.mtime, sizeof(header->header.mtime));
      printf("\nSTMT_EXEC;;6145\n");
mode_to_chars((mode_t)((33152 | (256 >> 3)) | ((256 >> 3) >> 3)), header->header.mode, sizeof(header->header.mode));
      printf("\nSTMT_EXEC;;6146\n");
printf("\nFUNC_CALL;getuid();\n");
tmp___0 = getuid();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6147\n");
uid_to_chars(tmp___0, header->header.uid, sizeof(header->header.uid));
      printf("\nSTMT_EXEC;;6148\n");
printf("\nFUNC_CALL;getgid();\n");
tmp___1 = getgid();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6149\n");
gid_to_chars(tmp___1, header->header.gid, sizeof(header->header.gid));
      printf("\nSTMT_EXEC;;6150\n");
major_to_chars(0, header->header.devmajor, sizeof(header->header.devmajor));
      printf("\nSTMT_EXEC;;6151\n");
major_to_chars(0, header->header.devminor, sizeof(header->header.devminor));
      printf("\nSTMT_EXEC;;6152\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)(header->header.magic), (char const * /* __restrict  */) "ustar", (size_t)6);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6153\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)(header->header.version), (char const * /* __restrict  */) "00", (size_t)2);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;6155\n");
printf("\nFUNC_RETURN;;\n");
return (header);
  }
printf("\nFUNC_RETURN;;\n");
}



static union block *write_short_name(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;write_short_name(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6163\n");
union block *header;
  printf("\nSTMT_EXEC;;6164\n");
union block *tmp;

  {
    {
      printf("\nSTMT_EXEC;;6168\n");
tmp = find_next_block();
      printf("\nSTMT_EXEC;;6169\n");
header = tmp;
      printf("\nSTMT_EXEC;;6170\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(header->buffer), 0, sizeof(union block));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6171\n");
tar_copy_str(header->header.name, (char const *)st->file_name, (size_t)100);
    }
    printf("\nSTMT_EXEC;;6173\n");
printf("\nFUNC_RETURN;;\n");
return (header);
  }
printf("\nFUNC_RETURN;;\n");
}
static void write_gnu_long_link(struct tar_stat_info *st, char const *p, char type)
{
  printf("\nFUNC_CALL;write_gnu_long_link(struct tar_stat_info *,const char *,char);\n");
printf("\nSTMT_EXEC;;6178\n");
size_t size;
  printf("\nSTMT_EXEC;;6179\n");
size_t tmp;
  printf("\nSTMT_EXEC;;6180\n");
size_t bufsize;
  printf("\nSTMT_EXEC;;6181\n");
union block *header;
  printf("\nSTMT_EXEC;;6182\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;6183\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;6187\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(p);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6188\n");
size = tmp + 1UL;
      printf("\nSTMT_EXEC;;6189\n");
header = start_private_header("././@LongLink", size);
      printf("\nSTMT_EXEC;;6190\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(header->header.magic), (char const * /* __restrict  */) "ustar  ");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6191\n");
header->header.typeflag = type;
      printf("\nSTMT_EXEC;;6192\n");
finish_header(st, header, (off_t)-1);
      printf("\nSTMT_EXEC;;6193\n");
header = find_next_block();
      printf("\nSTMT_EXEC;;6194\n");
bufsize = available_space_after(header);
    }
    {
      printf("\nSTMT_EXEC;;6197\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;6200\n");
if (!(bufsize < size))
        {
          printf("\nSTMT_EXEC;;6202\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;6205\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->buffer), (void const * /* __restrict  */)p, bufsize);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;6206\n");
p += bufsize;
          printf("\nSTMT_EXEC;;6207\n");
size -= bufsize;
          printf("\nSTMT_EXEC;;6208\n");
set_next_block_after(header + (bufsize - 1UL) / 512UL);
          printf("\nSTMT_EXEC;;6209\n");
header = find_next_block();
          printf("\nSTMT_EXEC;;6210\n");
bufsize = available_space_after(header);
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;6216\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->buffer), (void const * /* __restrict  */)p, size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6217\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(header->buffer + size), 0, bufsize - size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6218\n");
set_next_block_after(header + (size - 1UL) / 512UL);
    }
    printf("\nSTMT_EXEC;;6220\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static size_t split_long_name(char const *name, size_t length)
{
  printf("\nFUNC_CALL;split_long_name(const char *,size_t);\n");
printf("\nSTMT_EXEC;;6225\n");
size_t i;

  {
    printf("\nSTMT_EXEC;;6228\n");
if (length > 155UL)
    {
      printf("\nSTMT_EXEC;;6230\n");
length = (size_t)157;
    }
    printf("\nSTMT_EXEC;;6232\n");
i = length - 1UL;
    {
      printf("\nSTMT_EXEC;;6234\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;6237\n");
if (!(i > 0UL))
        {
          printf("\nSTMT_EXEC;;6239\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;6241\n");
if ((int const) * (name + i) == 47)
        {
          printf("\nSTMT_EXEC;;6243\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;6245\n");
i--;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;6249\n");
printf("\nFUNC_RETURN;;\n");
return (i);
  }
printf("\nFUNC_RETURN;;\n");
}
static union block *write_ustar_long_name(char const *name)
{
  printf("\nFUNC_CALL;write_ustar_long_name(const char *);\n");
printf("\nSTMT_EXEC;;6254\n");
size_t length;
  printf("\nSTMT_EXEC;;6255\n");
size_t tmp;
  printf("\nSTMT_EXEC;;6256\n");
size_t i;
  printf("\nSTMT_EXEC;;6257\n");
union block *header;
  printf("\nSTMT_EXEC;;6258\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;6259\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;6260\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;6261\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;6262\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;6263\n");
char *__cil_tmp11;
  printf("\nSTMT_EXEC;;6264\n");
char *__cil_tmp12;

  {
    {
      printf("\nSTMT_EXEC;;6268\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6269\n");
length = tmp;
    }
    printf("\nSTMT_EXEC;;6271\n");
if (length > 256UL)
    {
      {
        printf("\nSTMT_EXEC;;6274\n");
tmp___0 = quotearg_colon(name);
        printf("\nSTMT_EXEC;;6275\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: file name is too long (max %d); not dumped");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;6276\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, tmp___0, 256);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;6277\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;6279\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)((void *)0));
    }
    {
      printf("\nSTMT_EXEC;;6282\n");
i = split_long_name(name, length);
    }
    printf("\nSTMT_EXEC;;6284\n");
if (i == 0UL)
    {
      {
        printf("\nSTMT_EXEC;;6287\n");
tmp___2 = quotearg_colon(name);
        printf("\nSTMT_EXEC;;6288\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("%s: file name is too long (cannot be split); not dumped");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;6289\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;6290\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;6292\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)((void *)0));
    }
    else
    {
      printf("\nSTMT_EXEC;;6296\n");
if ((length - i) - 1UL > 100UL)
      {
        {
          printf("\nSTMT_EXEC;;6299\n");
tmp___2 = quotearg_colon(name);
          printf("\nSTMT_EXEC;;6300\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("%s: file name is too long (cannot be split); not dumped");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;6301\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;6302\n");
exit_status = 2;
        }
        printf("\nSTMT_EXEC;;6304\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)((void *)0));
      }
    }
    {
      printf("\nSTMT_EXEC;;6308\n");
header = find_next_block();
      printf("\nSTMT_EXEC;;6309\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(header->buffer), 0, sizeof(header->buffer));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6310\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->header.prefix), (void const * /* __restrict  */)name, i);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6311\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->header.name), (void const * /* __restrict  */)((name + i) + 1), (length - i) - 1UL);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;6313\n");
printf("\nFUNC_RETURN;;\n");
return (header);
  }
printf("\nFUNC_RETURN;;\n");
}
static void write_long_link(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;write_long_link(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6318\n");
char *tmp;
  printf("\nSTMT_EXEC;;6319\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;6320\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;6321\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;6325\n");
if ((unsigned int)archive_format == 4U)
      {
        printf("\nSTMT_EXEC;;6327\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;6329\n");
if ((unsigned int)archive_format == 1U)
      {
        printf("\nSTMT_EXEC;;6331\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;6333\n");
if ((unsigned int)archive_format == 3U)
      {
        printf("\nSTMT_EXEC;;6335\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;6337\n");
if ((unsigned int)archive_format == 5U)
      {
        printf("\nSTMT_EXEC;;6339\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;6341\n");
if ((unsigned int)archive_format == 2U)
      {
        printf("\nSTMT_EXEC;;6343\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6345\n");
if ((unsigned int)archive_format == 6U)
      {
        printf("\nSTMT_EXEC;;6347\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6349\n");
goto switch_default;
    case_4: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6352\n");
xheader_store("linkpath", (struct tar_stat_info const *)st, (void *)0);
    }
      printf("\nSTMT_EXEC;;6354\n");
goto switch_break;
    case_1: /* CIL Label */
    case_3: /* CIL Label */
    case_5: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6359\n");
tmp = quotearg_colon((char const *)st->link_name);
      printf("\nSTMT_EXEC;;6360\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: link name is too long; not dumped");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6361\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6362\n");
exit_status = 2;
    }
      printf("\nSTMT_EXEC;;6364\n");
goto switch_break;
    case_2: /* CIL Label */
    case_6: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6368\n");
write_gnu_long_link(st, (char const *)st->link_name, (char)'K');
    }
      printf("\nSTMT_EXEC;;6370\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6373\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;6377\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static union block *write_long_name(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;write_long_name(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6382\n");
char *tmp;
  printf("\nSTMT_EXEC;;6383\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;6384\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;6385\n");
union block *tmp___2;
  printf("\nSTMT_EXEC;;6386\n");
union block *tmp___3;
  printf("\nSTMT_EXEC;;6387\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;6388\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;6392\n");
if ((unsigned int)archive_format == 4U)
      {
        printf("\nSTMT_EXEC;;6394\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;6396\n");
if ((unsigned int)archive_format == 1U)
      {
        printf("\nSTMT_EXEC;;6398\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;6400\n");
if ((unsigned int)archive_format == 3U)
      {
        printf("\nSTMT_EXEC;;6402\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;6404\n");
if ((unsigned int)archive_format == 5U)
      {
        printf("\nSTMT_EXEC;;6406\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;6408\n");
if ((unsigned int)archive_format == 2U)
      {
        printf("\nSTMT_EXEC;;6410\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6412\n");
if ((unsigned int)archive_format == 6U)
      {
        printf("\nSTMT_EXEC;;6414\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6416\n");
goto switch_default;
    case_4: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6419\n");
xheader_store("path", (struct tar_stat_info const *)st, (void *)0);
    }
      printf("\nSTMT_EXEC;;6421\n");
goto switch_break;
    case_1: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6424\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)st->file_name);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;6426\n");
if (tmp___1 > 99UL)
      {
        {
          printf("\nSTMT_EXEC;;6429\n");
tmp = quotearg_colon((char const *)st->file_name);
          printf("\nSTMT_EXEC;;6430\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: file name is too long (max %d); not dumped");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;6431\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp, 99);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;6432\n");
exit_status = 2;
        }
        printf("\nSTMT_EXEC;;6434\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)((void *)0));
      }
      printf("\nSTMT_EXEC;;6436\n");
goto switch_break;
    case_3: /* CIL Label */
    case_5: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6440\n");
tmp___2 = write_ustar_long_name((char const *)st->file_name);
    }
      printf("\nSTMT_EXEC;;6442\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___2);
    case_2: /* CIL Label */
    case_6: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6446\n");
write_gnu_long_link(st, (char const *)st->file_name, (char)'L');
    }
      printf("\nSTMT_EXEC;;6448\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6451\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;6456\n");
tmp___3 = write_short_name(st);
    }
    printf("\nSTMT_EXEC;;6458\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___3);
  }
printf("\nFUNC_RETURN;;\n");
}
static union block *write_extended(struct tar_stat_info *st, union block *old_header)
{
  printf("\nFUNC_CALL;write_extended(struct tar_stat_info *,union block *);\n");
printf("\nSTMT_EXEC;;6463\n");
union block *header;
  printf("\nSTMT_EXEC;;6464\n");
union block hp;
  printf("\nSTMT_EXEC;;6465\n");
char *p;
  printf("\nSTMT_EXEC;;6466\n");
void *__cil_tmp6;
  printf("\nSTMT_EXEC;;6467\n");
void *__cil_tmp7;
  printf("\nSTMT_EXEC;;6468\n");
void *__cil_tmp8;
  printf("\nSTMT_EXEC;;6469\n");
void *__cil_tmp9;
  printf("\nSTMT_EXEC;;6470\n");
void *__cil_tmp10;
  printf("\nSTMT_EXEC;;6471\n");
void *__cil_tmp11;
  printf("\nSTMT_EXEC;;6472\n");
void *__cil_tmp12;
  printf("\nSTMT_EXEC;;6473\n");
void *__cil_tmp13;
  printf("\nSTMT_EXEC;;6474\n");
void *__cil_tmp14;
  printf("\nSTMT_EXEC;;6475\n");
void *__cil_tmp15;
  printf("\nSTMT_EXEC;;6476\n");
void *__cil_tmp16;
  printf("\nSTMT_EXEC;;6477\n");
void *__cil_tmp17;
  printf("\nSTMT_EXEC;;6478\n");
void *__cil_tmp18;
  printf("\nSTMT_EXEC;;6479\n");
void *__cil_tmp19;
  printf("\nSTMT_EXEC;;6480\n");
void *__cil_tmp20;
  printf("\nSTMT_EXEC;;6481\n");
void *__cil_tmp21;
  printf("\nSTMT_EXEC;;6482\n");
void *__cil_tmp22;
  printf("\nSTMT_EXEC;;6483\n");
void *__cil_tmp23;
  printf("\nSTMT_EXEC;;6484\n");
void *__cil_tmp24;
  printf("\nSTMT_EXEC;;6485\n");
void *__cil_tmp25;
  printf("\nSTMT_EXEC;;6486\n");
void *__cil_tmp26;
  printf("\nSTMT_EXEC;;6487\n");
void *__cil_tmp27;
  printf("\nSTMT_EXEC;;6488\n");
void *__cil_tmp28;
  printf("\nSTMT_EXEC;;6489\n");
void *__cil_tmp29;
  printf("\nSTMT_EXEC;;6490\n");
void *__cil_tmp30;
  printf("\nSTMT_EXEC;;6491\n");
void *__cil_tmp31;
  printf("\nSTMT_EXEC;;6492\n");
void *__cil_tmp32;
  printf("\nSTMT_EXEC;;6493\n");
void *__cil_tmp33;
  printf("\nSTMT_EXEC;;6494\n");
void *__cil_tmp34;
  printf("\nSTMT_EXEC;;6495\n");
void *__cil_tmp35;
  printf("\nSTMT_EXEC;;6496\n");
void *__cil_tmp36;
  printf("\nSTMT_EXEC;;6497\n");
void *__cil_tmp37;
  printf("\nSTMT_EXEC;;6498\n");
void *__cil_tmp38;
  printf("\nSTMT_EXEC;;6499\n");
void *__cil_tmp39;
  printf("\nSTMT_EXEC;;6500\n");
void *__cil_tmp40;
  printf("\nSTMT_EXEC;;6501\n");
void *__cil_tmp41;
  printf("\nSTMT_EXEC;;6502\n");
void *__cil_tmp42;
  printf("\nSTMT_EXEC;;6503\n");
void *__cil_tmp43;
  printf("\nSTMT_EXEC;;6504\n");
void *__cil_tmp44;
  printf("\nSTMT_EXEC;;6505\n");
int __cil_tmp45;
  printf("\nSTMT_EXEC;;6506\n");
void *__cil_tmp46;
  printf("\nSTMT_EXEC;;6507\n");
void *__cil_tmp47;
  printf("\nSTMT_EXEC;;6508\n");
void *__cil_tmp48;
  printf("\nSTMT_EXEC;;6509\n");
void *__cil_tmp49;
  printf("\nSTMT_EXEC;;6510\n");
int __cil_tmp50;
  printf("\nSTMT_EXEC;;6511\n");
void *__cil_tmp51;
  printf("\nSTMT_EXEC;;6512\n");
void *__cil_tmp52;
  printf("\nSTMT_EXEC;;6513\n");
void *__cil_tmp53;
  printf("\nSTMT_EXEC;;6514\n");
void *__cil_tmp54;
  printf("\nSTMT_EXEC;;6515\n");
void *__cil_tmp55;
  printf("\nSTMT_EXEC;;6516\n");
void *__cil_tmp56;
  printf("\nSTMT_EXEC;;6517\n");
int __cil_tmp57;
  printf("\nSTMT_EXEC;;6518\n");
void *__cil_tmp58;
  printf("\nSTMT_EXEC;;6519\n");
void *__cil_tmp59;
  printf("\nSTMT_EXEC;;6520\n");
void *__cil_tmp60;
  printf("\nSTMT_EXEC;;6521\n");
void *__cil_tmp61;
  printf("\nSTMT_EXEC;;6522\n");
void *__cil_tmp62;
  printf("\nSTMT_EXEC;;6523\n");
void *__cil_tmp63;
  printf("\nSTMT_EXEC;;6524\n");
void *__cil_tmp64;
  printf("\nSTMT_EXEC;;6525\n");
void *__cil_tmp65;
  printf("\nSTMT_EXEC;;6526\n");
void *__cil_tmp66;
  printf("\nSTMT_EXEC;;6527\n");
int __cil_tmp67;
  printf("\nSTMT_EXEC;;6528\n");
void *__cil_tmp68;
  printf("\nSTMT_EXEC;;6529\n");
void *__cil_tmp69;

  {
    printf("\nSTMT_EXEC;;6532\n");
if (extended_header.buffer)
    {
      printf("\nSTMT_EXEC;;6534\n");
printf("\nFUNC_RETURN;;\n");
return (old_header);
    }
    else
    {
      printf("\nSTMT_EXEC;;6538\n");
if ((unsigned long)extended_header.stk == (unsigned long)((void *)0))
      {
        printf("\nSTMT_EXEC;;6540\n");
printf("\nFUNC_RETURN;;\n");
return (old_header);
      }
    }
    {
      printf("\nSTMT_EXEC;;6544\n");
xheader_finish(&extended_header);
      printf("\nSTMT_EXEC;;6545\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(hp.buffer), (void const * /* __restrict  */)old_header, sizeof(hp));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6546\n");
p = xheader_xhdr_name(st);
      printf("\nSTMT_EXEC;;6547\n");
xheader_write((char)'x', p, &extended_header);
      printf("\nSTMT_EXEC;;6548\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)p);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6549\n");
header = find_next_block();
      printf("\nSTMT_EXEC;;6550\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)header, (void const * /* __restrict  */)(&hp.buffer), sizeof(hp.buffer));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;6552\n");
printf("\nFUNC_RETURN;;\n");
return (header);
  }
printf("\nFUNC_RETURN;;\n");
}
static union block *write_header_name(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;write_header_name(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6557\n");
union block *tmp;
  printf("\nSTMT_EXEC;;6558\n");
union block *tmp___0;
  printf("\nSTMT_EXEC;;6559\n");
union block *tmp___1;
  printf("\nSTMT_EXEC;;6560\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;6561\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;6562\n");
char *__cil_tmp7;

  {
    printf("\nSTMT_EXEC;;6565\n");
if ((unsigned int)archive_format == 4U)
    {
      {
        printf("\nSTMT_EXEC;;6568\n");
tmp___3 = string_ascii_p((char const *)st->file_name);
      }
      printf("\nSTMT_EXEC;;6570\n");
if (tmp___3)
      {
        printf("\nSTMT_EXEC;;6572\n");
goto _L;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6577\n");
xheader_store("path", (struct tar_stat_info const *)st, (void *)0);
          printf("\nSTMT_EXEC;;6578\n");
tmp = write_short_name(st);
        }
        printf("\nSTMT_EXEC;;6580\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
      }
    }
    else
    {
    _L:
    {
      printf("\nSTMT_EXEC;;6587\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen((char const *)st->file_name);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;6589\n");
if (100UL < tmp___2)
      {
        {
          printf("\nSTMT_EXEC;;6592\n");
tmp___0 = write_long_name(st);
        }
        printf("\nSTMT_EXEC;;6594\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
      }
      else
      {



        {
          printf("\nSTMT_EXEC;;6602\n");
tmp___1 = write_short_name(st);
        }
        printf("\nSTMT_EXEC;;6604\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
      }
    }




































  }
printf("\nFUNC_RETURN;;\n");
}
union block *start_header(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;start_header(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;6647\n");
union block *header;
  printf("\nSTMT_EXEC;;6648\n");
mode_t tmp;
  printf("\nSTMT_EXEC;;6649\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;6650\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;6651\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;6652\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;6653\n");
int tmp___4;
  printf("\nSTMT_EXEC;;6654\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;6655\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;6656\n");
char *__cil_tmp11;
  printf("\nSTMT_EXEC;;6657\n");
char *__cil_tmp12;
  printf("\nSTMT_EXEC;;6658\n");
char *__cil_tmp13;
  printf("\nSTMT_EXEC;;6659\n");
char *__cil_tmp14;
  printf("\nSTMT_EXEC;;6660\n");
char *__cil_tmp15;
  printf("\nSTMT_EXEC;;6661\n");
char *__cil_tmp16;
  printf("\nSTMT_EXEC;;6662\n");
char *__cil_tmp17;
  printf("\nSTMT_EXEC;;6663\n");
char *__cil_tmp18;
  printf("\nSTMT_EXEC;;6664\n");
char *__cil_tmp19;
  printf("\nSTMT_EXEC;;6665\n");
char *__cil_tmp20;
  printf("\nSTMT_EXEC;;6666\n");
char *__cil_tmp21;
  printf("\nSTMT_EXEC;;6667\n");
char *__cil_tmp22;

  {
    {
      printf("\nSTMT_EXEC;;6671\n");
header = write_header_name(st);
    }
    printf("\nSTMT_EXEC;;6673\n");
if (!header)
    {
      printf("\nSTMT_EXEC;;6675\n");
printf("\nFUNC_RETURN;;\n");
return ((union block *)((void *)0));
    }
    printf("\nSTMT_EXEC;;6677\n");
if (owner_option != 4294967295U)
    {
      printf("\nSTMT_EXEC;;6679\n");
st->stat.st_uid = owner_option;
    }
    printf("\nSTMT_EXEC;;6681\n");
if (group_option != 4294967295U)
    {
      printf("\nSTMT_EXEC;;6683\n");
st->stat.st_gid = group_option;
    }
    printf("\nSTMT_EXEC;;6685\n");
if (mode_option)
    {
      {
        printf("\nSTMT_EXEC;;6688\n");
tmp = mode_adjust(st->stat.st_mode, (struct mode_change const *)mode_option);
        printf("\nSTMT_EXEC;;6689\n");
st->stat.st_mode = (st->stat.st_mode & (unsigned int)(~(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) | tmp;
      }
    }
    printf("\nSTMT_EXEC;;6692\n");
if ((unsigned int)archive_format == 1U)
    {
      {
        printf("\nSTMT_EXEC;;6695\n");
mode_to_chars(st->stat.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))), header->header.mode, sizeof(header->header.mode));
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;6700\n");
if ((unsigned int)archive_format == 3U)
      {
        {
          printf("\nSTMT_EXEC;;6703\n");
mode_to_chars(st->stat.st_mode & (unsigned int)(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))), header->header.mode, sizeof(header->header.mode));
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6709\n");
mode_to_chars(st->stat.st_mode, header->header.mode, sizeof(header->header.mode));
        }
      }
    }
    printf("\nSTMT_EXEC;;6713\n");
if (st->stat.st_uid > 2097151U)
    {
      printf("\nSTMT_EXEC;;6715\n");
if ((unsigned int)archive_format == 4U)
      {
        {
          printf("\nSTMT_EXEC;;6718\n");
xheader_store("uid", (struct tar_stat_info const *)st, (void *)0);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6724\n");
uid_to_chars(st->stat.st_uid, header->header.uid, sizeof(header->header.uid));
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;6731\n");
uid_to_chars(st->stat.st_uid, header->header.uid, sizeof(header->header.uid));
      }
    }
    printf("\nSTMT_EXEC;;6734\n");
if (st->stat.st_gid > 2097151U)
    {
      printf("\nSTMT_EXEC;;6736\n");
if ((unsigned int)archive_format == 4U)
      {
        {
          printf("\nSTMT_EXEC;;6739\n");
xheader_store("gid", (struct tar_stat_info const *)st, (void *)0);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6745\n");
gid_to_chars(st->stat.st_gid, header->header.gid, sizeof(header->header.gid));
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;6752\n");
gid_to_chars(st->stat.st_gid, header->header.gid, sizeof(header->header.gid));
      }
    }
    printf("\nSTMT_EXEC;;6755\n");
if (st->stat.st_size > 2147483647L)
    {
      printf("\nSTMT_EXEC;;6757\n");
if ((unsigned int)archive_format == 4U)
      {
        {
          printf("\nSTMT_EXEC;;6760\n");
xheader_store("size", (struct tar_stat_info const *)st, (void *)0);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6766\n");
off_to_chars(st->stat.st_size, header->header.size, sizeof(header->header.size));
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;6773\n");
off_to_chars(st->stat.st_size, header->header.size, sizeof(header->header.size));
      }
    }
    {
      printf("\nSTMT_EXEC;;6777\n");
time_to_chars(st->stat.st_mtim.tv_sec, header->header.mtime, sizeof(header->header.mtime));
    }
    printf("\nSTMT_EXEC;;6779\n");
if ((st->stat.st_mode & 61440U) == 8192U)
    {
      printf("\nSTMT_EXEC;;6781\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;6785\n");
if ((st->stat.st_mode & 61440U) == 24576U)
      {
      _L___3: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;6789\n");
printf("\nFUNC_CALL;gnu_dev_major(unsigned long long);\n");
st->devmajor = gnu_dev_major((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;6790\n");
printf("\nFUNC_CALL;gnu_dev_minor(unsigned long long);\n");
st->devminor = gnu_dev_minor((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;6792\n");
if (st->devmajor > 2097151U)
        {
          printf("\nSTMT_EXEC;;6794\n");
if ((unsigned int)archive_format == 4U)
          {
            {
              printf("\nSTMT_EXEC;;6797\n");
xheader_store("devmajor", (struct tar_stat_info const *)st, (void *)0);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;6803\n");
major_to_chars((int)st->devmajor, header->header.devmajor, sizeof(header->header.devmajor));
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;6810\n");
major_to_chars((int)st->devmajor, header->header.devmajor, sizeof(header->header.devmajor));
          }
        }
        printf("\nSTMT_EXEC;;6813\n");
if (st->devminor > 2097151U)
        {
          printf("\nSTMT_EXEC;;6815\n");
if ((unsigned int)archive_format == 4U)
          {
            {
              printf("\nSTMT_EXEC;;6818\n");
xheader_store("devminor", (struct tar_stat_info const *)st, (void *)0);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;6824\n");
major_to_chars((int)st->devminor, header->header.devminor, sizeof(header->header.devminor));
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;6831\n");
major_to_chars((int)st->devminor, header->header.devminor, sizeof(header->header.devminor));
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;6838\n");
major_to_chars(0, header->header.devmajor, sizeof(header->header.devmajor));
          printf("\nSTMT_EXEC;;6839\n");
minor_to_chars(0, header->header.devminor, sizeof(header->header.devminor));
        }
      }
    }
    printf("\nSTMT_EXEC;;6843\n");
if ((unsigned int)archive_format == 4U)
    {
      {
        printf("\nSTMT_EXEC;;6846\n");
xheader_store("atime", (struct tar_stat_info const *)st, (void *)0);
        printf("\nSTMT_EXEC;;6847\n");
xheader_store("ctime", (struct tar_stat_info const *)st, (void *)0);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;6852\n");
if (incremental_option)
      {
        printf("\nSTMT_EXEC;;6854\n");
if ((unsigned int)archive_format == 2U)
        {
          {
            printf("\nSTMT_EXEC;;6857\n");
time_to_chars(st->stat.st_atim.tv_sec, header->oldgnu_header.atime, sizeof(header->oldgnu_header.atime));
            printf("\nSTMT_EXEC;;6858\n");
time_to_chars(st->stat.st_ctim.tv_sec, header->oldgnu_header.ctime, sizeof(header->oldgnu_header.ctime));
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;6863\n");
if ((unsigned int)archive_format == 6U)
          {
            {
              printf("\nSTMT_EXEC;;6866\n");
time_to_chars(st->stat.st_atim.tv_sec, header->oldgnu_header.atime, sizeof(header->oldgnu_header.atime));
              printf("\nSTMT_EXEC;;6867\n");
time_to_chars(st->stat.st_ctim.tv_sec, header->oldgnu_header.ctime, sizeof(header->oldgnu_header.ctime));
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;6873\n");
if ((unsigned int)archive_format == 1U)
    {
      printf("\nSTMT_EXEC;;6875\n");
tmp___4 = '\000';
    }
    else
    {
      printf("\nSTMT_EXEC;;6879\n");
tmp___4 = '0';
    }
    printf("\nSTMT_EXEC;;6881\n");
header->header.typeflag = (char)tmp___4;
    {
      printf("\nSTMT_EXEC;;6883\n");
if ((unsigned int)archive_format == 1U)
      {
        printf("\nSTMT_EXEC;;6885\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;6887\n");
if ((unsigned int)archive_format == 2U)
      {
        printf("\nSTMT_EXEC;;6889\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6891\n");
if ((unsigned int)archive_format == 6U)
      {
        printf("\nSTMT_EXEC;;6893\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;6895\n");
if ((unsigned int)archive_format == 4U)
      {
        printf("\nSTMT_EXEC;;6897\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;6899\n");
if ((unsigned int)archive_format == 3U)
      {
        printf("\nSTMT_EXEC;;6901\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;6903\n");
goto switch_default;
    case_1: /* CIL Label */
      {
printf("\nSTMT_EXEC;;6905\n");
goto switch_break;
}

    case_2: /* CIL Label */
    case_6: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6909\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(header->header.magic), (char const * /* __restrict  */) "ustar  ");printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;6911\n");
goto switch_break;
    case_4: /* CIL Label */
    case_3: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6915\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)(header->header.magic), (char const * /* __restrict  */) "ustar", (size_t)6);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;6916\n");
printf("\nFUNC_CALL;strncpy(char *__restrict,const char *__restrict,size_t);\n");
strncpy((char * /* __restrict  */)(header->header.version), (char const * /* __restrict  */) "00", (size_t)2);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;6918\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;6921\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;6925\n");
if (!((unsigned int)archive_format == 1U))
    {
      printf("\nSTMT_EXEC;;6927\n");
if (!numeric_owner_option)
      {
        {
          printf("\nSTMT_EXEC;;6930\n");
uid_to_uname(st->stat.st_uid, &st->uname);
          printf("\nSTMT_EXEC;;6931\n");
gid_to_gname(st->stat.st_gid, &st->gname);
        }
        printf("\nSTMT_EXEC;;6933\n");
if ((unsigned int)archive_format == 4U)
        {
          {
            printf("\nSTMT_EXEC;;6936\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen((char const *)st->uname);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;6938\n");
if (tmp___0 > 32UL)
          {
            {
              printf("\nSTMT_EXEC;;6941\n");
xheader_store("uname", (struct tar_stat_info const *)st, (void *)0);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;6947\n");
tmp___1 = string_ascii_p((char const *)st->uname);
            }
            printf("\nSTMT_EXEC;;6949\n");
if (tmp___1)
            {
              {
                printf("\nSTMT_EXEC;;6952\n");
string_to_chars(st->uname, header->header.uname, sizeof(header->header.uname));
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;6958\n");
xheader_store("uname", (struct tar_stat_info const *)st, (void *)0);
              }
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;6966\n");
string_to_chars(st->uname, header->header.uname, sizeof(header->header.uname));
          }
        }
        printf("\nSTMT_EXEC;;6969\n");
if ((unsigned int)archive_format == 4U)
        {
          {
            printf("\nSTMT_EXEC;;6972\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen((char const *)st->gname);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;6974\n");
if (tmp___2 > 32UL)
          {
            {
              printf("\nSTMT_EXEC;;6977\n");
xheader_store("gname", (struct tar_stat_info const *)st, (void *)0);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;6983\n");
tmp___3 = string_ascii_p((char const *)st->gname);
            }
            printf("\nSTMT_EXEC;;6985\n");
if (tmp___3)
            {
              {
                printf("\nSTMT_EXEC;;6988\n");
string_to_chars(st->gname, header->header.gname, sizeof(header->header.gname));
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;6994\n");
xheader_store("gname", (struct tar_stat_info const *)st, (void *)0);
              }
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;7002\n");
string_to_chars(st->gname, header->header.gname, sizeof(header->header.gname));
          }
        }
      }
    }














































































































    printf("\nSTMT_EXEC;;7117\n");
printf("\nFUNC_RETURN;;\n");
return (header);
  }
printf("\nFUNC_RETURN;;\n");
}
void simple_finish_header(union block *header)
{
  printf("\nFUNC_CALL;simple_finish_header(union block *);\n");
printf("\nSTMT_EXEC;;7122\n");
size_t i;
  printf("\nSTMT_EXEC;;7123\n");
int sum;
  printf("\nSTMT_EXEC;;7124\n");
char *p;
  printf("\nSTMT_EXEC;;7125\n");
char *tmp;
  printf("\nSTMT_EXEC;;7126\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;7127\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;7131\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->header.chksum), (void const * /* __restrict  */) "        ", sizeof(header->header.chksum));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;7132\n");
sum = 0;
      printf("\nSTMT_EXEC;;7133\n");
p = header->buffer;
      printf("\nSTMT_EXEC;;7134\n");
i = sizeof(*header);
    }
    {
      printf("\nSTMT_EXEC;;7137\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;7140\n");
tmp___0 = i;
        printf("\nSTMT_EXEC;;7141\n");
i--;
        printf("\nSTMT_EXEC;;7142\n");
if (!(tmp___0 != 0UL))
        {
          printf("\nSTMT_EXEC;;7144\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;7146\n");
tmp = p;
        printf("\nSTMT_EXEC;;7147\n");
p++;
        printf("\nSTMT_EXEC;;7148\n");
sum += 255 & (int)*tmp;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;7153\n");
uintmax_to_chars((uintmax_t)sum, header->header.chksum, (size_t)7);
      printf("\nSTMT_EXEC;;7154\n");
set_next_block_after(header);
    }
    printf("\nSTMT_EXEC;;7156\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
































printf("\nFUNC_RETURN;;\n");
}
void finish_header(struct tar_stat_info *st, union block *header, off_t block_ordinal)
{

  printf("\nFUNC_CALL;finish_header(struct tar_stat_info *,union block *,off_t);\n");
{
    printf("\nSTMT_EXEC;;7195\n");
if (verbose_option)
    {
      printf("\nSTMT_EXEC;;7197\n");
if ((int)header->header.typeflag != 75)
      {
        printf("\nSTMT_EXEC;;7199\n");
if ((int)header->header.typeflag != 76)
        {
          printf("\nSTMT_EXEC;;7201\n");
if ((int)header->header.typeflag != 120)
          {
            printf("\nSTMT_EXEC;;7203\n");
if ((int)header->header.typeflag != 103)
            {
              {
                printf("\nSTMT_EXEC;;7206\n");
current_header = header;
                printf("\nSTMT_EXEC;;7207\n");
current_format = archive_format;
                printf("\nSTMT_EXEC;;7208\n");
print_header(st, block_ordinal);
              }
            }
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;7216\n");
header = write_extended(st, header);
      printf("\nSTMT_EXEC;;7217\n");
simple_finish_header(header);
    }
    printf("\nSTMT_EXEC;;7219\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void pad_archive(off_t size_left)
{
  printf("\nFUNC_CALL;pad_archive(off_t);\n");
printf("\nSTMT_EXEC;;7224\n");
union block *blk;

  {
    {
      printf("\nSTMT_EXEC;;7228\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;7231\n");
if (!(size_left > 0L))
        {
          printf("\nSTMT_EXEC;;7233\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;7236\n");
save_sizeleft = size_left;
          printf("\nSTMT_EXEC;;7237\n");
blk = find_next_block();
          printf("\nSTMT_EXEC;;7238\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;7239\n");
set_next_block_after(blk);
          printf("\nSTMT_EXEC;;7240\n");
size_left -= 512L;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;7245\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}























static enum dump_status dump_regular_file(int fd, struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;dump_regular_file(int,struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;7273\n");
off_t size_left;
  printf("\nSTMT_EXEC;;7274\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;7275\n");
union block *blk;
  printf("\nSTMT_EXEC;;7276\n");
size_t bufsize;
  printf("\nSTMT_EXEC;;7277\n");
size_t count;
  printf("\nSTMT_EXEC;;7278\n");
size_t tmp;
  printf("\nSTMT_EXEC;;7279\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;7280\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;7281\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;7282\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;7283\n");
void *__cil_tmp13;

  {
    {
      printf("\nSTMT_EXEC;;7287\n");
size_left = st->stat.st_size;
      printf("\nSTMT_EXEC;;7288\n");
block_ordinal = current_block_ordinal();
      printf("\nSTMT_EXEC;;7289\n");
blk = start_header(st);
    }
    printf("\nSTMT_EXEC;;7291\n");
if (!blk)
    {
      printf("\nSTMT_EXEC;;7293\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)2);
    }
    printf("\nSTMT_EXEC;;7295\n");
if ((unsigned int)archive_format != 1U)
    {
    }
    {
      printf("\nSTMT_EXEC;;7299\n");
finish_header(st, blk, block_ordinal);
    }
    {
      printf("\nSTMT_EXEC;;7302\n");
while (1)
      {
      while_continue: /* CIL Label */;

        printf("\nSTMT_EXEC;;7306\n");
if (!(size_left > 0L))
        {
          printf("\nSTMT_EXEC;;7308\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;7310\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;7313\n");
assign_string(&save_name, (char const *)st->file_name);
            printf("\nSTMT_EXEC;;7314\n");
save_sizeleft = size_left;
            printf("\nSTMT_EXEC;;7315\n");
save_totsize = st->stat.st_size;
          }
        }
        {
          printf("\nSTMT_EXEC;;7319\n");
blk = find_next_block();
          printf("\nSTMT_EXEC;;7320\n");
bufsize = available_space_after(blk);
        }
        printf("\nSTMT_EXEC;;7322\n");
if ((size_t)size_left < bufsize)

        {
          printf("\nSTMT_EXEC;;7325\n");
bufsize = (size_t)size_left;
          printf("\nSTMT_EXEC;;7326\n");
count = bufsize % 512UL;
          printf("\nSTMT_EXEC;;7327\n");
if (count)
          {
            {
              printf("\nSTMT_EXEC;;7330\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer + size_left), 0, 512UL - count);printf("\nFUNC_RETURN;;\n");

            }
          }
        }
        printf("\nSTMT_EXEC;;7334\n");
if (fd < 0)
        {
          printf("\nSTMT_EXEC;;7336\n");
count = bufsize;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;7341\n");
tmp = safe_read(fd, (void *)(blk->buffer), bufsize);
            printf("\nSTMT_EXEC;;7342\n");
count = tmp;
          }
        }
        printf("\nSTMT_EXEC;;7345\n");
if (count == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;7348\n");
read_diag_details((char const *)st->orig_file_name, st->stat.st_size - size_left, bufsize);
            printf("\nSTMT_EXEC;;7349\n");
pad_archive(size_left);
          }
          printf("\nSTMT_EXEC;;7351\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)1);
        }
        {
          printf("\nSTMT_EXEC;;7354\n");
size_left = (off_t)((size_t)size_left - count);


          printf("\nSTMT_EXEC;;7357\n");
set_next_block_after(blk + (bufsize - 1UL) / 512UL);
        }
        printf("\nSTMT_EXEC;;7359\n");
if (count != bufsize)
        {
          {
            printf("\nSTMT_EXEC;;7362\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer + count), 0, bufsize - count);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;7363\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)size_left, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
            printf("\nSTMT_EXEC;;7364\n");
tmp___1 = quotearg_colon((char const *)st->orig_file_name);
            printf("\nSTMT_EXEC;;7365\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___2 = ngettext("%s: File shrank by %s byte; padding with zeros", "%s: File shrank by %s bytes; padding with zeros", (unsigned long)size_left);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;7366\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;7368\n");
if (!ignore_failed_read_option)
          {
            printf("\nSTMT_EXEC;;7370\n");
exit_status = 2;
          }
          {
            printf("\nSTMT_EXEC;;7373\n");
pad_archive(size_left);
          }
          printf("\nSTMT_EXEC;;7375\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)1);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;7380\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static void dump_regular_finish(int fd, struct tar_stat_info *st, time_t original_ctime)
{
  printf("\nFUNC_CALL;dump_regular_finish(int,struct tar_stat_info *,time_t);\n");
printf("\nSTMT_EXEC;;7385\n");
struct stat final_stat;
  printf("\nSTMT_EXEC;;7386\n");
char *tmp;
  printf("\nSTMT_EXEC;;7387\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;7388\n");
int tmp___1;
  printf("\nSTMT_EXEC;;7389\n");
int tmp___2;
  printf("\nSTMT_EXEC;;7390\n");
int tmp___3;
  printf("\nSTMT_EXEC;;7391\n");
void *__cil_tmp10;
  printf("\nSTMT_EXEC;;7392\n");
char *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;7395\n");
if (fd >= 0)
    {
      {
        printf("\nSTMT_EXEC;;7398\n");
printf("\nFUNC_CALL;fstat(int,struct stat *);\n");
tmp___1 = fstat(fd, &final_stat);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;7400\n");
if (tmp___1 != 0)
      {
        {
          printf("\nSTMT_EXEC;;7403\n");
stat_diag((char const *)st->orig_file_name);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;7408\n");
if (final_stat.st_ctim.tv_sec != original_ctime)
        {
          {
            printf("\nSTMT_EXEC;;7411\n");
tmp = quotearg_colon((char const *)st->orig_file_name);
            printf("\nSTMT_EXEC;;7412\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: file changed as we read it");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;7413\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

          }
        }
      }
      {
        printf("\nSTMT_EXEC;;7418\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___2 = close(fd);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;7420\n");
if (tmp___2 != 0)
      {
        {
          printf("\nSTMT_EXEC;;7423\n");
close_diag((char const *)st->orig_file_name);
        }
      }
    }
    printf("\nSTMT_EXEC;;7427\n");
if (remove_files_option)
    {
      {
        printf("\nSTMT_EXEC;;7430\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___3 = unlink((char const *)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;7432\n");
if (tmp___3 == -1)
      {
        {
          printf("\nSTMT_EXEC;;7435\n");
unlink_error((char const *)st->orig_file_name);
        }
      }
    }
    printf("\nSTMT_EXEC;;7439\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void dump_dir0(char *directory, struct tar_stat_info *st, int top_level, dev_t parent_device)
{
  printf("\nFUNC_CALL;dump_dir0(char *,struct tar_stat_info *,int,dev_t);\n");
printf("\nSTMT_EXEC;;7444\n");
dev_t our_device;
  printf("\nSTMT_EXEC;;7445\n");
union block *blk;
  printf("\nSTMT_EXEC;;7446\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;7447\n");
off_t tmp;
  printf("\nSTMT_EXEC;;7448\n");
off_t size_left;
  printf("\nSTMT_EXEC;;7449\n");
off_t totsize;
  printf("\nSTMT_EXEC;;7450\n");
size_t bufsize;
  printf("\nSTMT_EXEC;;7451\n");
ssize_t count;
  printf("\nSTMT_EXEC;;7452\n");
char const *buffer___2;
  printf("\nSTMT_EXEC;;7453\n");
char const *p_buffer;
  printf("\nSTMT_EXEC;;7454\n");
size_t size;
  printf("\nSTMT_EXEC;;7455\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;7456\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;7457\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;7458\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;7459\n");
char const *entry;
  printf("\nSTMT_EXEC;;7460\n");
size_t entry_len;
  printf("\nSTMT_EXEC;;7461\n");
char *name_buf;
  printf("\nSTMT_EXEC;;7462\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;7463\n");
size_t name_size;
  printf("\nSTMT_EXEC;;7464\n");
size_t tmp___5;
  printf("\nSTMT_EXEC;;7465\n");
size_t name_len;
  printf("\nSTMT_EXEC;;7466\n");
void *tmp___6;
  printf("\nSTMT_EXEC;;7467\n");
_Bool tmp___7;
  printf("\nSTMT_EXEC;;7468\n");
char *__cil_tmp29;

  {
    {
      printf("\nSTMT_EXEC;;7472\n");
our_device = st->stat.st_dev;
      printf("\nSTMT_EXEC;;7473\n");
tmp___1 = is_avoided_name((char const *)st->orig_file_name);
    }
    printf("\nSTMT_EXEC;;7475\n");
if (!tmp___1)
    {
      {
        printf("\nSTMT_EXEC;;7478\n");
blk = (union block *)((void *)0);
        printf("\nSTMT_EXEC;;7479\n");
tmp = current_block_ordinal();
        printf("\nSTMT_EXEC;;7480\n");
block_ordinal = tmp;
        printf("\nSTMT_EXEC;;7481\n");
st->stat.st_size = (__off_t)0;
        printf("\nSTMT_EXEC;;7482\n");
blk = start_header(st);
      }
      printf("\nSTMT_EXEC;;7484\n");
if (!blk)
      {
        printf("\nSTMT_EXEC;;7486\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
      printf("\nSTMT_EXEC;;7488\n");
if (incremental_option)
      {
        printf("\nSTMT_EXEC;;7490\n");
blk->header.typeflag = (char)'D';
      }
      else
      {
        printf("\nSTMT_EXEC;;7494\n");
blk->header.typeflag = (char)'5';
      }
      printf("\nSTMT_EXEC;;7496\n");
if (!incremental_option)
      {
        {
          printf("\nSTMT_EXEC;;7499\n");
finish_header(st, blk, block_ordinal);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;7504\n");
if (gnu_list_name->dir_contents)
        {
          {
            printf("\nSTMT_EXEC;;7507\n");
block_ordinal = current_block_ordinal();
            printf("\nSTMT_EXEC;;7508\n");
buffer___2 = gnu_list_name->dir_contents;
            printf("\nSTMT_EXEC;;7509\n");
totsize = (off_t)0;
          }
          printf("\nSTMT_EXEC;;7511\n");
if (buffer___2)
          {
            printf("\nSTMT_EXEC;;7513\n");
p_buffer = buffer___2;
            {
              printf("\nSTMT_EXEC;;7515\n");
while (1)
              {
              while_continue: /* CIL Label */;
                printf("\nSTMT_EXEC;;7518\n");
if (!*p_buffer)
                {
                  printf("\nSTMT_EXEC;;7520\n");
goto while_break;
                }
                {
                  printf("\nSTMT_EXEC;;7523\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(p_buffer);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;7524\n");
size = tmp___0 + 1UL;
                  printf("\nSTMT_EXEC;;7525\n");
totsize = (off_t)((size_t)totsize + size);
                  printf("\nSTMT_EXEC;;7526\n");
p_buffer += size;
                }
              }
            while_break: /* CIL Label */;
            }
          }
          {
            printf("\nSTMT_EXEC;;7533\n");
totsize++;
            printf("\nSTMT_EXEC;;7534\n");
off_to_chars(totsize, blk->header.size, sizeof(blk->header.size));
            printf("\nSTMT_EXEC;;7535\n");
finish_header(st, blk, block_ordinal);
            printf("\nSTMT_EXEC;;7536\n");
p_buffer = buffer___2;
            printf("\nSTMT_EXEC;;7537\n");
size_left = totsize;
          }
          {
            printf("\nSTMT_EXEC;;7540\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;7543\n");
if (!(size_left > 0L))
              {
                printf("\nSTMT_EXEC;;7545\n");
goto while_break___0;
              }
              printf("\nSTMT_EXEC;;7547\n");
if (multi_volume_option)
              {
                {
                  printf("\nSTMT_EXEC;;7550\n");
assign_string(&save_name, (char const *)st->orig_file_name);
                  printf("\nSTMT_EXEC;;7551\n");
save_sizeleft = size_left;
                  printf("\nSTMT_EXEC;;7552\n");
save_totsize = totsize;
                }
              }
              {
                printf("\nSTMT_EXEC;;7556\n");
blk = find_next_block();
                printf("\nSTMT_EXEC;;7557\n");
bufsize = available_space_after(blk);
              }
              printf("\nSTMT_EXEC;;7559\n");
if ((size_t)size_left < bufsize)
              {
                printf("\nSTMT_EXEC;;7561\n");
bufsize = (size_t)size_left;
                printf("\nSTMT_EXEC;;7562\n");
count = (ssize_t)(bufsize % 512UL);
                printf("\nSTMT_EXEC;;7563\n");
if (count)
                {
                  {
                    printf("\nSTMT_EXEC;;7566\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer + size_left), 0, (size_t)(512L - count));printf("\nFUNC_RETURN;;\n");

                  }
                }
              }
              {
                printf("\nSTMT_EXEC;;7571\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(blk->buffer), (void const * /* __restrict  */)p_buffer, bufsize);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;7572\n");
size_left = (off_t)((size_t)size_left - bufsize);
                printf("\nSTMT_EXEC;;7573\n");
p_buffer += bufsize;
                printf("\nSTMT_EXEC;;7574\n");
set_next_block_after(blk + (bufsize - 1UL) / 512UL);
              }
            }
          while_break___0: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;7579\n");
if (multi_volume_option)
          {
            {
              printf("\nSTMT_EXEC;;7582\n");
assign_string(&save_name, (char const *)0);
            }
          }
          printf("\nSTMT_EXEC;;7585\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    printf("\nSTMT_EXEC;;7589\n");
if (!recursion_option)
    {
      printf("\nSTMT_EXEC;;7591\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;7593\n");
if (one_file_system_option)
    {
      printf("\nSTMT_EXEC;;7595\n");
if (!top_level)
      {
        printf("\nSTMT_EXEC;;7597\n");
if (parent_device != st->stat.st_dev)
        {
          printf("\nSTMT_EXEC;;7599\n");
if (verbose_option)
          {
            {
              printf("\nSTMT_EXEC;;7602\n");
tmp___2 = quotearg_colon((char const *)st->orig_file_name);
              printf("\nSTMT_EXEC;;7603\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("%s: file is on a different filesystem; not dumped");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;7604\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

            }
          }
          printf("\nSTMT_EXEC;;7607\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;7612\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
tmp___4 = strdup((char const *)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;7613\n");
name_buf = tmp___4;
      printf("\nSTMT_EXEC;;7614\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___5 = strlen((char const *)name_buf);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;7615\n");
name_size = tmp___5;
      printf("\nSTMT_EXEC;;7616\n");
name_len = name_size;
      printf("\nSTMT_EXEC;;7617\n");
entry = (char const *)directory;
    }
    {
      printf("\nSTMT_EXEC;;7620\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;7624\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
entry_len = strlen(entry);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;7626\n");
if (!(entry_len != 0UL))
        {
          printf("\nSTMT_EXEC;;7628\n");
goto while_break___1;
        }
        printf("\nSTMT_EXEC;;7630\n");
if (name_size < name_len + entry_len)
        {
          {
            printf("\nSTMT_EXEC;;7633\n");
name_size = name_len + entry_len;
            printf("\nSTMT_EXEC;;7634\n");
tmp___6 = xrealloc((void *)name_buf, name_size + 1UL);
            printf("\nSTMT_EXEC;;7635\n");
name_buf = (char *)tmp___6;
          }
        }
        {
          printf("\nSTMT_EXEC;;7639\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(name_buf + name_len), (char const * /* __restrict  */)entry);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;7640\n");
tmp___7 = excluded_name((char const *)name_buf);
        }
        printf("\nSTMT_EXEC;;7642\n");
if (!tmp___7)
        {
          {
            printf("\nSTMT_EXEC;;7645\n");
dump_file(name_buf, 0, our_device);
          }
        }
        printf("\nSTMT_EXEC;;7648\n");
entry += entry_len + 1UL;
      }
    while_break___1: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;7653\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_buf);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;7655\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void ensure_slash(char **pstr)
{
  printf("\nFUNC_CALL;ensure_slash(char **);\n");
printf("\nSTMT_EXEC;;7660\n");
size_t len;
  printf("\nSTMT_EXEC;;7661\n");
size_t tmp;
  printf("\nSTMT_EXEC;;7662\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;7663\n");
size_t tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;7667\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen((char const *)*pstr);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;7668\n");
len = tmp;
    }
    {
      printf("\nSTMT_EXEC;;7671\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;7674\n");
if (len >= 1UL)
        {
          printf("\nSTMT_EXEC;;7676\n");
if (!((int)*(*pstr + (len - 1UL)) == 47))
          {
            printf("\nSTMT_EXEC;;7678\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;7683\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;7685\n");
len--;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;7689\n");
if (!((int)*(*pstr + len) == 47))
    {
      {
        printf("\nSTMT_EXEC;;7692\n");
tmp___0 = xrealloc((void *)*pstr, len + 2UL);
        printf("\nSTMT_EXEC;;7693\n");
*pstr = (char *)tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;7696\n");
tmp___1 = len;
    printf("\nSTMT_EXEC;;7697\n");
len++;
    printf("\nSTMT_EXEC;;7698\n");
*(*pstr + tmp___1) = (char)'/';
    printf("\nSTMT_EXEC;;7699\n");
*(*pstr + len) = (char)'\000';
    printf("\nSTMT_EXEC;;7700\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool dump_dir(struct tar_stat_info *st, int top_level, dev_t parent_device)
{
  printf("\nFUNC_CALL;dump_dir(struct tar_stat_info *,int,dev_t);\n");
printf("\nSTMT_EXEC;;7705\n");
char *directory;

  {
    {
      printf("\nSTMT_EXEC;;7709\n");
directory = savedir((char const *)st->orig_file_name);
    }
    printf("\nSTMT_EXEC;;7711\n");
if (!directory)
    {
      {
        printf("\nSTMT_EXEC;;7714\n");
savedir_diag((char const *)st->orig_file_name);
      }
      printf("\nSTMT_EXEC;;7716\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;7719\n");
ensure_slash(&st->orig_file_name);
      printf("\nSTMT_EXEC;;7720\n");
ensure_slash(&st->file_name);
      printf("\nSTMT_EXEC;;7721\n");
dump_dir0(directory, st, top_level, parent_device);
      printf("\nSTMT_EXEC;;7722\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)directory);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;7724\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}

























































void create_archive(void)
{
  printf("\nFUNC_CALL;create_archive();\n");
printf("\nSTMT_EXEC;;7786\n");
char *p;
  printf("\nSTMT_EXEC;;7787\n");
size_t buffer_size;
  printf("\nSTMT_EXEC;;7788\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;7789\n");
void *tmp;
  printf("\nSTMT_EXEC;;7790\n");
char const *q;
  printf("\nSTMT_EXEC;;7791\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;7792\n");
size_t plen;
  printf("\nSTMT_EXEC;;7793\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;7794\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;7795\n");
size_t tmp___3;
  printf("\nSTMT_EXEC;;7796\n");
size_t qlen;
  printf("\nSTMT_EXEC;;7797\n");
size_t tmp___4;
  printf("\nSTMT_EXEC;;7798\n");
void *tmp___5;
  printf("\nSTMT_EXEC;;7799\n");
_Bool tmp___6;
  printf("\nSTMT_EXEC;;7800\n");
_Bool tmp___7;

  {
    {
      printf("\nSTMT_EXEC;;7804\n");
open_archive((enum access_mode)1);
      printf("\nSTMT_EXEC;;7805\n");
xheader_write_global();
    }
    printf("\nSTMT_EXEC;;7807\n");
if (incremental_option)
    {
      {
        printf("\nSTMT_EXEC;;7810\n");
buffer_size = (size_t)1000;
        printf("\nSTMT_EXEC;;7811\n");
tmp = xmalloc(buffer_size);
        printf("\nSTMT_EXEC;;7812\n");
buffer___2 = (char *)tmp;
        printf("\nSTMT_EXEC;;7813\n");
collect_and_sort_names();
      }
      {

        printf("\nSTMT_EXEC;;7817\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;7821\n");
p = name_from_list();
          }
          printf("\nSTMT_EXEC;;7823\n");
if (!((unsigned long)p != (unsigned long)((void *)0)))
          {
            printf("\nSTMT_EXEC;;7825\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;7828\n");
tmp___0 = excluded_name((char const *)p);
          }
          printf("\nSTMT_EXEC;;7830\n");
if (!tmp___0)
          {
            {
              printf("\nSTMT_EXEC;;7833\n");
dump_file(p, -1, (dev_t)0);
            }
          }
        }
      while_break: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;7840\n");
blank_name_list();
      }
      {
        printf("\nSTMT_EXEC;;7843\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;7847\n");
p = name_from_list();
          }
          printf("\nSTMT_EXEC;;7849\n");
if (!((unsigned long)p != (unsigned long)((void *)0)))
          {
            printf("\nSTMT_EXEC;;7851\n");
goto while_break___0;
          }
          {
            printf("\nSTMT_EXEC;;7854\n");
tmp___6 = excluded_name((char const *)p);
          }
          printf("\nSTMT_EXEC;;7856\n");
if (!tmp___6)
          {
            {
              printf("\nSTMT_EXEC;;7859\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)p);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;7860\n");
plen = tmp___1;
            }
            printf("\nSTMT_EXEC;;7862\n");
if (buffer_size <= plen)
            {
              {
                printf("\nSTMT_EXEC;;7865\n");
while (1)
                {
                while_continue___1: /* CIL Label */;
                  printf("\nSTMT_EXEC;;7868\n");
buffer_size *= 2UL;
                  printf("\nSTMT_EXEC;;7869\n");
if (!(buffer_size <= plen))
                  {
                    printf("\nSTMT_EXEC;;7871\n");
goto while_break___1;
                  }
                  printf("\nSTMT_EXEC;;7873\n");
goto while_continue___1;
                }
              while_break___1: /* CIL Label */;
              }
              {
                printf("\nSTMT_EXEC;;7878\n");
tmp___2 = xrealloc((void *)buffer___2, buffer_size);
                printf("\nSTMT_EXEC;;7879\n");
buffer___2 = (char *)tmp___2;
              }
            }
            {
              printf("\nSTMT_EXEC;;7883\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)buffer___2, (void const * /* __restrict  */)p, plen);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;7885\n");
if (!((int)*(buffer___2 + (plen - 1UL)) == 47))
            {
              printf("\nSTMT_EXEC;;7887\n");
tmp___3 = plen;
              printf("\nSTMT_EXEC;;7888\n");
plen++;
              printf("\nSTMT_EXEC;;7889\n");
*(buffer___2 + tmp___3) = (char)'/';
            }
            printf("\nSTMT_EXEC;;7891\n");
q = gnu_list_name->dir_contents;
            printf("\nSTMT_EXEC;;7892\n");
if (q)
            {
              {
                printf("\nSTMT_EXEC;;7895\n");
while (1)
                {
                while_continue___2: /* CIL Label */;
                  printf("\nSTMT_EXEC;;7898\n");
if (!*q)
                  {
                    printf("\nSTMT_EXEC;;7900\n");
goto while_break___2;
                  }
                  {
                    printf("\nSTMT_EXEC;;7903\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___4 = strlen(q);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;7904\n");
qlen = tmp___4;
                  }
                  printf("\nSTMT_EXEC;;7906\n");
if ((int const) * q == 89)
                  {
                    printf("\nSTMT_EXEC;;7908\n");
if (buffer_size < plen + qlen)
                    {
                      {
                        printf("\nSTMT_EXEC;;7911\n");
while (1)
                        {
                        while_continue___3: /* CIL Label */;
                          printf("\nSTMT_EXEC;;7914\n");
buffer_size *= 2UL;
                          printf("\nSTMT_EXEC;;7915\n");
if (!(buffer_size < plen + qlen))
                          {
                            printf("\nSTMT_EXEC;;7917\n");
goto while_break___3;
                          }
                          printf("\nSTMT_EXEC;;7919\n");
goto while_continue___3;
                        }
                      while_break___3: /* CIL Label */;
                      }
                      {
                        printf("\nSTMT_EXEC;;7924\n");
tmp___5 = xrealloc((void *)buffer___2, buffer_size);
                        printf("\nSTMT_EXEC;;7925\n");
buffer___2 = (char *)tmp___5;
                      }
                    }
                    {
                      printf("\nSTMT_EXEC;;7929\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(buffer___2 + plen), (char const * /* __restrict  */)(q + 1));printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;7930\n");
dump_file(buffer___2, -1, (dev_t)0);
                    }
                  }
                  printf("\nSTMT_EXEC;;7933\n");
q += qlen + 1UL;
                }
              while_break___2: /* CIL Label */;
              }
            }
          }
        }
      while_break___0: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;7943\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)buffer___2);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;7949\n");
while (1)
        {
        while_continue___4: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;7953\n");
p = name_next(1);
          }
          printf("\nSTMT_EXEC;;7955\n");
if (!((unsigned long)p != (unsigned long)((void *)0)))
          {
            printf("\nSTMT_EXEC;;7957\n");
goto while_break___4;
          }
          {
            printf("\nSTMT_EXEC;;7960\n");
tmp___7 = excluded_name((char const *)p);
          }
          printf("\nSTMT_EXEC;;7962\n");
if (!tmp___7)
          {
            {
              printf("\nSTMT_EXEC;;7965\n");
dump_file(p, 1, (dev_t)0);
            }
          }
        }
      while_break___4: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;7973\n");
write_eot();
      printf("\nSTMT_EXEC;;7974\n");
close_archive();
    }
    printf("\nSTMT_EXEC;;7976\n");
if (listed_incremental_option)
    {
      {
        printf("\nSTMT_EXEC;;7979\n");
write_directory_file();
      }
    }
    printf("\nSTMT_EXEC;;7982\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static unsigned int hash_link(void const *entry, unsigned int n_buckets)
{
  printf("\nFUNC_CALL;hash_link(const void *,unsigned int);\n");
printf("\nSTMT_EXEC;;7987\n");
struct link const *l;
  printf("\nSTMT_EXEC;;7988\n");
uintmax_t num;

  {
    printf("\nSTMT_EXEC;;7991\n");
l = (struct link const *)entry;
    printf("\nSTMT_EXEC;;7992\n");
num = (uintmax_t)(l->dev ^ l->ino);
    printf("\nSTMT_EXEC;;7993\n");
printf("\nFUNC_RETURN;;\n");
return ((unsigned int)(num % (unsigned long)n_buckets));
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool compare_links(void const *entry1, void const *entry2)
{
  printf("\nFUNC_CALL;compare_links(const void *,const void *);\n");
printf("\nSTMT_EXEC;;7998\n");
struct link const *link1;
  printf("\nSTMT_EXEC;;7999\n");
struct link const *link2;

  {
    printf("\nSTMT_EXEC;;8002\n");
link1 = (struct link const *)entry1;
    printf("\nSTMT_EXEC;;8003\n");
link2 = (struct link const *)entry2;
    printf("\nSTMT_EXEC;;8004\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(((link1->dev ^ link2->dev) | (link1->ino ^ link2->ino)) == 0UL));
  }
printf("\nFUNC_RETURN;;\n");
}
static void unknown_file_error(char *p)
{
  printf("\nFUNC_CALL;unknown_file_error(char *);\n");
printf("\nSTMT_EXEC;;8009\n");
char *tmp;
  printf("\nSTMT_EXEC;;8010\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;8011\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;8015\n");
tmp = quotearg_colon((char const *)p);
      printf("\nSTMT_EXEC;;8016\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: Unknown file type; file ignored");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;8017\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;8019\n");
if (!ignore_failed_read_option)
    {
      printf("\nSTMT_EXEC;;8021\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;8023\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static Hash_table *link_table;
static _Bool dump_hard_link(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;dump_hard_link(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;8029\n");
struct link lp;
  printf("\nSTMT_EXEC;;8030\n");
struct link *duplicate;
  printf("\nSTMT_EXEC;;8031\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;8032\n");
union block *blk;
  printf("\nSTMT_EXEC;;8033\n");
char const *link_name;
  printf("\nSTMT_EXEC;;8034\n");
char *tmp;
  printf("\nSTMT_EXEC;;8035\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;8036\n");
int tmp___1;
  printf("\nSTMT_EXEC;;8037\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;8038\n");
void *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;8041\n");
if (link_table)
    {
      printf("\nSTMT_EXEC;;8043\n");
if (st->stat.st_nlink > 1UL)
      {
        {
          printf("\nSTMT_EXEC;;8046\n");
lp.ino = st->stat.st_ino;
          printf("\nSTMT_EXEC;;8047\n");
lp.dev = st->stat.st_dev;
          printf("\nSTMT_EXEC;;8048\n");
tmp___2 = hash_lookup((Hash_table const *)link_table, (void const *)(&lp));
          printf("\nSTMT_EXEC;;8049\n");
duplicate = (struct link *)tmp___2;
        }
        printf("\nSTMT_EXEC;;8051\n");
if (duplicate)
        {
          {
            printf("\nSTMT_EXEC;;8054\n");
tmp = safer_name_suffix((char const *)(duplicate->name), (_Bool)1);
            printf("\nSTMT_EXEC;;8055\n");
link_name = (char const *)tmp;
            printf("\nSTMT_EXEC;;8056\n");
(duplicate->nlink)--;
            printf("\nSTMT_EXEC;;8057\n");
block_ordinal = current_block_ordinal();
            printf("\nSTMT_EXEC;;8058\n");
assign_string(&st->link_name, link_name);
            printf("\nSTMT_EXEC;;8059\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(link_name);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;8061\n");
if (100UL < tmp___0)
          {
            {
              printf("\nSTMT_EXEC;;8064\n");
write_long_link(st);
            }
          }
          {
            printf("\nSTMT_EXEC;;8068\n");
st->stat.st_size = (__off_t)0;
            printf("\nSTMT_EXEC;;8069\n");
blk = start_header(st);
          }
          printf("\nSTMT_EXEC;;8071\n");
if (!blk)
          {
            printf("\nSTMT_EXEC;;8073\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
          }
          {
            printf("\nSTMT_EXEC;;8076\n");
tar_copy_str(blk->header.linkname, link_name, (size_t)100);
            printf("\nSTMT_EXEC;;8077\n");
blk->header.typeflag = (char)'1';
            printf("\nSTMT_EXEC;;8078\n");
finish_header(st, blk, block_ordinal);
          }
          printf("\nSTMT_EXEC;;8080\n");
if (remove_files_option)
          {
            {
              printf("\nSTMT_EXEC;;8083\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___1 = unlink((char const *)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;8085\n");
if (tmp___1 != 0)
            {
              {
                printf("\nSTMT_EXEC;;8088\n");
unlink_error((char const *)st->orig_file_name);
              }
            }
          }
          printf("\nSTMT_EXEC;;8092\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
        }
      }
    }
    printf("\nSTMT_EXEC;;8096\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static void file_count_links(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;file_count_links(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;8101\n");
struct link *duplicate;
  printf("\nSTMT_EXEC;;8102\n");
struct link *lp;
  printf("\nSTMT_EXEC;;8103\n");
size_t tmp;
  printf("\nSTMT_EXEC;;8104\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;8105\n");
void *tmp___1;

  {
    printf("\nSTMT_EXEC;;8108\n");
if (st->stat.st_nlink > 1UL)
    {
      {
        printf("\nSTMT_EXEC;;8111\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen((char const *)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;8112\n");
tmp___0 = xmalloc(((unsigned long)(&((struct link *)0)->name) + tmp) + 1UL);
        printf("\nSTMT_EXEC;;8113\n");
lp = (struct link *)tmp___0;
        printf("\nSTMT_EXEC;;8114\n");
lp->ino = st->stat.st_ino;
        printf("\nSTMT_EXEC;;8115\n");
lp->dev = st->stat.st_dev;
        printf("\nSTMT_EXEC;;8116\n");
lp->nlink = st->stat.st_nlink;
        printf("\nSTMT_EXEC;;8117\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(lp->name), (char const * /* __restrict  */)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;8119\n");
if (link_table)
      {
        printf("\nSTMT_EXEC;;8121\n");
goto _L;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;8126\n");
link_table = hash_initialize((size_t)0, (Hash_tuning const *)0, (size_t(*)(void const *, size_t))(&hash_link), &compare_links, (void (*)(void *))0);
        }
        printf("\nSTMT_EXEC;;8128\n");
if (link_table)
        {
        _L:
        {
          printf("\nSTMT_EXEC;;8132\n");
tmp___1 = hash_insert(link_table, (void const *)lp);
          printf("\nSTMT_EXEC;;8133\n");
duplicate = (struct link *)tmp___1;
        }
          printf("\nSTMT_EXEC;;8135\n");
if (!duplicate)
          {
            {
              printf("\nSTMT_EXEC;;8138\n");
xalloc_die();
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;8145\n");
xalloc_die();
          }
        }
      }
      printf("\nSTMT_EXEC;;8149\n");
if ((unsigned long)duplicate != (unsigned long)lp)
      {
        {
          printf("\nSTMT_EXEC;;8152\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

        }
      }
      printf("\nSTMT_EXEC;;8155\n");
(lp->nlink)--;
    }
    printf("\nSTMT_EXEC;;8157\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void check_links(void)
{
  printf("\nFUNC_CALL;check_links();\n");
printf("\nSTMT_EXEC;;8162\n");
struct link *lp;
  printf("\nSTMT_EXEC;;8163\n");
void *tmp;
  printf("\nSTMT_EXEC;;8164\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;8165\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;8166\n");
char *__cil_tmp5;

  {
    printf("\nSTMT_EXEC;;8169\n");
if (!link_table)
    {
      printf("\nSTMT_EXEC;;8171\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;8174\n");
tmp = hash_get_first((Hash_table const *)link_table);
      printf("\nSTMT_EXEC;;8175\n");
lp = (struct link *)tmp;
    }
    {
      printf("\nSTMT_EXEC;;8178\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;8181\n");
if (!lp)
        {
          printf("\nSTMT_EXEC;;8183\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;8185\n");
if (lp->nlink)
        {
          {
            printf("\nSTMT_EXEC;;8188\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Missing links to \'%s\'.\n");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;8189\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, lp->name);printf("\nFUNC_RETURN;;\n");

          }
        }
        {
          printf("\nSTMT_EXEC;;8193\n");
tmp___0 = hash_get_next((Hash_table const *)link_table, (void const *)lp);
          printf("\nSTMT_EXEC;;8194\n");
lp = (struct link *)tmp___0;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;8199\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}



































































































































































static void dump_file0(struct tar_stat_info *st, char *p, int top_level, dev_t parent_device)
{
  printf("\nFUNC_CALL;dump_file0(struct tar_stat_info *,char *,int,dev_t);\n");
printf("\nSTMT_EXEC;;8367\n");
union block *header;
  printf("\nSTMT_EXEC;;8368\n");
char type;
  printf("\nSTMT_EXEC;;8369\n");
time_t original_ctime;
  printf("\nSTMT_EXEC;;8370\n");
struct utimbuf restore_times;
  printf("\nSTMT_EXEC;;8371\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;8372\n");
int tmp;
  printf("\nSTMT_EXEC;;8373\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;8374\n");
int tmp___1;
  printf("\nSTMT_EXEC;;8375\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;8376\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;8377\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;8378\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;8379\n");
_Bool tmp___6;
  printf("\nSTMT_EXEC;;8380\n");
_Bool tmp___7;
  printf("\nSTMT_EXEC;;8381\n");
int fd;
  printf("\nSTMT_EXEC;;8382\n");
enum dump_status status;
  printf("\nSTMT_EXEC;;8383\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;8384\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;8385\n");
int *tmp___10;
  printf("\nSTMT_EXEC;;8386\n");
_Bool tmp___11;
  printf("\nSTMT_EXEC;;8387\n");
_Bool tmp___12;
  printf("\nSTMT_EXEC;;8388\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;8389\n");
int size;
  printf("\nSTMT_EXEC;;8390\n");
size_t linklen;
  printf("\nSTMT_EXEC;;8391\n");
void *tmp___13;
  printf("\nSTMT_EXEC;;8392\n");
ssize_t tmp___14;
  printf("\nSTMT_EXEC;;8393\n");
int tmp___15;
  printf("\nSTMT_EXEC;;8394\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;8395\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;8396\n");
_Bool tmp___20;
  printf("\nSTMT_EXEC;;8397\n");
unsigned int tmp___21;
  printf("\nSTMT_EXEC;;8398\n");
unsigned int tmp___22;
  printf("\nSTMT_EXEC;;8399\n");
int tmp___23;
  printf("\nSTMT_EXEC;;8400\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;8401\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;8402\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;8403\n");
char *__cil_tmp41;
  printf("\nSTMT_EXEC;;8404\n");
char *__cil_tmp42;

  {
    printf("\nSTMT_EXEC;;8407\n");
block_ordinal = (off_t)-1;
    printf("\nSTMT_EXEC;;8408\n");
if (interactive_option)
    {
      {
        printf("\nSTMT_EXEC;;8411\n");
tmp = confirm("add", (char const *)p);
      }
      printf("\nSTMT_EXEC;;8413\n");
if (!tmp)
      {
        printf("\nSTMT_EXEC;;8415\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }






















    {
      printf("\nSTMT_EXEC;;8441\n");
assign_string(&st->orig_file_name, (char const *)p);
      printf("\nSTMT_EXEC;;8442\n");
tmp___0 = safer_name_suffix((char const *)p, (_Bool)0);
      printf("\nSTMT_EXEC;;8443\n");
assign_string(&st->file_name, (char const *)tmp___0);
      printf("\nSTMT_EXEC;;8444\n");
tmp___1 = deref_stat(dereference_option, (char const *)p, &st->stat);
    }
    printf("\nSTMT_EXEC;;8446\n");
if (tmp___1 != 0)
    {
      {
        printf("\nSTMT_EXEC;;8449\n");
stat_diag((char const *)p);
      }
      printf("\nSTMT_EXEC;;8451\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;8454\n");
st->archive_file_size = st->stat.st_size;
      printf("\nSTMT_EXEC;;8455\n");
sys_stat_nanoseconds(st);
      printf("\nSTMT_EXEC;;8456\n");
original_ctime = st->stat.st_ctim.tv_sec;
      printf("\nSTMT_EXEC;;8457\n");
restore_times.actime = st->stat.st_atim.tv_sec;
      printf("\nSTMT_EXEC;;8458\n");
restore_times.modtime = st->stat.st_mtim.tv_sec;
    }
    printf("\nSTMT_EXEC;;8460\n");
if (!((st->stat.st_mode & 61440U) == 16384U))
    {
      printf("\nSTMT_EXEC;;8462\n");
if (st->stat.st_mtim.tv_sec < newer_mtime_option.tv_sec)
      {
        printf("\nSTMT_EXEC;;8464\n");
goto _L___5;
      }
      else
      {
        printf("\nSTMT_EXEC;;8468\n");
if (st->stat.st_mtim.tv_sec == newer_mtime_option.tv_sec)
        {
          printf("\nSTMT_EXEC;;8470\n");
if (st->stat.st_mtim.tv_nsec < newer_mtime_option.tv_nsec)
          {
          _L___5: /* CIL Label */
            {
printf("\nSTMT_EXEC;;8473\n");
if (!after_date_option)
            {
              printf("\nSTMT_EXEC;;8475\n");
goto _L___4;
            }
            else
            {
              printf("\nSTMT_EXEC;;8479\n");
if (st->stat.st_ctim.tv_sec < newer_mtime_option.tv_sec)
              {
                printf("\nSTMT_EXEC;;8481\n");
goto _L___4;
              }
              else
              {
                printf("\nSTMT_EXEC;;8485\n");
if (st->stat.st_ctim.tv_sec == newer_mtime_option.tv_sec)
                {
                  printf("\nSTMT_EXEC;;8487\n");
if (st->stat.st_ctim.tv_nsec < newer_mtime_option.tv_nsec)
                  {
                  _L___4: /* CIL Label */
                    {
printf("\nSTMT_EXEC;;8490\n");
if (0 < top_level)
                    {
                      {
                        printf("\nSTMT_EXEC;;8493\n");
tmp___2 = quotearg_colon((char const *)p);
                        printf("\nSTMT_EXEC;;8494\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("%s: file is unchanged; not dumped");printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;8495\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

                      }
                    }
}

                    printf("\nSTMT_EXEC;;8498\n");
printf("\nFUNC_RETURN;;\n");
return;
                  }
                }
              }
            }
}

          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;8508\n");
tmp___6 = sys_file_is_archive(st);
    }
    printf("\nSTMT_EXEC;;8510\n");
if (tmp___6)
    {
      {
        printf("\nSTMT_EXEC;;8513\n");
tmp___4 = quotearg_colon((char const *)p);
        printf("\nSTMT_EXEC;;8514\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("%s: file is the archive; not dumped");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;8515\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___5, tmp___4);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;8517\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;8519\n");
if ((st->stat.st_mode & 61440U) == 16384U)
    {
      {
        printf("\nSTMT_EXEC;;8522\n");
dump_dir(st, top_level, parent_device);
      }
      printf("\nSTMT_EXEC;;8524\n");
if (atime_preserve_option)
      {
        {
          printf("\nSTMT_EXEC;;8527\n");
printf("\nFUNC_CALL;utime(const char *,const struct utimbuf *);\n");
utime((char const *)p, (struct utimbuf const *)(&restore_times));printf("\nFUNC_RETURN;;\n");

        }
      }
      printf("\nSTMT_EXEC;;8530\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;8535\n");
tmp___20 = is_avoided_name((char const *)p);
      }
      printf("\nSTMT_EXEC;;8537\n");
if (tmp___20)
      {
        printf("\nSTMT_EXEC;;8539\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;8544\n");
tmp___7 = dump_hard_link(st);
        }
        printf("\nSTMT_EXEC;;8546\n");
if (tmp___7)
        {
          printf("\nSTMT_EXEC;;8548\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
        printf("\nSTMT_EXEC;;8550\n");
if ((st->stat.st_mode & 61440U) == 32768U)
        {
          printf("\nSTMT_EXEC;;8552\n");
goto _L___6;
        }
        else
        {
          printf("\nSTMT_EXEC;;8556\n");
if (0)
          {
          _L___6: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;8560\n");
tmp___11 = file_dumpable_p(st);
          }
            printf("\nSTMT_EXEC;;8562\n");
if (tmp___11)
            {
              {
                printf("\nSTMT_EXEC;;8565\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
fd = open((char const *)st->orig_file_name, 0);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;8567\n");
if (fd < 0)
              {
                printf("\nSTMT_EXEC;;8569\n");
if (!top_level)
                {
                  {
                    printf("\nSTMT_EXEC;;8572\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___10 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;8574\n");
if (*tmp___10 == 2)
                  {
                    {
                      printf("\nSTMT_EXEC;;8577\n");
tmp___8 = quotearg_colon((char const *)st->orig_file_name);
                      printf("\nSTMT_EXEC;;8578\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("%s: File removed before we read it");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;8579\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9, tmp___8);printf("\nFUNC_RETURN;;\n");

                    }
                  }
                  else
                  {
                    {
                      printf("\nSTMT_EXEC;;8585\n");
open_diag((char const *)st->orig_file_name);
                    }
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;8592\n");
open_diag((char const *)st->orig_file_name);
                  }
                }
                printf("\nSTMT_EXEC;;8595\n");
printf("\nFUNC_RETURN;;\n");
return;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;8600\n");
fd = -1;
            }
            printf("\nSTMT_EXEC;;8602\n");
if (sparse_option)
            {
              {
                printf("\nSTMT_EXEC;;8605\n");
tmp___12 = sparse_file_p(st);
              }
              printf("\nSTMT_EXEC;;8607\n");
if (tmp___12)
              {
                {
                  printf("\nSTMT_EXEC;;8610\n");
status = sparse_dump_file(fd, st);
                }
                printf("\nSTMT_EXEC;;8612\n");
if ((unsigned int)status == 3U)
                {
                  {
                    printf("\nSTMT_EXEC;;8615\n");
status = dump_regular_file(fd, st);
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;8622\n");
status = dump_regular_file(fd, st);
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;8629\n");
status = dump_regular_file(fd, st);
              }
            }
            {
              printf("\nSTMT_EXEC;;8633\n");
if ((unsigned int)status == 0U)
              {
                printf("\nSTMT_EXEC;;8635\n");
goto case_0;
              }
              printf("\nSTMT_EXEC;;8637\n");
if ((unsigned int)status == 1U)
              {
                printf("\nSTMT_EXEC;;8639\n");
goto case_1;
              }
              printf("\nSTMT_EXEC;;8641\n");
if ((unsigned int)status == 2U)
              {
                printf("\nSTMT_EXEC;;8643\n");
goto case_2;
              }
              printf("\nSTMT_EXEC;;8645\n");
if ((unsigned int)status == 3U)
              {
                printf("\nSTMT_EXEC;;8647\n");
goto case_3;
              }
              printf("\nSTMT_EXEC;;8649\n");
goto switch_break;
            case_0: /* CIL Label */
              {
printf("\nSTMT_EXEC;;8651\n");
if (multi_volume_option)
              {
                {
                  printf("\nSTMT_EXEC;;8654\n");
assign_string(&save_name, (char const *)0);
                }
              }
}

              {
                printf("\nSTMT_EXEC;;8658\n");
dump_regular_finish(fd, st, original_ctime);
              }
              printf("\nSTMT_EXEC;;8660\n");
goto switch_break;
            case_1: /* CIL Label */
              {
printf("\nSTMT_EXEC;;8662\n");
if (multi_volume_option)
              {
                {
                  printf("\nSTMT_EXEC;;8665\n");
assign_string(&save_name, (char const *)0);
                }
              }
}

              {
                printf("\nSTMT_EXEC;;8669\n");
printf("\nFUNC_CALL;close(int);\n");
close(fd);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;8671\n");
goto switch_break;
            case_2: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;8674\n");
printf("\nFUNC_CALL;close(int);\n");
close(fd);printf("\nFUNC_RETURN;;\n");

            }
              printf("\nSTMT_EXEC;;8676\n");
printf("\nFUNC_RETURN;;\n");
return;
            case_3: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;8679\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

            }
            switch_break: /* CIL Label */;
            }
            printf("\nSTMT_EXEC;;8683\n");
if (atime_preserve_option)
            {
              {
                printf("\nSTMT_EXEC;;8686\n");
printf("\nFUNC_CALL;utime(const char *,const struct utimbuf *);\n");
utime((char const *)st->orig_file_name, (struct utimbuf const *)(&restore_times));printf("\nFUNC_RETURN;;\n");

              }
            }
            {
              printf("\nSTMT_EXEC;;8690\n");
file_count_links(st);
            }
            printf("\nSTMT_EXEC;;8692\n");
printf("\nFUNC_RETURN;;\n");
return;
          }
          else
          {
            printf("\nSTMT_EXEC;;8696\n");
if ((st->stat.st_mode & 61440U) == 40960U)
            {
              printf("\nSTMT_EXEC;;8698\n");
linklen = (size_t)st->stat.st_size;
              printf("\nSTMT_EXEC;;8699\n");
if (linklen != (size_t)st->stat.st_size)
              {
                {
                  printf("\nSTMT_EXEC;;8702\n");
xalloc_die();
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;8707\n");
if (linklen + 1UL == 0UL)
                {
                  {
                    printf("\nSTMT_EXEC;;8710\n");
xalloc_die();
                  }
                }
              }
              {
                printf("\nSTMT_EXEC;;8715\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___13 = __builtin_alloca(linklen + 1UL);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;8716\n");
buffer___2 = (char *)tmp___13;
                printf("\nSTMT_EXEC;;8717\n");
printf("\nFUNC_CALL;readlink(const char *__restrict,char *__restrict,size_t);\n");
tmp___14 = readlink((char const * /* __restrict  */)p, (char * /* __restrict  */)buffer___2, linklen + 1UL);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;8718\n");
size = (int)tmp___14;
              }
              printf("\nSTMT_EXEC;;8720\n");
if (size < 0)
              {
                {
                  printf("\nSTMT_EXEC;;8723\n");
readlink_diag((char const *)p);
                }
                printf("\nSTMT_EXEC;;8725\n");
printf("\nFUNC_RETURN;;\n");
return;
              }
              {
                printf("\nSTMT_EXEC;;8728\n");
*(buffer___2 + size) = (char)'\000';
                printf("\nSTMT_EXEC;;8729\n");
assign_string(&st->link_name, (char const *)buffer___2);
              }
              printf("\nSTMT_EXEC;;8731\n");
if (size > 100)
              {
                {
                  printf("\nSTMT_EXEC;;8734\n");
write_long_link(st);
                }
              }
              {
                printf("\nSTMT_EXEC;;8738\n");
block_ordinal = current_block_ordinal();
                printf("\nSTMT_EXEC;;8739\n");
st->stat.st_size = (__off_t)0;
                printf("\nSTMT_EXEC;;8740\n");
header = start_header(st);
              }
              printf("\nSTMT_EXEC;;8742\n");
if (!header)
              {
                printf("\nSTMT_EXEC;;8744\n");
printf("\nFUNC_RETURN;;\n");
return;
              }
              {
                printf("\nSTMT_EXEC;;8747\n");
tar_copy_str(header->header.linkname, (char const *)buffer___2, (size_t)100);
                printf("\nSTMT_EXEC;;8748\n");
header->header.typeflag = (char)'2';
                printf("\nSTMT_EXEC;;8749\n");
finish_header(st, header, block_ordinal);
              }
              printf("\nSTMT_EXEC;;8751\n");
if (remove_files_option)
              {
                {
                  printf("\nSTMT_EXEC;;8754\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___15 = unlink((char const *)p);printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;8756\n");
if (tmp___15 == -1)
                {
                  {
                    printf("\nSTMT_EXEC;;8759\n");
unlink_error((char const *)p);
                  }
                }
              }
              {
                printf("\nSTMT_EXEC;;8764\n");
file_count_links(st);
              }
              printf("\nSTMT_EXEC;;8766\n");
printf("\nFUNC_RETURN;;\n");
return;
            }
            else
            {
              printf("\nSTMT_EXEC;;8770\n");
if ((st->stat.st_mode & 61440U) == 8192U)
              {
                printf("\nSTMT_EXEC;;8772\n");
type = (char)'3';
              }
              else
              {
                printf("\nSTMT_EXEC;;8776\n");
if ((st->stat.st_mode & 61440U) == 24576U)
                {
                  printf("\nSTMT_EXEC;;8778\n");
type = (char)'4';
                }
                else
                {
                  printf("\nSTMT_EXEC;;8782\n");
if ((st->stat.st_mode & 61440U) == 4096U)
                  {
                    printf("\nSTMT_EXEC;;8784\n");
type = (char)'6';
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;8788\n");
if ((st->stat.st_mode & 61440U) == 49152U)
                    {
                      {
                        printf("\nSTMT_EXEC;;8791\n");
tmp___16 = quotearg_colon((char const *)p);
                        printf("\nSTMT_EXEC;;8792\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___17 = gettext("%s: socket ignored");printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;8793\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___17, tmp___16);printf("\nFUNC_RETURN;;\n");

                      }
                      printf("\nSTMT_EXEC;;8795\n");
printf("\nFUNC_RETURN;;\n");
return;
                    }
                    else
                    {
                      {
                        printf("\nSTMT_EXEC;;8800\n");
unknown_file_error(p);
                      }
                      printf("\nSTMT_EXEC;;8802\n");
printf("\nFUNC_RETURN;;\n");
return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;8812\n");
if ((unsigned int)archive_format == 1U)
    {
      {
        printf("\nSTMT_EXEC;;8815\n");
unknown_file_error(p);
      }
      printf("\nSTMT_EXEC;;8817\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;8820\n");
block_ordinal = current_block_ordinal();
      printf("\nSTMT_EXEC;;8821\n");
st->stat.st_size = (__off_t)0;
      printf("\nSTMT_EXEC;;8822\n");
header = start_header(st);
    }
    printf("\nSTMT_EXEC;;8824\n");
if (!header)
    {
      printf("\nSTMT_EXEC;;8826\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;8828\n");
header->header.typeflag = type;
    printf("\nSTMT_EXEC;;8829\n");
if ((int)type != 54)
    {
      {
        printf("\nSTMT_EXEC;;8832\n");
printf("\nFUNC_CALL;gnu_dev_major(unsigned long long);\n");
tmp___21 = gnu_dev_major((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;8833\n");
major_to_chars((int)tmp___21, header->header.devmajor, sizeof(header->header.devmajor));
        printf("\nSTMT_EXEC;;8834\n");
printf("\nFUNC_CALL;gnu_dev_minor(unsigned long long);\n");
tmp___22 = gnu_dev_minor((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;8835\n");
minor_to_chars((int)tmp___22, header->header.devminor, sizeof(header->header.devminor));
      }
    }
    {
      printf("\nSTMT_EXEC;;8839\n");
finish_header(st, header, block_ordinal);
    }
    printf("\nSTMT_EXEC;;8841\n");
if (remove_files_option)
    {
      {
        printf("\nSTMT_EXEC;;8844\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___23 = unlink((char const *)p);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;8846\n");
if (tmp___23 == -1)
      {
        {
          printf("\nSTMT_EXEC;;8849\n");
unlink_error((char const *)p);
        }
      }
    }
    printf("\nSTMT_EXEC;;8853\n");
printf("\nFUNC_RETURN;;\n");
return;











































































































































































































  }
printf("\nFUNC_RETURN;;\n");
}
void dump_file(char *p, int top_level, dev_t parent_device)
{
  printf("\nFUNC_CALL;dump_file(char *,int,dev_t);\n");
printf("\nSTMT_EXEC;;9061\n");
struct tar_stat_info st;
  printf("\nSTMT_EXEC;;9062\n");
void *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;9066\n");
tar_stat_init(&st);

      printf("\nSTMT_EXEC;;9068\n");
dump_file0(&st, p, top_level, parent_device);
      printf("\nSTMT_EXEC;;9069\n");
tar_stat_destroy(&st);
    }
    printf("\nSTMT_EXEC;;9071\n");
printf("\nFUNC_RETURN;;\n");
return;


  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","003.delete.o.i","") */
_Bool ignore_zeros_option;
uintmax_t occurrence_option;
void delete_archive_members(void);
size_t recent_long_name_blocks;
size_t recent_long_link_blocks;
void truncate_warn(char const *name);
void name_gather(void);
void names_notfound(void);
struct name *name_scan(char const *path);
void xheader_decode(struct tar_stat_info *st);
int sys_truncate(int fd);
static union block *new_record;
static int new_blocks;
static _Bool acting_as_filter;
union block *recent_long_name;
union block *recent_long_link;
static off_t records_skipped;
static void move_archive(off_t count)
{
  printf("\nFUNC_CALL;move_archive(off_t);\n");
printf("\nSTMT_EXEC;;9096\n");
struct mtop operation;
  printf("\nSTMT_EXEC;;9097\n");
int tmp;
  printf("\nSTMT_EXEC;;9098\n");
int tmp___0;
  printf("\nSTMT_EXEC;;9099\n");
int tmp___1;
  printf("\nSTMT_EXEC;;9100\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;9101\n");
int tmp___3;
  printf("\nSTMT_EXEC;;9102\n");
int tmp___4;
  printf("\nSTMT_EXEC;;9103\n");
int tmp___5;
  printf("\nSTMT_EXEC;;9104\n");
int tmp___6;
  printf("\nSTMT_EXEC;;9105\n");
off_t position0;
  printf("\nSTMT_EXEC;;9106\n");
off_t tmp___7;
  printf("\nSTMT_EXEC;;9107\n");
__off_t tmp___8;
  printf("\nSTMT_EXEC;;9108\n");
off_t tmp___9;
  printf("\nSTMT_EXEC;;9109\n");
off_t increment;
  printf("\nSTMT_EXEC;;9110\n");
off_t position;
  printf("\nSTMT_EXEC;;9111\n");
off_t tmp___10;
  printf("\nSTMT_EXEC;;9112\n");
__off_t tmp___11;
  printf("\nSTMT_EXEC;;9113\n");
off_t tmp___12;

  {
    printf("\nSTMT_EXEC;;9116\n");
if (count == 0L)
    {
      printf("\nSTMT_EXEC;;9118\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;9120\n");
if (count < 0L)
    {
      printf("\nSTMT_EXEC;;9122\n");
operation.mt_op = (short)4;
      printf("\nSTMT_EXEC;;9123\n");
operation.mt_count = (int)(-count);
      printf("\nSTMT_EXEC;;9124\n");
tmp___6 = (off_t)operation.mt_count == -count;
    }
    else
    {
      printf("\nSTMT_EXEC;;9128\n");
operation.mt_op = (short)3;
      printf("\nSTMT_EXEC;;9129\n");
operation.mt_count = (int)count;
      printf("\nSTMT_EXEC;;9130\n");
tmp___6 = (off_t)operation.mt_count == count;
    }
    printf("\nSTMT_EXEC;;9132\n");
if (tmp___6)
    {
      printf("\nSTMT_EXEC;;9134\n");
if (archive >= 1 << 30)
      {
        {
          printf("\nSTMT_EXEC;;9137\n");
tmp = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
          printf("\nSTMT_EXEC;;9138\n");
tmp___1 = tmp;
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;9144\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___0 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;9145\n");
tmp___1 = tmp___0;
        }
      }
      printf("\nSTMT_EXEC;;9148\n");
if (0 <= tmp___1)
      {
        printf("\nSTMT_EXEC;;9150\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
      {
        printf("\nSTMT_EXEC;;9153\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;9155\n");
if (*tmp___2 == 5)
      {
        printf("\nSTMT_EXEC;;9157\n");
if (archive >= 1 << 30)
        {
          {
            printf("\nSTMT_EXEC;;9160\n");
tmp___3 = rmt_ioctl__(archive - (1 << 30), (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)), (char *)(&operation));
            printf("\nSTMT_EXEC;;9161\n");
tmp___5 = tmp___3;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;9167\n");
printf("\nFUNC_CALL;ioctl(int,unsigned long);\n");
tmp___4 = ioctl(archive, (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16), (char *)(&operation));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9168\n");
tmp___5 = tmp___4;
          }
        }
        printf("\nSTMT_EXEC;;9171\n");
if (0 <= tmp___5)
        {
          printf("\nSTMT_EXEC;;9173\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    printf("\nSTMT_EXEC;;9177\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;9180\n");
tmp___7 = rmt_lseek__(archive - (1 << 30), (off_t)0, 1);
        printf("\nSTMT_EXEC;;9181\n");
tmp___9 = tmp___7;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;9187\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___8 = lseek(archive, (off_t)0, 1);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;9188\n");
tmp___9 = tmp___8;
      }
    }
    printf("\nSTMT_EXEC;;9191\n");
position0 = tmp___9;
    printf("\nSTMT_EXEC;;9192\n");
increment = (off_t)(record_size * (size_t)count);
    printf("\nSTMT_EXEC;;9193\n");
position = position0 + increment;
    printf("\nSTMT_EXEC;;9194\n");
if ((size_t)(increment / count) != record_size)
    {
      {
        printf("\nSTMT_EXEC;;9197\n");
seek_error_details(*(archive_name_array + 0), position);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;9202\n");
if ((position < position0) != (increment < 0L))
      {
        {
          printf("\nSTMT_EXEC;;9205\n");
seek_error_details(*(archive_name_array + 0), position);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;9210\n");
if (position < 0L)
        {
          printf("\nSTMT_EXEC;;9212\n");
position = (off_t)0;
        }
        else
        {
          printf("\nSTMT_EXEC;;9216\n");
position = position;
        }
        printf("\nSTMT_EXEC;;9218\n");
if (archive >= 1 << 30)
        {
          {
            printf("\nSTMT_EXEC;;9221\n");
tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
            printf("\nSTMT_EXEC;;9222\n");
tmp___12 = tmp___10;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;9228\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp___11 = lseek(archive, position, 0);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9229\n");
tmp___12 = tmp___11;
          }
        }
        printf("\nSTMT_EXEC;;9232\n");
if (tmp___12 != position)
        {
          {
            printf("\nSTMT_EXEC;;9235\n");
seek_error_details(*(archive_name_array + 0), position);
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;9240\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void write_record(int move_back_flag)
{
  printf("\nFUNC_CALL;write_record(int);\n");
printf("\nSTMT_EXEC;;9245\n");
union block *save_record;

  {
    printf("\nSTMT_EXEC;;9248\n");
save_record = record_start;
    printf("\nSTMT_EXEC;;9249\n");
record_start = new_record;
    printf("\nSTMT_EXEC;;9250\n");
if (acting_as_filter)
    {
      {
        printf("\nSTMT_EXEC;;9253\n");
archive = 1;
        printf("\nSTMT_EXEC;;9254\n");
flush_write();
        printf("\nSTMT_EXEC;;9255\n");
archive = 0;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;9261\n");
move_archive((records_written + records_skipped) - records_read);
        printf("\nSTMT_EXEC;;9262\n");
flush_write();
      }
    }
    printf("\nSTMT_EXEC;;9265\n");
record_start = save_record;
    printf("\nSTMT_EXEC;;9266\n");
if (move_back_flag)
    {
      printf("\nSTMT_EXEC;;9268\n");
if (!acting_as_filter)
      {
        {
          printf("\nSTMT_EXEC;;9271\n");
move_archive(records_read - (records_written + records_skipped));
        }
      }
    }
    printf("\nSTMT_EXEC;;9275\n");
new_blocks = 0;
    printf("\nSTMT_EXEC;;9276\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void write_recent_blocks(union block *h, size_t blocks)
{
  printf("\nFUNC_CALL;write_recent_blocks(union block *,size_t);\n");
printf("\nSTMT_EXEC;;9281\n");
size_t i;
  printf("\nSTMT_EXEC;;9282\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;9285\n");
i = (size_t)0;
    {
      printf("\nSTMT_EXEC;;9287\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;9290\n");
if (!(i < blocks))
        {
          printf("\nSTMT_EXEC;;9292\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;9294\n");
tmp = new_blocks;
        printf("\nSTMT_EXEC;;9295\n");
new_blocks++;
        printf("\nSTMT_EXEC;;9296\n");
*(new_record + tmp) = *(h + i);
        printf("\nSTMT_EXEC;;9297\n");
if (new_blocks == blocking_factor)
        {
          {
            printf("\nSTMT_EXEC;;9300\n");
write_record(1);
          }
        }
        printf("\nSTMT_EXEC;;9303\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;9307\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void write_recent_bytes(char *data, size_t bytes)
{
  printf("\nFUNC_CALL;write_recent_bytes(char *,size_t);\n");
printf("\nSTMT_EXEC;;9312\n");
size_t blocks;
  printf("\nSTMT_EXEC;;9313\n");
size_t rest;

  {
    {
      printf("\nSTMT_EXEC;;9317\n");
blocks = bytes / 512UL;
      printf("\nSTMT_EXEC;;9318\n");
rest = bytes - blocks * 512UL;
      printf("\nSTMT_EXEC;;9319\n");
write_recent_blocks((union block *)data, blocks);
      printf("\nSTMT_EXEC;;9320\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)((new_record + new_blocks)->buffer), (void const * /* __restrict  */)(data + blocks * 512UL), rest);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;9322\n");
if (rest < 512UL)
    {
      {
        printf("\nSTMT_EXEC;;9325\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)((new_record + new_blocks)->buffer + rest), 0, 512UL - rest);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;9328\n");
new_blocks++;
    printf("\nSTMT_EXEC;;9329\n");
if (new_blocks == blocking_factor)
    {
      {
        printf("\nSTMT_EXEC;;9332\n");
write_record(1);
      }
    }
    printf("\nSTMT_EXEC;;9335\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void delete_archive_members(void)
{
  printf("\nFUNC_CALL;delete_archive_members();\n");
printf("\nSTMT_EXEC;;9340\n");
enum read_header logical_status;
  printf("\nSTMT_EXEC;;9341\n");
enum read_header previous_status;
  printf("\nSTMT_EXEC;;9342\n");
struct name *name;
  printf("\nSTMT_EXEC;;9343\n");
off_t blocks_to_skip;
  printf("\nSTMT_EXEC;;9344\n");
off_t blocks_to_keep;
  printf("\nSTMT_EXEC;;9345\n");
int kept_blocks_in_record;
  printf("\nSTMT_EXEC;;9346\n");
int tmp;
  printf("\nSTMT_EXEC;;9347\n");
enum read_header status;
  printf("\nSTMT_EXEC;;9348\n");
enum read_header tmp___0;
  printf("\nSTMT_EXEC;;9349\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;9350\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;9351\n");
void *tmp___3;
  printf("\nSTMT_EXEC;;9352\n");
enum read_header status___0;
  printf("\nSTMT_EXEC;;9353\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;9354\n");
int count;
  printf("\nSTMT_EXEC;;9355\n");
int total_zero_blocks;
  printf("\nSTMT_EXEC;;9356\n");
int zero_blocks;
  printf("\nSTMT_EXEC;;9357\n");
int tmp___5;
  printf("\nSTMT_EXEC;;9358\n");
uintmax_t tmp___6;
  printf("\nSTMT_EXEC;;9359\n");
uintmax_t tmp___7;
  printf("\nSTMT_EXEC;;9360\n");
char *__cil_tmp21;
  printf("\nSTMT_EXEC;;9361\n");
char *__cil_tmp22;
  printf("\nSTMT_EXEC;;9362\n");
char *__cil_tmp23;

  {
    {
      printf("\nSTMT_EXEC;;9366\n");
logical_status = (enum read_header)0;
      printf("\nSTMT_EXEC;;9367\n");
previous_status = (enum read_header)0;
      printf("\nSTMT_EXEC;;9368\n");
blocks_to_skip = (off_t)0;
      printf("\nSTMT_EXEC;;9369\n");
blocks_to_keep = (off_t)0;
      printf("\nSTMT_EXEC;;9370\n");
name_gather();
      printf("\nSTMT_EXEC;;9371\n");
open_archive((enum access_mode)2);
      printf("\nSTMT_EXEC;;9372\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;9373\n");
acting_as_filter = (_Bool)(tmp == 0);
    }
    {
      printf("\nSTMT_EXEC;;9376\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;9380\n");
tmp___0 = read_header((_Bool)1);
          printf("\nSTMT_EXEC;;9381\n");
status = tmp___0;
        }
        {
          printf("\nSTMT_EXEC;;9384\n");
if ((unsigned int)status == 0U)
          {
            printf("\nSTMT_EXEC;;9386\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;9388\n");
if ((unsigned int)status == 1U)
          {
            printf("\nSTMT_EXEC;;9390\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;9392\n");
if ((unsigned int)status == 2U)
          {
            printf("\nSTMT_EXEC;;9394\n");
goto case_2;
          }
          printf("\nSTMT_EXEC;;9396\n");
if ((unsigned int)status == 3U)
          {
            printf("\nSTMT_EXEC;;9398\n");
goto case_3;
          }
          printf("\nSTMT_EXEC;;9400\n");
if ((unsigned int)status == 4U)
          {
            printf("\nSTMT_EXEC;;9402\n");
goto case_4;
          }
          printf("\nSTMT_EXEC;;9404\n");
if ((unsigned int)status == 5U)
          {
            printf("\nSTMT_EXEC;;9406\n");
goto case_5;
          }
          printf("\nSTMT_EXEC;;9408\n");
goto switch_break;
        case_0: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;9411\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

        }
        case_1: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;9415\n");
name = name_scan((char const *)current_stat_info.file_name);
        }
          printf("\nSTMT_EXEC;;9417\n");
if ((unsigned long)name == (unsigned long)((void *)0))
          {
            {
              printf("\nSTMT_EXEC;;9420\n");
skip_member();
            }
            printf("\nSTMT_EXEC;;9422\n");
goto switch_break;
          }
          printf("\nSTMT_EXEC;;9424\n");
(name->found_count)++;
          printf("\nSTMT_EXEC;;9425\n");
if (occurrence_option == 0UL)
          {
            printf("\nSTMT_EXEC;;9427\n");
tmp___6 = name->found_count;
          }
          else
          {
            printf("\nSTMT_EXEC;;9431\n");
tmp___6 = (uintmax_t)(name->found_count == occurrence_option);
          }
          printf("\nSTMT_EXEC;;9433\n");
if (!tmp___6)
          {
            {
              printf("\nSTMT_EXEC;;9436\n");
skip_member();
            }
            printf("\nSTMT_EXEC;;9438\n");
goto switch_break;
          }
        case_2: /* CIL Label */
          {
printf("\nSTMT_EXEC;;9441\n");
logical_status = status;
}

          printf("\nSTMT_EXEC;;9442\n");
goto switch_break;
        case_3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;9444\n");
if (ignore_zeros_option)
          {
            {
              printf("\nSTMT_EXEC;;9447\n");
set_next_block_after(current_header);
            }
            printf("\nSTMT_EXEC;;9449\n");
goto switch_break;
          }
}

        case_4: /* CIL Label */
          {
printf("\nSTMT_EXEC;;9452\n");
logical_status = (enum read_header)4;
}

          printf("\nSTMT_EXEC;;9453\n");
goto switch_break;
        case_5: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;9456\n");
set_next_block_after(current_header);
        }
          {
            printf("\nSTMT_EXEC;;9459\n");
if ((unsigned int)previous_status == 0U)
            {
              printf("\nSTMT_EXEC;;9461\n");
goto case_0___0;
            }
            printf("\nSTMT_EXEC;;9463\n");
if ((unsigned int)previous_status == 1U)
            {
              printf("\nSTMT_EXEC;;9465\n");
goto case_1___0;
            }
            printf("\nSTMT_EXEC;;9467\n");
if ((unsigned int)previous_status == 2U)
            {
              printf("\nSTMT_EXEC;;9469\n");
goto case_1___0;
            }
            printf("\nSTMT_EXEC;;9471\n");
if ((unsigned int)previous_status == 3U)
            {
              printf("\nSTMT_EXEC;;9473\n");
goto case_1___0;
            }
            printf("\nSTMT_EXEC;;9475\n");
if ((unsigned int)previous_status == 5U)
            {
              printf("\nSTMT_EXEC;;9477\n");
goto case_5___0;
            }
            printf("\nSTMT_EXEC;;9479\n");
if ((unsigned int)previous_status == 4U)
            {
              printf("\nSTMT_EXEC;;9481\n");
goto case_4___0;
            }
            printf("\nSTMT_EXEC;;9483\n");
goto switch_break___0;
          case_0___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;9486\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("This does not look like a tar archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9487\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

          }
          case_1___0: /* CIL Label */
          case_2___0: /* CIL Label */
          case_3___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;9493\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Skipping to next header");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9494\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9495\n");
exit_status = 2;
          }
          case_5___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;9498\n");
goto switch_break___0;
}

          case_4___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;9501\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

          }
          switch_break___0: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;9505\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;9508\n");
previous_status = status;
        printf("\nSTMT_EXEC;;9509\n");
if (!((unsigned int)logical_status == 0U))
        {
          printf("\nSTMT_EXEC;;9511\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;9517\n");
records_skipped = records_read - 1L;
      printf("\nSTMT_EXEC;;9518\n");
tmp___3 = xmalloc(record_size);
      printf("\nSTMT_EXEC;;9519\n");
new_record = (union block *)tmp___3;
    }
    printf("\nSTMT_EXEC;;9521\n");
if ((unsigned int)logical_status == 1U)
    {
      printf("\nSTMT_EXEC;;9523\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;9527\n");
if ((unsigned int)logical_status == 2U)
      {
      _L___3: /* CIL Label */
        {
printf("\nSTMT_EXEC;;9530\n");
write_archive_to_stdout = (_Bool)0;
}

        printf("\nSTMT_EXEC;;9531\n");
new_blocks = (int)(current_block - record_start);
        printf("\nSTMT_EXEC;;9532\n");
if (new_blocks)
        {
          {
            printf("\nSTMT_EXEC;;9535\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)new_record, (void const * /* __restrict  */)record_start, (size_t)(new_blocks * 512));printf("\nFUNC_RETURN;;\n");

          }
        }
        printf("\nSTMT_EXEC;;9538\n");
if ((unsigned int)logical_status == 1U)
        {
          printf("\nSTMT_EXEC;;9540\n");
logical_status = (enum read_header)0;
          printf("\nSTMT_EXEC;;9541\n");
goto flush_file;
        }
        {
          printf("\nSTMT_EXEC;;9544\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;9547\n");
if ((unsigned long)current_block == (unsigned long)record_end)
            {
              {
                printf("\nSTMT_EXEC;;9550\n");
flush_archive();
              }
            }
            {
              printf("\nSTMT_EXEC;;9554\n");
status___0 = read_header((_Bool)0);
              printf("\nSTMT_EXEC;;9555\n");
xheader_decode(&current_stat_info);
            }
            printf("\nSTMT_EXEC;;9557\n");
if ((unsigned int)status___0 == 3U)
            {
              printf("\nSTMT_EXEC;;9559\n");
if (ignore_zeros_option)
              {
                {
                  printf("\nSTMT_EXEC;;9562\n");
set_next_block_after(current_header);
                }
                printf("\nSTMT_EXEC;;9564\n");
goto while_continue___0;
              }
            }
            printf("\nSTMT_EXEC;;9567\n");
if ((unsigned int)status___0 == 4U)
            {
              printf("\nSTMT_EXEC;;9569\n");
logical_status = (enum read_header)4;
              printf("\nSTMT_EXEC;;9570\n");
goto while_break___0;
            }
            else
            {
              printf("\nSTMT_EXEC;;9574\n");
if ((unsigned int)status___0 == 3U)
              {
                printf("\nSTMT_EXEC;;9576\n");
logical_status = (enum read_header)4;
                printf("\nSTMT_EXEC;;9577\n");
goto while_break___0;
              }
            }
            printf("\nSTMT_EXEC;;9580\n");
if ((unsigned int)status___0 == 5U)
            {
              {
                printf("\nSTMT_EXEC;;9583\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Deleting non-header from archive");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;9584\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;9585\n");
exit_status = 2;
                printf("\nSTMT_EXEC;;9586\n");
set_next_block_after(current_header);
              }
              printf("\nSTMT_EXEC;;9588\n");
goto while_continue___0;
            }
            {
              printf("\nSTMT_EXEC;;9591\n");
name = name_scan((char const *)current_stat_info.file_name);
            }
            printf("\nSTMT_EXEC;;9593\n");
if ((unsigned long)name != (unsigned long)((void *)0))
            {
              printf("\nSTMT_EXEC;;9595\n");
(name->found_count)++;
              printf("\nSTMT_EXEC;;9596\n");
if (occurrence_option == 0UL)
              {
                printf("\nSTMT_EXEC;;9598\n");
tmp___7 = name->found_count;
              }
              else
              {
                printf("\nSTMT_EXEC;;9602\n");
tmp___7 = (uintmax_t)(name->found_count == occurrence_option);
              }
              printf("\nSTMT_EXEC;;9604\n");
if (tmp___7)
              {
              flush_file:
              {
                printf("\nSTMT_EXEC;;9608\n");
set_next_block_after(current_header);
                printf("\nSTMT_EXEC;;9609\n");
blocks_to_skip = ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
              }
                {
                  printf("\nSTMT_EXEC;;9612\n");
while (1)
                  {
                  while_continue___1: /* CIL Label */;
                    printf("\nSTMT_EXEC;;9615\n");
if (!(record_end - current_block <= blocks_to_skip))
                    {
                      printf("\nSTMT_EXEC;;9617\n");
goto while_break___1;
                    }
                    {
                      printf("\nSTMT_EXEC;;9620\n");
blocks_to_skip -= record_end - current_block;
                      printf("\nSTMT_EXEC;;9621\n");
flush_archive();
                    }
                  }
                while_break___1: /* CIL Label */;
                }
                printf("\nSTMT_EXEC;;9626\n");
current_block += blocks_to_skip;
                printf("\nSTMT_EXEC;;9627\n");
blocks_to_skip = (off_t)0;
                printf("\nSTMT_EXEC;;9628\n");
goto while_continue___0;
              }
            }
            printf("\nSTMT_EXEC;;9631\n");
if (extended_header.size)
            {
              {
                printf("\nSTMT_EXEC;;9634\n");
write_recent_bytes(extended_header.buffer, extended_header.size);
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;9640\n");
write_recent_blocks(recent_long_name, recent_long_name_blocks);
                printf("\nSTMT_EXEC;;9641\n");
write_recent_blocks(recent_long_link, recent_long_link_blocks);
              }
            }
            {
              printf("\nSTMT_EXEC;;9645\n");
*(new_record + new_blocks) = *current_header;
              printf("\nSTMT_EXEC;;9646\n");
new_blocks++;
              printf("\nSTMT_EXEC;;9647\n");
blocks_to_keep = ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
              printf("\nSTMT_EXEC;;9648\n");
set_next_block_after(current_header);
            }
            printf("\nSTMT_EXEC;;9650\n");
if (new_blocks == blocking_factor)
            {
              {
                printf("\nSTMT_EXEC;;9653\n");
write_record(1);
              }
            }
            printf("\nSTMT_EXEC;;9656\n");
kept_blocks_in_record = (int)(record_end - current_block);
            printf("\nSTMT_EXEC;;9657\n");
if ((off_t)kept_blocks_in_record > blocks_to_keep)
            {
              printf("\nSTMT_EXEC;;9659\n");
kept_blocks_in_record = (int)blocks_to_keep;
            }
            {
              printf("\nSTMT_EXEC;;9662\n");
while (1)
              {
              while_continue___2: /* CIL Label */;
                printf("\nSTMT_EXEC;;9665\n");
if (!blocks_to_keep)
                {
                  printf("\nSTMT_EXEC;;9667\n");
goto while_break___2;
                }
                printf("\nSTMT_EXEC;;9669\n");
if ((unsigned long)current_block == (unsigned long)record_end)
                {
                  {
                    printf("\nSTMT_EXEC;;9672\n");
flush_read();
                    printf("\nSTMT_EXEC;;9673\n");
current_block = record_start;
                    printf("\nSTMT_EXEC;;9674\n");
kept_blocks_in_record = blocking_factor;
                  }
                  printf("\nSTMT_EXEC;;9676\n");
if ((off_t)kept_blocks_in_record > blocks_to_keep)
                  {
                    printf("\nSTMT_EXEC;;9678\n");
kept_blocks_in_record = (int)blocks_to_keep;
                  }
                }
                printf("\nSTMT_EXEC;;9681\n");
count = kept_blocks_in_record;
                printf("\nSTMT_EXEC;;9682\n");
if (blocking_factor - new_blocks < count)
                {
                  printf("\nSTMT_EXEC;;9684\n");
count = blocking_factor - new_blocks;
                }
                printf("\nSTMT_EXEC;;9686\n");
if (!count)
                {
                  {
                    printf("\nSTMT_EXEC;;9689\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

                  }
                }
                {
                  printf("\nSTMT_EXEC;;9693\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(new_record + new_blocks), (void const * /* __restrict  */)current_block, (size_t)(count * 512));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;9694\n");
new_blocks += count;
                  printf("\nSTMT_EXEC;;9695\n");
current_block += count;
                  printf("\nSTMT_EXEC;;9696\n");
blocks_to_keep -= (off_t)count;
                  printf("\nSTMT_EXEC;;9697\n");
kept_blocks_in_record -= count;
                }
                printf("\nSTMT_EXEC;;9699\n");
if (new_blocks == blocking_factor)
                {
                  {
                    printf("\nSTMT_EXEC;;9702\n");
write_record(1);
                  }
                }
              }
            while_break___2: /* CIL Label */;
            }
          }
        while_break___0: /* CIL Label */;
        }
      }
    }
    printf("\nSTMT_EXEC;;9713\n");
if ((unsigned int)logical_status == 4U)
    {
      printf("\nSTMT_EXEC;;9715\n");
total_zero_blocks = 0;
      {
        printf("\nSTMT_EXEC;;9717\n");
while (1)
        {
        while_continue___3: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;9721\n");
zero_blocks = blocking_factor - new_blocks;
            printf("\nSTMT_EXEC;;9722\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(new_record + new_blocks), 0, (size_t)(512 * zero_blocks));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9723\n");
total_zero_blocks += zero_blocks;
            printf("\nSTMT_EXEC;;9724\n");
write_record(total_zero_blocks < 2);
          }
          printf("\nSTMT_EXEC;;9726\n");
if (!(total_zero_blocks < 2))
          {
            printf("\nSTMT_EXEC;;9728\n");
goto while_break___3;
          }
        }
      while_break___3: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;9735\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)new_record);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;9737\n");
if (!acting_as_filter)
    {
      printf("\nSTMT_EXEC;;9739\n");
if (!(archive >= 1 << 30))
      {
        {
          printf("\nSTMT_EXEC;;9742\n");
tmp___5 = sys_truncate(archive);
        }
        printf("\nSTMT_EXEC;;9744\n");
if (tmp___5)
        {
          {
            printf("\nSTMT_EXEC;;9747\n");
truncate_warn(*(archive_name_array + 0));
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;9753\n");
close_archive();
      printf("\nSTMT_EXEC;;9754\n");
names_notfound();
    }
    printf("\nSTMT_EXEC;;9756\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","004.extract.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) stat)(char const *__restrict __file, struct stat *__restrict __buf);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) lstat)(char const *__restrict __file, struct stat *__restrict __buf);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) chmod)(char const *__file, __mode_t __mode);
extern __attribute__((__nothrow__)) __mode_t(__attribute__((__leaf__)) umask)(__mode_t __mask);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) mkdir)(char const *__path, __mode_t __mode);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) mknod)(char const *__path, __mode_t __mode, __dev_t __dev);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const *__path, __mode_t __mode);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) access)(char const *__name, int __type);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) chown)(char const *__file, __uid_t __owner, __gid_t __group);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) lchown)(char const *__file, __uid_t __owner, __gid_t __group);
extern __attribute__((__nothrow__)) __uid_t(__attribute__((__leaf__)) geteuid)(void);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) link)(char const *__from, char const *__to);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) symlink)(char const *__from, char const *__to);
char *base_name(char const *name);
void (*xalloc_fail_func)(void);
size_t full_write(int fd, void const *buf, size_t count);
_Bool absolute_names_option;
enum old_files old_files_option;
_Bool recursive_unlink_option;
int same_owner_option;
int same_permissions_option;
size_t strip_path_elements;
_Bool touch_option;
_Bool we_are_root;
void extr_init(void);
void extract_archive(void);
void extract_finish(void);
void gnu_restore(char const *directory_name);
char const *tartime(time_t t);
void print_for_mkdir(char *pathname, int length, mode_t mode);
void skip_file(off_t size);
void extract_mangle(void);
int remove_any_file(char const *path, enum remove_option option);
void chmod_error_details(char const *name, mode_t mode);
void chown_error_details(char const *name, uid_t uid, gid_t gid);
void link_error(char const *target, char const *source);
void mkdir_error(char const *name);
void mkfifo_error(char const *name);
void mknod_error(char const *name);
void symlink_error(char const *contents, char const *name);
void utime_error(char const *name);
void write_error_details(char const *name, size_t status, size_t size);
size_t stripped_prefix_len(char const *file_name, size_t num);
_Bool contains_dot_dot(char const *name);
_Bool sparse_member_p(struct tar_stat_info *st);
enum dump_status sparse_extract_file(int fd, struct tar_stat_info *st, off_t *size);
static mode_t newdir_umask;
static mode_t current_umask;
static struct delayed_set_stat *delayed_set_stat_head;
static struct delayed_symlink *delayed_symlink_head;
void extr_init(void)
{
  printf("\nFUNC_CALL;extr_init();\n");
printf("\nSTMT_EXEC;;9812\n");
__uid_t tmp;

  {
    {
      printf("\nSTMT_EXEC;;9816\n");
printf("\nFUNC_CALL;geteuid();\n");
tmp = geteuid();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;9817\n");
we_are_root = (_Bool)(tmp == 0U);
      printf("\nSTMT_EXEC;;9818\n");
same_permissions_option += (int)we_are_root;
      printf("\nSTMT_EXEC;;9819\n");
same_owner_option += (int)we_are_root;
      printf("\nSTMT_EXEC;;9820\n");
xalloc_fail_func = &extract_finish;
      printf("\nSTMT_EXEC;;9821\n");
printf("\nFUNC_CALL;umask(__mode_t);\n");
newdir_umask = umask((__mode_t)0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;9823\n");
if (0 < same_permissions_option)
    {
      printf("\nSTMT_EXEC;;9825\n");
current_umask = (mode_t)0;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;9830\n");
printf("\nFUNC_CALL;umask(__mode_t);\n");
umask(newdir_umask);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;9831\n");
current_umask = newdir_umask;
      }
    }
    printf("\nSTMT_EXEC;;9834\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void set_mode(char const *file_name, struct stat const *stat_info, struct stat const *cur_info, mode_t invert_permissions, enum permstatus permstatus, char typeflag)
{
  printf("\nFUNC_CALL;set_mode(const char *,const struct stat *,const struct stat *,mode_t,enum permstatus,char);\n");
printf("\nSTMT_EXEC;;9839\n");
mode_t mode;
  printf("\nSTMT_EXEC;;9840\n");
struct stat st;
  printf("\nSTMT_EXEC;;9841\n");
int tmp;
  printf("\nSTMT_EXEC;;9842\n");
int tmp___0;
  printf("\nSTMT_EXEC;;9843\n");
void *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;9846\n");
if (0 < same_permissions_option)
    {
      printf("\nSTMT_EXEC;;9848\n");
if ((unsigned int)permstatus != 2U)
      {
        printf("\nSTMT_EXEC;;9850\n");
mode = (mode_t)stat_info->st_mode;
        printf("\nSTMT_EXEC;;9851\n");
if ((unsigned int)permstatus == 1U)
        {
          printf("\nSTMT_EXEC;;9853\n");
if (!(mode & (unsigned int)(~(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))))
          {
            printf("\nSTMT_EXEC;;9855\n");
if ((int)typeflag != 53)
            {
              printf("\nSTMT_EXEC;;9857\n");
if ((int)typeflag != 68)
              {
                printf("\nSTMT_EXEC;;9859\n");
printf("\nFUNC_RETURN;;\n");
return;
              }
            }
          }
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;9867\n");
goto _L___3;
      }
    }
    else
    {
    _L___3: /* CIL Label */
      {
printf("\nSTMT_EXEC;;9873\n");
if (!invert_permissions)
      {
        printf("\nSTMT_EXEC;;9875\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
      else
      {
        printf("\nSTMT_EXEC;;9879\n");
if (!cur_info)
        {
          {
            printf("\nSTMT_EXEC;;9882\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp = stat((char const * /* __restrict  */)file_name, (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;9884\n");
if (tmp != 0)
          {
            {
              printf("\nSTMT_EXEC;;9887\n");
stat_error(file_name);
            }
            printf("\nSTMT_EXEC;;9889\n");
printf("\nFUNC_RETURN;;\n");
return;
          }
          printf("\nSTMT_EXEC;;9891\n");
cur_info = (struct stat const *)(&st);
        }
        printf("\nSTMT_EXEC;;9893\n");
mode = (mode_t)(cur_info->st_mode ^ (unsigned int const)invert_permissions);
      }
}

    }
    {
      printf("\nSTMT_EXEC;;9897\n");
printf("\nFUNC_CALL;chmod(const char *,__mode_t);\n");
tmp___0 = chmod(file_name, mode);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;9899\n");
if (tmp___0 != 0)
    {
      {
        printf("\nSTMT_EXEC;;9902\n");
chmod_error_details(file_name, mode);
      }
    }
    printf("\nSTMT_EXEC;;9905\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void check_time(char const *file_name, time_t t)
{
  printf("\nFUNC_CALL;check_time(const char *,time_t);\n");
printf("\nSTMT_EXEC;;9910\n");
time_t now;
  printf("\nSTMT_EXEC;;9911\n");
char const *tmp;
  printf("\nSTMT_EXEC;;9912\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;9913\n");
char const *tmp___1;
  printf("\nSTMT_EXEC;;9914\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;9915\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;9916\n");
char *__cil_tmp9;

  {
    printf("\nSTMT_EXEC;;9919\n");
if (t <= 0L)
    {
      {
        printf("\nSTMT_EXEC;;9922\n");
tmp = tartime(t);
        printf("\nSTMT_EXEC;;9923\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: implausibly old time stamp %s");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;9924\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, file_name, tmp);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      printf("\nSTMT_EXEC;;9929\n");
if (start_timespec.tv_sec < t)
      {
        {
          printf("\nSTMT_EXEC;;9932\n");
printf("\nFUNC_CALL;time(time_t *);\n");
now = time((time_t *)0);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;9934\n");
if (now < t)
        {
          {
            printf("\nSTMT_EXEC;;9937\n");
tmp___1 = tartime(t);
            printf("\nSTMT_EXEC;;9938\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: time stamp %s is %lu s in the future");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;9939\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, file_name, tmp___1, (unsigned long)(t - now));printf("\nFUNC_RETURN;;\n");

          }
        }
      }
    }
    printf("\nSTMT_EXEC;;9944\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void set_stat(char const *file_name, struct stat const *stat_info, struct stat const *cur_info, mode_t invert_permissions, enum permstatus permstatus, char typeflag)
{
  printf("\nFUNC_CALL;set_stat(const char *,const struct stat *,const struct stat *,mode_t,enum permstatus,char);\n");
printf("\nSTMT_EXEC;;9949\n");
struct utimbuf utimbuf;
  printf("\nSTMT_EXEC;;9950\n");
int tmp;
  printf("\nSTMT_EXEC;;9951\n");
int tmp___0;
  printf("\nSTMT_EXEC;;9952\n");
int tmp___1;

  {
    printf("\nSTMT_EXEC;;9955\n");
if ((int)typeflag != 50)
    {
      printf("\nSTMT_EXEC;;9957\n");
if (!touch_option)
      {
        printf("\nSTMT_EXEC;;9959\n");
if ((unsigned int)permstatus != 2U)
        {
          printf("\nSTMT_EXEC;;9961\n");
if (incremental_option)
          {
            printf("\nSTMT_EXEC;;9963\n");
utimbuf.actime = (__time_t)stat_info->st_atim.tv_sec;
          }
          else
          {
            printf("\nSTMT_EXEC;;9967\n");
utimbuf.actime = start_timespec.tv_sec;
          }
          {
            printf("\nSTMT_EXEC;;9970\n");
utimbuf.modtime = (__time_t)stat_info->st_mtim.tv_sec;
            printf("\nSTMT_EXEC;;9971\n");
printf("\nFUNC_CALL;utime(const char *,const struct utimbuf *);\n");
tmp = utime(file_name, (struct utimbuf const *)(&utimbuf));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;9973\n");
if (tmp < 0)
          {
            {
              printf("\nSTMT_EXEC;;9976\n");
utime_error(file_name);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;9982\n");
check_time(file_name, utimbuf.actime);
              printf("\nSTMT_EXEC;;9983\n");
check_time(file_name, utimbuf.modtime);
            }
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;9989\n");
set_mode(file_name, stat_info, cur_info, invert_permissions, permstatus, typeflag);
      }
    }
    printf("\nSTMT_EXEC;;9992\n");
if (0 < same_owner_option)
    {
      printf("\nSTMT_EXEC;;9994\n");
if ((unsigned int)permstatus != 2U)
      {
        printf("\nSTMT_EXEC;;9996\n");
if ((int)typeflag == 50)
        {
          {
            printf("\nSTMT_EXEC;;9999\n");
printf("\nFUNC_CALL;lchown(const char *,__uid_t,__gid_t);\n");
tmp___0 = lchown(file_name, (__uid_t)stat_info->st_uid, (__gid_t)stat_info->st_gid);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;10001\n");
if (tmp___0 < 0)
          {
            {
              printf("\nSTMT_EXEC;;10004\n");
chown_error_details(file_name, (uid_t)stat_info->st_uid, (gid_t)stat_info->st_gid);
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;10011\n");
printf("\nFUNC_CALL;chown(const char *,__uid_t,__gid_t);\n");
tmp___1 = chown(file_name, (__uid_t)stat_info->st_uid, (__gid_t)stat_info->st_gid);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;10013\n");
if (tmp___1 < 0)
          {
            {
              printf("\nSTMT_EXEC;;10016\n");
chown_error_details(file_name, (uid_t)stat_info->st_uid, (gid_t)stat_info->st_gid);
            }
          }
          printf("\nSTMT_EXEC;;10019\n");
if (stat_info->st_mode & 3584U)
          {
            {
              printf("\nSTMT_EXEC;;10022\n");
set_mode(file_name, stat_info, (struct stat const *)0, invert_permissions, permstatus, typeflag);
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;10028\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void delay_set_stat(char const *file_name, struct stat const *stat_info, mode_t invert_permissions, enum permstatus permstatus)
{
  printf("\nFUNC_CALL;delay_set_stat(const char *,const struct stat *,mode_t,enum permstatus);\n");
printf("\nSTMT_EXEC;;10033\n");
size_t file_name_len;
  printf("\nSTMT_EXEC;;10034\n");
size_t tmp;
  printf("\nSTMT_EXEC;;10035\n");
struct delayed_set_stat *data;
  printf("\nSTMT_EXEC;;10036\n");
void *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;10040\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10041\n");
file_name_len = tmp;
      printf("\nSTMT_EXEC;;10042\n");
tmp___0 = xmalloc(((unsigned long)(&((struct delayed_set_stat *)0)->file_name) + file_name_len) + 1UL);
      printf("\nSTMT_EXEC;;10043\n");
data = (struct delayed_set_stat *)tmp___0;
      printf("\nSTMT_EXEC;;10044\n");
data->file_name_len = file_name_len;
      printf("\nSTMT_EXEC;;10045\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(data->file_name), (char const * /* __restrict  */)file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10046\n");
data->invert_permissions = invert_permissions;
      printf("\nSTMT_EXEC;;10047\n");
data->permstatus = permstatus;
      printf("\nSTMT_EXEC;;10048\n");
data->after_symlinks = (_Bool)0;
      printf("\nSTMT_EXEC;;10049\n");
data->stat_info = (struct stat) * stat_info;
      printf("\nSTMT_EXEC;;10050\n");
data->next = delayed_set_stat_head;
      printf("\nSTMT_EXEC;;10051\n");
delayed_set_stat_head = data;
    }
    printf("\nSTMT_EXEC;;10053\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void repair_delayed_set_stat(char const *dir, struct stat const *dir_stat_info)
{
  printf("\nFUNC_CALL;repair_delayed_set_stat(const char *,const struct stat *);\n");
printf("\nSTMT_EXEC;;10058\n");
struct delayed_set_stat *data;
  printf("\nSTMT_EXEC;;10059\n");
struct stat st;
  printf("\nSTMT_EXEC;;10060\n");
int tmp;
  printf("\nSTMT_EXEC;;10061\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;10062\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;10063\n");
void *__cil_tmp8;
  printf("\nSTMT_EXEC;;10064\n");
char *__cil_tmp9;

  {
    printf("\nSTMT_EXEC;;10067\n");
data = delayed_set_stat_head;
    {
      printf("\nSTMT_EXEC;;10069\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;10072\n");
if (!data)
        {
          printf("\nSTMT_EXEC;;10074\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;10077\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp = stat((char const * /* __restrict  */)(data->file_name), (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;10079\n");
if (tmp != 0)
        {
          {
            printf("\nSTMT_EXEC;;10082\n");
stat_error((char const *)(data->file_name));
          }
          printf("\nSTMT_EXEC;;10084\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
        printf("\nSTMT_EXEC;;10086\n");
if (st.st_dev == (__dev_t)dir_stat_info->st_dev)
        {
          printf("\nSTMT_EXEC;;10088\n");
if (st.st_ino == (__ino_t)dir_stat_info->st_ino)
          {
            printf("\nSTMT_EXEC;;10090\n");
data->stat_info = current_stat_info.stat;
            printf("\nSTMT_EXEC;;10091\n");
data->invert_permissions = (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) & (current_stat_info.stat.st_mode ^ st.st_mode);
            printf("\nSTMT_EXEC;;10092\n");
data->permstatus = (enum permstatus)1;
            printf("\nSTMT_EXEC;;10093\n");
printf("\nFUNC_RETURN;;\n");
return;
          }
        }
        printf("\nSTMT_EXEC;;10096\n");
data = data->next;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;10101\n");
tmp___0 = quotearg_colon(dir);
      printf("\nSTMT_EXEC;;10102\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Unexpected inconsistency when making directory");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10103\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10104\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;10106\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int make_directories(char *file_name)
{
  printf("\nFUNC_CALL;make_directories(char *);\n");
printf("\nSTMT_EXEC;;10111\n");
char *cursor0;
  printf("\nSTMT_EXEC;;10112\n");
char *cursor;
  printf("\nSTMT_EXEC;;10113\n");
int did_something;
  printf("\nSTMT_EXEC;;10114\n");
int mode;
  printf("\nSTMT_EXEC;;10115\n");
int invert_permissions;
  printf("\nSTMT_EXEC;;10116\n");
int status;
  printf("\nSTMT_EXEC;;10117\n");
int *tmp;
  printf("\nSTMT_EXEC;;10118\n");
int tmp___0;
  printf("\nSTMT_EXEC;;10119\n");
int *tmp___1;

  {
    printf("\nSTMT_EXEC;;10122\n");
cursor0 = file_name + 0;
    printf("\nSTMT_EXEC;;10123\n");
did_something = 0;
    printf("\nSTMT_EXEC;;10124\n");
cursor = cursor0;
    {
      printf("\nSTMT_EXEC;;10126\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;10129\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;10131\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;10133\n");
if (!((int)*cursor == 47))
        {
          printf("\nSTMT_EXEC;;10135\n");
goto __Cont;
        }
        printf("\nSTMT_EXEC;;10137\n");
if ((unsigned long)cursor == (unsigned long)cursor0)
        {
          printf("\nSTMT_EXEC;;10139\n");
goto __Cont;
        }
        else
        {
          printf("\nSTMT_EXEC;;10143\n");
if ((int)*(cursor + -1) == 47)
          {
            printf("\nSTMT_EXEC;;10145\n");
goto __Cont;
          }
        }
        printf("\nSTMT_EXEC;;10148\n");
if ((int)*(cursor + -1) == 46)
        {
          printf("\nSTMT_EXEC;;10150\n");
if ((unsigned long)cursor == (unsigned long)(cursor0 + 1))
          {
            printf("\nSTMT_EXEC;;10152\n");
goto __Cont;
          }
          else
          {
            printf("\nSTMT_EXEC;;10156\n");
if ((int)*(cursor + -2) == 47)
            {
              printf("\nSTMT_EXEC;;10158\n");
goto __Cont;
            }
            else
            {
              printf("\nSTMT_EXEC;;10162\n");
if ((int)*(cursor + -2) == 46)
              {
                printf("\nSTMT_EXEC;;10164\n");
if ((unsigned long)cursor == (unsigned long)(cursor0 + 2))
                {
                  printf("\nSTMT_EXEC;;10166\n");
goto __Cont;
                }
                else
                {
                  printf("\nSTMT_EXEC;;10170\n");
if ((int)*(cursor + -3) == 47)
                  {
                    printf("\nSTMT_EXEC;;10172\n");
goto __Cont;
                  }
                }
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;10179\n");
*cursor = (char)'\000';
        printf("\nSTMT_EXEC;;10180\n");
mode = (int)((unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) & ~newdir_umask);
        printf("\nSTMT_EXEC;;10181\n");
if (we_are_root)
        {
          printf("\nSTMT_EXEC;;10183\n");
invert_permissions = 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;10187\n");
invert_permissions = 192 & ~mode;
        }
        {
          printf("\nSTMT_EXEC;;10190\n");
printf("\nFUNC_CALL;mkdir(const char *,__mode_t);\n");
status = mkdir((char const *)file_name, (__mode_t)(mode ^ invert_permissions));printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;10192\n");
if (status == 0)
        {
          {
            printf("\nSTMT_EXEC;;10195\n");
delay_set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (mode_t)invert_permissions, (enum permstatus)2);
            printf("\nSTMT_EXEC;;10196\n");
print_for_mkdir(file_name, (int)(cursor - file_name), (mode_t)mode);
            printf("\nSTMT_EXEC;;10197\n");
did_something = 1;
            printf("\nSTMT_EXEC;;10198\n");
*cursor = (char)'/';
          }
          printf("\nSTMT_EXEC;;10200\n");
goto __Cont;
        }
        {
          printf("\nSTMT_EXEC;;10203\n");
*cursor = (char)'/';
          printf("\nSTMT_EXEC;;10204\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;10206\n");
if (*tmp___1 == 17)
        {
          printf("\nSTMT_EXEC;;10208\n");
goto __Cont;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;10213\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;10215\n");
if (*tmp == 38)
          {
            printf("\nSTMT_EXEC;;10217\n");
goto _L___3;
          }
          else
          {
            printf("\nSTMT_EXEC;;10221\n");
if (0)
            {
            _L___3: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;10225\n");
printf("\nFUNC_CALL;access(const char *,int);\n");
tmp___0 = access((char const *)file_name, 2);printf("\nFUNC_RETURN;;\n");

            }
              printf("\nSTMT_EXEC;;10227\n");
if (tmp___0 == 0)
              {
                printf("\nSTMT_EXEC;;10229\n");
goto __Cont;
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;10234\n");
goto while_break;
      __Cont:
        {
printf("\nSTMT_EXEC;;10236\n");
cursor++;
}

      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;10240\n");
printf("\nFUNC_RETURN;;\n");
return (did_something);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool file_newer_p(char const *file_name, struct tar_stat_info *tar_stat)
{
  printf("\nFUNC_CALL;file_newer_p(const char *,struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;10245\n");
struct stat st;
  printf("\nSTMT_EXEC;;10246\n");
int tmp;
  printf("\nSTMT_EXEC;;10247\n");
void *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;10251\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp = stat((char const * /* __restrict  */)file_name, (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;10253\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;10256\n");
stat_warn(file_name);
      }
      printf("\nSTMT_EXEC;;10258\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    printf("\nSTMT_EXEC;;10260\n");
if (!((st.st_mode & 61440U) == 16384U))
    {
      printf("\nSTMT_EXEC;;10262\n");
if (st.st_mtim.tv_sec >= tar_stat->stat.st_mtim.tv_sec)
      {
        printf("\nSTMT_EXEC;;10264\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
      }
    }
    printf("\nSTMT_EXEC;;10267\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static int prepare_to_extract(char const *file_name)
{
  printf("\nFUNC_CALL;prepare_to_extract(const char *);\n");
printf("\nSTMT_EXEC;;10272\n");
int tmp;
  printf("\nSTMT_EXEC;;10273\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;10274\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;10275\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;10276\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;10277\n");
char *__cil_tmp7;

  {
    printf("\nSTMT_EXEC;;10280\n");
if (to_stdout_option)
    {
      printf("\nSTMT_EXEC;;10282\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;10285\n");
if ((unsigned int)old_files_option == 3U)
      {
        printf("\nSTMT_EXEC;;10287\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;10289\n");
if ((unsigned int)old_files_option == 5U)
      {
        printf("\nSTMT_EXEC;;10291\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;10293\n");
goto switch_default;
    case_3: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10296\n");
tmp = remove_any_file(file_name, (enum remove_option)recursive_unlink_option);
    }
      printf("\nSTMT_EXEC;;10298\n");
if (!tmp)
      {
        {
          printf("\nSTMT_EXEC;;10301\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;10303\n");
if (*tmp___0)
        {
          {
            printf("\nSTMT_EXEC;;10306\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;10308\n");
if (*tmp___1 != 2)
          {
            {
              printf("\nSTMT_EXEC;;10311\n");
unlink_error(file_name);
            }
            printf("\nSTMT_EXEC;;10313\n");
printf("\nFUNC_RETURN;;\n");
return (0);
          }
        }
      }
      printf("\nSTMT_EXEC;;10317\n");
goto switch_break;
    case_5: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10320\n");
tmp___3 = file_newer_p(file_name, &current_stat_info);
    }
      printf("\nSTMT_EXEC;;10322\n");
if (tmp___3)
      {
        {
          printf("\nSTMT_EXEC;;10325\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Current `%s\' is newer");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;10326\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, file_name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;10328\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
      printf("\nSTMT_EXEC;;10330\n");
goto switch_break;
    switch_default: /* CIL Label */
      {
printf("\nSTMT_EXEC;;10332\n");
goto switch_break;
}

    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;10335\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static int maybe_recoverable(char *file_name, int *interdir_made)
{
  printf("\nFUNC_CALL;maybe_recoverable(char *,int *);\n");
printf("\nSTMT_EXEC;;10340\n");
int e;
  printf("\nSTMT_EXEC;;10341\n");
int *tmp;
  printf("\nSTMT_EXEC;;10342\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;10343\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;10344\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;10345\n");
int r;
  printf("\nSTMT_EXEC;;10346\n");
int tmp___3;
  printf("\nSTMT_EXEC;;10347\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;10348\n");
int *tmp___5;
  printf("\nSTMT_EXEC;;10349\n");
int tmp___6;

  {
    {
      printf("\nSTMT_EXEC;;10353\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10354\n");
e = *tmp;
    }
    printf("\nSTMT_EXEC;;10356\n");
if (*interdir_made)
    {
      printf("\nSTMT_EXEC;;10358\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;10361\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

    }
    {
      printf("\nSTMT_EXEC;;10364\n");
if (*tmp___0 == 17)
      {
        printf("\nSTMT_EXEC;;10366\n");
goto case_17;
      }
      printf("\nSTMT_EXEC;;10368\n");
if (*tmp___0 == 2)
      {
        printf("\nSTMT_EXEC;;10370\n");
goto case_2___0;
      }
      printf("\nSTMT_EXEC;;10372\n");
goto switch_default;
    case_17: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10375\n");
if ((unsigned int)old_files_option == 4U)
      {
        printf("\nSTMT_EXEC;;10377\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;10379\n");
if ((unsigned int)old_files_option == 5U)
      {
        printf("\nSTMT_EXEC;;10381\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;10383\n");
if ((unsigned int)old_files_option == 0U)
      {
        printf("\nSTMT_EXEC;;10385\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;10387\n");
if ((unsigned int)old_files_option == 1U)
      {
        printf("\nSTMT_EXEC;;10389\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;10391\n");
if ((unsigned int)old_files_option == 2U)
      {
        printf("\nSTMT_EXEC;;10393\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;10395\n");
if ((unsigned int)old_files_option == 3U)
      {
        printf("\nSTMT_EXEC;;10397\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;10399\n");
goto switch_break___0;
    case_4: /* CIL Label */
      {
printf("\nSTMT_EXEC;;10401\n");
printf("\nFUNC_RETURN;;\n");
return (0);
}

    case_5: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10404\n");
tmp___2 = file_newer_p((char const *)file_name, &current_stat_info);
    }
      printf("\nSTMT_EXEC;;10406\n");
if (tmp___2)
      {
        {
          printf("\nSTMT_EXEC;;10409\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;10410\n");
*tmp___1 = e;
        }
        printf("\nSTMT_EXEC;;10412\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
    case_0: /* CIL Label */
    case_1: /* CIL Label */
    case_2: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10418\n");
tmp___3 = remove_any_file((char const *)file_name, (enum remove_option)0);
      printf("\nSTMT_EXEC;;10419\n");
r = tmp___3;
      printf("\nSTMT_EXEC;;10420\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10421\n");
*tmp___4 = 17;
    }
      printf("\nSTMT_EXEC;;10423\n");
printf("\nFUNC_RETURN;;\n");
return (r);
    case_3: /* CIL Label */
      {
printf("\nSTMT_EXEC;;10425\n");
goto switch_break___0;
}

    switch_break___0: /* CIL Label */;
    }
    case_2___0: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;10430\n");
tmp___6 = make_directories(file_name);
    }
      printf("\nSTMT_EXEC;;10432\n");
if (!tmp___6)
      {
        {
          printf("\nSTMT_EXEC;;10435\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___5 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;10436\n");
*tmp___5 = 2;
        }
        printf("\nSTMT_EXEC;;10438\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
      printf("\nSTMT_EXEC;;10440\n");
*interdir_made = 1;
      printf("\nSTMT_EXEC;;10441\n");
printf("\nFUNC_RETURN;;\n");
return (1);
    switch_default: /* CIL Label */
      {
printf("\nSTMT_EXEC;;10443\n");
printf("\nFUNC_RETURN;;\n");
return (0);
}

    switch_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static void apply_nonancestor_delayed_set_stat(char const *file_name, _Bool after_symlinks)
{
  printf("\nFUNC_CALL;apply_nonancestor_delayed_set_stat(const char *,_Bool);\n");
printf("\nSTMT_EXEC;;10450\n");
size_t file_name_len;
  printf("\nSTMT_EXEC;;10451\n");
size_t tmp;
  printf("\nSTMT_EXEC;;10452\n");
_Bool check_for_renamed_directories;
  printf("\nSTMT_EXEC;;10453\n");
struct delayed_set_stat *data;
  printf("\nSTMT_EXEC;;10454\n");
_Bool skip_this_one;
  printf("\nSTMT_EXEC;;10455\n");
struct stat st;
  printf("\nSTMT_EXEC;;10456\n");
struct stat const *cur_info;
  printf("\nSTMT_EXEC;;10457\n");
int tmp___0;
  printf("\nSTMT_EXEC;;10458\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;10459\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;10460\n");
int tmp___3;
  printf("\nSTMT_EXEC;;10461\n");
void *__cil_tmp14;
  printf("\nSTMT_EXEC;;10462\n");
char *__cil_tmp15;
  printf("\nSTMT_EXEC;;10463\n");
char *__cil_tmp16;

  {
    {
      printf("\nSTMT_EXEC;;10467\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;10468\n");
file_name_len = tmp;
      printf("\nSTMT_EXEC;;10469\n");
check_for_renamed_directories = (_Bool)0;
    }
    {
      printf("\nSTMT_EXEC;;10472\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;10475\n");
if (!delayed_set_stat_head)
        {
          printf("\nSTMT_EXEC;;10477\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;10479\n");
data = delayed_set_stat_head;
        printf("\nSTMT_EXEC;;10480\n");
skip_this_one = (_Bool)0;
        printf("\nSTMT_EXEC;;10481\n");
cur_info = (struct stat const *)0;
        printf("\nSTMT_EXEC;;10482\n");
check_for_renamed_directories = (_Bool)((int)check_for_renamed_directories | (int)data->after_symlinks);
        printf("\nSTMT_EXEC;;10483\n");
if ((int)after_symlinks < (int)data->after_symlinks)
        {
          printf("\nSTMT_EXEC;;10485\n");
goto while_break;
        }
        else
        {
          printf("\nSTMT_EXEC;;10489\n");
if (data->file_name_len < file_name_len)
          {
            printf("\nSTMT_EXEC;;10491\n");
if (*(file_name + data->file_name_len))
            {
              printf("\nSTMT_EXEC;;10493\n");
if ((int const) * (file_name + data->file_name_len) == 47)
              {
                printf("\nSTMT_EXEC;;10495\n");
goto _L___3;
              }
              else
              {
                printf("\nSTMT_EXEC;;10499\n");
if ((int const) * (file_name + (data->file_name_len - 1UL)) == 47)
                {
                _L___3: /* CIL Label */
                {
                  printf("\nSTMT_EXEC;;10503\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___0 = memcmp((void const *)file_name, (void const *)(data->file_name), data->file_name_len);printf("\nFUNC_RETURN;;\n");

                }
                  printf("\nSTMT_EXEC;;10505\n");
if (tmp___0 == 0)
                  {
                    printf("\nSTMT_EXEC;;10507\n");
goto while_break;
                  }
                }
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;10514\n");
if (check_for_renamed_directories)
        {
          {
            printf("\nSTMT_EXEC;;10517\n");
cur_info = (struct stat const *)(&st);
            printf("\nSTMT_EXEC;;10518\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___3 = stat((char const * /* __restrict  */)(data->file_name), (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;10520\n");
if (tmp___3 != 0)
          {
            {
              printf("\nSTMT_EXEC;;10523\n");
stat_error((char const *)(data->file_name));
              printf("\nSTMT_EXEC;;10524\n");
skip_this_one = (_Bool)1;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;10529\n");
if (st.st_dev == data->stat_info.st_dev)
            {
              printf("\nSTMT_EXEC;;10531\n");
if (!(st.st_ino == data->stat_info.st_ino))
              {
                {
                  printf("\nSTMT_EXEC;;10534\n");
tmp___1 = quotearg_colon((char const *)(data->file_name));
                  printf("\nSTMT_EXEC;;10535\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Directory renamed before its status "
                                    "could be extracted");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;10537\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, tmp___1);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;10538\n");
exit_status = 2;
                  printf("\nSTMT_EXEC;;10539\n");
skip_this_one = (_Bool)1;
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;10546\n");
tmp___1 = quotearg_colon((char const *)(data->file_name));
                printf("\nSTMT_EXEC;;10547\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Directory renamed before its status "
                                  "could be extracted");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;10549\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, tmp___1);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;10550\n");
exit_status = 2;
                printf("\nSTMT_EXEC;;10551\n");
skip_this_one = (_Bool)1;
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;10556\n");
if (!skip_this_one)
        {
          {
            printf("\nSTMT_EXEC;;10559\n");
set_stat((char const *)(data->file_name), (struct stat const *)(&data->stat_info), cur_info, data->invert_permissions, data->permstatus, (char)'5');
          }
        }
        {
          printf("\nSTMT_EXEC;;10563\n");
delayed_set_stat_head = data->next;
          printf("\nSTMT_EXEC;;10564\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)data);printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;10569\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int conttype_diagnosed;
void extract_archive(void)
{
  printf("\nFUNC_CALL;extract_archive();\n");
printf("\nSTMT_EXEC;;10575\n");
union block *data_block;
  printf("\nSTMT_EXEC;;10576\n");
int fd;
  printf("\nSTMT_EXEC;;10577\n");
int status;
  printf("\nSTMT_EXEC;;10578\n");
size_t count;
  printf("\nSTMT_EXEC;;10579\n");
size_t written;
  printf("\nSTMT_EXEC;;10580\n");
int openflag;
  printf("\nSTMT_EXEC;;10581\n");
mode_t mode;
  printf("\nSTMT_EXEC;;10582\n");
off_t size;
  printf("\nSTMT_EXEC;;10583\n");
int interdir_made;
  printf("\nSTMT_EXEC;;10584\n");
char typeflag;
  printf("\nSTMT_EXEC;;10585\n");
char *file_name;
  printf("\nSTMT_EXEC;;10586\n");
int tmp;
  printf("\nSTMT_EXEC;;10587\n");
size_t prefix_len;
  printf("\nSTMT_EXEC;;10588\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;10589\n");
int e;
  printf("\nSTMT_EXEC;;10590\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;10591\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;10592\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;10593\n");
_Bool tmp___4;
  printf("\nSTMT_EXEC;;10594\n");
_Bool tmp___5;
  printf("\nSTMT_EXEC;;10595\n");
int tmp___6;
  printf("\nSTMT_EXEC;;10596\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;10597\n");
int tmp___8;
  printf("\nSTMT_EXEC;;10598\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;10599\n");
int *tmp___10;
  printf("\nSTMT_EXEC;;10600\n");
int tmp___11;
  printf("\nSTMT_EXEC;;10601\n");
int tmp___12;
  printf("\nSTMT_EXEC;;10602\n");
struct stat st;
  printf("\nSTMT_EXEC;;10603\n");
int tmp___13;
  printf("\nSTMT_EXEC;;10604\n");
struct delayed_set_stat *h;
  printf("\nSTMT_EXEC;;10605\n");
struct delayed_symlink *p;
  printf("\nSTMT_EXEC;;10606\n");
size_t tmp___14;
  printf("\nSTMT_EXEC;;10607\n");
void *tmp___15;
  printf("\nSTMT_EXEC;;10608\n");
size_t tmp___16;
  printf("\nSTMT_EXEC;;10609\n");
void *tmp___17;
  printf("\nSTMT_EXEC;;10610\n");
int tmp___18;
  printf("\nSTMT_EXEC;;10611\n");
int tmp___19;
  printf("\nSTMT_EXEC;;10612\n");
char *tmp___20;
  printf("\nSTMT_EXEC;;10613\n");
int tmp___21;
  printf("\nSTMT_EXEC;;10614\n");
int tmp___22;
  printf("\nSTMT_EXEC;;10615\n");
_Bool tmp___23;
  printf("\nSTMT_EXEC;;10616\n");
int tmp___24;
  printf("\nSTMT_EXEC;;10617\n");
char const *link_name;
  printf("\nSTMT_EXEC;;10618\n");
char *tmp___25;
  printf("\nSTMT_EXEC;;10619\n");
struct stat st1;
  printf("\nSTMT_EXEC;;10620\n");
struct stat st2;
  printf("\nSTMT_EXEC;;10621\n");
int e___0;
  printf("\nSTMT_EXEC;;10622\n");
struct delayed_symlink *ds;
  printf("\nSTMT_EXEC;;10623\n");
struct string_list *p___0;
  printf("\nSTMT_EXEC;;10624\n");
size_t tmp___26;
  printf("\nSTMT_EXEC;;10625\n");
void *tmp___27;
  printf("\nSTMT_EXEC;;10626\n");
int tmp___28;
  printf("\nSTMT_EXEC;;10627\n");
int tmp___29;
  printf("\nSTMT_EXEC;;10628\n");
int *tmp___30;
  printf("\nSTMT_EXEC;;10629\n");
int *tmp___31;
  printf("\nSTMT_EXEC;;10630\n");
int tmp___32;
  printf("\nSTMT_EXEC;;10631\n");
int tmp___33;
  printf("\nSTMT_EXEC;;10632\n");
int tmp___34;
  printf("\nSTMT_EXEC;;10633\n");
int tmp___35;
  printf("\nSTMT_EXEC;;10634\n");
int tmp___36;
  printf("\nSTMT_EXEC;;10635\n");
int tmp___37;
  printf("\nSTMT_EXEC;;10636\n");
struct stat st___0;
  printf("\nSTMT_EXEC;;10637\n");
int tmp___38;
  printf("\nSTMT_EXEC;;10638\n");
int *tmp___39;
  printf("\nSTMT_EXEC;;10639\n");
int *tmp___40;
  printf("\nSTMT_EXEC;;10640\n");
int tmp___41;
  printf("\nSTMT_EXEC;;10641\n");
int *tmp___42;
  printf("\nSTMT_EXEC;;10642\n");
char const *tmp___43;
  printf("\nSTMT_EXEC;;10643\n");
char *tmp___44;
  printf("\nSTMT_EXEC;;10644\n");
char *tmp___45;
  printf("\nSTMT_EXEC;;10645\n");
char *tmp___46;
  printf("\nSTMT_EXEC;;10646\n");
char *tmp___47;
  printf("\nSTMT_EXEC;;10647\n");
char *tmp___48;
  printf("\nSTMT_EXEC;;10648\n");
char *tmp___49;
  printf("\nSTMT_EXEC;;10649\n");
int tmp___50;
  printf("\nSTMT_EXEC;;10650\n");
int tmp___51;
  printf("\nSTMT_EXEC;;10651\n");
int tmp___52;
  printf("\nSTMT_EXEC;;10652\n");
int tmp___53;
  printf("\nSTMT_EXEC;;10653\n");
int tmp___54;
  printf("\nSTMT_EXEC;;10654\n");
void *__cil_tmp80;
  printf("\nSTMT_EXEC;;10655\n");
void *__cil_tmp81;
  printf("\nSTMT_EXEC;;10656\n");
void *__cil_tmp82;
  printf("\nSTMT_EXEC;;10657\n");
void *__cil_tmp83;
  printf("\nSTMT_EXEC;;10658\n");
char *__cil_tmp84;
  printf("\nSTMT_EXEC;;10659\n");
char *__cil_tmp85;
  printf("\nSTMT_EXEC;;10660\n");
char *__cil_tmp86;
  printf("\nSTMT_EXEC;;10661\n");
char *__cil_tmp87;
  printf("\nSTMT_EXEC;;10662\n");
char *__cil_tmp88;
  printf("\nSTMT_EXEC;;10663\n");
char *__cil_tmp89;
  printf("\nSTMT_EXEC;;10664\n");
char *__cil_tmp90;
  printf("\nSTMT_EXEC;;10665\n");
char *__cil_tmp91;

  {
    {
      printf("\nSTMT_EXEC;;10669\n");
interdir_made = 0;















      printf("\nSTMT_EXEC;;10685\n");
set_next_block_after(current_header);
      printf("\nSTMT_EXEC;;10686\n");
decode_header(current_header, &current_stat_info, &current_format, 1);
    }
    printf("\nSTMT_EXEC;;10688\n");
if (interactive_option)
    {
      {
        printf("\nSTMT_EXEC;;10691\n");
tmp = confirm("extract", (char const *)current_stat_info.file_name);
      }
      printf("\nSTMT_EXEC;;10693\n");
if (!tmp)
      {
        {
          printf("\nSTMT_EXEC;;10696\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;10698\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    printf("\nSTMT_EXEC;;10701\n");
if (verbose_option)
    {
      {
        printf("\nSTMT_EXEC;;10704\n");
print_header(&current_stat_info, (off_t)-1);
      }
    }

    {
      printf("\nSTMT_EXEC;;10709\n");
file_name = safer_name_suffix((char const *)current_stat_info.file_name, (_Bool)0);
    }
    printf("\nSTMT_EXEC;;10711\n");
if (strip_path_elements)
    {
      {
        printf("\nSTMT_EXEC;;10714\n");
tmp___0 = stripped_prefix_len((char const *)file_name, strip_path_elements);
        printf("\nSTMT_EXEC;;10715\n");
prefix_len = tmp___0;
      }
      printf("\nSTMT_EXEC;;10717\n");
if (prefix_len == 0xffffffffffffffffUL)
      {
        {
          printf("\nSTMT_EXEC;;10720\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;10722\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
      printf("\nSTMT_EXEC;;10724\n");
file_name += prefix_len;
    }
    {
      printf("\nSTMT_EXEC;;10727\n");
apply_nonancestor_delayed_set_stat((char const *)file_name, (_Bool)0);
    }
    printf("\nSTMT_EXEC;;10729\n");
if (backup_option)
    {
      printf("\nSTMT_EXEC;;10731\n");
if (!to_stdout_option)
      {
        {
          printf("\nSTMT_EXEC;;10734\n");
tmp___4 = maybe_backup_file((char const *)file_name, 0);
        }
        printf("\nSTMT_EXEC;;10736\n");
if (!tmp___4)
        {
          {
            printf("\nSTMT_EXEC;;10739\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;10740\n");
e = *tmp___1;
            printf("\nSTMT_EXEC;;10741\n");
tmp___2 = quotearg_colon((char const *)file_name);
            printf("\nSTMT_EXEC;;10742\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("%s: Was unable to backup this file");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;10743\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;10744\n");
exit_status = 2;
            printf("\nSTMT_EXEC;;10745\n");
skip_member();
          }
          printf("\nSTMT_EXEC;;10747\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;10752\n");
tmp___5 = sparse_member_p(&current_stat_info);
    }
    printf("\nSTMT_EXEC;;10754\n");
if (tmp___5)
    {
      printf("\nSTMT_EXEC;;10756\n");
tmp___50 = 'S';
    }
    else
    {
      printf("\nSTMT_EXEC;;10760\n");
tmp___50 = (int)current_header->header.typeflag;
    }
    printf("\nSTMT_EXEC;;10762\n");
typeflag = (char)tmp___50;
    {
      printf("\nSTMT_EXEC;;10764\n");
if ((int)typeflag == 83)
      {
        printf("\nSTMT_EXEC;;10766\n");
goto case_83;
      }
      printf("\nSTMT_EXEC;;10768\n");
if ((int)typeflag == 0)
      {
        printf("\nSTMT_EXEC;;10770\n");
goto case_83;
      }
      printf("\nSTMT_EXEC;;10772\n");
if ((int)typeflag == 48)
      {
        printf("\nSTMT_EXEC;;10774\n");
goto case_83;
      }
      printf("\nSTMT_EXEC;;10776\n");
if ((int)typeflag == 55)
      {
        printf("\nSTMT_EXEC;;10778\n");
goto case_83;
      }
      printf("\nSTMT_EXEC;;10780\n");
if ((int)typeflag == 50)
      {
        printf("\nSTMT_EXEC;;10782\n");
goto case_50;
      }
      printf("\nSTMT_EXEC;;10784\n");
if ((int)typeflag == 49)
      {
        printf("\nSTMT_EXEC;;10786\n");
goto case_49;
      }
      printf("\nSTMT_EXEC;;10788\n");
if ((int)typeflag == 51)
      {
        printf("\nSTMT_EXEC;;10790\n");
goto case_51;
      }
      printf("\nSTMT_EXEC;;10792\n");
if ((int)typeflag == 52)
      {
        printf("\nSTMT_EXEC;;10794\n");
goto case_52;
      }
      printf("\nSTMT_EXEC;;10796\n");
if ((int)typeflag == 54)
      {
        printf("\nSTMT_EXEC;;10798\n");
goto case_54;
      }
      printf("\nSTMT_EXEC;;10800\n");
if ((int)typeflag == 53)
      {
        printf("\nSTMT_EXEC;;10802\n");
goto really_dir;
      }
      printf("\nSTMT_EXEC;;10804\n");
if ((int)typeflag == 68)
      {
        printf("\nSTMT_EXEC;;10806\n");
goto really_dir;
      }
      printf("\nSTMT_EXEC;;10808\n");
if ((int)typeflag == 86)
      {
        printf("\nSTMT_EXEC;;10810\n");
goto case_86;
      }
      printf("\nSTMT_EXEC;;10812\n");
if ((int)typeflag == 78)
      {
        printf("\nSTMT_EXEC;;10814\n");
goto case_78;
      }
      printf("\nSTMT_EXEC;;10816\n");
if ((int)typeflag == 77)
      {
        printf("\nSTMT_EXEC;;10818\n");
goto case_77;
      }
      printf("\nSTMT_EXEC;;10820\n");
if ((int)typeflag == 76)
      {
        printf("\nSTMT_EXEC;;10822\n");
goto case_76;
      }
      printf("\nSTMT_EXEC;;10824\n");
if ((int)typeflag == 75)
      {
        printf("\nSTMT_EXEC;;10826\n");
goto case_76;
      }
      printf("\nSTMT_EXEC;;10828\n");
goto switch_default;
    case_83: /* CIL Label */
    case_0:  /* CIL Label */
    case_48: /* CIL Label */
    case_55: /* CIL Label */
      {
printf("\nSTMT_EXEC;;10833\n");
if (current_stat_info.had_trailing_slash)
      {
        printf("\nSTMT_EXEC;;10835\n");
goto really_dir;
      }
}

    again_file:
      {
printf("\nSTMT_EXEC;;10838\n");
if ((unsigned int)old_files_option == 2U)
      {
        printf("\nSTMT_EXEC;;10840\n");
tmp___51 = 512;
      }
      else
      {
        printf("\nSTMT_EXEC;;10844\n");
tmp___51 = 128;
      }
}

      printf("\nSTMT_EXEC;;10846\n");
openflag = 65 | tmp___51;
      printf("\nSTMT_EXEC;;10847\n");
mode = (current_stat_info.stat.st_mode & (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & ~current_umask;
      printf("\nSTMT_EXEC;;10848\n");
if (to_stdout_option)
      {
        printf("\nSTMT_EXEC;;10850\n");
fd = 1;
        printf("\nSTMT_EXEC;;10851\n");
goto extract_file;
      }
      {
        printf("\nSTMT_EXEC;;10854\n");
tmp___6 = prepare_to_extract((char const *)file_name);
      }
      printf("\nSTMT_EXEC;;10856\n");
if (!tmp___6)
      {
        {
          printf("\nSTMT_EXEC;;10859\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;10861\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;10864\n");
undo_last_backup();
          }
        }
        printf("\nSTMT_EXEC;;10867\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;10869\n");
if ((int)typeflag == 55)
      {
        printf("\nSTMT_EXEC;;10871\n");
if (!conttype_diagnosed)
        {
          {
            printf("\nSTMT_EXEC;;10874\n");
conttype_diagnosed = 1;
            printf("\nSTMT_EXEC;;10875\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("Extracting contiguous files as regular files");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;10876\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___7);printf("\nFUNC_RETURN;;\n");

          }
        }
      }
      {
        printf("\nSTMT_EXEC;;10881\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
fd = open((char const *)file_name, openflag, mode);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;10883\n");
if (fd < 0)
      {
        {
          printf("\nSTMT_EXEC;;10886\n");
tmp___8 = maybe_recoverable(file_name, &interdir_made);
        }
        printf("\nSTMT_EXEC;;10888\n");
if (tmp___8)
        {
          printf("\nSTMT_EXEC;;10890\n");
goto again_file;
        }
        {
          printf("\nSTMT_EXEC;;10893\n");
open_error((char const *)file_name);
          printf("\nSTMT_EXEC;;10894\n");
skip_member();
        }
        printf("\nSTMT_EXEC;;10896\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;10899\n");
undo_last_backup();
          }
        }
        printf("\nSTMT_EXEC;;10902\n");
goto switch_break;
      }
    extract_file:
      {
printf("\nSTMT_EXEC;;10905\n");
if (current_stat_info.is_sparse)
      {
        {
          printf("\nSTMT_EXEC;;10908\n");
sparse_extract_file(fd, &current_stat_info, &size);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;10913\n");
size = current_stat_info.stat.st_size;
        {
          printf("\nSTMT_EXEC;;10915\n");
while (1)
          {
          while_continue: /* CIL Label */;
            printf("\nSTMT_EXEC;;10918\n");
if (!(size > 0L))
            {
              printf("\nSTMT_EXEC;;10920\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;10922\n");
if (multi_volume_option)
            {
              {
                printf("\nSTMT_EXEC;;10925\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
                printf("\nSTMT_EXEC;;10926\n");
save_totsize = current_stat_info.stat.st_size;
                printf("\nSTMT_EXEC;;10927\n");
save_sizeleft = size;
              }
            }

            {
              printf("\nSTMT_EXEC;;10932\n");
data_block = find_next_block();
            }
            printf("\nSTMT_EXEC;;10934\n");
if (!data_block)
            {
              {
                printf("\nSTMT_EXEC;;10937\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;10938\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;10939\n");
exit_status = 2;
              }
              printf("\nSTMT_EXEC;;10941\n");
goto while_break;
            }
            {
              printf("\nSTMT_EXEC;;10944\n");
written = available_space_after(data_block);
            }
            printf("\nSTMT_EXEC;;10946\n");
if (written > (size_t)size)
            {
              printf("\nSTMT_EXEC;;10948\n");
written = (size_t)size;
            }
            {
              printf("\nSTMT_EXEC;;10951\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___10 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;10952\n");
*tmp___10 = 0;
              printf("\nSTMT_EXEC;;10953\n");
count = full_write(fd, (void const *)(data_block->buffer), written);
              printf("\nSTMT_EXEC;;10954\n");
size = (off_t)((size_t)size - count);
              printf("\nSTMT_EXEC;;10955\n");
set_next_block_after((union block *)((data_block->buffer + written) - 1));
            }
            printf("\nSTMT_EXEC;;10957\n");
if (count != written)
            {
              {
                printf("\nSTMT_EXEC;;10960\n");
write_error_details((char const *)file_name, count, written);
              }
              printf("\nSTMT_EXEC;;10962\n");
goto while_break;
            }
          }
        while_break: /* CIL Label */;
        }
      }
}

      {
        printf("\nSTMT_EXEC;;10969\n");
skip_file(size);
      }
      printf("\nSTMT_EXEC;;10971\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;10974\n");
assign_string(&save_name, (char const *)0);
        }
      }
      printf("\nSTMT_EXEC;;10977\n");
if (to_stdout_option)
      {
        printf("\nSTMT_EXEC;;10979\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;10982\n");
printf("\nFUNC_CALL;close(int);\n");
status = close(fd);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;10984\n");
if (status < 0)
      {
        {
          printf("\nSTMT_EXEC;;10987\n");
close_error((char const *)file_name);
        }
        printf("\nSTMT_EXEC;;10989\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;10992\n");
undo_last_backup();
          }
        }
      }
      printf("\nSTMT_EXEC;;10996\n");
if ((unsigned int)old_files_option == 2U)
      {
        printf("\nSTMT_EXEC;;10998\n");
tmp___52 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;11002\n");
tmp___52 = 1;
      }
      {
        printf("\nSTMT_EXEC;;11005\n");
set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (struct stat const *)0, (mode_t)0, (enum permstatus)tmp___52, typeflag);
      }
      printf("\nSTMT_EXEC;;11007\n");
goto switch_break;
    case_50: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11010\n");
tmp___11 = prepare_to_extract((char const *)file_name);
    }
      printf("\nSTMT_EXEC;;11012\n");
if (!tmp___11)
      {
        printf("\nSTMT_EXEC;;11014\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;11016\n");
if (absolute_names_option)
      {
        printf("\nSTMT_EXEC;;11018\n");
goto _L;
      }
      else
      {
        printf("\nSTMT_EXEC;;11022\n");
if ((int)*(current_stat_info.link_name + 0) == 47)
        {
          printf("\nSTMT_EXEC;;11024\n");
goto _L___0;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;11029\n");
tmp___23 = contains_dot_dot((char const *)current_stat_info.link_name);
          }
          printf("\nSTMT_EXEC;;11031\n");
if (tmp___23)
          {
          _L___0:
          {
            printf("\nSTMT_EXEC;;11035\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              {
                printf("\nSTMT_EXEC;;11039\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
fd = open((char const *)file_name, 193, 0);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;11041\n");
if (!(fd < 0))
              {
                printf("\nSTMT_EXEC;;11043\n");
goto while_break___0;
              }
              {
                printf("\nSTMT_EXEC;;11046\n");
tmp___13 = maybe_recoverable(file_name, &interdir_made);
              }
              printf("\nSTMT_EXEC;;11048\n");
if (!tmp___13)
              {
                printf("\nSTMT_EXEC;;11050\n");
goto while_break___0;
              }
            }
          while_break___0: /* CIL Label */;
          }
            printf("\nSTMT_EXEC;;11055\n");
status = -1;
            printf("\nSTMT_EXEC;;11056\n");
if (fd < 0)
            {
              {
                printf("\nSTMT_EXEC;;11059\n");
open_error((char const *)file_name);
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;11065\n");
printf("\nFUNC_CALL;fstat(int,struct stat *);\n");
tmp___22 = fstat(fd, &st);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;11067\n");
if (tmp___22 != 0)
              {
                {
                  printf("\nSTMT_EXEC;;11070\n");
stat_error((char const *)file_name);
                  printf("\nSTMT_EXEC;;11071\n");
printf("\nFUNC_CALL;close(int);\n");
close(fd);printf("\nFUNC_RETURN;;\n");

                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;11077\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___21 = close(fd);printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;11079\n");
if (tmp___21 != 0)
                {
                  {
                    printf("\nSTMT_EXEC;;11082\n");
close_error((char const *)file_name);
                  }
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;11088\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___14 = strlen((char const *)current_stat_info.link_name);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;11089\n");
tmp___15 = xmalloc(((unsigned long)(&((struct delayed_symlink *)0)->target) + tmp___14) + 1UL);
                    printf("\nSTMT_EXEC;;11090\n");
p = (struct delayed_symlink *)tmp___15;
                    printf("\nSTMT_EXEC;;11091\n");
p->next = delayed_symlink_head;
                    printf("\nSTMT_EXEC;;11092\n");
delayed_symlink_head = p;
                    printf("\nSTMT_EXEC;;11093\n");
p->dev = st.st_dev;
                    printf("\nSTMT_EXEC;;11094\n");
p->ino = st.st_ino;
                    printf("\nSTMT_EXEC;;11095\n");
p->mtime = st.st_mtim.tv_sec;
                    printf("\nSTMT_EXEC;;11096\n");
p->uid = current_stat_info.stat.st_uid;
                    printf("\nSTMT_EXEC;;11097\n");
p->gid = current_stat_info.stat.st_gid;
                    printf("\nSTMT_EXEC;;11098\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___16 = strlen((char const *)file_name);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;11099\n");
tmp___17 = xmalloc(((unsigned long)(&((struct string_list *)0)->string) + tmp___16) + 1UL);
                    printf("\nSTMT_EXEC;;11100\n");
p->sources = (struct string_list *)tmp___17;
                    printf("\nSTMT_EXEC;;11101\n");
(p->sources)->next = (struct string_list *)0;
                    printf("\nSTMT_EXEC;;11102\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)((p->sources)->string), (char const * /* __restrict  */)file_name);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;11103\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(p->target), (char const * /* __restrict  */)current_stat_info.link_name);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;11104\n");
h = delayed_set_stat_head;
                  }
                  printf("\nSTMT_EXEC;;11106\n");
if (h)
                  {
                    printf("\nSTMT_EXEC;;11108\n");
if (!h->after_symlinks)
                    {
                      {
                        printf("\nSTMT_EXEC;;11111\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___19 = strncmp((char const *)file_name, (char const *)(h->file_name), h->file_name_len);printf("\nFUNC_RETURN;;\n");

                      }
                      printf("\nSTMT_EXEC;;11113\n");
if (tmp___19 == 0)
                      {
                        printf("\nSTMT_EXEC;;11115\n");
if ((int)*(file_name + h->file_name_len) == 47)
                        {
                          {
                            printf("\nSTMT_EXEC;;11118\n");
tmp___20 = base_name((char const *)file_name);
                          }
                          printf("\nSTMT_EXEC;;11120\n");
if ((unsigned long)tmp___20 == (unsigned long)((file_name + h->file_name_len) + 1))
                          {
                            {
                              printf("\nSTMT_EXEC;;11123\n");
while (1)
                              {
                              while_continue___1: /* CIL Label */;
                                {
                                  printf("\nSTMT_EXEC;;11127\n");
h->after_symlinks = (_Bool)1;
                                  printf("\nSTMT_EXEC;;11128\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___18 = stat((char const * /* __restrict  */)(h->file_name), (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

                                }
                                printf("\nSTMT_EXEC;;11130\n");
if (tmp___18 != 0)
                                {
                                  {
                                    printf("\nSTMT_EXEC;;11133\n");
stat_error((char const *)(h->file_name));
                                  }
                                }
                                else
                                {
                                  printf("\nSTMT_EXEC;;11138\n");
h->stat_info.st_dev = st.st_dev;
                                  printf("\nSTMT_EXEC;;11139\n");
h->stat_info.st_ino = st.st_ino;
                                }
                                printf("\nSTMT_EXEC;;11141\n");
h = h->next;
                                printf("\nSTMT_EXEC;;11142\n");
if (h)
                                {
                                  printf("\nSTMT_EXEC;;11144\n");
if (!(!h->after_symlinks))
                                  {
                                    printf("\nSTMT_EXEC;;11146\n");
goto while_break___1;
                                  }
                                }
                                else
                                {
                                  printf("\nSTMT_EXEC;;11151\n");
goto while_break___1;
                                }
                              }
                            while_break___1: /* CIL Label */;
                            }
                          }
                        }
                      }
                    }
                  }
                  printf("\nSTMT_EXEC;;11161\n");
status = 0;
                }
              }
            }
          }
          else
          {
          _L:
          {
            printf("\nSTMT_EXEC;;11170\n");
while (1)
            {
            while_continue___2: /* CIL Label */;
              {
                printf("\nSTMT_EXEC;;11174\n");
printf("\nFUNC_CALL;symlink(const char *,const char *);\n");
status = symlink((char const *)current_stat_info.link_name, (char const *)file_name);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;11176\n");
if (!(status != 0))
              {
                printf("\nSTMT_EXEC;;11178\n");
goto while_break___2;
              }
              {
                printf("\nSTMT_EXEC;;11181\n");
tmp___12 = maybe_recoverable(file_name, &interdir_made);
              }
              printf("\nSTMT_EXEC;;11183\n");
if (!tmp___12)
              {
                printf("\nSTMT_EXEC;;11185\n");
goto while_break___2;
              }
            }
          while_break___2: /* CIL Label */;
          }
            printf("\nSTMT_EXEC;;11190\n");
if (status == 0)
            {
              {
                printf("\nSTMT_EXEC;;11193\n");
set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (struct stat const *)0, (mode_t)0, (enum permstatus)0, (char)'2');
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;11199\n");
symlink_error((char const *)current_stat_info.link_name, (char const *)file_name);
              }
            }
          }
        }
      }
      printf("\nSTMT_EXEC;;11205\n");
if (status != 0)
      {
        printf("\nSTMT_EXEC;;11207\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;11210\n");
undo_last_backup();
          }
        }
      }
      printf("\nSTMT_EXEC;;11214\n");
goto switch_break;
    case_49: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11217\n");
tmp___24 = prepare_to_extract((char const *)file_name);
    }
      printf("\nSTMT_EXEC;;11219\n");
if (!tmp___24)
      {
        printf("\nSTMT_EXEC;;11221\n");
goto switch_break;
      }
    again_link:
    {
      printf("\nSTMT_EXEC;;11225\n");
tmp___25 = safer_name_suffix((char const *)current_stat_info.link_name, (_Bool)1);
      printf("\nSTMT_EXEC;;11226\n");
link_name = (char const *)tmp___25;
      printf("\nSTMT_EXEC;;11227\n");
printf("\nFUNC_CALL;link(const char *,const char *);\n");
status = link(link_name, (char const *)file_name);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;11229\n");
if (status == 0)
      {
        printf("\nSTMT_EXEC;;11231\n");
ds = delayed_symlink_head;
        printf("\nSTMT_EXEC;;11232\n");
if (ds)
        {
          {
            printf("\nSTMT_EXEC;;11235\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___28 = stat((char const * /* __restrict  */)link_name, (struct stat * /* __restrict  */)(&st1));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;11237\n");
if (tmp___28 == 0)
          {
            {
              printf("\nSTMT_EXEC;;11240\n");
while (1)
              {
              while_continue___3: /* CIL Label */;
                printf("\nSTMT_EXEC;;11243\n");
if (!ds)
                {
                  printf("\nSTMT_EXEC;;11245\n");
goto while_break___3;
                }
                printf("\nSTMT_EXEC;;11247\n");
if (ds->dev == st1.st_dev)
                {
                  printf("\nSTMT_EXEC;;11249\n");
if (ds->ino == st1.st_ino)
                  {
                    printf("\nSTMT_EXEC;;11251\n");
if (ds->mtime == st1.st_mtim.tv_sec)
                    {
                      {
                        printf("\nSTMT_EXEC;;11254\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___26 = strlen((char const *)file_name);printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;11255\n");
tmp___27 = xmalloc(((unsigned long)(&((struct string_list *)0)->string) + tmp___26) + 1UL);
                        printf("\nSTMT_EXEC;;11256\n");
p___0 = (struct string_list *)tmp___27;
                        printf("\nSTMT_EXEC;;11257\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(p___0->string), (char const * /* __restrict  */)file_name);printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;11258\n");
p___0->next = ds->sources;
                        printf("\nSTMT_EXEC;;11259\n");
ds->sources = p___0;
                      }
                      printf("\nSTMT_EXEC;;11261\n");
goto while_break___3;
                    }
                  }
                }
                printf("\nSTMT_EXEC;;11265\n");
ds = ds->next;
              }
            while_break___3: /* CIL Label */;
            }
          }
        }
        printf("\nSTMT_EXEC;;11271\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;11274\n");
tmp___29 = maybe_recoverable(file_name, &interdir_made);
      }
      printf("\nSTMT_EXEC;;11276\n");
if (tmp___29)
      {
        printf("\nSTMT_EXEC;;11278\n");
goto again_link;
      }
      printf("\nSTMT_EXEC;;11280\n");
if (incremental_option)
      {
        {
          printf("\nSTMT_EXEC;;11283\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___30 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;11285\n");
if (*tmp___30 == 17)
        {
          printf("\nSTMT_EXEC;;11287\n");
goto switch_break;
        }
      }
      {
        printf("\nSTMT_EXEC;;11291\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___31 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;11292\n");
e___0 = *tmp___31;
        printf("\nSTMT_EXEC;;11293\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___32 = stat((char const * /* __restrict  */)link_name, (struct stat * /* __restrict  */)(&st1));printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;11295\n");
if (tmp___32 == 0)
      {
        {
          printf("\nSTMT_EXEC;;11298\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___33 = stat((char const * /* __restrict  */)file_name, (struct stat * /* __restrict  */)(&st2));printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;11300\n");
if (tmp___33 == 0)
        {
          printf("\nSTMT_EXEC;;11302\n");
if (st1.st_dev == st2.st_dev)
          {
            printf("\nSTMT_EXEC;;11304\n");
if (st1.st_ino == st2.st_ino)
            {
              printf("\nSTMT_EXEC;;11306\n");
goto switch_break;
            }
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;11312\n");
link_error(link_name, (char const *)file_name);
      }
      printf("\nSTMT_EXEC;;11314\n");
if (backup_option)
      {
        {
          printf("\nSTMT_EXEC;;11317\n");
undo_last_backup();
        }
      }
      printf("\nSTMT_EXEC;;11320\n");
goto switch_break;
    case_51: /* CIL Label */
      {
printf("\nSTMT_EXEC;;11322\n");
current_stat_info.stat.st_mode |= 8192U;
}

      printf("\nSTMT_EXEC;;11323\n");
goto make_node;
    case_52: /* CIL Label */
      {
printf("\nSTMT_EXEC;;11325\n");
current_stat_info.stat.st_mode |= 24576U;
}

    make_node:
    {
      printf("\nSTMT_EXEC;;11328\n");
tmp___34 = prepare_to_extract((char const *)file_name);
    }
      printf("\nSTMT_EXEC;;11330\n");
if (!tmp___34)
      {
        printf("\nSTMT_EXEC;;11332\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;11335\n");
printf("\nFUNC_CALL;mknod(const char *,__mode_t,__dev_t);\n");
status = mknod((char const *)file_name, current_stat_info.stat.st_mode, current_stat_info.stat.st_rdev);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;11337\n");
if (status != 0)
      {
        {
          printf("\nSTMT_EXEC;;11340\n");
tmp___35 = maybe_recoverable(file_name, &interdir_made);
        }
        printf("\nSTMT_EXEC;;11342\n");
if (tmp___35)
        {
          printf("\nSTMT_EXEC;;11344\n");
goto make_node;
        }
        {
          printf("\nSTMT_EXEC;;11347\n");
mknod_error((char const *)file_name);
        }
        printf("\nSTMT_EXEC;;11349\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;11352\n");
undo_last_backup();
          }
        }
        printf("\nSTMT_EXEC;;11355\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;11358\n");
set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (struct stat const *)0, (mode_t)0, (enum permstatus)1, typeflag);
      }
      printf("\nSTMT_EXEC;;11360\n");
goto switch_break;
    case_54: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11363\n");
tmp___36 = prepare_to_extract((char const *)file_name);
    }
      printf("\nSTMT_EXEC;;11365\n");
if (!tmp___36)
      {
        printf("\nSTMT_EXEC;;11367\n");
goto switch_break;
      }
      {
        printf("\nSTMT_EXEC;;11370\n");
while (1)
        {
        while_continue___4: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;11374\n");
printf("\nFUNC_CALL;mkfifo(const char *,__mode_t);\n");
status = mkfifo((char const *)file_name, current_stat_info.stat.st_mode);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;11376\n");
if (!(status != 0))
          {
            printf("\nSTMT_EXEC;;11378\n");
goto while_break___4;
          }
          {
            printf("\nSTMT_EXEC;;11381\n");
tmp___37 = maybe_recoverable(file_name, &interdir_made);
          }
          printf("\nSTMT_EXEC;;11383\n");
if (!tmp___37)
          {
            printf("\nSTMT_EXEC;;11385\n");
goto while_break___4;
          }
        }
      while_break___4: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;11390\n");
if (status == 0)
      {
        {
          printf("\nSTMT_EXEC;;11393\n");
set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (struct stat const *)((void *)0), (mode_t)0, (enum permstatus)1, typeflag);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;11399\n");
mkfifo_error((char const *)file_name);
        }
        printf("\nSTMT_EXEC;;11401\n");
if (backup_option)
        {
          {
            printf("\nSTMT_EXEC;;11404\n");
undo_last_backup();
          }
        }
      }
      printf("\nSTMT_EXEC;;11408\n");
goto switch_break;









































































































































































































    really_dir:
    case_53: /* CIL Label */
    case_68: /* CIL Label */
      {
printf("\nSTMT_EXEC;;11613\n");
if (incremental_option)
      {
        {
          printf("\nSTMT_EXEC;;11616\n");
gnu_restore((char const *)file_name);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;11621\n");
if ((int)typeflag == 68)
        {
          {
            printf("\nSTMT_EXEC;;11624\n");
skip_member();
          }
        }
      }
}

      printf("\nSTMT_EXEC;;11628\n");
if (we_are_root)
      {
        printf("\nSTMT_EXEC;;11630\n");
tmp___53 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;11634\n");
tmp___53 = 192;
      }
      {
        printf("\nSTMT_EXEC;;11637\n");
mode = (current_stat_info.stat.st_mode | (unsigned int)tmp___53) & (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
        printf("\nSTMT_EXEC;;11638\n");
status = prepare_to_extract((char const *)file_name);
      }
      printf("\nSTMT_EXEC;;11640\n");
if (status == 0)
      {
        printf("\nSTMT_EXEC;;11642\n");
goto switch_break;
      }
      printf("\nSTMT_EXEC;;11644\n");
if (status < 0)
      {
        printf("\nSTMT_EXEC;;11646\n");
goto directory_exists;
      }
    again_dir:




    {
      printf("\nSTMT_EXEC;;11654\n");
printf("\nFUNC_CALL;mkdir(const char *,__mode_t);\n");
status = mkdir((char const *)file_name, mode);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;11656\n");
if (status != 0)
      {
        {
          printf("\nSTMT_EXEC;;11659\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___40 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;11661\n");
if (*tmp___40 == 17)
        {
          printf("\nSTMT_EXEC;;11663\n");
if (interdir_made)
          {
            printf("\nSTMT_EXEC;;11665\n");
goto _L___3;
          }
          else
          {
            printf("\nSTMT_EXEC;;11669\n");
if ((unsigned int)old_files_option == 0U)
            {
              printf("\nSTMT_EXEC;;11671\n");
goto _L___3;
            }
            else
            {
              printf("\nSTMT_EXEC;;11675\n");
if ((unsigned int)old_files_option == 2U)
              {
              _L___3: /* CIL Label */
              {
                printf("\nSTMT_EXEC;;11679\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___38 = stat((char const * /* __restrict  */)file_name, (struct stat * /* __restrict  */)(&st___0));printf("\nFUNC_RETURN;;\n");

              }
                printf("\nSTMT_EXEC;;11681\n");
if (tmp___38 == 0)
                {
                  printf("\nSTMT_EXEC;;11683\n");
if (interdir_made)
                  {
                    {
                      printf("\nSTMT_EXEC;;11686\n");
repair_delayed_set_stat((char const *)file_name, (struct stat const *)(&st___0));
                    }
                    printf("\nSTMT_EXEC;;11688\n");
goto switch_break;
                  }
                  printf("\nSTMT_EXEC;;11690\n");
if ((st___0.st_mode & 61440U) == 16384U)
                  {
                    printf("\nSTMT_EXEC;;11692\n");
mode = st___0.st_mode & ~current_umask;
                    printf("\nSTMT_EXEC;;11693\n");
goto directory_exists;
                  }
                }
                {
                  printf("\nSTMT_EXEC;;11697\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___39 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;11698\n");
*tmp___39 = 17;
                }
              }
            }
          }
        }
        {
          printf("\nSTMT_EXEC;;11705\n");
tmp___41 = maybe_recoverable(file_name, &interdir_made);
        }
        printf("\nSTMT_EXEC;;11707\n");
if (tmp___41)
        {
          printf("\nSTMT_EXEC;;11709\n");
goto again_dir;
        }
        {
          printf("\nSTMT_EXEC;;11712\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___42 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;11714\n");
if (*tmp___42 != 17)
        {
          {
            printf("\nSTMT_EXEC;;11717\n");
mkdir_error((char const *)file_name);
          }
          printf("\nSTMT_EXEC;;11719\n");
if (backup_option)
          {
            {
              printf("\nSTMT_EXEC;;11722\n");
undo_last_backup();
            }
          }
          printf("\nSTMT_EXEC;;11725\n");
goto switch_break;
        }
      }
    directory_exists:
      {
printf("\nSTMT_EXEC;;11729\n");
if (status == 0)
      {
        printf("\nSTMT_EXEC;;11731\n");
goto _L___4;
      }
      else
      {
        printf("\nSTMT_EXEC;;11735\n");
if ((unsigned int)old_files_option == 0U)
        {
          printf("\nSTMT_EXEC;;11737\n");
goto _L___4;
        }
        else
        {
          printf("\nSTMT_EXEC;;11741\n");
if ((unsigned int)old_files_option == 2U)
          {
          _L___4: /* CIL Label */
            {
printf("\nSTMT_EXEC;;11744\n");
if (status == 0)
            {
              printf("\nSTMT_EXEC;;11746\n");
tmp___54 = 1;
            }
            else
            {
              printf("\nSTMT_EXEC;;11750\n");
tmp___54 = 0;
            }
}

            {
              printf("\nSTMT_EXEC;;11753\n");
delay_set_stat((char const *)file_name, (struct stat const *)(&current_stat_info.stat), (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) & (mode ^ current_stat_info.stat.st_mode), (enum permstatus)tmp___54);
            }
          }
        }
      }
}

      printf("\nSTMT_EXEC;;11758\n");
goto switch_break;
    case_86: /* CIL Label */
      {
printf("\nSTMT_EXEC;;11760\n");
if (verbose_option)
      {
        {
          printf("\nSTMT_EXEC;;11763\n");
tmp___43 = quote((char const *)current_stat_info.file_name);
          printf("\nSTMT_EXEC;;11764\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___44 = gettext("Reading %s\n");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;11765\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___44, tmp___43);printf("\nFUNC_RETURN;;\n");

        }
      }
}

      printf("\nSTMT_EXEC;;11768\n");
goto switch_break;
    case_78: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11771\n");
extract_mangle();
    }
      printf("\nSTMT_EXEC;;11773\n");
goto switch_break;
    case_77: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11776\n");
tmp___45 = quotearg_colon((char const *)current_stat_info.file_name);
      printf("\nSTMT_EXEC;;11777\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___46 = gettext("%s: Cannot extract -- file is continued from another volume");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;11778\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___46, tmp___45);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;11779\n");
exit_status = 2;
      printf("\nSTMT_EXEC;;11780\n");
skip_member();
    }
      printf("\nSTMT_EXEC;;11782\n");
if (backup_option)
      {
        {
          printf("\nSTMT_EXEC;;11785\n");
undo_last_backup();
        }
      }
      printf("\nSTMT_EXEC;;11788\n");
goto switch_break;
    case_76: /* CIL Label */
    case_75: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11792\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___47 = gettext("Visible long name error");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;11793\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___47);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;11794\n");
exit_status = 2;
      printf("\nSTMT_EXEC;;11795\n");
skip_member();
    }
      printf("\nSTMT_EXEC;;11797\n");
if (backup_option)
      {
        {
          printf("\nSTMT_EXEC;;11800\n");
undo_last_backup();
        }
      }
      printf("\nSTMT_EXEC;;11803\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;11806\n");
tmp___48 = quotearg_colon((char const *)file_name);
      printf("\nSTMT_EXEC;;11807\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___49 = gettext("%s: Unknown file type \'%c\', extracted as normal file");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;11808\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___49, tmp___48, (int)typeflag);printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;11810\n");
goto again_file;
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;11813\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void apply_delayed_symlinks(void)
{
  printf("\nFUNC_CALL;apply_delayed_symlinks();\n");
printf("\nSTMT_EXEC;;11818\n");
struct delayed_symlink *ds;
  printf("\nSTMT_EXEC;;11819\n");
struct string_list *sources;
  printf("\nSTMT_EXEC;;11820\n");
char const *valid_source;
  printf("\nSTMT_EXEC;;11821\n");
char const *source;
  printf("\nSTMT_EXEC;;11822\n");
struct stat st;
  printf("\nSTMT_EXEC;;11823\n");
int tmp;
  printf("\nSTMT_EXEC;;11824\n");
int tmp___0;
  printf("\nSTMT_EXEC;;11825\n");
int tmp___1;
  printf("\nSTMT_EXEC;;11826\n");
int tmp___2;
  printf("\nSTMT_EXEC;;11827\n");
struct string_list *next;
  printf("\nSTMT_EXEC;;11828\n");
struct delayed_symlink *next___0;
  printf("\nSTMT_EXEC;;11829\n");
void *__cil_tmp12;

  {
    printf("\nSTMT_EXEC;;11832\n");
ds = delayed_symlink_head;
    {
      printf("\nSTMT_EXEC;;11834\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;11837\n");
if (!ds)
        {
          printf("\nSTMT_EXEC;;11839\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;11841\n");
sources = ds->sources;
        printf("\nSTMT_EXEC;;11842\n");
valid_source = (char const *)0;
        printf("\nSTMT_EXEC;;11843\n");
sources = ds->sources;
        {
          printf("\nSTMT_EXEC;;11845\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;11848\n");
if (!sources)
            {
              printf("\nSTMT_EXEC;;11850\n");
goto while_break___0;
            }
            {
              printf("\nSTMT_EXEC;;11853\n");
source = (char const *)(sources->string);
              printf("\nSTMT_EXEC;;11854\n");
printf("\nFUNC_CALL;lstat(const char *__restrict,struct stat *__restrict);\n");
tmp___2 = lstat((char const * /* __restrict  */)source, (struct stat * /* __restrict  */)(&st));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;11856\n");
if (tmp___2 == 0)
            {
              printf("\nSTMT_EXEC;;11858\n");
if (st.st_dev == ds->dev)
              {
                printf("\nSTMT_EXEC;;11860\n");
if (st.st_ino == ds->ino)
                {
                  printf("\nSTMT_EXEC;;11862\n");
if (st.st_mtim.tv_sec == ds->mtime)
                  {
                    {
                      printf("\nSTMT_EXEC;;11865\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___1 = unlink(source);printf("\nFUNC_RETURN;;\n");

                    }
                    printf("\nSTMT_EXEC;;11867\n");
if (tmp___1 != 0)
                    {
                      {
                        printf("\nSTMT_EXEC;;11870\n");
unlink_error(source);
                      }
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;11875\n");
if (valid_source)
                      {
                        {
                          printf("\nSTMT_EXEC;;11878\n");
printf("\nFUNC_CALL;link(const char *,const char *);\n");
tmp___0 = link(valid_source, source);printf("\nFUNC_RETURN;;\n");

                        }
                        printf("\nSTMT_EXEC;;11880\n");
if (!(tmp___0 == 0))
                        {
                          printf("\nSTMT_EXEC;;11882\n");
goto _L;
                        }
                      }
                      else
                      {
                      _L:
                      {
                        printf("\nSTMT_EXEC;;11889\n");
printf("\nFUNC_CALL;symlink(const char *,const char *);\n");
tmp = symlink((char const *)(ds->target), source);printf("\nFUNC_RETURN;;\n");

                      }
                        printf("\nSTMT_EXEC;;11891\n");
if (tmp != 0)
                        {
                          {
                            printf("\nSTMT_EXEC;;11894\n");
symlink_error((char const *)(ds->target), source);
                          }
                        }
                        else
                        {
                          {
                            printf("\nSTMT_EXEC;;11900\n");
valid_source = source;
                            printf("\nSTMT_EXEC;;11901\n");
st.st_uid = ds->uid;
                            printf("\nSTMT_EXEC;;11902\n");
st.st_gid = ds->gid;
                            printf("\nSTMT_EXEC;;11903\n");
set_stat(source, (struct stat const *)(&st), (struct stat const *)0, (mode_t)0, (enum permstatus)0, (char)'2');
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            printf("\nSTMT_EXEC;;11912\n");
sources = sources->next;
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;11916\n");
sources = ds->sources;
        {
          printf("\nSTMT_EXEC;;11918\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;11921\n");
if (!sources)
            {
              printf("\nSTMT_EXEC;;11923\n");
goto while_break___1;
            }
            {
              printf("\nSTMT_EXEC;;11926\n");
next = sources->next;
              printf("\nSTMT_EXEC;;11927\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)sources);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;11928\n");
sources = next;
            }
          }
        while_break___1: /* CIL Label */;
        }
        {
          printf("\nSTMT_EXEC;;11934\n");
next___0 = ds->next;
          printf("\nSTMT_EXEC;;11935\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)ds);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;11936\n");
ds = next___0;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;11941\n");
delayed_symlink_head = (struct delayed_symlink *)0;
    printf("\nSTMT_EXEC;;11942\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void extract_finish(void)
{
  printf("\nFUNC_CALL;extract_finish();\n");
printf("\nSTMT_EXEC;;11947\n");
char *__cil_tmp1;
  printf("\nSTMT_EXEC;;11948\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;11952\n");
apply_nonancestor_delayed_set_stat("", (_Bool)0);
      printf("\nSTMT_EXEC;;11953\n");
apply_delayed_symlinks();
      printf("\nSTMT_EXEC;;11954\n");
apply_nonancestor_delayed_set_stat("", (_Bool)1);
    }
    printf("\nSTMT_EXEC;;11956\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}


























































































































































































































































































































































































































































































































































































































































































































































































































































__attribute__((__noreturn__)) void fatal_exit(void);
void fatal_exit(void)
{
  printf("\nFUNC_CALL;fatal_exit();\n");
printf("\nSTMT_EXEC;;12788\n");
char *tmp;
  printf("\nSTMT_EXEC;;12789\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;12793\n");
extract_finish();

      printf("\nSTMT_EXEC;;12795\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Error is not recoverable: exiting now");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;12796\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(2, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;12797\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }


  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","005.xheader.o.i","") */
extern __attribute__((__nothrow__)) unsigned short const **(__attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(2), __leaf__)) strtok)(char *__restrict __s, char const *__restrict __delim);
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1, 2), __leaf__)) stpcpy)(char *__restrict __dest, char const *__restrict __src);
extern __attribute__((__nothrow__)) __pid_t(__attribute__((__leaf__)) getpid)(void);
extern __attribute__((__nothrow__)) unsigned long(__attribute__((__nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr, char **__restrict __endptr, int __base);
extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) calloc)(size_t __nmemb, size_t __size) __attribute__((__malloc__));
extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1), __leaf__)) getenv)(char const *__name);
char *dir_name(char const *path);
strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base, uintmax_t *val, char const *valid_suffixes);
__attribute__((__noreturn__)) void usage(int status);
void xheader_decode_global(void);
void xheader_read(union block *p, size_t size);
void xheader_destroy(struct xheader *xhdr);
char *xheader_ghdr_name(void);
void xheader_set_option(char *string);
_Bool utf8_convert(_Bool to_utf, char const *input, char **output);
extern void _obstack_newchunk(struct obstack *, int);
extern int _obstack_begin(struct obstack *, int, int, void *(*)(long), void (*)(void *));
extern void obstack_free(struct obstack *obstack, void *block);
static _Bool xheader_protected_pattern_p(char const *pattern);
static _Bool xheader_protected_keyword_p(char const *keyword);
static __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw);
static void code_string(char const *string, char const *keyword, struct xheader *xhdr);
static void extended_header_init(void);
static size_t global_header_count;
static struct keyword_list *keyword_pattern_list;
static struct keyword_list *keyword_global_override_list;
static struct keyword_list *keyword_override_list;
static struct keyword_list *global_header_override_list;
static char *exthdr_name;
static char *globexthdr_name;
static _Bool xheader_keyword_deleted_p(char const *kw)
{
  printf("\nFUNC_CALL;xheader_keyword_deleted_p(const char *);\n");
printf("\nSTMT_EXEC;;12837\n");
struct keyword_list *kp;
  printf("\nSTMT_EXEC;;12838\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;12841\n");
kp = keyword_pattern_list;
    {
      printf("\nSTMT_EXEC;;12843\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;12846\n");
if (!kp)
        {
          printf("\nSTMT_EXEC;;12848\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;12851\n");
printf("\nFUNC_CALL;fnmatch(const char *,const char *,int);\n");
tmp = fnmatch((char const *)kp->pattern, kw, 0);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;12853\n");
if (tmp == 0)
        {
          printf("\nSTMT_EXEC;;12855\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
        }
        printf("\nSTMT_EXEC;;12857\n");
kp = kp->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;12861\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool xheader_keyword_override_p(char const *keyword)
{
  printf("\nFUNC_CALL;xheader_keyword_override_p(const char *);\n");
printf("\nSTMT_EXEC;;12866\n");
struct keyword_list *kp;
  printf("\nSTMT_EXEC;;12867\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;12870\n");
kp = keyword_override_list;
    {
      printf("\nSTMT_EXEC;;12872\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;12875\n");
if (!kp)
        {
          printf("\nSTMT_EXEC;;12877\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;12880\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)kp->pattern, keyword);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;12882\n");
if (tmp == 0)
        {
          printf("\nSTMT_EXEC;;12884\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
        }
        printf("\nSTMT_EXEC;;12886\n");
kp = kp->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;12890\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static void xheader_list_append(struct keyword_list **root, char const *kw, char const *value)
{
  printf("\nFUNC_CALL;xheader_list_append(struct keyword_list **,const char *,const char *);\n");
printf("\nSTMT_EXEC;;12895\n");
struct keyword_list *kp;
  printf("\nSTMT_EXEC;;12896\n");
void *tmp;
  printf("\nSTMT_EXEC;;12897\n");
char *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;12901\n");
tmp = xmalloc(sizeof(*kp));
      printf("\nSTMT_EXEC;;12902\n");
kp = (struct keyword_list *)tmp;
      printf("\nSTMT_EXEC;;12903\n");
kp->pattern = xstrdup(kw);
    }
    printf("\nSTMT_EXEC;;12905\n");
if (value)
    {
      {
        printf("\nSTMT_EXEC;;12908\n");
tmp___0 = xstrdup(value);
        printf("\nSTMT_EXEC;;12909\n");
kp->value = tmp___0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;12914\n");
kp->value = (char *)((void *)0);
    }
    printf("\nSTMT_EXEC;;12916\n");
kp->next = *root;
    printf("\nSTMT_EXEC;;12917\n");
*root = kp;
    printf("\nSTMT_EXEC;;12918\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void xheader_list_destroy(struct keyword_list **root)
{
  printf("\nFUNC_CALL;xheader_list_destroy(struct keyword_list **);\n");
printf("\nSTMT_EXEC;;12923\n");
struct keyword_list *kw;
  printf("\nSTMT_EXEC;;12924\n");
struct keyword_list *next;

  {
    printf("\nSTMT_EXEC;;12927\n");
if (root)
    {
      printf("\nSTMT_EXEC;;12929\n");
kw = *root;
      {
        printf("\nSTMT_EXEC;;12931\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;12934\n");
if (!kw)
          {
            printf("\nSTMT_EXEC;;12936\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;12939\n");
next = kw->next;
            printf("\nSTMT_EXEC;;12940\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)kw->pattern);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;12941\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)kw->value);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;12942\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)kw);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;12943\n");
kw = next;
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;12948\n");
*root = (struct keyword_list *)((void *)0);
    }
    printf("\nSTMT_EXEC;;12950\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw);
static void xheader_set_single_keyword(char *kw)
{
  printf("\nFUNC_CALL;xheader_set_single_keyword(char *);\n");
printf("\nSTMT_EXEC;;12956\n");
char *tmp;
  printf("\nSTMT_EXEC;;12957\n");
char *__cil_tmp3;

  {
    {
      printf("\nSTMT_EXEC;;12961\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Keyword %s is unknown or not yet imlemented");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;12962\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, kw);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;12963\n");
usage(2);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static void xheader_set_keyword_equal(char *kw, char *eq)
{
  printf("\nFUNC_CALL;xheader_set_keyword_equal(char *,char *);\n");
printf("\nSTMT_EXEC;;12969\n");
_Bool global;
  printf("\nSTMT_EXEC;;12970\n");
char *p;
  printf("\nSTMT_EXEC;;12971\n");
unsigned short const **tmp;
  printf("\nSTMT_EXEC;;12972\n");
unsigned short const **tmp___0;
  printf("\nSTMT_EXEC;;12973\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;12974\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;12975\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;12976\n");
_Bool tmp___4;
  printf("\nSTMT_EXEC;;12977\n");
int tmp___5;
  printf("\nSTMT_EXEC;;12978\n");
int tmp___6;
  printf("\nSTMT_EXEC;;12979\n");
int tmp___7;
  printf("\nSTMT_EXEC;;12980\n");
char *__cil_tmp14;
  printf("\nSTMT_EXEC;;12981\n");
char *__cil_tmp15;

  {
    printf("\nSTMT_EXEC;;12984\n");
global = (_Bool)1;
    printf("\nSTMT_EXEC;;12985\n");
p = eq;
    printf("\nSTMT_EXEC;;12986\n");
if ((int)*(eq + -1) == 58)
    {
      printf("\nSTMT_EXEC;;12988\n");
p--;
      printf("\nSTMT_EXEC;;12989\n");
global = (_Bool)0;
    }
    {
      printf("\nSTMT_EXEC;;12992\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;12995\n");
if ((unsigned long)p > (unsigned long)kw)
        {
          {
            printf("\nSTMT_EXEC;;12998\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;13000\n");
if (!((int const) * (*tmp + (int)*p) & 8192))
          {
            printf("\nSTMT_EXEC;;13002\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13007\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;13009\n");
p--;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13013\n");
*p = (char)0;
    printf("\nSTMT_EXEC;;13014\n");
p = eq + 1;
    {
      printf("\nSTMT_EXEC;;13016\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;13019\n");
if (*p)
        {
          {
            printf("\nSTMT_EXEC;;13022\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___0 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;13024\n");
if (!((int const) * (*tmp___0 + (int)*p) & 8192))
          {
            printf("\nSTMT_EXEC;;13026\n");
goto while_break___0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13031\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;13033\n");
p++;
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;13038\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___7 = strcmp((char const *)kw, "delete");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;13040\n");
if (tmp___7 == 0)
    {
      {
        printf("\nSTMT_EXEC;;13043\n");
tmp___2 = xheader_protected_pattern_p((char const *)p);
      }
      printf("\nSTMT_EXEC;;13045\n");
if (tmp___2)
      {
        {
          printf("\nSTMT_EXEC;;13048\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Pattern %s cannot be used");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;13049\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, p);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;13050\n");
usage(2);
        }
      }
      {
        printf("\nSTMT_EXEC;;13054\n");
xheader_list_append(&keyword_pattern_list, (char const *)p, (char const *)((void *)0));
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;13060\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___6 = strcmp((char const *)kw, "exthdr.name");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;13062\n");
if (tmp___6 == 0)
      {
        {
          printf("\nSTMT_EXEC;;13065\n");
assign_string(&exthdr_name, (char const *)p);
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;13071\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___5 = strcmp((char const *)kw, "globexthdr.name");printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;13073\n");
if (tmp___5 == 0)
        {
          {
            printf("\nSTMT_EXEC;;13076\n");
assign_string(&globexthdr_name, (char const *)p);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;13082\n");
tmp___4 = xheader_protected_keyword_p((char const *)kw);
          }
          printf("\nSTMT_EXEC;;13084\n");
if (tmp___4)
          {
            {
              printf("\nSTMT_EXEC;;13087\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Keyword %s cannot be overridden");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;13088\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, kw);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;13089\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;13092\n");
if (global)
          {
            {
              printf("\nSTMT_EXEC;;13095\n");
xheader_list_append(&keyword_global_override_list, (char const *)kw, (char const *)p);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;13101\n");
xheader_list_append(&keyword_override_list, (char const *)kw, (char const *)p);
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;13107\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_set_option(char *string)
{
  printf("\nFUNC_CALL;xheader_set_option(char *);\n");
printf("\nSTMT_EXEC;;13112\n");
char *token;
  printf("\nSTMT_EXEC;;13113\n");
char *p;
  printf("\nSTMT_EXEC;;13114\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;13118\n");
printf("\nFUNC_CALL;strtok(char *__restrict,const char *__restrict);\n");
token = strtok((char * /* __restrict  */)string, (char const * /* __restrict  */) ",");printf("\nFUNC_RETURN;;\n");

    }
    {
      printf("\nSTMT_EXEC;;13121\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13124\n");
if (!token)
        {
          printf("\nSTMT_EXEC;;13126\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;13129\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp = strchr((char const *)token, '=');printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;13130\n");
p = tmp;
        }
        printf("\nSTMT_EXEC;;13132\n");
if (!p)
        {
          {
            printf("\nSTMT_EXEC;;13135\n");
xheader_set_single_keyword(token);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;13141\n");
xheader_set_keyword_equal(token, p);
          }
        }
        {
          printf("\nSTMT_EXEC;;13145\n");
printf("\nFUNC_CALL;strtok(char *__restrict,const char *__restrict);\n");
token = strtok((char * /* __restrict  */)((void *)0), (char const * /* __restrict  */) ",");printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13150\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void to_decimal(uintmax_t value, char *where, size_t size)
{
  printf("\nFUNC_CALL;to_decimal(uintmax_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;13155\n");
size_t i;
  printf("\nSTMT_EXEC;;13156\n");
size_t j;
  printf("\nSTMT_EXEC;;13157\n");
size_t tmp;
  printf("\nSTMT_EXEC;;13158\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;13159\n");
char c;

  {
    printf("\nSTMT_EXEC;;13162\n");
i = (size_t)0;
    printf("\nSTMT_EXEC;;13163\n");
tmp = i;
    printf("\nSTMT_EXEC;;13164\n");
i++;
    printf("\nSTMT_EXEC;;13165\n");
*(where + tmp) = (char)0;
    {
      printf("\nSTMT_EXEC;;13167\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13170\n");
tmp___0 = i;
        printf("\nSTMT_EXEC;;13171\n");
i++;
        printf("\nSTMT_EXEC;;13172\n");
*(where + tmp___0) = (char)(48UL + value % 10UL);
        printf("\nSTMT_EXEC;;13173\n");
value /= 10UL;
        printf("\nSTMT_EXEC;;13174\n");
if (i < size)
        {
          printf("\nSTMT_EXEC;;13176\n");
if (!value)
          {
            printf("\nSTMT_EXEC;;13178\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13183\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13188\n");
j = (size_t)0;
    printf("\nSTMT_EXEC;;13189\n");
i--;
    {
      printf("\nSTMT_EXEC;;13191\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;13194\n");
if (!(j < i))
        {
          printf("\nSTMT_EXEC;;13196\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;13198\n");
c = *(where + j);
        printf("\nSTMT_EXEC;;13199\n");
*(where + j) = *(where + i);
        printf("\nSTMT_EXEC;;13200\n");
*(where + i) = c;
        printf("\nSTMT_EXEC;;13201\n");
j++;
        printf("\nSTMT_EXEC;;13202\n");
i--;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13206\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static char *xheader_format_name(struct tar_stat_info *st, char const *fmt, _Bool allow_n)
{
  printf("\nFUNC_CALL;xheader_format_name(struct tar_stat_info *,const char *,_Bool);\n");
printf("\nSTMT_EXEC;;13211\n");
char *buf;
  printf("\nSTMT_EXEC;;13212\n");
size_t len;
  printf("\nSTMT_EXEC;;13213\n");
size_t tmp;
  printf("\nSTMT_EXEC;;13214\n");
char *q;
  printf("\nSTMT_EXEC;;13215\n");
char const *p;
  printf("\nSTMT_EXEC;;13216\n");
char *dir;
  printf("\nSTMT_EXEC;;13217\n");
char *base;
  printf("\nSTMT_EXEC;;13218\n");
char pidbuf[64];
  printf("\nSTMT_EXEC;;13219\n");
char nbuf[64];
  printf("\nSTMT_EXEC;;13220\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;13221\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;13222\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;13223\n");
__pid_t tmp___3;
  printf("\nSTMT_EXEC;;13224\n");
size_t tmp___4;
  printf("\nSTMT_EXEC;;13225\n");
size_t tmp___5;
  printf("\nSTMT_EXEC;;13226\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;13227\n");
void *tmp___7;
  printf("\nSTMT_EXEC;;13228\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;13229\n");
char const *tmp___9;
  printf("\nSTMT_EXEC;;13230\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;13231\n");
char const *tmp___11;
  printf("\nSTMT_EXEC;;13232\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;13233\n");
char const *tmp___13;
  printf("\nSTMT_EXEC;;13234\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;13235\n");
char const *tmp___15;
  printf("\nSTMT_EXEC;;13236\n");
void *__cil_tmp29;
  printf("\nSTMT_EXEC;;13237\n");
void *__cil_tmp30;

  {
    {
      printf("\nSTMT_EXEC;;13241\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(fmt);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;13242\n");
len = tmp;
      printf("\nSTMT_EXEC;;13243\n");
dir = (char *)((void *)0);
      printf("\nSTMT_EXEC;;13244\n");
base = (char *)((void *)0);
      printf("\nSTMT_EXEC;;13245\n");
p = fmt;
    }
    {
      printf("\nSTMT_EXEC;;13248\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13251\n");
if (*p)
        {
          {
            printf("\nSTMT_EXEC;;13254\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___6 = strchr(p, '%');printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;13255\n");
p = (char const *)tmp___6;
          }
          printf("\nSTMT_EXEC;;13257\n");
if (!p)
          {
            printf("\nSTMT_EXEC;;13259\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13264\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;13267\n");
if ((int const) * (p + 1) == 37)
          {
            printf("\nSTMT_EXEC;;13269\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;13271\n");
if ((int const) * (p + 1) == 100)
          {
            printf("\nSTMT_EXEC;;13273\n");
goto case_100;
          }
          printf("\nSTMT_EXEC;;13275\n");
if ((int const) * (p + 1) == 102)
          {
            printf("\nSTMT_EXEC;;13277\n");
goto case_102;
          }
          printf("\nSTMT_EXEC;;13279\n");
if ((int const) * (p + 1) == 112)
          {
            printf("\nSTMT_EXEC;;13281\n");
goto case_112;
          }
          printf("\nSTMT_EXEC;;13283\n");
if ((int const) * (p + 1) == 110)
          {
            printf("\nSTMT_EXEC;;13285\n");
goto case_110;
          }
          printf("\nSTMT_EXEC;;13287\n");
goto switch_break;
        case_37: /* CIL Label */
          {
printf("\nSTMT_EXEC;;13289\n");
len--;
}

          printf("\nSTMT_EXEC;;13290\n");
goto switch_break;
        case_100: /* CIL Label */
          {
printf("\nSTMT_EXEC;;13292\n");
if (st)
          {
            {
              printf("\nSTMT_EXEC;;13295\n");
tmp___0 = dir_name((char const *)st->orig_file_name);
              printf("\nSTMT_EXEC;;13296\n");
dir = safer_name_suffix((char const *)tmp___0, (_Bool)0);
              printf("\nSTMT_EXEC;;13297\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)dir);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;13298\n");
len += tmp___1 - 1UL;
            }
          }
}

          printf("\nSTMT_EXEC;;13301\n");
goto switch_break;
        case_102: /* CIL Label */
          {
printf("\nSTMT_EXEC;;13303\n");
if (st)
          {
            {
              printf("\nSTMT_EXEC;;13306\n");
base = base_name((char const *)st->orig_file_name);
              printf("\nSTMT_EXEC;;13307\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen((char const *)base);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;13308\n");
len += tmp___2 - 1UL;
            }
          }
}

          printf("\nSTMT_EXEC;;13311\n");
goto switch_break;
        case_112: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;13314\n");
printf("\nFUNC_CALL;getpid();\n");
tmp___3 = getpid();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;13315\n");
to_decimal((uintmax_t)tmp___3, pidbuf, sizeof(pidbuf));
          printf("\nSTMT_EXEC;;13316\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___4 = strlen((char const *)(pidbuf));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;13317\n");
len += tmp___4 - 1UL;
        }
          printf("\nSTMT_EXEC;;13319\n");
goto switch_break;
        case_110: /* CIL Label */
          {
printf("\nSTMT_EXEC;;13321\n");
if (allow_n)
          {
            {
              printf("\nSTMT_EXEC;;13324\n");
to_decimal(global_header_count + 1UL, pidbuf, sizeof(pidbuf));
              printf("\nSTMT_EXEC;;13325\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___5 = strlen((char const *)(nbuf));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;13326\n");
len += tmp___5 - 1UL;
            }
          }
}

          printf("\nSTMT_EXEC;;13329\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;13332\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;13337\n");
tmp___7 = xmalloc(len + 1UL);
      printf("\nSTMT_EXEC;;13338\n");
buf = (char *)tmp___7;
      printf("\nSTMT_EXEC;;13339\n");
q = buf;
      printf("\nSTMT_EXEC;;13340\n");
p = fmt;
    }
    {
      printf("\nSTMT_EXEC;;13343\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;13346\n");
if (!*p)
        {
          printf("\nSTMT_EXEC;;13348\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;13350\n");
if ((int const) * p == 37)
        {
          {
            printf("\nSTMT_EXEC;;13353\n");
if ((int const) * (p + 1) == 37)
            {
              printf("\nSTMT_EXEC;;13355\n");
goto case_37___0;
            }
            printf("\nSTMT_EXEC;;13357\n");
if ((int const) * (p + 1) == 100)
            {
              printf("\nSTMT_EXEC;;13359\n");
goto case_100___0;
            }
            printf("\nSTMT_EXEC;;13361\n");
if ((int const) * (p + 1) == 102)
            {
              printf("\nSTMT_EXEC;;13363\n");
goto case_102___0;
            }
            printf("\nSTMT_EXEC;;13365\n");
if ((int const) * (p + 1) == 112)
            {
              printf("\nSTMT_EXEC;;13367\n");
goto case_112___0;
            }
            printf("\nSTMT_EXEC;;13369\n");
if ((int const) * (p + 1) == 110)
            {
              printf("\nSTMT_EXEC;;13371\n");
goto case_110___0;
            }
            printf("\nSTMT_EXEC;;13373\n");
goto switch_default;
          case_37___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;13375\n");
tmp___8 = q;
}

            printf("\nSTMT_EXEC;;13376\n");
q++;
            printf("\nSTMT_EXEC;;13377\n");
tmp___9 = p;
            printf("\nSTMT_EXEC;;13378\n");
p++;
            printf("\nSTMT_EXEC;;13379\n");
*tmp___8 = (char)*tmp___9;
            printf("\nSTMT_EXEC;;13380\n");
p++;
            printf("\nSTMT_EXEC;;13381\n");
goto switch_break___0;
          case_100___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;13383\n");
if (dir)
            {
              {
                printf("\nSTMT_EXEC;;13386\n");
printf("\nFUNC_CALL;stpcpy(char *__restrict,const char *__restrict);\n");
q = stpcpy((char * /* __restrict  */)q, (char const * /* __restrict  */)dir);printf("\nFUNC_RETURN;;\n");

              }
            }
}

            printf("\nSTMT_EXEC;;13389\n");
p += 2;
            printf("\nSTMT_EXEC;;13390\n");
goto switch_break___0;
          case_102___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;13392\n");
if (base)
            {
              {
                printf("\nSTMT_EXEC;;13395\n");
printf("\nFUNC_CALL;stpcpy(char *__restrict,const char *__restrict);\n");
q = stpcpy((char * /* __restrict  */)q, (char const * /* __restrict  */)base);printf("\nFUNC_RETURN;;\n");

              }
            }
}

            printf("\nSTMT_EXEC;;13398\n");
p += 2;
            printf("\nSTMT_EXEC;;13399\n");
goto switch_break___0;
          case_112___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;13402\n");
printf("\nFUNC_CALL;stpcpy(char *__restrict,const char *__restrict);\n");
q = stpcpy((char * /* __restrict  */)q, (char const * /* __restrict  */)(pidbuf));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;13403\n");
p += 2;
          }
            printf("\nSTMT_EXEC;;13405\n");
goto switch_break___0;
          case_110___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;13407\n");
if (allow_n)
            {
              {
                printf("\nSTMT_EXEC;;13410\n");
printf("\nFUNC_CALL;stpcpy(char *__restrict,const char *__restrict);\n");
q = stpcpy((char * /* __restrict  */)q, (char const * /* __restrict  */)(nbuf));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;13411\n");
p += 2;
              }
            }
}

          switch_default: /* CIL Label */
            {
printf("\nSTMT_EXEC;;13415\n");
tmp___10 = q;
}

            printf("\nSTMT_EXEC;;13416\n");
q++;
            printf("\nSTMT_EXEC;;13417\n");
tmp___11 = p;
            printf("\nSTMT_EXEC;;13418\n");
p++;
            printf("\nSTMT_EXEC;;13419\n");
*tmp___10 = (char)*tmp___11;
            printf("\nSTMT_EXEC;;13420\n");
if (*p)
            {
              printf("\nSTMT_EXEC;;13422\n");
tmp___12 = q;
              printf("\nSTMT_EXEC;;13423\n");
q++;
              printf("\nSTMT_EXEC;;13424\n");
tmp___13 = p;
              printf("\nSTMT_EXEC;;13425\n");
p++;
              printf("\nSTMT_EXEC;;13426\n");
*tmp___12 = (char)*tmp___13;
            }
          switch_break___0: /* CIL Label */;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13433\n");
tmp___14 = q;
          printf("\nSTMT_EXEC;;13434\n");
q++;
          printf("\nSTMT_EXEC;;13435\n");
tmp___15 = p;
          printf("\nSTMT_EXEC;;13436\n");
p++;
          printf("\nSTMT_EXEC;;13437\n");
*tmp___14 = (char)*tmp___15;
        }
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;13443\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        printf("\nSTMT_EXEC;;13446\n");
if ((unsigned long)q > (unsigned long)buf)
        {
          printf("\nSTMT_EXEC;;13448\n");
if (!((int)*(q + -1) == 47))
          {
            printf("\nSTMT_EXEC;;13450\n");
goto while_break___1;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;13455\n");
goto while_break___1;
        }
        printf("\nSTMT_EXEC;;13457\n");
q--;
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13461\n");
*q = (char)0;
    printf("\nSTMT_EXEC;;13462\n");
printf("\nFUNC_RETURN;;\n");
return (buf);
  }
printf("\nFUNC_RETURN;;\n");
}
char *xheader_xhdr_name(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;xheader_xhdr_name(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;13467\n");
char *tmp;
  printf("\nSTMT_EXEC;;13468\n");
char *__cil_tmp3;

  {
    printf("\nSTMT_EXEC;;13471\n");
if (!exthdr_name)
    {
      {
        printf("\nSTMT_EXEC;;13474\n");
assign_string(&exthdr_name, "%d/PaxHeaders.%p/%f");
      }
    }
    {
      printf("\nSTMT_EXEC;;13478\n");
tmp = xheader_format_name(st, (char const *)exthdr_name, (_Bool)0);
    }
    printf("\nSTMT_EXEC;;13480\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
char *xheader_ghdr_name(void)
{
  printf("\nFUNC_CALL;xheader_ghdr_name();\n");
printf("\nSTMT_EXEC;;13485\n");
size_t len;
  printf("\nSTMT_EXEC;;13486\n");
char const *tmp;
  printf("\nSTMT_EXEC;;13487\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;13488\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;13489\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;13490\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;13491\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;13492\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;13493\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;13494\n");
char *__cil_tmp10;

  {
    printf("\nSTMT_EXEC;;13497\n");
if (!globexthdr_name)
    {
      {
        printf("\nSTMT_EXEC;;13500\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp___0 = getenv("TMPDIR");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13501\n");
tmp = (char const *)tmp___0;
      }
      printf("\nSTMT_EXEC;;13503\n");
if (!tmp)
      {
        printf("\nSTMT_EXEC;;13505\n");
tmp = "/tmp";
      }
      {
        printf("\nSTMT_EXEC;;13508\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen(tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13509\n");
len = tmp___1 + sizeof("/GlobalHead.%p.%n");
        printf("\nSTMT_EXEC;;13510\n");
tmp___2 = xmalloc(len);
        printf("\nSTMT_EXEC;;13511\n");
globexthdr_name = (char *)tmp___2;
        printf("\nSTMT_EXEC;;13512\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)globexthdr_name, (char const * /* __restrict  */)tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13513\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)globexthdr_name, (char const * /* __restrict  */) "/GlobalHead.%p.%n");printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;13517\n");
tmp___3 = xheader_format_name((struct tar_stat_info *)((void *)0), (char const *)globexthdr_name, (_Bool)1);
    }
    printf("\nSTMT_EXEC;;13519\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___3);
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_write(char type, char *name, struct xheader *xhdr)
{
  printf("\nFUNC_CALL;xheader_write(char,char *,struct xheader *);\n");
printf("\nSTMT_EXEC;;13524\n");
union block *header;
  printf("\nSTMT_EXEC;;13525\n");
size_t size;
  printf("\nSTMT_EXEC;;13526\n");
char *p;
  printf("\nSTMT_EXEC;;13527\n");
size_t len;

  {
    {
      printf("\nSTMT_EXEC;;13531\n");
size = xhdr->size;
      printf("\nSTMT_EXEC;;13532\n");
header = start_private_header((char const *)name, size);
      printf("\nSTMT_EXEC;;13533\n");
header->header.typeflag = type;
      printf("\nSTMT_EXEC;;13534\n");
simple_finish_header(header);
      printf("\nSTMT_EXEC;;13535\n");
p = xhdr->buffer;
    }
    {
      printf("\nSTMT_EXEC;;13538\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;13542\n");
header = find_next_block();
          printf("\nSTMT_EXEC;;13543\n");
len = (size_t)512;
        }
        printf("\nSTMT_EXEC;;13545\n");
if (len > size)
        {
          printf("\nSTMT_EXEC;;13547\n");
len = size;
        }
        {
          printf("\nSTMT_EXEC;;13550\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(header->buffer), (void const * /* __restrict  */)p, len);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;13552\n");
if (len < 512UL)
        {
          {
            printf("\nSTMT_EXEC;;13555\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(header->buffer + len), 0, 512UL - len);printf("\nFUNC_RETURN;;\n");

          }
        }
        {
          printf("\nSTMT_EXEC;;13559\n");
p += len;
          printf("\nSTMT_EXEC;;13560\n");
size -= len;
          printf("\nSTMT_EXEC;;13561\n");
set_next_block_after(header);
        }
        printf("\nSTMT_EXEC;;13563\n");
if (!(size > 0UL))
        {
          printf("\nSTMT_EXEC;;13565\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;13571\n");
xheader_destroy(xhdr);
    }
    printf("\nSTMT_EXEC;;13573\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_write_global(void)
{
  printf("\nFUNC_CALL;xheader_write_global();\n");
printf("\nSTMT_EXEC;;13578\n");
char *name;
  printf("\nSTMT_EXEC;;13579\n");
struct keyword_list *kp;

  {
    printf("\nSTMT_EXEC;;13582\n");
if (!keyword_global_override_list)
    {
      printf("\nSTMT_EXEC;;13584\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;13587\n");
extended_header_init();
      printf("\nSTMT_EXEC;;13588\n");
kp = keyword_global_override_list;
    }
    {
      printf("\nSTMT_EXEC;;13591\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13594\n");
if (!kp)
        {
          printf("\nSTMT_EXEC;;13596\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;13599\n");
code_string((char const *)kp->value, (char const *)kp->pattern, &extended_header);
          printf("\nSTMT_EXEC;;13600\n");
kp = kp->next;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;13606\n");
xheader_finish(&extended_header);
      printf("\nSTMT_EXEC;;13607\n");
name = xheader_ghdr_name();
      printf("\nSTMT_EXEC;;13608\n");
xheader_write((char)'g', name, &extended_header);
      printf("\nSTMT_EXEC;;13609\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;13610\n");
global_header_count++;
    }
    printf("\nSTMT_EXEC;;13612\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
struct xhdr_tab const xhdr_tab[17];
static struct xhdr_tab const *locate_handler(char const *keyword)
{
  printf("\nFUNC_CALL;locate_handler(const char *);\n");
printf("\nSTMT_EXEC;;13618\n");
struct xhdr_tab const *p;
  printf("\nSTMT_EXEC;;13619\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;13622\n");
p = xhdr_tab;
    {
      printf("\nSTMT_EXEC;;13624\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13627\n");
if (!p->keyword)
        {
          printf("\nSTMT_EXEC;;13629\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;13632\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)p->keyword, keyword);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;13634\n");
if (tmp == 0)
        {
          printf("\nSTMT_EXEC;;13636\n");
printf("\nFUNC_RETURN;;\n");
return (p);
        }
        printf("\nSTMT_EXEC;;13638\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13642\n");
printf("\nFUNC_RETURN;;\n");
return ((struct xhdr_tab const *)((void *)0));
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool xheader_protected_pattern_p(char const *pattern)
{
  printf("\nFUNC_CALL;xheader_protected_pattern_p(const char *);\n");
printf("\nSTMT_EXEC;;13647\n");
struct xhdr_tab const *p;
  printf("\nSTMT_EXEC;;13648\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;13651\n");
p = xhdr_tab;
    {
      printf("\nSTMT_EXEC;;13653\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13656\n");
if (!p->keyword)
        {
          printf("\nSTMT_EXEC;;13658\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;13660\n");
if (p->protect)
        {
          {
            printf("\nSTMT_EXEC;;13663\n");
printf("\nFUNC_CALL;fnmatch(const char *,const char *,int);\n");
tmp = fnmatch(pattern, (char const *)p->keyword, 0);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;13665\n");
if (tmp == 0)
          {
            printf("\nSTMT_EXEC;;13667\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
          }
        }
        printf("\nSTMT_EXEC;;13670\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13674\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool xheader_protected_keyword_p(char const *keyword)
{
  printf("\nFUNC_CALL;xheader_protected_keyword_p(const char *);\n");
printf("\nSTMT_EXEC;;13679\n");
struct xhdr_tab const *p;
  printf("\nSTMT_EXEC;;13680\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;13683\n");
p = xhdr_tab;
    {
      printf("\nSTMT_EXEC;;13685\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13688\n");
if (!p->keyword)
        {
          printf("\nSTMT_EXEC;;13690\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;13692\n");
if (p->protect)
        {
          {
            printf("\nSTMT_EXEC;;13695\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)p->keyword, keyword);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;13697\n");
if (tmp == 0)
          {
            printf("\nSTMT_EXEC;;13699\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
          }
        }
        printf("\nSTMT_EXEC;;13702\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13706\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool decode_record(char **p, void (*handler)(void *, char const *, char const *), void *data)
{
  printf("\nFUNC_CALL;decode_record(char **,void (*)(void *, const char *, const char *),void *);\n");
printf("\nSTMT_EXEC;;13711\n");
size_t len;
  printf("\nSTMT_EXEC;;13712\n");
char const *keyword;
  printf("\nSTMT_EXEC;;13713\n");
char *start;
  printf("\nSTMT_EXEC;;13714\n");
char endc;
  printf("\nSTMT_EXEC;;13715\n");
char *tmp;
  printf("\nSTMT_EXEC;;13716\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;13717\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;13718\n");
char *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;13721\n");
start = *p;
    printf("\nSTMT_EXEC;;13722\n");
if ((int)*(*p) == 0)
    {
      printf("\nSTMT_EXEC;;13724\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;13727\n");
printf("\nFUNC_CALL;strtoul(const char *__restrict,char **__restrict,int);\n");
len = strtoul((char const * /* __restrict  */) * p, (char ** /* __restrict  */)p, 10);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;13729\n");
if ((int)*(*p) != 32)
    {
      {
        printf("\nSTMT_EXEC;;13732\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Malformed extended header: missing whitespace after the length");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13733\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13734\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;13736\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;13738\n");
(*p)++;
    printf("\nSTMT_EXEC;;13739\n");
keyword = (char const *)*p;
    {
      printf("\nSTMT_EXEC;;13741\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13744\n");
if (!((unsigned long)*p < (unsigned long)(start + len)))
        {
          printf("\nSTMT_EXEC;;13746\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;13748\n");
if ((int)*(*p) == 61)
        {
          printf("\nSTMT_EXEC;;13750\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;13752\n");
(*p)++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13756\n");
if ((int)*(*p) != 61)
    {
      {
        printf("\nSTMT_EXEC;;13759\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("Malformed extended header: missing equal sign");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13760\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;13761\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;13763\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;13766\n");
*(*p) = (char)0;
      printf("\nSTMT_EXEC;;13767\n");
endc = *(start + (len - 1UL));
      printf("\nSTMT_EXEC;;13768\n");
*(start + (len - 1UL)) = (char)0;
      printf("\nSTMT_EXEC;;13769\n");
(*handler)(data, keyword, (char const *)(*p + 1));
      printf("\nSTMT_EXEC;;13770\n");
*(start + (len - 1UL)) = endc;
      printf("\nSTMT_EXEC;;13771\n");
*(*p) = (char)'=';
      printf("\nSTMT_EXEC;;13772\n");
*p = start + len;
    }
    printf("\nSTMT_EXEC;;13774\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static void run_override_list(struct keyword_list *kp, struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;run_override_list(struct keyword_list *,struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;13779\n");
struct xhdr_tab const *t;
  printf("\nSTMT_EXEC;;13780\n");
struct xhdr_tab const *tmp;

  {
    {
      printf("\nSTMT_EXEC;;13784\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;13787\n");
if (!kp)
        {
          printf("\nSTMT_EXEC;;13789\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;13792\n");
tmp = locate_handler((char const *)kp->pattern);
          printf("\nSTMT_EXEC;;13793\n");
t = tmp;
        }
        printf("\nSTMT_EXEC;;13795\n");
if (t)
        {
          {
            printf("\nSTMT_EXEC;;13798\n");
(*(t->decoder))(st, (char const *)kp->value);
          }
        }
        printf("\nSTMT_EXEC;;13801\n");
kp = kp->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;13805\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void decx(void *data, char const *keyword, char const *value)
{
  printf("\nFUNC_CALL;decx(void *,const char *,const char *);\n");
printf("\nSTMT_EXEC;;13810\n");
struct xhdr_tab const *t;
  printf("\nSTMT_EXEC;;13811\n");
struct tar_stat_info *st;
  printf("\nSTMT_EXEC;;13812\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;13813\n");
_Bool tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;13817\n");
st = (struct tar_stat_info *)data;
      printf("\nSTMT_EXEC;;13818\n");
tmp = xheader_keyword_deleted_p(keyword);
    }
    printf("\nSTMT_EXEC;;13820\n");
if (tmp)
    {
      printf("\nSTMT_EXEC;;13822\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;13827\n");
tmp___0 = xheader_keyword_override_p(keyword);
      }
      printf("\nSTMT_EXEC;;13829\n");
if (tmp___0)
      {
        printf("\nSTMT_EXEC;;13831\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    {
      printf("\nSTMT_EXEC;;13835\n");
t = locate_handler(keyword);
    }
    printf("\nSTMT_EXEC;;13837\n");
if (t)
    {
      {
        printf("\nSTMT_EXEC;;13840\n");
(*(t->decoder))(st, value);
      }
    }
    printf("\nSTMT_EXEC;;13843\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_decode(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;xheader_decode(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;13848\n");
char *p;
  printf("\nSTMT_EXEC;;13849\n");
char *endp;
  printf("\nSTMT_EXEC;;13850\n");
_Bool tmp;

  {
    {
      printf("\nSTMT_EXEC;;13854\n");
run_override_list(keyword_global_override_list, st);
      printf("\nSTMT_EXEC;;13855\n");
run_override_list(global_header_override_list, st);
    }
    printf("\nSTMT_EXEC;;13857\n");
if (extended_header.size)
    {
      printf("\nSTMT_EXEC;;13859\n");
p = extended_header.buffer + 512;
      printf("\nSTMT_EXEC;;13860\n");
endp = extended_header.buffer + (extended_header.size - 1UL);
      {
        printf("\nSTMT_EXEC;;13862\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;13865\n");
if (!((unsigned long)p < (unsigned long)endp))
          {
            printf("\nSTMT_EXEC;;13867\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;13870\n");
tmp = decode_record(&p, &decx, (void *)st);
          }
          printf("\nSTMT_EXEC;;13872\n");
if (!tmp)
          {
            printf("\nSTMT_EXEC;;13874\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;13881\n");
run_override_list(keyword_override_list, st);
    }
    printf("\nSTMT_EXEC;;13883\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void decg(void *data, char const *keyword, char const *value)
{
  printf("\nFUNC_CALL;decg(void *,const char *,const char *);\n");
printf("\nSTMT_EXEC;;13888\n");
struct keyword_list **kwl;

  {
    {
      printf("\nSTMT_EXEC;;13892\n");
kwl = (struct keyword_list **)data;
      printf("\nSTMT_EXEC;;13893\n");
xheader_list_append(kwl, keyword, value);
    }
    printf("\nSTMT_EXEC;;13895\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_decode_global(void)
{
  printf("\nFUNC_CALL;xheader_decode_global();\n");
printf("\nSTMT_EXEC;;13900\n");
char *p;
  printf("\nSTMT_EXEC;;13901\n");
char *endp;
  printf("\nSTMT_EXEC;;13902\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;13905\n");
if (extended_header.size)
    {
      {
        printf("\nSTMT_EXEC;;13908\n");
p = extended_header.buffer + 512;
        printf("\nSTMT_EXEC;;13909\n");
endp = extended_header.buffer + (extended_header.size - 1UL);
        printf("\nSTMT_EXEC;;13910\n");
xheader_list_destroy(&global_header_override_list);
      }
      {
        printf("\nSTMT_EXEC;;13913\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;13916\n");
if (!((unsigned long)p < (unsigned long)endp))
          {
            printf("\nSTMT_EXEC;;13918\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;13921\n");
tmp = decode_record(&p, &decg, (void *)(&global_header_override_list));
          }
          printf("\nSTMT_EXEC;;13923\n");
if (!tmp)
          {
            printf("\nSTMT_EXEC;;13925\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;13931\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void extended_header_init(void)
{
  printf("\nFUNC_CALL;extended_header_init();\n");
printf("\nSTMT_EXEC;;13936\n");
void *tmp;

  {
    printf("\nSTMT_EXEC;;13939\n");
if (!extended_header.stk)
    {
      {
        printf("\nSTMT_EXEC;;13942\n");
tmp = xmalloc(sizeof(*(extended_header.stk)));
        printf("\nSTMT_EXEC;;13943\n");
extended_header.stk = (struct obstack *)tmp;
        printf("\nSTMT_EXEC;;13944\n");
printf("\nFUNC_CALL;_obstack_begin(struct obstack *,int,int,void *(*)(long),void (*)(void *));\n");
_obstack_begin(extended_header.stk, 0, 0, (void *(*)(long))(&xmalloc), (void (*)(void *))(&free));printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;13947\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_store(char const *keyword, struct tar_stat_info const *st, void *data)
{
  printf("\nFUNC_CALL;xheader_store(const char *,const struct tar_stat_info *,void *);\n");
printf("\nSTMT_EXEC;;13952\n");
struct xhdr_tab const *t;
  printf("\nSTMT_EXEC;;13953\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;13954\n");
_Bool tmp___0;

  {
    printf("\nSTMT_EXEC;;13957\n");
if (extended_header.buffer)
    {
      printf("\nSTMT_EXEC;;13959\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;13962\n");
t = locate_handler(keyword);
    }
    printf("\nSTMT_EXEC;;13964\n");
if (!t)
    {
      printf("\nSTMT_EXEC;;13966\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;13969\n");
tmp = xheader_keyword_deleted_p(keyword);
    }
    printf("\nSTMT_EXEC;;13971\n");
if (tmp)
    {
      printf("\nSTMT_EXEC;;13973\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;13978\n");
tmp___0 = xheader_keyword_override_p(keyword);
      }
      printf("\nSTMT_EXEC;;13980\n");
if (tmp___0)
      {
        printf("\nSTMT_EXEC;;13982\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    {
      printf("\nSTMT_EXEC;;13986\n");
extended_header_init();
      printf("\nSTMT_EXEC;;13987\n");
(*(t->coder))(st, keyword, &extended_header, data);
    }
    printf("\nSTMT_EXEC;;13989\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_read(union block *p, size_t size)
{
  printf("\nFUNC_CALL;xheader_read(union block *,size_t);\n");
printf("\nSTMT_EXEC;;13994\n");
size_t j;
  printf("\nSTMT_EXEC;;13995\n");
size_t nblocks;
  printf("\nSTMT_EXEC;;13996\n");
void *tmp;
  printf("\nSTMT_EXEC;;13997\n");
size_t len;

  {
    {
      printf("\nSTMT_EXEC;;14001\n");
j = (size_t)0;
      printf("\nSTMT_EXEC;;14002\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)extended_header.buffer);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14003\n");
size += 512UL;
      printf("\nSTMT_EXEC;;14004\n");
extended_header.size = size;
      printf("\nSTMT_EXEC;;14005\n");
nblocks = ((size + 512UL) - 1UL) / 512UL;
      printf("\nSTMT_EXEC;;14006\n");
tmp = xmalloc(size + 1UL);
      printf("\nSTMT_EXEC;;14007\n");
extended_header.buffer = (char *)tmp;
    }
    {
      printf("\nSTMT_EXEC;;14010\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;14013\n");
len = size;
        printf("\nSTMT_EXEC;;14014\n");
if (len > 512UL)
        {
          printf("\nSTMT_EXEC;;14016\n");
len = (size_t)512;
        }
        {
          printf("\nSTMT_EXEC;;14019\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(extended_header.buffer + j), (void const * /* __restrict  */)(p->buffer), len);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;14020\n");
set_next_block_after(p);
          printf("\nSTMT_EXEC;;14021\n");
p = find_next_block();
          printf("\nSTMT_EXEC;;14022\n");
j += len;
          printf("\nSTMT_EXEC;;14023\n");
size -= len;
        }
        printf("\nSTMT_EXEC;;14025\n");
if (!(size > 0UL))
        {
          printf("\nSTMT_EXEC;;14027\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;14032\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static size_t format_uintmax(uintmax_t val, char *buf, size_t s)
{
  printf("\nFUNC_CALL;format_uintmax(uintmax_t,char *,size_t);\n");
printf("\nSTMT_EXEC;;14037\n");
char *p;
  printf("\nSTMT_EXEC;;14038\n");
char *tmp;
  printf("\nSTMT_EXEC;;14039\n");
char *tmp___0;

  {
    printf("\nSTMT_EXEC;;14042\n");
if (!buf)
    {
      printf("\nSTMT_EXEC;;14044\n");
s = (size_t)0;
      {
        printf("\nSTMT_EXEC;;14046\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;14049\n");
s++;
          printf("\nSTMT_EXEC;;14050\n");
val /= 10UL;
          printf("\nSTMT_EXEC;;14051\n");
if (!(val != 0UL))
          {
            printf("\nSTMT_EXEC;;14053\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;14061\n");
p = (buf + s) - 1;
      {
        printf("\nSTMT_EXEC;;14063\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;14066\n");
tmp = p;
          printf("\nSTMT_EXEC;;14067\n");
p--;
          printf("\nSTMT_EXEC;;14068\n");
*tmp = (char)(val % 10UL + 48UL);
          printf("\nSTMT_EXEC;;14069\n");
val /= 10UL;
          printf("\nSTMT_EXEC;;14070\n");
if (!(val != 0UL))
          {
            printf("\nSTMT_EXEC;;14072\n");
goto while_break___0;
          }
        }
      while_break___0: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;14078\n");
while (1)
        {
        while_continue___1: /* CIL Label */;
          printf("\nSTMT_EXEC;;14081\n");
if (!((unsigned long)p >= (unsigned long)buf))
          {
            printf("\nSTMT_EXEC;;14083\n");
goto while_break___1;
          }
          printf("\nSTMT_EXEC;;14085\n");
tmp___0 = p;
          printf("\nSTMT_EXEC;;14086\n");
p--;
          printf("\nSTMT_EXEC;;14087\n");
*tmp___0 = (char)'0';
        }
      while_break___1: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;14092\n");
printf("\nFUNC_RETURN;;\n");
return (s);
  }
printf("\nFUNC_RETURN;;\n");
}
static void xheader_print(struct xheader *xhdr, char const *keyword, char const *value)
{
  printf("\nFUNC_CALL;xheader_print(struct xheader *,const char *,const char *);\n");
printf("\nSTMT_EXEC;;14097\n");
size_t len;
  printf("\nSTMT_EXEC;;14098\n");
size_t tmp;
  printf("\nSTMT_EXEC;;14099\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;14100\n");
size_t p;
  printf("\nSTMT_EXEC;;14101\n");
size_t n;
  printf("\nSTMT_EXEC;;14102\n");
char nbuf[100];
  printf("\nSTMT_EXEC;;14103\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;14104\n");
int __len;
  printf("\nSTMT_EXEC;;14105\n");
struct obstack *__o___0;
  printf("\nSTMT_EXEC;;14106\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;14107\n");
struct obstack *__o___1;
  printf("\nSTMT_EXEC;;14108\n");
int __len___0;
  printf("\nSTMT_EXEC;;14109\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;14110\n");
struct obstack *__o___2;
  printf("\nSTMT_EXEC;;14111\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;14112\n");
struct obstack *__o___3;
  printf("\nSTMT_EXEC;;14113\n");
int __len___1;
  printf("\nSTMT_EXEC;;14114\n");
size_t tmp___4;
  printf("\nSTMT_EXEC;;14115\n");
struct obstack *__o___4;
  printf("\nSTMT_EXEC;;14116\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;14117\n");
void *__cil_tmp24;

  {
    {
      printf("\nSTMT_EXEC;;14121\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(keyword);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14122\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(value);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14123\n");
len = (tmp + tmp___0) + 3UL;
      printf("\nSTMT_EXEC;;14124\n");
n = (size_t)0;
    }
    {
      printf("\nSTMT_EXEC;;14127\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;14131\n");
p = n;
          printf("\nSTMT_EXEC;;14132\n");
n = format_uintmax(len + p, (char *)((void *)0), (size_t)0);
        }
        printf("\nSTMT_EXEC;;14134\n");
if (!(n != p))
        {
          printf("\nSTMT_EXEC;;14136\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;14142\n");
format_uintmax(len + n, nbuf, n);
      printf("\nSTMT_EXEC;;14143\n");
__o = xhdr->stk;
      printf("\nSTMT_EXEC;;14144\n");
__len = (int)n;
    }
    printf("\nSTMT_EXEC;;14146\n");
if ((unsigned long)(__o->next_free + __len) > (unsigned long)__o->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14149\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o, __len);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;14153\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)__o->next_free, (void const * /* __restrict  */)(nbuf), (size_t)__len);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14154\n");
__o->next_free += __len;
      printf("\nSTMT_EXEC;;14155\n");
__o___0 = xhdr->stk;
    }
    printf("\nSTMT_EXEC;;14157\n");
if ((unsigned long)(__o___0->next_free + 1) > (unsigned long)__o___0->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14160\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___0, 1);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;14164\n");
tmp___1 = __o___0->next_free;
      printf("\nSTMT_EXEC;;14165\n");
(__o___0->next_free)++;
      printf("\nSTMT_EXEC;;14166\n");
*tmp___1 = (char)' ';
      printf("\nSTMT_EXEC;;14167\n");
__o___1 = xhdr->stk;
      printf("\nSTMT_EXEC;;14168\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen(keyword);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14169\n");
__len___0 = (int)tmp___2;
    }
    printf("\nSTMT_EXEC;;14171\n");
if ((unsigned long)(__o___1->next_free + __len___0) > (unsigned long)__o___1->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14174\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___1, __len___0);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;14178\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)__o___1->next_free, (void const * /* __restrict  */)keyword, (size_t)__len___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14179\n");
__o___1->next_free += __len___0;
      printf("\nSTMT_EXEC;;14180\n");
__o___2 = xhdr->stk;
    }
    printf("\nSTMT_EXEC;;14182\n");
if ((unsigned long)(__o___2->next_free + 1) > (unsigned long)__o___2->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14185\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___2, 1);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;14189\n");
tmp___3 = __o___2->next_free;
      printf("\nSTMT_EXEC;;14190\n");
(__o___2->next_free)++;
      printf("\nSTMT_EXEC;;14191\n");
*tmp___3 = (char)'=';
      printf("\nSTMT_EXEC;;14192\n");
__o___3 = xhdr->stk;
      printf("\nSTMT_EXEC;;14193\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___4 = strlen(value);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14194\n");
__len___1 = (int)tmp___4;
    }
    printf("\nSTMT_EXEC;;14196\n");
if ((unsigned long)(__o___3->next_free + __len___1) > (unsigned long)__o___3->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14199\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___3, __len___1);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;14203\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)__o___3->next_free, (void const * /* __restrict  */)value, (size_t)__len___1);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14204\n");
__o___3->next_free += __len___1;
      printf("\nSTMT_EXEC;;14205\n");
__o___4 = xhdr->stk;
    }
    printf("\nSTMT_EXEC;;14207\n");
if ((unsigned long)(__o___4->next_free + 1) > (unsigned long)__o___4->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14210\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___4, 1);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;14213\n");
tmp___5 = __o___4->next_free;
    printf("\nSTMT_EXEC;;14214\n");
(__o___4->next_free)++;
    printf("\nSTMT_EXEC;;14215\n");
*tmp___5 = (char)'\n';
    printf("\nSTMT_EXEC;;14216\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_finish(struct xheader *xhdr)
{
  printf("\nFUNC_CALL;xheader_finish(struct xheader *);\n");
printf("\nSTMT_EXEC;;14221\n");
struct keyword_list *kp;
  printf("\nSTMT_EXEC;;14222\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;14223\n");
char *tmp;
  printf("\nSTMT_EXEC;;14224\n");
struct obstack *__o1;
  printf("\nSTMT_EXEC;;14225\n");
void *value;

  {
    printf("\nSTMT_EXEC;;14228\n");
kp = keyword_override_list;
    {
      printf("\nSTMT_EXEC;;14230\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;14233\n");
if (!kp)
        {
          printf("\nSTMT_EXEC;;14235\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;14238\n");
code_string((char const *)kp->value, (char const *)kp->pattern, xhdr);
          printf("\nSTMT_EXEC;;14239\n");
kp = kp->next;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;14244\n");
__o = xhdr->stk;
    printf("\nSTMT_EXEC;;14245\n");
if ((unsigned long)(__o->next_free + 1) > (unsigned long)__o->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;14248\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o, 1);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;14251\n");
tmp = __o->next_free;
    printf("\nSTMT_EXEC;;14252\n");
(__o->next_free)++;
    printf("\nSTMT_EXEC;;14253\n");
*tmp = (char)0;
    printf("\nSTMT_EXEC;;14254\n");
__o1 = xhdr->stk;
    printf("\nSTMT_EXEC;;14255\n");
value = (void *)__o1->object_base;
    printf("\nSTMT_EXEC;;14256\n");
if ((unsigned long)__o1->next_free == (unsigned long)value)
    {
      printf("\nSTMT_EXEC;;14258\n");
__o1->maybe_empty_object = 1U;
    }
    printf("\nSTMT_EXEC;;14260\n");
__o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long)__o1->alignment_mask) & (long)(~__o1->alignment_mask));
    printf("\nSTMT_EXEC;;14261\n");
if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk)
    {
      printf("\nSTMT_EXEC;;14263\n");
__o1->next_free = __o1->chunk_limit;
    }
    {
      printf("\nSTMT_EXEC;;14266\n");
__o1->object_base = __o1->next_free;
      printf("\nSTMT_EXEC;;14267\n");
xhdr->buffer = (char *)value;
      printf("\nSTMT_EXEC;;14268\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
xhdr->size = strlen((char const *)xhdr->buffer);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;14270\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void xheader_destroy(struct xheader *xhdr)
{
  printf("\nFUNC_CALL;xheader_destroy(struct xheader *);\n");
printf("\nSTMT_EXEC;;14275\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;14276\n");
void *__obj;
  printf("\nSTMT_EXEC;;14277\n");
char *tmp;

  {
    printf("\nSTMT_EXEC;;14280\n");
if (xhdr->stk)
    {
      printf("\nSTMT_EXEC;;14282\n");
__o = xhdr->stk;
      printf("\nSTMT_EXEC;;14283\n");
__obj = (void *)0;
      printf("\nSTMT_EXEC;;14284\n");
if ((unsigned long)__obj > (unsigned long)((void *)__o->chunk))
      {
        printf("\nSTMT_EXEC;;14286\n");
if ((unsigned long)__obj < (unsigned long)((void *)__o->chunk_limit))
        {
          printf("\nSTMT_EXEC;;14288\n");
tmp = (char *)__obj;
          printf("\nSTMT_EXEC;;14289\n");
__o->object_base = tmp;
          printf("\nSTMT_EXEC;;14290\n");
__o->next_free = tmp;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;14295\n");
printf("\nFUNC_CALL;obstack_free(struct obstack *,void *);\n");
obstack_free(__o, __obj);printf("\nFUNC_RETURN;;\n");

          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;14302\n");
printf("\nFUNC_CALL;obstack_free(struct obstack *,void *);\n");
obstack_free(__o, __obj);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;14306\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)xhdr->stk);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14307\n");
xhdr->stk = (struct obstack *)((void *)0);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;14313\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)xhdr->buffer);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;14316\n");
xhdr->buffer = (char *)0;
    printf("\nSTMT_EXEC;;14317\n");
xhdr->size = (size_t)0;
    printf("\nSTMT_EXEC;;14318\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void code_string(char const *string, char const *keyword, struct xheader *xhdr)
{
  printf("\nFUNC_CALL;code_string(const char *,const char *,struct xheader *);\n");
printf("\nSTMT_EXEC;;14323\n");
char *outstr;
  printf("\nSTMT_EXEC;;14324\n");
_Bool tmp;

  {
    {
      printf("\nSTMT_EXEC;;14328\n");
tmp = utf8_convert((_Bool)1, string, &outstr);
    }
    printf("\nSTMT_EXEC;;14330\n");
if (!tmp)
    {
      {
        printf("\nSTMT_EXEC;;14333\n");
outstr = xstrdup(string);
      }
    }
    {
      printf("\nSTMT_EXEC;;14337\n");
xheader_print(xhdr, keyword, (char const *)outstr);
      printf("\nSTMT_EXEC;;14338\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)outstr);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;14340\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void decode_string(char **string, char const *arg)
{
  printf("\nFUNC_CALL;decode_string(char **,const char *);\n");
printf("\nSTMT_EXEC;;14345\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;14348\n");
if (*string)
    {
      {
        printf("\nSTMT_EXEC;;14351\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)*string);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14352\n");
*string = (char *)((void *)0);
      }
    }
    {
      printf("\nSTMT_EXEC;;14356\n");
tmp = utf8_convert((_Bool)0, arg, string);
    }
    printf("\nSTMT_EXEC;;14358\n");
if (!tmp)
    {
      {
        printf("\nSTMT_EXEC;;14361\n");
assign_string(string, arg);
      }
    }
    printf("\nSTMT_EXEC;;14364\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void code_time(time_t t, unsigned long nano, char const *keyword, struct xheader *xhdr)
{
  printf("\nFUNC_CALL;code_time(time_t,unsigned long,const char *,struct xheader *);\n");
printf("\nSTMT_EXEC;;14369\n");
char sbuf[200];
  printf("\nSTMT_EXEC;;14370\n");
size_t s;
  printf("\nSTMT_EXEC;;14371\n");
size_t tmp;
  printf("\nSTMT_EXEC;;14372\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;14373\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;14374\n");
void *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;14378\n");
tmp = format_uintmax((uintmax_t)t, (char *)((void *)0), (size_t)0);
      printf("\nSTMT_EXEC;;14379\n");
s = tmp;
    }
    printf("\nSTMT_EXEC;;14381\n");
if (s + 11UL >= sizeof(sbuf))
    {
      printf("\nSTMT_EXEC;;14383\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;14386\n");
format_uintmax((uintmax_t)t, sbuf, s);
      printf("\nSTMT_EXEC;;14387\n");
tmp___0 = s;
      printf("\nSTMT_EXEC;;14388\n");
s++;
      printf("\nSTMT_EXEC;;14389\n");
sbuf[tmp___0] = (char)'.';
      printf("\nSTMT_EXEC;;14390\n");
tmp___1 = format_uintmax(nano, sbuf + s, (size_t)9);
      printf("\nSTMT_EXEC;;14391\n");
s += tmp___1;
      printf("\nSTMT_EXEC;;14392\n");
sbuf[s] = (char)0;
      printf("\nSTMT_EXEC;;14393\n");
xheader_print(xhdr, keyword, (char const *)(sbuf));
    }
    printf("\nSTMT_EXEC;;14395\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void decode_time(char const *arg, time_t *secs, unsigned long *nsecs)
{
  printf("\nFUNC_CALL;decode_time(const char *,time_t *,unsigned long *);\n");
printf("\nSTMT_EXEC;;14400\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14401\n");
char *p;
  printf("\nSTMT_EXEC;;14402\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;14403\n");
strtol_error tmp___0;
  printf("\nSTMT_EXEC;;14404\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;14405\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;14409\n");
tmp___0 = xstrtoumax(arg, &p, 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14411\n");
if ((unsigned int)tmp___0 == 0U)
    {
      printf("\nSTMT_EXEC;;14413\n");
*secs = (time_t)u;
      printf("\nSTMT_EXEC;;14414\n");
if ((int)*p == 46)
      {
        {
          printf("\nSTMT_EXEC;;14417\n");
tmp = xstrtoumax((char const *)(p + 1), (char **)((void *)0), 10, &u, "");
        }
        printf("\nSTMT_EXEC;;14419\n");
if ((unsigned int)tmp == 0U)
        {
          printf("\nSTMT_EXEC;;14421\n");
*nsecs = u;
        }
      }
    }
    printf("\nSTMT_EXEC;;14425\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void code_num(uintmax_t value, char const *keyword, struct xheader *xhdr)
{
  printf("\nFUNC_CALL;code_num(uintmax_t,const char *,struct xheader *);\n");
printf("\nSTMT_EXEC;;14430\n");
char sbuf[100];
  printf("\nSTMT_EXEC;;14431\n");
size_t s;
  printf("\nSTMT_EXEC;;14432\n");
size_t tmp;
  printf("\nSTMT_EXEC;;14433\n");
void *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;14437\n");
tmp = format_uintmax(value, (char *)((void *)0), (size_t)0);
      printf("\nSTMT_EXEC;;14438\n");
s = tmp;
      printf("\nSTMT_EXEC;;14439\n");
format_uintmax(value, sbuf, s);
      printf("\nSTMT_EXEC;;14440\n");
sbuf[s] = (char)0;
      printf("\nSTMT_EXEC;;14441\n");
xheader_print(xhdr, keyword, (char const *)(sbuf));
    }
    printf("\nSTMT_EXEC;;14443\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void dummy_coder(struct tar_stat_info const *st __attribute__((__unused__)), char const *keyword __attribute__((__unused__)), struct xheader *xhdr __attribute__((__unused__)), void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;dummy_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    printf("\nSTMT_EXEC;;14450\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void dummy_decoder(struct tar_stat_info *st __attribute__((__unused__)), char const *arg __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;dummy_decoder(struct tar_stat_info *,const char *);\n");
{
    printf("\nSTMT_EXEC;;14457\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void atime_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;atime_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14465\n");
code_time((time_t)st->stat.st_atim.tv_sec, (unsigned long)st->atime_nsec, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14467\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void atime_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;atime_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14475\n");
decode_time(arg, &st->stat.st_atim.tv_sec, &st->atime_nsec);
    }
    printf("\nSTMT_EXEC;;14477\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void gid_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;gid_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14485\n");
code_num((uintmax_t)st->stat.st_gid, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14487\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void gid_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;gid_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14492\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14493\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;14494\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;14498\n");
tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14500\n");
if ((unsigned int)tmp == 0U)
    {
      printf("\nSTMT_EXEC;;14502\n");
st->stat.st_gid = (__gid_t)u;
    }
    printf("\nSTMT_EXEC;;14504\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void gname_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;gname_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14512\n");
code_string((char const *)st->gname, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14514\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void gname_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;gname_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14522\n");
decode_string(&st->gname, arg);
    }
    printf("\nSTMT_EXEC;;14524\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void linkpath_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;linkpath_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14532\n");
code_string((char const *)st->link_name, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14534\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void linkpath_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;linkpath_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14542\n");
decode_string(&st->link_name, arg);
    }
    printf("\nSTMT_EXEC;;14544\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void ctime_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;ctime_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14552\n");
code_time((time_t)st->stat.st_ctim.tv_sec, (unsigned long)st->ctime_nsec, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14554\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void ctime_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;ctime_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14562\n");
decode_time(arg, &st->stat.st_ctim.tv_sec, &st->ctime_nsec);
    }
    printf("\nSTMT_EXEC;;14564\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void mtime_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;mtime_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14572\n");
code_time((time_t)st->stat.st_mtim.tv_sec, (unsigned long)st->mtime_nsec, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14574\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void mtime_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;mtime_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14582\n");
decode_time(arg, &st->stat.st_mtim.tv_sec, &st->mtime_nsec);
    }
    printf("\nSTMT_EXEC;;14584\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void path_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;path_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14592\n");
code_string((char const *)st->file_name, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14594\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void path_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;path_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14602\n");
decode_string(&st->orig_file_name, arg);
      printf("\nSTMT_EXEC;;14603\n");
decode_string(&st->file_name, arg);
      printf("\nSTMT_EXEC;;14604\n");
st->had_trailing_slash = strip_trailing_slashes(st->file_name);
    }
    printf("\nSTMT_EXEC;;14606\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void size_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;size_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14614\n");
code_num((uintmax_t)st->stat.st_size, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14616\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void size_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;size_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14621\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14622\n");
__off_t tmp;
  printf("\nSTMT_EXEC;;14623\n");
strtol_error tmp___0;
  printf("\nSTMT_EXEC;;14624\n");
char *__cil_tmp6;

  {
    {
      printf("\nSTMT_EXEC;;14628\n");
tmp___0 = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14630\n");
if ((unsigned int)tmp___0 == 0U)
    {
      printf("\nSTMT_EXEC;;14632\n");
tmp = (__off_t)u;
      printf("\nSTMT_EXEC;;14633\n");
st->stat.st_size = tmp;
      printf("\nSTMT_EXEC;;14634\n");
st->archive_file_size = tmp;
    }
    printf("\nSTMT_EXEC;;14636\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void uid_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;uid_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14644\n");
code_num((uintmax_t)st->stat.st_uid, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14646\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void uid_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;uid_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14651\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14652\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;14653\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;14657\n");
tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14659\n");
if ((unsigned int)tmp == 0U)
    {
      printf("\nSTMT_EXEC;;14661\n");
st->stat.st_uid = (__uid_t)u;
    }
    printf("\nSTMT_EXEC;;14663\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void uname_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;uname_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14671\n");
code_string((char const *)st->uname, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14673\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void uname_decoder(struct tar_stat_info *st, char const *arg)
{

  printf("\nFUNC_CALL;uname_decoder(struct tar_stat_info *,const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;14681\n");
decode_string(&st->uname, arg);
    }
    printf("\nSTMT_EXEC;;14683\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_size_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data)
{

  printf("\nFUNC_CALL;sparse_size_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14691\n");
size_coder(st, keyword, xhdr, data);
    }
    printf("\nSTMT_EXEC;;14693\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_size_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;sparse_size_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14698\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14699\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;14700\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;14704\n");
tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14706\n");
if ((unsigned int)tmp == 0U)
    {
      printf("\nSTMT_EXEC;;14708\n");
st->stat.st_size = (__off_t)u;
    }
    printf("\nSTMT_EXEC;;14710\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_numblocks_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;sparse_numblocks_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
{
    {
      printf("\nSTMT_EXEC;;14718\n");
code_num((uintmax_t)st->sparse_map_avail, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14720\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_numblocks_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;sparse_numblocks_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14725\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14726\n");
void *tmp;
  printf("\nSTMT_EXEC;;14727\n");
strtol_error tmp___0;
  printf("\nSTMT_EXEC;;14728\n");
char *__cil_tmp6;

  {
    {
      printf("\nSTMT_EXEC;;14732\n");
tmp___0 = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14734\n");
if ((unsigned int)tmp___0 == 0U)
    {
      {
        printf("\nSTMT_EXEC;;14737\n");
st->sparse_map_size = u;
        printf("\nSTMT_EXEC;;14738\n");
printf("\nFUNC_CALL;calloc(size_t,size_t);\n");
tmp = calloc(st->sparse_map_size, sizeof(*(st->sparse_map + 0)));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14739\n");
st->sparse_map = (struct sp_array *)tmp;
        printf("\nSTMT_EXEC;;14740\n");
st->sparse_map_avail = (size_t)0;
      }
    }
    printf("\nSTMT_EXEC;;14743\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_offset_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data)
{
  printf("\nFUNC_CALL;sparse_offset_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
printf("\nSTMT_EXEC;;14748\n");
size_t i;

  {
    {
      printf("\nSTMT_EXEC;;14752\n");
i = *((size_t *)data);
      printf("\nSTMT_EXEC;;14753\n");
code_num((uintmax_t)(st->sparse_map + i)->offset, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14755\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_offset_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;sparse_offset_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14760\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14761\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;14762\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;14766\n");
tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14768\n");
if ((unsigned int)tmp == 0U)
    {
      printf("\nSTMT_EXEC;;14770\n");
(st->sparse_map + st->sparse_map_avail)->offset = (off_t)u;
    }
    printf("\nSTMT_EXEC;;14772\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_numbytes_coder(struct tar_stat_info const *st, char const *keyword, struct xheader *xhdr, void *data)
{
  printf("\nFUNC_CALL;sparse_numbytes_coder(const struct tar_stat_info *,const char *,struct xheader *,void *);\n");
printf("\nSTMT_EXEC;;14777\n");
size_t i;

  {
    {
      printf("\nSTMT_EXEC;;14781\n");
i = *((size_t *)data);
      printf("\nSTMT_EXEC;;14782\n");
code_num((st->sparse_map + i)->numbytes, keyword, xhdr);
    }
    printf("\nSTMT_EXEC;;14784\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_numbytes_decoder(struct tar_stat_info *st, char const *arg)
{
  printf("\nFUNC_CALL;sparse_numbytes_decoder(struct tar_stat_info *,const char *);\n");
printf("\nSTMT_EXEC;;14789\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;14790\n");
void *tmp;
  printf("\nSTMT_EXEC;;14791\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;14792\n");
strtol_error tmp___1;
  printf("\nSTMT_EXEC;;14793\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;14797\n");
tmp___1 = xstrtoumax(arg, (char **)((void *)0), 10, &u, "");
    }
    printf("\nSTMT_EXEC;;14799\n");
if ((unsigned int)tmp___1 == 0U)
    {
      printf("\nSTMT_EXEC;;14801\n");
if (st->sparse_map_avail == st->sparse_map_size)
      {
        {
          printf("\nSTMT_EXEC;;14804\n");
st->sparse_map_size *= 2UL;
          printf("\nSTMT_EXEC;;14805\n");
tmp = xrealloc((void *)st->sparse_map, st->sparse_map_size * sizeof(*(st->sparse_map + 0)));
          printf("\nSTMT_EXEC;;14806\n");
st->sparse_map = (struct sp_array *)tmp;
        }
      }
      printf("\nSTMT_EXEC;;14809\n");
tmp___0 = st->sparse_map_avail;
      printf("\nSTMT_EXEC;;14810\n");
(st->sparse_map_avail)++;
      printf("\nSTMT_EXEC;;14811\n");
(st->sparse_map + tmp___0)->numbytes = u;
    }
    printf("\nSTMT_EXEC;;14813\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
struct xhdr_tab const xhdr_tab[17] = {{"atime", &atime_coder, &atime_decoder, (_Bool)0}, {"comment", &dummy_coder, &dummy_decoder, (_Bool)0}, {"charset", &dummy_coder, &dummy_decoder, (_Bool)0}, {"ctime", &ctime_coder, &ctime_decoder, (_Bool)0}, {"gid", &gid_coder, &gid_decoder, (_Bool)0}, {"gname", &gname_coder, &gname_decoder, (_Bool)0}, {"linkpath", &linkpath_coder, &linkpath_decoder, (_Bool)0}, {"mtime", &mtime_coder, &mtime_decoder, (_Bool)0}, {"path", &path_coder, &path_decoder, (_Bool)0}, {"size", &size_coder, &size_decoder, (_Bool)0}, {"uid", &uid_coder, &uid_decoder, (_Bool)0}, {"uname", &uname_coder, &uname_decoder, (_Bool)0}, {"GNU.sparse.size", &sparse_size_coder, &sparse_size_decoder, (_Bool)1}, {"GNU.sparse.numblocks", &sparse_numblocks_coder, &sparse_numblocks_decoder, (_Bool)1}, {"GNU.sparse.offset", &sparse_offset_coder, &sparse_offset_decoder, (_Bool)1}, {"GNU.sparse.numbytes", &sparse_numbytes_coder, &sparse_numbytes_decoder, (_Bool)1}, {(char const *)((void *)0), (void (*)(struct tar_stat_info const *, char const *, struct xheader *, void *data))((void *)0), (void (*)(struct tar_stat_info *, char const *))((void *)0), (_Bool)0}};
/* #pragma merger("0","006.incremen.o.i","") */
extern void(__attribute__((__nonnull__(1, 4))) qsort)(void *__base, size_t __nmemb, size_t __size, int (*__compar)(void const *, void const *));
extern __attribute__((__nothrow__)) FILE *(__attribute__((__leaf__)) fdopen)(int __fd, char const *__modes);
extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
extern int fseek(FILE *__stream, long __off, int __whence);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fileno)(FILE *__stream);
size_t hash_do_for_each(Hash_table const *table___0, _Bool (*processor)(void *, void *), void *processor_data);
size_t hash_string(char const *string, size_t n_buckets);
char const *program_name;
void read_directory_file(void);
char *quote_copy_string(char const *string);
int unquote_string(char *string);
void savedir_error(char const *name);
void seek_error(char const *name);
void truncate_error(char const *name);
char *new_name(char const *path, char const *name);
static Hash_table *directory_table;
static unsigned int hash_directory(void const *entry, unsigned int n_buckets)
{
  printf("\nFUNC_CALL;hash_directory(const void *,unsigned int);\n");
printf("\nSTMT_EXEC;;14836\n");
struct directory const *directory;
  printf("\nSTMT_EXEC;;14837\n");
size_t tmp;

  {
    {
      printf("\nSTMT_EXEC;;14841\n");
directory = (struct directory const *)entry;
      printf("\nSTMT_EXEC;;14842\n");
tmp = hash_string((char const *)(directory->name), (size_t)n_buckets);
    }
    printf("\nSTMT_EXEC;;14844\n");
printf("\nFUNC_RETURN;;\n");
return ((unsigned int)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool compare_directories(void const *entry1, void const *entry2)
{
  printf("\nFUNC_CALL;compare_directories(const void *,const void *);\n");
printf("\nSTMT_EXEC;;14849\n");
struct directory const *directory1;
  printf("\nSTMT_EXEC;;14850\n");
struct directory const *directory2;
  printf("\nSTMT_EXEC;;14851\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;14855\n");
directory1 = (struct directory const *)entry1;
      printf("\nSTMT_EXEC;;14856\n");
directory2 = (struct directory const *)entry2;
      printf("\nSTMT_EXEC;;14857\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)(directory1->name), (char const *)(directory2->name));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;14859\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(tmp == 0));
  }
printf("\nFUNC_RETURN;;\n");
}
static struct directory *note_directory(char const *name, dev_t dev, ino_t ino, _Bool nfs, _Bool found)
{
  printf("\nFUNC_CALL;note_directory(const char *,dev_t,ino_t,_Bool,_Bool);\n");
printf("\nSTMT_EXEC;;14864\n");
size_t size;
  printf("\nSTMT_EXEC;;14865\n");
size_t tmp;
  printf("\nSTMT_EXEC;;14866\n");
struct directory *directory;
  printf("\nSTMT_EXEC;;14867\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;14868\n");
void *tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;14872\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;14873\n");
size = ((unsigned long)(&((struct directory *)0)->name) + tmp) + 1UL;
      printf("\nSTMT_EXEC;;14874\n");
tmp___0 = xmalloc(size);
      printf("\nSTMT_EXEC;;14875\n");
directory = (struct directory *)tmp___0;
      printf("\nSTMT_EXEC;;14876\n");
directory->device_number = dev;
      printf("\nSTMT_EXEC;;14877\n");
directory->inode_number = ino;
      printf("\nSTMT_EXEC;;14878\n");
directory->children = (enum children)1;
      printf("\nSTMT_EXEC;;14879\n");
directory->nfs = nfs;
      printf("\nSTMT_EXEC;;14880\n");
directory->found = found;
      printf("\nSTMT_EXEC;;14881\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(directory->name), (char const * /* __restrict  */)name);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;14883\n");
if (directory_table)
    {
      printf("\nSTMT_EXEC;;14885\n");
goto _L;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;14890\n");
directory_table = hash_initialize((size_t)0, (Hash_tuning const *)0, (size_t(*)(void const *, size_t))(&hash_directory), &compare_directories, (void (*)(void *))0);
      }
      printf("\nSTMT_EXEC;;14892\n");
if (directory_table)
      {
      _L:
      {
        printf("\nSTMT_EXEC;;14896\n");
tmp___1 = hash_insert(directory_table, (void const *)directory);
      }
        printf("\nSTMT_EXEC;;14898\n");
if (!tmp___1)
        {
          {
            printf("\nSTMT_EXEC;;14901\n");
xalloc_die();
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;14908\n");
xalloc_die();
        }
      }
    }
    printf("\nSTMT_EXEC;;14912\n");
printf("\nFUNC_RETURN;;\n");
return (directory);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct directory *find_directory(char *name)
{
  printf("\nFUNC_CALL;find_directory(char *);\n");
printf("\nSTMT_EXEC;;14917\n");
size_t size;
  printf("\nSTMT_EXEC;;14918\n");
size_t tmp;
  printf("\nSTMT_EXEC;;14919\n");
struct directory *dir;
  printf("\nSTMT_EXEC;;14920\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;14921\n");
void *tmp___1;

  {
    printf("\nSTMT_EXEC;;14924\n");
if (!directory_table)
    {
      printf("\nSTMT_EXEC;;14926\n");
printf("\nFUNC_RETURN;;\n");
return ((struct directory *)0);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;14931\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen((char const *)name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14932\n");
size = ((unsigned long)(&((struct directory *)0)->name) + tmp) + 1UL;
        printf("\nSTMT_EXEC;;14933\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___0 = __builtin_alloca(size);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14934\n");
dir = (struct directory *)tmp___0;
        printf("\nSTMT_EXEC;;14935\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(dir->name), (char const * /* __restrict  */)name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;14936\n");
tmp___1 = hash_lookup((Hash_table const *)directory_table, (void const *)dir);
      }
      printf("\nSTMT_EXEC;;14938\n");
printf("\nFUNC_RETURN;;\n");
return ((struct directory *)tmp___1);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static int compare_dirents(void const *first, void const *second)
{
  printf("\nFUNC_CALL;compare_dirents(const void *,const void *);\n");
printf("\nSTMT_EXEC;;14944\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;14948\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)(*((char *const *)first) + 1), (char const *)(*((char *const *)second) + 1));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;14950\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static void scan_path(struct obstack *stk, char *path, dev_t device)
{
  printf("\nFUNC_CALL;scan_path(struct obstack *,char *,dev_t);\n");
printf("\nSTMT_EXEC;;14955\n");
char *dirp;
  printf("\nSTMT_EXEC;;14956\n");
char *tmp;
  printf("\nSTMT_EXEC;;14957\n");
char const *entry;
  printf("\nSTMT_EXEC;;14958\n");
size_t entrylen;
  printf("\nSTMT_EXEC;;14959\n");
char *name_buffer___0;
  printf("\nSTMT_EXEC;;14960\n");
size_t name_buffer_size;
  printf("\nSTMT_EXEC;;14961\n");
size_t name_length;
  printf("\nSTMT_EXEC;;14962\n");
struct directory *directory;
  printf("\nSTMT_EXEC;;14963\n");
enum children children;
  printf("\nSTMT_EXEC;;14964\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;14965\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;14966\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;14967\n");
size_t tmp___3;
  printf("\nSTMT_EXEC;;14968\n");
void *tmp___4;
  printf("\nSTMT_EXEC;;14969\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;14970\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;14971\n");
struct stat stat_data;
  printf("\nSTMT_EXEC;;14972\n");
int tmp___6;
  printf("\nSTMT_EXEC;;14973\n");
_Bool nfs;
  printf("\nSTMT_EXEC;;14974\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;14975\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;14976\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;14977\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;14978\n");
struct obstack *__o___0;
  printf("\nSTMT_EXEC;;14979\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;14980\n");
struct obstack *__o___1;
  printf("\nSTMT_EXEC;;14981\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;14982\n");
struct obstack *__o___2;
  printf("\nSTMT_EXEC;;14983\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;14984\n");
struct obstack *__o___3;
  printf("\nSTMT_EXEC;;14985\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;14986\n");
_Bool tmp___15;
  printf("\nSTMT_EXEC;;14987\n");
struct obstack *__o___4;
  printf("\nSTMT_EXEC;;14988\n");
int __len;
  printf("\nSTMT_EXEC;;14989\n");
struct obstack *__o___5;
  printf("\nSTMT_EXEC;;14990\n");
int __len___0;
  printf("\nSTMT_EXEC;;14991\n");
unsigned int tmp___16;
  printf("\nSTMT_EXEC;;14992\n");
int tmp___17;
  printf("\nSTMT_EXEC;;14993\n");
void *__cil_tmp42;
  printf("\nSTMT_EXEC;;14994\n");
char *__cil_tmp43;
  printf("\nSTMT_EXEC;;14995\n");
char *__cil_tmp44;
  printf("\nSTMT_EXEC;;14996\n");
char *__cil_tmp45;
  printf("\nSTMT_EXEC;;14997\n");
char *__cil_tmp46;

  {
    {
      printf("\nSTMT_EXEC;;15001\n");
tmp = savedir((char const *)path);
      printf("\nSTMT_EXEC;;15002\n");
dirp = tmp;
    }
    printf("\nSTMT_EXEC;;15004\n");
if (!dirp)
    {
      {
        printf("\nSTMT_EXEC;;15007\n");
savedir_error((char const *)path);
      }
    }
    {
      printf("\nSTMT_EXEC;;15011\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15012\n");
*tmp___0 = 0;
      printf("\nSTMT_EXEC;;15013\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)path);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15014\n");
name_buffer_size = tmp___1 + 100UL;
      printf("\nSTMT_EXEC;;15015\n");
tmp___2 = xmalloc(name_buffer_size + 2UL);
      printf("\nSTMT_EXEC;;15016\n");
name_buffer___0 = (char *)tmp___2;
      printf("\nSTMT_EXEC;;15017\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)name_buffer___0, (char const * /* __restrict  */)path);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15018\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___3 = strlen((char const *)path);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15020\n");
if (!((int)*(path + (tmp___3 - 1UL)) == 47))
    {
      {
        printf("\nSTMT_EXEC;;15023\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)name_buffer___0, (char const * /* __restrict  */) "/");printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;15027\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
name_length = strlen((char const *)name_buffer___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15028\n");
directory = find_directory(path);
    }
    printf("\nSTMT_EXEC;;15030\n");
if (directory)
    {
      printf("\nSTMT_EXEC;;15032\n");
tmp___16 = (unsigned int)directory->children;
    }
    else
    {
      printf("\nSTMT_EXEC;;15036\n");
tmp___16 = 1U;
    }
    printf("\nSTMT_EXEC;;15038\n");
children = (enum children)tmp___16;
    printf("\nSTMT_EXEC;;15039\n");
if (dirp)
    {
      printf("\nSTMT_EXEC;;15041\n");
if ((unsigned int)children != 0U)
      {
        printf("\nSTMT_EXEC;;15043\n");
entry = (char const *)dirp;
        {
          printf("\nSTMT_EXEC;;15045\n");
while (1)
          {
          while_continue: /* CIL Label */;
            {
              printf("\nSTMT_EXEC;;15049\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
entrylen = strlen(entry);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;15051\n");
if (!(entrylen != 0UL))
            {
              printf("\nSTMT_EXEC;;15053\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;15055\n");
if (name_buffer_size <= entrylen + name_length)
            {
              {
                printf("\nSTMT_EXEC;;15058\n");
while (1)
                {
                while_continue___0: /* CIL Label */;
                  printf("\nSTMT_EXEC;;15061\n");
name_buffer_size += 100UL;
                  printf("\nSTMT_EXEC;;15062\n");
if (!(name_buffer_size <= entrylen + name_length))
                  {
                    printf("\nSTMT_EXEC;;15064\n");
goto while_break___0;
                  }
                }
              while_break___0: /* CIL Label */;
              }
              {
                printf("\nSTMT_EXEC;;15070\n");
tmp___4 = xrealloc((void *)name_buffer___0, name_buffer_size + 2UL);
                printf("\nSTMT_EXEC;;15071\n");
name_buffer___0 = (char *)tmp___4;
              }
            }
            {
              printf("\nSTMT_EXEC;;15075\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(name_buffer___0 + name_length), (char const * /* __restrict  */)entry);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15076\n");
tmp___15 = excluded_name((char const *)name_buffer___0);
            }
            printf("\nSTMT_EXEC;;15078\n");
if (tmp___15)
            {
              printf("\nSTMT_EXEC;;15080\n");
__o = stk;
              printf("\nSTMT_EXEC;;15081\n");
if ((unsigned long)(__o->next_free + 1) > (unsigned long)__o->chunk_limit)
              {
                {
                  printf("\nSTMT_EXEC;;15084\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o, 1);printf("\nFUNC_RETURN;;\n");

                }
              }
              printf("\nSTMT_EXEC;;15087\n");
tmp___5 = __o->next_free;
              printf("\nSTMT_EXEC;;15088\n");
(__o->next_free)++;
              printf("\nSTMT_EXEC;;15089\n");
*tmp___5 = (char)'N';
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;15094\n");
tmp___6 = deref_stat(dereference_option, (char const *)name_buffer___0, &stat_data);
              }
              printf("\nSTMT_EXEC;;15096\n");
if (tmp___6)
              {
                {
                  printf("\nSTMT_EXEC;;15099\n");
stat_diag((char const *)name_buffer___0);
                }
                printf("\nSTMT_EXEC;;15101\n");
goto __Cont;
              }
              printf("\nSTMT_EXEC;;15103\n");
if ((stat_data.st_mode & 61440U) == 16384U)
              {
                {
                  printf("\nSTMT_EXEC;;15106\n");
nfs = (_Bool)((stat_data.st_dev & (0xffffffffffffffffUL << (sizeof(stat_data.st_dev) * 8UL - 1UL))) != 0UL);
                  printf("\nSTMT_EXEC;;15107\n");
directory = find_directory(name_buffer___0);
                }
                printf("\nSTMT_EXEC;;15109\n");
if ((unsigned long)directory != (unsigned long)((void *)0))
                {
                  printf("\nSTMT_EXEC;;15111\n");
if ((int)directory->nfs & (int)nfs)
                  {
                    printf("\nSTMT_EXEC;;15113\n");
goto _L___4;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;15117\n");
if (directory->device_number == stat_data.st_dev)
                    {
                    _L___4: /* CIL Label */
                      {
printf("\nSTMT_EXEC;;15120\n");
if (!(directory->inode_number == stat_data.st_ino))
                      {
                        printf("\nSTMT_EXEC;;15122\n");
goto _L___3;
                      }
}

                    }
                    else
                    {
                    _L___3: /* CIL Label */
                      {
printf("\nSTMT_EXEC;;15128\n");
if (verbose_option)
                      {
                        {
                          printf("\nSTMT_EXEC;;15131\n");
tmp___7 = quotearg_colon((char const *)name_buffer___0);
                          printf("\nSTMT_EXEC;;15132\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("%s: Directory has been renamed");printf("\nFUNC_RETURN;;\n");

                          printf("\nSTMT_EXEC;;15133\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8, tmp___7);printf("\nFUNC_RETURN;;\n");

                        }
                      }
}

                      printf("\nSTMT_EXEC;;15136\n");
directory->children = (enum children)2;
                      printf("\nSTMT_EXEC;;15137\n");
directory->nfs = nfs;
                      printf("\nSTMT_EXEC;;15138\n");
directory->device_number = stat_data.st_dev;
                      printf("\nSTMT_EXEC;;15139\n");
directory->inode_number = stat_data.st_ino;
                    }
                  }
                  printf("\nSTMT_EXEC;;15142\n");
directory->found = (_Bool)1;
                }
                else
                {
                  printf("\nSTMT_EXEC;;15146\n");
if (verbose_option)
                  {
                    {
                      printf("\nSTMT_EXEC;;15149\n");
tmp___9 = quotearg_colon((char const *)name_buffer___0);
                      printf("\nSTMT_EXEC;;15150\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___10 = gettext("%s: Directory is new");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;15151\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___10, tmp___9);printf("\nFUNC_RETURN;;\n");

                    }
                  }
                  {
                    printf("\nSTMT_EXEC;;15155\n");
directory = note_directory((char const *)name_buffer___0, stat_data.st_dev, stat_data.st_ino, nfs, (_Bool)1);
                  }
                  printf("\nSTMT_EXEC;;15157\n");
if (listed_incremental_option)
                  {
                    printf("\nSTMT_EXEC;;15159\n");
tmp___17 = 2;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;15163\n");
if (stat_data.st_mtim.tv_sec < newer_mtime_option.tv_sec)
                    {
                      printf("\nSTMT_EXEC;;15165\n");
tmp___17 = 2;
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;15169\n");
if (stat_data.st_mtim.tv_sec == newer_mtime_option.tv_sec)
                      {
                        printf("\nSTMT_EXEC;;15171\n");
if (stat_data.st_mtim.tv_nsec < newer_mtime_option.tv_nsec)
                        {
                          printf("\nSTMT_EXEC;;15173\n");
tmp___17 = 2;
                        }
                        else
                        {
                          printf("\nSTMT_EXEC;;15177\n");
goto _L___5;
                        }
                      }
                      else
                      {
                      _L___5: /* CIL Label */
                        {
printf("\nSTMT_EXEC;;15183\n");
if (after_date_option)
                        {
                          printf("\nSTMT_EXEC;;15185\n");
if (stat_data.st_ctim.tv_sec < newer_mtime_option.tv_sec)
                          {
                            printf("\nSTMT_EXEC;;15187\n");
tmp___17 = 2;
                          }
                          else
                          {
                            printf("\nSTMT_EXEC;;15191\n");
if (stat_data.st_ctim.tv_sec == newer_mtime_option.tv_sec)
                            {
                              printf("\nSTMT_EXEC;;15193\n");
if (stat_data.st_ctim.tv_nsec < newer_mtime_option.tv_nsec)
                              {
                                printf("\nSTMT_EXEC;;15195\n");
tmp___17 = 2;
                              }
                              else
                              {
                                printf("\nSTMT_EXEC;;15199\n");
tmp___17 = 1;
                              }
                            }
                            else
                            {
                              printf("\nSTMT_EXEC;;15204\n");
tmp___17 = 1;
                            }
                          }
                        }
                        else
                        {
                          printf("\nSTMT_EXEC;;15210\n");
tmp___17 = 1;
                        }
}

                      }
                    }
                  }
                  printf("\nSTMT_EXEC;;15215\n");
directory->children = (enum children)tmp___17;
                }
                printf("\nSTMT_EXEC;;15217\n");
if (one_file_system_option)
                {
                  printf("\nSTMT_EXEC;;15219\n");
if (device != stat_data.st_dev)
                  {
                    printf("\nSTMT_EXEC;;15221\n");
directory->children = (enum children)0;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;15225\n");
goto _L___6;
                  }
                }
                else
                {
                _L___6: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;15231\n");
if ((unsigned int)children == 2U)
                  {
                    printf("\nSTMT_EXEC;;15233\n");
directory->children = (enum children)2;
                  }
}

                }
                printf("\nSTMT_EXEC;;15236\n");
__o___0 = stk;
                printf("\nSTMT_EXEC;;15237\n");
if ((unsigned long)(__o___0->next_free + 1) > (unsigned long)__o___0->chunk_limit)
                {
                  {
                    printf("\nSTMT_EXEC;;15240\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___0, 1);printf("\nFUNC_RETURN;;\n");

                  }
                }
                printf("\nSTMT_EXEC;;15243\n");
tmp___11 = __o___0->next_free;
                printf("\nSTMT_EXEC;;15244\n");
(__o___0->next_free)++;
                printf("\nSTMT_EXEC;;15245\n");
*tmp___11 = (char)'D';
              }
              else
              {
                printf("\nSTMT_EXEC;;15249\n");
if (one_file_system_option)
                {
                  printf("\nSTMT_EXEC;;15251\n");
if (device != stat_data.st_dev)
                  {
                    printf("\nSTMT_EXEC;;15253\n");
__o___1 = stk;
                    printf("\nSTMT_EXEC;;15254\n");
if ((unsigned long)(__o___1->next_free + 1) > (unsigned long)__o___1->chunk_limit)
                    {
                      {
                        printf("\nSTMT_EXEC;;15257\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___1, 1);printf("\nFUNC_RETURN;;\n");

                      }
                    }
                    printf("\nSTMT_EXEC;;15260\n");
tmp___12 = __o___1->next_free;
                    printf("\nSTMT_EXEC;;15261\n");
(__o___1->next_free)++;
                    printf("\nSTMT_EXEC;;15262\n");
*tmp___12 = (char)'N';
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;15266\n");
goto _L___12;
                  }
                }
                else
                {
                _L___12: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;15272\n");
if ((unsigned int)children == 1U)
                  {
                    printf("\nSTMT_EXEC;;15274\n");
if (stat_data.st_mtim.tv_sec < newer_mtime_option.tv_sec)
                    {
                      printf("\nSTMT_EXEC;;15276\n");
goto _L___11;
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;15280\n");
if (stat_data.st_mtim.tv_sec == newer_mtime_option.tv_sec)
                      {
                        printf("\nSTMT_EXEC;;15282\n");
if (stat_data.st_mtim.tv_nsec < newer_mtime_option.tv_nsec)
                        {
                        _L___11: /* CIL Label */
                          {
printf("\nSTMT_EXEC;;15285\n");
if (!after_date_option)
                          {
                            printf("\nSTMT_EXEC;;15287\n");
goto _L___9;
                          }
                          else
                          {
                            printf("\nSTMT_EXEC;;15291\n");
if (stat_data.st_ctim.tv_sec < newer_mtime_option.tv_sec)
                            {
                              printf("\nSTMT_EXEC;;15293\n");
goto _L___9;
                            }
                            else
                            {
                              printf("\nSTMT_EXEC;;15297\n");
if (stat_data.st_ctim.tv_sec == newer_mtime_option.tv_sec)
                              {
                                printf("\nSTMT_EXEC;;15299\n");
if (stat_data.st_ctim.tv_nsec < newer_mtime_option.tv_nsec)
                                {
                                _L___9: /* CIL Label */
                                  {
printf("\nSTMT_EXEC;;15302\n");
__o___2 = stk;
}

                                  printf("\nSTMT_EXEC;;15303\n");
if ((unsigned long)(__o___2->next_free + 1) > (unsigned long)__o___2->chunk_limit)
                                  {
                                    {
                                      printf("\nSTMT_EXEC;;15306\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___2, 1);printf("\nFUNC_RETURN;;\n");

                                    }
                                  }
                                  printf("\nSTMT_EXEC;;15309\n");
tmp___13 = __o___2->next_free;
                                  printf("\nSTMT_EXEC;;15310\n");
(__o___2->next_free)++;
                                  printf("\nSTMT_EXEC;;15311\n");
*tmp___13 = (char)'N';
                                }
                                else
                                {
                                  printf("\nSTMT_EXEC;;15315\n");
goto _L___10;
                                }
                              }
                              else
                              {
                                printf("\nSTMT_EXEC;;15320\n");
goto _L___10;
                              }
                            }
                          }
}

                        }
                        else
                        {
                          printf("\nSTMT_EXEC;;15327\n");
goto _L___10;
                        }
                      }
                      else
                      {
                        printf("\nSTMT_EXEC;;15332\n");
goto _L___10;
                      }
                    }
                  }
                  else
                  {
                  _L___10: /* CIL Label */
                    {
printf("\nSTMT_EXEC;;15339\n");
__o___3 = stk;
}

                    printf("\nSTMT_EXEC;;15340\n");
if ((unsigned long)(__o___3->next_free + 1) > (unsigned long)__o___3->chunk_limit)
                    {
                      {
                        printf("\nSTMT_EXEC;;15343\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___3, 1);printf("\nFUNC_RETURN;;\n");

                      }
                    }
                    printf("\nSTMT_EXEC;;15346\n");
tmp___14 = __o___3->next_free;
                    printf("\nSTMT_EXEC;;15347\n");
(__o___3->next_free)++;
                    printf("\nSTMT_EXEC;;15348\n");
*tmp___14 = (char)'Y';
                  }
}

                }
              }
            }
            printf("\nSTMT_EXEC;;15353\n");
__o___4 = stk;
            printf("\nSTMT_EXEC;;15354\n");
__len = (int)(entrylen + 1UL);
            printf("\nSTMT_EXEC;;15355\n");
if ((unsigned long)(__o___4->next_free + __len) > (unsigned long)__o___4->chunk_limit)
            {
              {
                printf("\nSTMT_EXEC;;15358\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___4, __len);printf("\nFUNC_RETURN;;\n");

              }
            }
            {
              printf("\nSTMT_EXEC;;15362\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)__o___4->next_free, (void const * /* __restrict  */)entry, (size_t)__len);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15363\n");
__o___4->next_free += __len;
            }
          __Cont:
            {
printf("\nSTMT_EXEC;;15366\n");
entry += entrylen + 1UL;
}

          }
        while_break: /* CIL Label */;
        }
      }
    }
    printf("\nSTMT_EXEC;;15372\n");
__o___5 = stk;
    printf("\nSTMT_EXEC;;15373\n");
__len___0 = 2;
    printf("\nSTMT_EXEC;;15374\n");
if ((unsigned long)(__o___5->next_free + __len___0) > (unsigned long)__o___5->chunk_limit)
    {
      {
        printf("\nSTMT_EXEC;;15377\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o___5, __len___0);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;15381\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)__o___5->next_free, (void const * /* __restrict  */) "\000\000", (size_t)__len___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15382\n");
__o___5->next_free += __len___0;
      printf("\nSTMT_EXEC;;15383\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_buffer___0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15385\n");
if (dirp)
    {
      {
        printf("\nSTMT_EXEC;;15388\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)dirp);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;15391\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static char *sort_obstack(struct obstack *stk)
{
  printf("\nFUNC_CALL;sort_obstack(struct obstack *);\n");
printf("\nSTMT_EXEC;;15396\n");
char *pointer;
  printf("\nSTMT_EXEC;;15397\n");
struct obstack *__o1;
  printf("\nSTMT_EXEC;;15398\n");
void *value;
  printf("\nSTMT_EXEC;;15399\n");
size_t counter;
  printf("\nSTMT_EXEC;;15400\n");
char *cursor;
  printf("\nSTMT_EXEC;;15401\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;15402\n");
char **array;
  printf("\nSTMT_EXEC;;15403\n");
char **array_cursor;
  printf("\nSTMT_EXEC;;15404\n");
size_t tmp;
  printf("\nSTMT_EXEC;;15405\n");
struct obstack *__h;
  printf("\nSTMT_EXEC;;15406\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;15407\n");
int __len;
  printf("\nSTMT_EXEC;;15408\n");
struct obstack *__o1___0;
  printf("\nSTMT_EXEC;;15409\n");
void *value___0;
  printf("\nSTMT_EXEC;;15410\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;15411\n");
char **tmp___1;
  printf("\nSTMT_EXEC;;15412\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;15413\n");
char *string;
  printf("\nSTMT_EXEC;;15414\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;15415\n");
char tmp___4;
  printf("\nSTMT_EXEC;;15416\n");
char *tmp___5;

  {
    printf("\nSTMT_EXEC;;15419\n");
__o1 = stk;
    printf("\nSTMT_EXEC;;15420\n");
value = (void *)__o1->object_base;
    printf("\nSTMT_EXEC;;15421\n");
if ((unsigned long)__o1->next_free == (unsigned long)value)
    {
      printf("\nSTMT_EXEC;;15423\n");
__o1->maybe_empty_object = 1U;
    }
    printf("\nSTMT_EXEC;;15425\n");
__o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long)__o1->alignment_mask) & (long)(~__o1->alignment_mask));
    printf("\nSTMT_EXEC;;15426\n");
if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk)
    {
      printf("\nSTMT_EXEC;;15428\n");
__o1->next_free = __o1->chunk_limit;
    }
    printf("\nSTMT_EXEC;;15430\n");
__o1->object_base = __o1->next_free;
    printf("\nSTMT_EXEC;;15431\n");
pointer = (char *)value;
    printf("\nSTMT_EXEC;;15432\n");
counter = (size_t)0;
    printf("\nSTMT_EXEC;;15433\n");
cursor = pointer;
    {
      printf("\nSTMT_EXEC;;15435\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;15438\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;15440\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;15443\n");
counter++;
          printf("\nSTMT_EXEC;;15444\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen((char const *)cursor);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;15445\n");
cursor += tmp + 1UL;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;15450\n");
if (!counter)
    {
      printf("\nSTMT_EXEC;;15452\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)((void *)0));
    }
    printf("\nSTMT_EXEC;;15454\n");
__h = stk;
    printf("\nSTMT_EXEC;;15455\n");
__o = __h;
    printf("\nSTMT_EXEC;;15456\n");
__len = (int)(sizeof(char *) * (counter + 1UL));
    printf("\nSTMT_EXEC;;15457\n");
if (__o->chunk_limit - __o->next_free < (long)__len)
    {
      {
        printf("\nSTMT_EXEC;;15460\n");
printf("\nFUNC_CALL;_obstack_newchunk(struct obstack *,int);\n");
_obstack_newchunk(__o, __len);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;15463\n");
__o->next_free += __len;
    printf("\nSTMT_EXEC;;15464\n");
__o1___0 = __h;
    printf("\nSTMT_EXEC;;15465\n");
value___0 = (void *)__o1___0->object_base;
    printf("\nSTMT_EXEC;;15466\n");
if ((unsigned long)__o1___0->next_free == (unsigned long)value___0)
    {
      printf("\nSTMT_EXEC;;15468\n");
__o1___0->maybe_empty_object = 1U;
    }
    printf("\nSTMT_EXEC;;15470\n");
__o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long)__o1___0->alignment_mask) & (long)(~__o1___0->alignment_mask));
    printf("\nSTMT_EXEC;;15471\n");
if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk)
    {
      printf("\nSTMT_EXEC;;15473\n");
__o1___0->next_free = __o1___0->chunk_limit;
    }
    printf("\nSTMT_EXEC;;15475\n");
__o1___0->object_base = __o1___0->next_free;
    printf("\nSTMT_EXEC;;15476\n");
array = (char **)value___0;
    printf("\nSTMT_EXEC;;15477\n");
array_cursor = array;
    printf("\nSTMT_EXEC;;15478\n");
cursor = pointer;
    {
      printf("\nSTMT_EXEC;;15480\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;15483\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;15485\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;15488\n");
tmp___1 = array_cursor;
          printf("\nSTMT_EXEC;;15489\n");
array_cursor++;
          printf("\nSTMT_EXEC;;15490\n");
*tmp___1 = cursor;
          printf("\nSTMT_EXEC;;15491\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen((char const *)cursor);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;15492\n");
cursor += tmp___0 + 1UL;
        }
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;15498\n");
*array_cursor = (char *)0;
      printf("\nSTMT_EXEC;;15499\n");
printf("\nFUNC_CALL;qsort(void *,size_t,size_t,int (*)(const void *, const void *));\n");
qsort((void *)array, counter, sizeof(char *), &compare_dirents);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15500\n");
tmp___2 = xmalloc((size_t)((cursor - pointer) + 2L));
      printf("\nSTMT_EXEC;;15501\n");
buffer___2 = (char *)tmp___2;
      printf("\nSTMT_EXEC;;15502\n");
cursor = buffer___2;
      printf("\nSTMT_EXEC;;15503\n");
array_cursor = array;
    }
    {
      printf("\nSTMT_EXEC;;15506\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        printf("\nSTMT_EXEC;;15509\n");
if (!*array_cursor)
        {
          printf("\nSTMT_EXEC;;15511\n");
goto while_break___1;
        }
        printf("\nSTMT_EXEC;;15513\n");
string = *array_cursor;
        {
          printf("\nSTMT_EXEC;;15515\n");
while (1)
          {
          while_continue___2: /* CIL Label */;
            printf("\nSTMT_EXEC;;15518\n");
tmp___3 = cursor;
            printf("\nSTMT_EXEC;;15519\n");
cursor++;
            printf("\nSTMT_EXEC;;15520\n");
tmp___5 = string;
            printf("\nSTMT_EXEC;;15521\n");
string++;
            printf("\nSTMT_EXEC;;15522\n");
tmp___4 = *tmp___5;
            printf("\nSTMT_EXEC;;15523\n");
*tmp___3 = tmp___4;
            printf("\nSTMT_EXEC;;15524\n");
if (!tmp___4)
            {
              printf("\nSTMT_EXEC;;15526\n");
goto while_break___2;
            }
            printf("\nSTMT_EXEC;;15528\n");
goto while_continue___2;
          }
        while_break___2: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;15532\n");
array_cursor++;
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;15536\n");
*cursor = (char)'\000';
    printf("\nSTMT_EXEC;;15537\n");
printf("\nFUNC_RETURN;;\n");
return (buffer___2);
  }
printf("\nFUNC_RETURN;;\n");
}
char *get_directory_contents(char *path, dev_t device)
{
  printf("\nFUNC_CALL;get_directory_contents(char *,dev_t);\n");
printf("\nSTMT_EXEC;;15542\n");
struct obstack stk;
  printf("\nSTMT_EXEC;;15543\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;15544\n");
struct obstack *__o;
  printf("\nSTMT_EXEC;;15545\n");
void *__obj;
  printf("\nSTMT_EXEC;;15546\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;15550\n");
printf("\nFUNC_CALL;_obstack_begin(struct obstack *,int,int,void *(*)(long),void (*)(void *));\n");
_obstack_begin(&stk, 0, 0, (void *(*)(long))(&xmalloc), (void (*)(void *))(&free));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;15551\n");
scan_path(&stk, path, device);
      printf("\nSTMT_EXEC;;15552\n");
buffer___2 = sort_obstack(&stk);
      printf("\nSTMT_EXEC;;15553\n");
__o = &stk;
      printf("\nSTMT_EXEC;;15554\n");
__obj = (void *)0;
    }
    printf("\nSTMT_EXEC;;15556\n");
if ((unsigned long)__obj > (unsigned long)((void *)__o->chunk))
    {
      printf("\nSTMT_EXEC;;15558\n");
if ((unsigned long)__obj < (unsigned long)((void *)__o->chunk_limit))
      {
        printf("\nSTMT_EXEC;;15560\n");
tmp = (char *)__obj;
        printf("\nSTMT_EXEC;;15561\n");
__o->object_base = tmp;
        printf("\nSTMT_EXEC;;15562\n");
__o->next_free = tmp;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;15567\n");
printf("\nFUNC_CALL;obstack_free(struct obstack *,void *);\n");
obstack_free(__o, __obj);printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;15574\n");
printf("\nFUNC_CALL;obstack_free(struct obstack *,void *);\n");
obstack_free(__o, __obj);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;15577\n");
printf("\nFUNC_RETURN;;\n");
return (buffer___2);
  }
printf("\nFUNC_RETURN;;\n");
}
static FILE *listed_incremental_stream;
void read_directory_file(void)
{
  printf("\nFUNC_CALL;read_directory_file();\n");
printf("\nSTMT_EXEC;;15583\n");
int fd;
  printf("\nSTMT_EXEC;;15584\n");
FILE *fp;
  printf("\nSTMT_EXEC;;15585\n");
char *buf;
  printf("\nSTMT_EXEC;;15586\n");
size_t bufsize;
  printf("\nSTMT_EXEC;;15587\n");
char *ebuf;
  printf("\nSTMT_EXEC;;15588\n");
int n;
  printf("\nSTMT_EXEC;;15589\n");
long lineno;
  printf("\nSTMT_EXEC;;15590\n");
unsigned long u;
  printf("\nSTMT_EXEC;;15591\n");
int *tmp;
  printf("\nSTMT_EXEC;;15592\n");
unsigned long tmp___0;
  printf("\nSTMT_EXEC;;15593\n");
time_t t;
  printf("\nSTMT_EXEC;;15594\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;15595\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;15596\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;15597\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;15598\n");
int *tmp___5;
  printf("\nSTMT_EXEC;;15599\n");
int *tmp___6;
  printf("\nSTMT_EXEC;;15600\n");
dev_t dev;
  printf("\nSTMT_EXEC;;15601\n");
ino_t ino;
  printf("\nSTMT_EXEC;;15602\n");
_Bool nfs;
  printf("\nSTMT_EXEC;;15603\n");
char *strp;
  printf("\nSTMT_EXEC;;15604\n");
int *tmp___7;
  printf("\nSTMT_EXEC;;15605\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;15606\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;15607\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;15608\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;15609\n");
int *tmp___12;
  printf("\nSTMT_EXEC;;15610\n");
int *tmp___13;
  printf("\nSTMT_EXEC;;15611\n");
int *tmp___14;
  printf("\nSTMT_EXEC;;15612\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;15613\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;15614\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;15615\n");
char *tmp___18;
  printf("\nSTMT_EXEC;;15616\n");
int *tmp___19;
  printf("\nSTMT_EXEC;;15617\n");
int *tmp___20;
  printf("\nSTMT_EXEC;;15618\n");
__ssize_t tmp___21;
  printf("\nSTMT_EXEC;;15619\n");
__ssize_t tmp___22;
  printf("\nSTMT_EXEC;;15620\n");
int tmp___23;
  printf("\nSTMT_EXEC;;15621\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;15622\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;15623\n");
char *__cil_tmp41;
  printf("\nSTMT_EXEC;;15624\n");
char *__cil_tmp42;
  printf("\nSTMT_EXEC;;15625\n");
char *__cil_tmp43;
  printf("\nSTMT_EXEC;;15626\n");
char *__cil_tmp44;
  printf("\nSTMT_EXEC;;15627\n");
char *__cil_tmp45;
  printf("\nSTMT_EXEC;;15628\n");
char *__cil_tmp46;
  printf("\nSTMT_EXEC;;15629\n");
char *__cil_tmp47;
  printf("\nSTMT_EXEC;;15630\n");
char *__cil_tmp48;
  printf("\nSTMT_EXEC;;15631\n");
char *__cil_tmp49;
  printf("\nSTMT_EXEC;;15632\n");
char *__cil_tmp50;

  {
    {
      printf("\nSTMT_EXEC;;15636\n");
buf = (char *)0;
      printf("\nSTMT_EXEC;;15637\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
fd = open(listed_incremental_option, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15639\n");
if (fd < 0)
    {
      {
        printf("\nSTMT_EXEC;;15642\n");
open_error(listed_incremental_option);
      }
      printf("\nSTMT_EXEC;;15644\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;15647\n");
printf("\nFUNC_CALL;fdopen(int,const char *);\n");
fp = fdopen(fd, "r+");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15649\n");
if (!fp)
    {
      {
        printf("\nSTMT_EXEC;;15652\n");
open_error(listed_incremental_option);
        printf("\nSTMT_EXEC;;15653\n");
printf("\nFUNC_CALL;close(int);\n");
close(fd);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;15655\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;15658\n");
listed_incremental_stream = fp;
      printf("\nSTMT_EXEC;;15659\n");
printf("\nFUNC_CALL;getline(char **__restrict,size_t *__restrict,FILE *__restrict);\n");
tmp___22 = getline((char ** /* __restrict  */)(&buf), (size_t * /* __restrict  */)(&bufsize), (FILE * /* __restrict  */) fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15661\n");
if (0L < tmp___22)
    {
      {
        printf("\nSTMT_EXEC;;15664\n");
lineno = 1L;
        printf("\nSTMT_EXEC;;15665\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;15666\n");
*tmp = 0;
        printf("\nSTMT_EXEC;;15667\n");
printf("\nFUNC_CALL;strtoul(const char *__restrict,char **__restrict,int);\n");
tmp___0 = strtoul((char const * /* __restrict  */)buf, (char ** /* __restrict  */)(&ebuf), 10);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;15668\n");
u = tmp___0;
        printf("\nSTMT_EXEC;;15669\n");
t = (time_t)u;
      }
      printf("\nSTMT_EXEC;;15671\n");
if ((unsigned long)buf == (unsigned long)ebuf)
      {
        {
          printf("\nSTMT_EXEC;;15674\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Invalid time stamp");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;15675\n");
tmp___2 = quotearg_colon(listed_incremental_option);
          printf("\nSTMT_EXEC;;15676\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:1: %s", tmp___2, tmp___1);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;15677\n");
exit_status = 2;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;15682\n");
if (u == 0UL)
        {
          {
            printf("\nSTMT_EXEC;;15685\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___6 = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;15687\n");
if (*tmp___6 == 22)
          {
            {
              printf("\nSTMT_EXEC;;15690\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Invalid time stamp");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15691\n");
tmp___2 = quotearg_colon(listed_incremental_option);
              printf("\nSTMT_EXEC;;15692\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:1: %s", tmp___2, tmp___1);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15693\n");
exit_status = 2;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;15698\n");
goto _L;
          }
        }
        else
        {
        _L:
          {
printf("\nSTMT_EXEC;;15704\n");
if ((unsigned long)t != u)
          {
            {
              printf("\nSTMT_EXEC;;15707\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Time stamp out of range");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15708\n");
tmp___4 = quotearg_colon(listed_incremental_option);
              printf("\nSTMT_EXEC;;15709\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:1: %s", tmp___4, tmp___3);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15710\n");
exit_status = 2;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;15715\n");
if (u == 0xffffffffffffffffUL)
            {
              {
                printf("\nSTMT_EXEC;;15718\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___5 = __errno_location();printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;15720\n");
if (*tmp___5 == 34)
              {
                {
                  printf("\nSTMT_EXEC;;15723\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Time stamp out of range");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15724\n");
tmp___4 = quotearg_colon(listed_incremental_option);
                  printf("\nSTMT_EXEC;;15725\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:1: %s", tmp___4, tmp___3);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15726\n");
exit_status = 2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;15731\n");
newer_mtime_option.tv_sec = t;
                printf("\nSTMT_EXEC;;15732\n");
newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;15737\n");
newer_mtime_option.tv_sec = t;
              printf("\nSTMT_EXEC;;15738\n");
newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
            }
          }
}

        }
      }
      {
        printf("\nSTMT_EXEC;;15744\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;15748\n");
printf("\nFUNC_CALL;getline(char **__restrict,size_t *__restrict,FILE *__restrict);\n");
tmp___21 = getline((char ** /* __restrict  */)(&buf), (size_t * /* __restrict  */)(&bufsize), (FILE * /* __restrict  */) fp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;15749\n");
n = (int)tmp___21;
          }
          printf("\nSTMT_EXEC;;15751\n");
if (!(0 < n))
          {
            printf("\nSTMT_EXEC;;15753\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;15755\n");
nfs = (_Bool)((int)*(buf + 0) == 43);
          printf("\nSTMT_EXEC;;15756\n");
strp = buf + (int)nfs;
          printf("\nSTMT_EXEC;;15757\n");
lineno++;
          printf("\nSTMT_EXEC;;15758\n");
if ((int)*(buf + (n - 1)) == 10)
          {
            printf("\nSTMT_EXEC;;15760\n");
*(buf + (n - 1)) = (char)'\000';
          }
          {
            printf("\nSTMT_EXEC;;15763\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___7 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;15764\n");
*tmp___7 = 0;
            printf("\nSTMT_EXEC;;15765\n");
printf("\nFUNC_CALL;strtoul(const char *__restrict,char **__restrict,int);\n");
u = strtoul((char const * /* __restrict  */)strp, (char ** /* __restrict  */)(&ebuf), 10);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;15766\n");
dev = u;
          }
          printf("\nSTMT_EXEC;;15768\n");
if ((unsigned long)strp == (unsigned long)ebuf)
          {
            {
              printf("\nSTMT_EXEC;;15771\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("Invalid device number");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15772\n");
tmp___9 = quotearg_colon(listed_incremental_option);
              printf("\nSTMT_EXEC;;15773\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___9, lineno, tmp___8);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15774\n");
exit_status = 2;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;15779\n");
if (u == 0UL)
            {
              {
                printf("\nSTMT_EXEC;;15782\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___13 = __errno_location();printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;15784\n");
if (*tmp___13 == 22)
              {
                {
                  printf("\nSTMT_EXEC;;15787\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("Invalid device number");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15788\n");
tmp___9 = quotearg_colon(listed_incremental_option);
                  printf("\nSTMT_EXEC;;15789\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___9, lineno, tmp___8);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15790\n");
exit_status = 2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;15795\n");
goto _L___0;
              }
            }
            else
            {
            _L___0:
              {
printf("\nSTMT_EXEC;;15801\n");
if (dev != u)
              {
                {
                  printf("\nSTMT_EXEC;;15804\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___10 = gettext("Device number out of range");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15805\n");
tmp___11 = quotearg_colon(listed_incremental_option);
                  printf("\nSTMT_EXEC;;15806\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___11, lineno, tmp___10);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15807\n");
exit_status = 2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;15812\n");
if (u == 0xffffffffffffffffUL)
                {
                  {
                    printf("\nSTMT_EXEC;;15815\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___12 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;15817\n");
if (*tmp___12 == 34)
                  {
                    {
                      printf("\nSTMT_EXEC;;15820\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___10 = gettext("Device number out of range");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;15821\n");
tmp___11 = quotearg_colon(listed_incremental_option);
                      printf("\nSTMT_EXEC;;15822\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___11, lineno, tmp___10);printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;15823\n");
exit_status = 2;
                    }
                  }
                }
              }
}

            }
          }
          {
            printf("\nSTMT_EXEC;;15831\n");
strp = ebuf;
            printf("\nSTMT_EXEC;;15832\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___14 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;15833\n");
*tmp___14 = 0;
            printf("\nSTMT_EXEC;;15834\n");
printf("\nFUNC_CALL;strtoul(const char *__restrict,char **__restrict,int);\n");
u = strtoul((char const * /* __restrict  */)strp, (char ** /* __restrict  */)(&ebuf), 10);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;15835\n");
ino = u;
          }
          printf("\nSTMT_EXEC;;15837\n");
if ((unsigned long)strp == (unsigned long)ebuf)
          {
            {
              printf("\nSTMT_EXEC;;15840\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___15 = gettext("Invalid inode number");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15841\n");
tmp___16 = quotearg_colon(listed_incremental_option);
              printf("\nSTMT_EXEC;;15842\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___16, lineno, tmp___15);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;15843\n");
exit_status = 2;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;15848\n");
if (u == 0UL)
            {
              {
                printf("\nSTMT_EXEC;;15851\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___20 = __errno_location();printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;15853\n");
if (*tmp___20 == 22)
              {
                {
                  printf("\nSTMT_EXEC;;15856\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___15 = gettext("Invalid inode number");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15857\n");
tmp___16 = quotearg_colon(listed_incremental_option);
                  printf("\nSTMT_EXEC;;15858\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___16, lineno, tmp___15);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15859\n");
exit_status = 2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;15864\n");
goto _L___1;
              }
            }
            else
            {
            _L___1:
              {
printf("\nSTMT_EXEC;;15870\n");
if (ino != u)
              {
                {
                  printf("\nSTMT_EXEC;;15873\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___17 = gettext("Inode number out of range");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15874\n");
tmp___18 = quotearg_colon(listed_incremental_option);
                  printf("\nSTMT_EXEC;;15875\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___18, lineno, tmp___17);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;15876\n");
exit_status = 2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;15881\n");
if (u == 0xffffffffffffffffUL)
                {
                  {
                    printf("\nSTMT_EXEC;;15884\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___19 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  }
                  printf("\nSTMT_EXEC;;15886\n");
if (*tmp___19 == 34)
                  {
                    {
                      printf("\nSTMT_EXEC;;15889\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___17 = gettext("Inode number out of range");printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;15890\n");
tmp___18 = quotearg_colon(listed_incremental_option);
                      printf("\nSTMT_EXEC;;15891\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s:%ld: %s", tmp___18, lineno, tmp___17);printf("\nFUNC_RETURN;;\n");

                      printf("\nSTMT_EXEC;;15892\n");
exit_status = 2;
                    }
                  }
                }
              }
}

            }
          }
          {
            printf("\nSTMT_EXEC;;15900\n");
strp = ebuf;
            printf("\nSTMT_EXEC;;15901\n");
strp++;
            printf("\nSTMT_EXEC;;15902\n");
unquote_string(strp);
            printf("\nSTMT_EXEC;;15903\n");
note_directory((char const *)strp, dev, ino, nfs, (_Bool)0);
          }
        }
      while_break: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;15910\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___23 = ferror_unlocked(fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15912\n");
if (tmp___23)
    {
      {
        printf("\nSTMT_EXEC;;15915\n");
read_error(listed_incremental_option);
      }
    }
    printf("\nSTMT_EXEC;;15918\n");
if (buf)
    {
      {
        printf("\nSTMT_EXEC;;15921\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)buf);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;15924\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool write_directory_file_entry(void *entry, void *data)
{
  printf("\nFUNC_CALL;write_directory_file_entry(void *,void *);\n");
printf("\nSTMT_EXEC;;15929\n");
struct directory const *directory;
  printf("\nSTMT_EXEC;;15930\n");
FILE *fp;
  printf("\nSTMT_EXEC;;15931\n");
int e;
  printf("\nSTMT_EXEC;;15932\n");
char *str;
  printf("\nSTMT_EXEC;;15933\n");
char *tmp;
  printf("\nSTMT_EXEC;;15934\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;15935\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;15936\n");
int tmp___2;
  printf("\nSTMT_EXEC;;15937\n");
int tmp___3;
  printf("\nSTMT_EXEC;;15938\n");
char *tmp___4;

  {
    printf("\nSTMT_EXEC;;15941\n");
directory = (struct directory const *)entry;
    printf("\nSTMT_EXEC;;15942\n");
fp = (FILE *)data;
    printf("\nSTMT_EXEC;;15943\n");
if (directory->found)
    {
      {
        printf("\nSTMT_EXEC;;15946\n");
tmp = quote_copy_string((char const *)(directory->name));
        printf("\nSTMT_EXEC;;15947\n");
str = tmp;
      }
      printf("\nSTMT_EXEC;;15949\n");
if (str)
      {
        printf("\nSTMT_EXEC;;15951\n");
tmp___4 = (char * /* const  */)str;
      }
      else
      {
        printf("\nSTMT_EXEC;;15955\n");
tmp___4 = directory->name;
      }
      {
        printf("\nSTMT_EXEC;;15958\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) fp, (char const * /* __restrict  */)("+%lu %lu %s\n" + !directory->nfs), (unsigned long)directory->device_number, (unsigned long)directory->inode_number, tmp___4);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;15959\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;15960\n");
e = *tmp___0;
      }
      printf("\nSTMT_EXEC;;15962\n");
if (str)
      {
        {
          printf("\nSTMT_EXEC;;15965\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)str);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;15969\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;15970\n");
*tmp___1 = e;
      }
    }
    {
      printf("\nSTMT_EXEC;;15974\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___2 = ferror_unlocked(fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;15976\n");
if (tmp___2)
    {
      printf("\nSTMT_EXEC;;15978\n");
tmp___3 = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;15982\n");
tmp___3 = 1;
    }
    printf("\nSTMT_EXEC;;15984\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp___3);
  }
printf("\nFUNC_RETURN;;\n");
}
void write_directory_file(void)
{
  printf("\nFUNC_CALL;write_directory_file();\n");
printf("\nSTMT_EXEC;;15989\n");
FILE *fp;
  printf("\nSTMT_EXEC;;15990\n");
int tmp;
  printf("\nSTMT_EXEC;;15991\n");
int tmp___0;
  printf("\nSTMT_EXEC;;15992\n");
int tmp___1;
  printf("\nSTMT_EXEC;;15993\n");
int tmp___2;
  printf("\nSTMT_EXEC;;15994\n");
int tmp___3;
  printf("\nSTMT_EXEC;;15995\n");
int tmp___4;

  {
    printf("\nSTMT_EXEC;;15998\n");
fp = listed_incremental_stream;
    printf("\nSTMT_EXEC;;15999\n");
if (!fp)
    {
      printf("\nSTMT_EXEC;;16001\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;16004\n");
printf("\nFUNC_CALL;fseek(FILE *,long,int);\n");
tmp = fseek(fp, 0L, 0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;16006\n");
if (tmp != 0)
    {
      {
        printf("\nSTMT_EXEC;;16009\n");
seek_error(listed_incremental_option);
      }
    }
    {
      printf("\nSTMT_EXEC;;16013\n");
printf("\nFUNC_CALL;fileno(FILE *);\n");
tmp___0 = fileno(fp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;16014\n");
tmp___1 = sys_truncate(tmp___0);
    }
    printf("\nSTMT_EXEC;;16016\n");
if (tmp___1 != 0)
    {
      {
        printf("\nSTMT_EXEC;;16019\n");
truncate_error(listed_incremental_option);
      }
    }
    {
      printf("\nSTMT_EXEC;;16023\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) fp, (char const * /* __restrict  */) "%lu\n", (unsigned long)start_timespec.tv_sec);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;16024\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___2 = ferror_unlocked(fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;16026\n");
if (!tmp___2)
    {
      printf("\nSTMT_EXEC;;16028\n");
if (directory_table)
      {
        {
          printf("\nSTMT_EXEC;;16031\n");
hash_do_for_each((Hash_table const *)directory_table, &write_directory_file_entry, (void *)fp);
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;16036\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___3 = ferror_unlocked(fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;16038\n");
if (tmp___3)
    {
      {
        printf("\nSTMT_EXEC;;16041\n");
write_error(listed_incremental_option);
      }
    }
    {
      printf("\nSTMT_EXEC;;16045\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___4 = fclose(fp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;16047\n");
if (tmp___4 != 0)
    {
      {
        printf("\nSTMT_EXEC;;16050\n");
close_error(listed_incremental_option);
      }
    }
    printf("\nSTMT_EXEC;;16053\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void gnu_restore(char const *directory_name)
{
  printf("\nFUNC_CALL;gnu_restore(const char *);\n");
printf("\nSTMT_EXEC;;16058\n");
char *archive_dir;
  printf("\nSTMT_EXEC;;16059\n");
char *current_dir;
  printf("\nSTMT_EXEC;;16060\n");
char *cur;
  printf("\nSTMT_EXEC;;16061\n");
char *arc;
  printf("\nSTMT_EXEC;;16062\n");
size_t size;
  printf("\nSTMT_EXEC;;16063\n");
size_t copied;
  printf("\nSTMT_EXEC;;16064\n");
union block *data_block;
  printf("\nSTMT_EXEC;;16065\n");
char *to;
  printf("\nSTMT_EXEC;;16066\n");
void *tmp;
  printf("\nSTMT_EXEC;;16067\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;16068\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;16069\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;16070\n");
int tmp___3;
  printf("\nSTMT_EXEC;;16071\n");
char *p;
  printf("\nSTMT_EXEC;;16072\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;16073\n");
char const *tmp___5;
  printf("\nSTMT_EXEC;;16074\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;16075\n");
int e;
  printf("\nSTMT_EXEC;;16076\n");
int *tmp___7;
  printf("\nSTMT_EXEC;;16077\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;16078\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;16079\n");
int tmp___10;
  printf("\nSTMT_EXEC;;16080\n");
int tmp___11;
  printf("\nSTMT_EXEC;;16081\n");
char *__cil_tmp25;
  printf("\nSTMT_EXEC;;16082\n");
char *__cil_tmp26;
  printf("\nSTMT_EXEC;;16083\n");
char *__cil_tmp27;
  printf("\nSTMT_EXEC;;16084\n");
char *__cil_tmp28;

  {
    {
      printf("\nSTMT_EXEC;;16088\n");
current_dir = savedir(directory_name);
    }
    printf("\nSTMT_EXEC;;16090\n");
if (!current_dir)
    {
      {
        printf("\nSTMT_EXEC;;16093\n");
skip_member();
      }
      printf("\nSTMT_EXEC;;16095\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    printf("\nSTMT_EXEC;;16097\n");
size = (size_t)current_stat_info.stat.st_size;
    printf("\nSTMT_EXEC;;16098\n");
if (size != (size_t)current_stat_info.stat.st_size)
    {
      {
        printf("\nSTMT_EXEC;;16101\n");
xalloc_die();
      }
    }
    {
      printf("\nSTMT_EXEC;;16105\n");
tmp = xmalloc(size);
      printf("\nSTMT_EXEC;;16106\n");
archive_dir = (char *)tmp;
      printf("\nSTMT_EXEC;;16107\n");
to = archive_dir;
    }
    {
      printf("\nSTMT_EXEC;;16110\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;16113\n");
if (!(size > 0UL))
        {
          printf("\nSTMT_EXEC;;16115\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;16118\n");
data_block = find_next_block();
        }
        printf("\nSTMT_EXEC;;16120\n");
if (!data_block)
        {
          {
            printf("\nSTMT_EXEC;;16123\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;16124\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;16125\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;16127\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;16130\n");
copied = available_space_after(data_block);
        }
        printf("\nSTMT_EXEC;;16132\n");
if (copied > size)
        {
          printf("\nSTMT_EXEC;;16134\n");
copied = size;
        }
        {
          printf("\nSTMT_EXEC;;16137\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)to, (void const * /* __restrict  */)(data_block->buffer), copied);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;16138\n");
to += copied;
          printf("\nSTMT_EXEC;;16139\n");
set_next_block_after((union block *)((data_block->buffer + copied) - 1));
          printf("\nSTMT_EXEC;;16140\n");
size -= copied;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;16145\n");
cur = current_dir;
    {
      printf("\nSTMT_EXEC;;16147\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;16150\n");
if (!*cur)
        {
          printf("\nSTMT_EXEC;;16152\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;16154\n");
arc = archive_dir;
        {
          printf("\nSTMT_EXEC;;16156\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;16159\n");
if (!*arc)
            {
              printf("\nSTMT_EXEC;;16161\n");
goto while_break___1;
            }
            {
              printf("\nSTMT_EXEC;;16164\n");
arc++;
              printf("\nSTMT_EXEC;;16165\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___3 = strcmp((char const *)arc, (char const *)cur);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;16167\n");
if (!tmp___3)
            {
              printf("\nSTMT_EXEC;;16169\n");
goto while_break___1;
            }
            {
              printf("\nSTMT_EXEC;;16172\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen((char const *)arc);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16173\n");
arc += tmp___2 + 1UL;
            }
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;16178\n");
if ((int)*arc == 0)
        {
          {
            printf("\nSTMT_EXEC;;16181\n");
tmp___4 = new_name(directory_name, (char const *)cur);
            printf("\nSTMT_EXEC;;16182\n");
p = tmp___4;
          }
          printf("\nSTMT_EXEC;;16184\n");
if (!interactive_option)
          {
            printf("\nSTMT_EXEC;;16186\n");
goto _L;
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;16191\n");
tmp___11 = confirm("delete", (char const *)p);
            }
            printf("\nSTMT_EXEC;;16193\n");
if (tmp___11)
            {
            _L:
              {
printf("\nSTMT_EXEC;;16196\n");
if (verbose_option)
              {
                {
                  printf("\nSTMT_EXEC;;16199\n");
tmp___5 = quote((char const *)p);
                  printf("\nSTMT_EXEC;;16200\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("%s: Deleting %s\n");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;16201\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___6, program_name, tmp___5);printf("\nFUNC_RETURN;;\n");

                }
              }
}

              {
                printf("\nSTMT_EXEC;;16205\n");
tmp___10 = remove_any_file((char const *)p, (enum remove_option)1);
              }
              printf("\nSTMT_EXEC;;16207\n");
if (!tmp___10)
              {
                {
                  printf("\nSTMT_EXEC;;16210\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___7 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;16211\n");
e = *tmp___7;
                  printf("\nSTMT_EXEC;;16212\n");
tmp___8 = quotearg_colon((char const *)p);
                  printf("\nSTMT_EXEC;;16213\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("%s: Cannot remove");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;16214\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___9, tmp___8);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;16215\n");
exit_status = 2;
                }
              }
            }
          }
          {
            printf("\nSTMT_EXEC;;16221\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)p);printf("\nFUNC_RETURN;;\n");

          }
        }
        {
          printf("\nSTMT_EXEC;;16225\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)cur);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;16226\n");
cur += tmp___1 + 1UL;
        }
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;16232\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)current_dir);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;16233\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)archive_dir);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;16235\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","007.list.o.i","") */
extern __attribute__((__nothrow__)) unsigned long long(__attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major, unsigned int __minor) __attribute__((__const__));
extern int putc_unlocked(int __c, FILE *__stream);
extern size_t fwrite_unlocked(void const *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
extern __attribute__((__nothrow__)) struct tm *(__attribute__((__leaf__)) gmtime)(time_t const *__timer);
extern __attribute__((__nothrow__)) struct tm *(__attribute__((__leaf__)) localtime)(time_t const *__timer);
struct quoting_options *clone_quoting_options(struct quoting_options *o___0);
void set_quoting_style(struct quoting_options *o___0, enum quoting_style s);
size_t quotearg_buffer(char *buffer___2, size_t buffersize, char const *arg, size_t argsize, struct quoting_options const *o___0);
char *quotearg(char const *arg);
_Bool utc_option;
_Bool block_number_option;
_Bool show_omitted_dirs_option;
gid_t gid_from_header(char const *p, size_t s);
int major_from_header(char const *p, size_t s);
int minor_from_header(char const *p, size_t s);
mode_t mode_from_header(char const *p, size_t s);
size_t size_from_header(char const *p, size_t s);
time_t time_from_header(char const *p, size_t s);
uid_t uid_from_header(char const *p, size_t s);
void list_archive(void);
void read_and(void (*do_something)(void));
void decode_mode(mode_t mode, char *string);
int name_match(char const *path);
_Bool all_names_found(struct tar_stat_info *p);
_Bool sparse_fixup_header(struct tar_stat_info *st);
enum dump_status sparse_skip_file(struct tar_stat_info *st);
static uintmax_t from_header(char const *where0, size_t digs, char const *type, uintmax_t minus_minval, uintmax_t maxval);
static char const base_64_digits[64] = {(char const)'A', (char const)'B', (char const)'C', (char const)'D', (char const)'E', (char const)'F', (char const)'G', (char const)'H', (char const)'I', (char const)'J', (char const)'K', (char const)'L', (char const)'M', (char const)'N', (char const)'O', (char const)'P', (char const)'Q', (char const)'R', (char const)'S', (char const)'T', (char const)'U', (char const)'V', (char const)'W', (char const)'X', (char const)'Y', (char const)'Z', (char const)'a', (char const)'b', (char const)'c', (char const)'d', (char const)'e', (char const)'f', (char const)'g', (char const)'h', (char const)'i', (char const)'j', (char const)'k', (char const)'l', (char const)'m', (char const)'n', (char const)'o', (char const)'p', (char const)'q', (char const)'r', (char const)'s', (char const)'t', (char const)'u', (char const)'v', (char const)'w', (char const)'x', (char const)'y', (char const)'z', (char const)'0', (char const)'1', (char const)'2', (char const)'3', (char const)'4', (char const)'5', (char const)'6', (char const)'7', (char const)'8', (char const)'9', (char const)'+', (char const)'/'};
static char base64_map[256];
static void base64_init(void)
{
  printf("\nFUNC_CALL;base64_init();\n");
printf("\nSTMT_EXEC;;16270\n");
int i;

  {
    {
      printf("\nSTMT_EXEC;;16274\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(base64_map), 64, sizeof(base64_map));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;16275\n");
i = 0;
    }
    {
      printf("\nSTMT_EXEC;;16278\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;16281\n");
if (!(i < 64))
        {
          printf("\nSTMT_EXEC;;16283\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;16285\n");
base64_map[(int)base_64_digits[i]] = (char)i;
        printf("\nSTMT_EXEC;;16286\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;16290\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void read_and(void (*do_something)(void))
{
  printf("\nFUNC_CALL;read_and(void (*)(void));\n");
printf("\nSTMT_EXEC;;16295\n");
enum read_header status;
  printf("\nSTMT_EXEC;;16296\n");
enum read_header prev_status;
  printf("\nSTMT_EXEC;;16297\n");
char *tmp;
  printf("\nSTMT_EXEC;;16298\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;16299\n");
int tmp___1;
  printf("\nSTMT_EXEC;;16300\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;16301\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;16302\n");
off_t tmp___3;
  printf("\nSTMT_EXEC;;16303\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;16304\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;16305\n");
char buf___0[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;16306\n");
off_t tmp___6;
  printf("\nSTMT_EXEC;;16307\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;16308\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;16309\n");
char buf___1[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;16310\n");
off_t tmp___9;
  printf("\nSTMT_EXEC;;16311\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;16312\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;16313\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;16314\n");
char buf___2[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;16315\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;16316\n");
off_t tmp___13;
  printf("\nSTMT_EXEC;;16317\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;16318\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;16319\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;16320\n");
_Bool tmp___17;
  printf("\nSTMT_EXEC;;16321\n");
void *__cil_tmp28;
  printf("\nSTMT_EXEC;;16322\n");
void *__cil_tmp29;
  printf("\nSTMT_EXEC;;16323\n");
void *__cil_tmp30;
  printf("\nSTMT_EXEC;;16324\n");
void *__cil_tmp31;
  printf("\nSTMT_EXEC;;16325\n");
char *__cil_tmp32;
  printf("\nSTMT_EXEC;;16326\n");
char *__cil_tmp33;
  printf("\nSTMT_EXEC;;16327\n");
char *__cil_tmp34;
  printf("\nSTMT_EXEC;;16328\n");
char *__cil_tmp35;
  printf("\nSTMT_EXEC;;16329\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;16330\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;16331\n");
char *__cil_tmp38;

  {
    {
      printf("\nSTMT_EXEC;;16335\n");
status = (enum read_header)0;
      printf("\nSTMT_EXEC;;16336\n");
base64_init();































      printf("\nSTMT_EXEC;;16368\n");
name_gather();
      printf("\nSTMT_EXEC;;16369\n");
open_archive((enum access_mode)0);
    }
    {
      printf("\nSTMT_EXEC;;16372\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;16376\n");
prev_status = status;
          printf("\nSTMT_EXEC;;16377\n");
tar_stat_destroy(&current_stat_info);
          printf("\nSTMT_EXEC;;16378\n");
xheader_destroy(&extended_header);
          printf("\nSTMT_EXEC;;16379\n");
status = read_header((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;16382\n");
if ((unsigned int)status == 0U)
          {
            printf("\nSTMT_EXEC;;16384\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;16386\n");
if ((unsigned int)status == 2U)
          {
            printf("\nSTMT_EXEC;;16388\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;16390\n");
if ((unsigned int)status == 1U)
          {
            printf("\nSTMT_EXEC;;16392\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;16394\n");
if ((unsigned int)status == 3U)
          {
            printf("\nSTMT_EXEC;;16396\n");
goto case_3;
          }
          printf("\nSTMT_EXEC;;16398\n");
if ((unsigned int)status == 4U)
          {
            printf("\nSTMT_EXEC;;16400\n");
goto case_4;
          }
          printf("\nSTMT_EXEC;;16402\n");
if ((unsigned int)status == 5U)
          {
            printf("\nSTMT_EXEC;;16404\n");
goto case_5;
          }
          printf("\nSTMT_EXEC;;16406\n");
goto switch_break;
        case_0: /* CIL Label */
        case_2: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;16410\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

        }
        case_1: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;16414\n");
tmp___1 = name_match((char const *)current_stat_info.file_name);
        }
          printf("\nSTMT_EXEC;;16416\n");
if (tmp___1)
          {
            printf("\nSTMT_EXEC;;16418\n");
if (0L <= newer_mtime_option.tv_nsec)
            {
              {
                printf("\nSTMT_EXEC;;16421\n");
current_stat_info.stat.st_mtim.tv_sec = time_from_header((char const *)(current_header->header.mtime), sizeof(current_header->header.mtime));
                printf("\nSTMT_EXEC;;16422\n");
current_stat_info.stat.st_mtim.tv_nsec = (__syscall_slong_t)0;
              }
              printf("\nSTMT_EXEC;;16424\n");
if (current_stat_info.stat.st_mtim.tv_sec < newer_mtime_option.tv_sec)
              {
                printf("\nSTMT_EXEC;;16426\n");
goto _L;
              }
              else
              {
                printf("\nSTMT_EXEC;;16430\n");
if (current_stat_info.stat.st_mtim.tv_sec == newer_mtime_option.tv_sec)
                {
                  printf("\nSTMT_EXEC;;16432\n");
if (current_stat_info.stat.st_mtim.tv_nsec < newer_mtime_option.tv_nsec)
                  {
                    printf("\nSTMT_EXEC;;16434\n");
goto _L;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;16438\n");
goto _L___0;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;16443\n");
goto _L___0;
                }
              }
            }
            else
            {
            _L___0:
            {
              printf("\nSTMT_EXEC;;16451\n");
tmp___2 = excluded_name((char const *)current_stat_info.file_name);
            }
              printf("\nSTMT_EXEC;;16453\n");
if (tmp___2)
              {
              _L:
              {
                printf("\nSTMT_EXEC;;16457\n");
if ((int)current_header->header.typeflag == 86)
                {
                  printf("\nSTMT_EXEC;;16459\n");
goto case_86;
                }
                printf("\nSTMT_EXEC;;16461\n");
if ((int)current_header->header.typeflag == 77)
                {
                  printf("\nSTMT_EXEC;;16463\n");
goto case_86;
                }
                printf("\nSTMT_EXEC;;16465\n");
if ((int)current_header->header.typeflag == 78)
                {
                  printf("\nSTMT_EXEC;;16467\n");
goto case_86;
                }
                printf("\nSTMT_EXEC;;16469\n");
if ((int)current_header->header.typeflag == 53)
                {
                  printf("\nSTMT_EXEC;;16471\n");
goto case_53;
                }
                printf("\nSTMT_EXEC;;16473\n");
goto switch_default;
              case_86: /* CIL Label */
              case_77: /* CIL Label */
              case_78: /* CIL Label */
                {
printf("\nSTMT_EXEC;;16477\n");
goto switch_break___0;
}

              case_53: /* CIL Label */
                {
printf("\nSTMT_EXEC;;16479\n");
if (show_omitted_dirs_option)
                {
                  {
                    printf("\nSTMT_EXEC;;16482\n");
tmp = quotearg_colon((char const *)current_stat_info.file_name);
                    printf("\nSTMT_EXEC;;16483\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: Omitting");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;16484\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

                  }
                }
}

              switch_default: /* CIL Label */
              {
                printf("\nSTMT_EXEC;;16489\n");
skip_member();
              }
                printf("\nSTMT_EXEC;;16491\n");
goto __Cont;
              switch_break___0: /* CIL Label */;
              }
              }
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;16499\n");
goto _L;
          }
          {
            printf("\nSTMT_EXEC;;16502\n");
(*do_something)();
          }
          printf("\nSTMT_EXEC;;16504\n");
goto __Cont;
        case_3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;16506\n");
if (block_number_option)
          {
            {
              printf("\nSTMT_EXEC;;16509\n");
tmp___3 = current_block_ordinal();
              printf("\nSTMT_EXEC;;16510\n");
tmp___4 = stringify_uintmax_t_backwards((uintmax_t)tmp___3, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;16511\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("block %s: ** Block of NULs **\n");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16512\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___5, tmp___4);printf("\nFUNC_RETURN;;\n");

            }
          }
}

          {
            printf("\nSTMT_EXEC;;16516\n");
set_next_block_after(current_header);
          }
          printf("\nSTMT_EXEC;;16518\n");
if (!ignore_zeros_option)
          {
            {
              printf("\nSTMT_EXEC;;16521\n");
status = read_header((_Bool)0);
            }
            printf("\nSTMT_EXEC;;16523\n");
if ((unsigned int)status == 3U)
            {
              printf("\nSTMT_EXEC;;16525\n");
goto switch_break;
            }
            {
              printf("\nSTMT_EXEC;;16528\n");
tmp___6 = current_block_ordinal();
              printf("\nSTMT_EXEC;;16529\n");
tmp___7 = stringify_uintmax_t_backwards((uintmax_t)tmp___6, buf___0 + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;16530\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("A lone zero block at %s");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16531\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8, tmp___7);printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;16533\n");
goto switch_break;
          }
          printf("\nSTMT_EXEC;;16535\n");
status = prev_status;
          printf("\nSTMT_EXEC;;16536\n");
goto __Cont;
        case_4: /* CIL Label */
          {
printf("\nSTMT_EXEC;;16538\n");
if (block_number_option)
          {
            {
              printf("\nSTMT_EXEC;;16541\n");
tmp___9 = current_block_ordinal();
              printf("\nSTMT_EXEC;;16542\n");
tmp___10 = stringify_uintmax_t_backwards((uintmax_t)tmp___9, buf___1 + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;16543\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___11 = gettext("block %s: ** End of File **\n");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16544\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___11, tmp___10);printf("\nFUNC_RETURN;;\n");

            }
          }
}

          printf("\nSTMT_EXEC;;16547\n");
goto switch_break;
        case_5: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;16550\n");
set_next_block_after(current_header);
        }
          {
            printf("\nSTMT_EXEC;;16553\n");
if ((unsigned int)prev_status == 0U)
            {
              printf("\nSTMT_EXEC;;16555\n");
goto case_0___0;
            }
            printf("\nSTMT_EXEC;;16557\n");
if ((unsigned int)prev_status == 3U)
            {
              printf("\nSTMT_EXEC;;16559\n");
goto case_3___0;
            }
            printf("\nSTMT_EXEC;;16561\n");
if ((unsigned int)prev_status == 1U)
            {
              printf("\nSTMT_EXEC;;16563\n");
goto case_3___0;
            }
            printf("\nSTMT_EXEC;;16565\n");
if ((unsigned int)prev_status == 4U)
            {
              printf("\nSTMT_EXEC;;16567\n");
goto case_4___0;
            }
            printf("\nSTMT_EXEC;;16569\n");
if ((unsigned int)prev_status == 5U)
            {
              printf("\nSTMT_EXEC;;16571\n");
goto case_4___0;
            }
            printf("\nSTMT_EXEC;;16573\n");
if ((unsigned int)prev_status == 2U)
            {
              printf("\nSTMT_EXEC;;16575\n");
goto case_2___0;
            }
            printf("\nSTMT_EXEC;;16577\n");
goto switch_break___1;
          case_0___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;16580\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___12 = gettext("This does not look like a tar archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;16581\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___12);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;16582\n");
exit_status = 2;
          }
          case_3___0: /* CIL Label */
          case_1___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;16586\n");
if (block_number_option)
            {
              {
                printf("\nSTMT_EXEC;;16589\n");
tmp___13 = current_block_ordinal();
                printf("\nSTMT_EXEC;;16590\n");
block_ordinal = tmp___13;
                printf("\nSTMT_EXEC;;16591\n");
block_ordinal = (off_t)((size_t)block_ordinal - recent_long_name_blocks);
                printf("\nSTMT_EXEC;;16592\n");
block_ordinal = (off_t)((size_t)block_ordinal - recent_long_link_blocks);
                printf("\nSTMT_EXEC;;16593\n");
tmp___14 = stringify_uintmax_t_backwards((uintmax_t)block_ordinal, buf___2 + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
                printf("\nSTMT_EXEC;;16594\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___15 = gettext("block %s: ");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;16595\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___15, tmp___14);printf("\nFUNC_RETURN;;\n");

              }
            }
}

            {
              printf("\nSTMT_EXEC;;16599\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___16 = gettext("Skipping to next header");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16600\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___16);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16601\n");
exit_status = 2;
            }
            printf("\nSTMT_EXEC;;16603\n");
goto switch_break___1;
          case_4___0: /* CIL Label */
          case_5___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;16606\n");
goto switch_break___1;
}

          case_2___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;16609\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

          }
          switch_break___1: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;16613\n");
goto __Cont;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;16616\n");
goto while_break;
      __Cont:
      {
        printf("\nSTMT_EXEC;;16619\n");
tmp___17 = all_names_found(&current_stat_info);
      }
        printf("\nSTMT_EXEC;;16621\n");
if (tmp___17)
        {
          printf("\nSTMT_EXEC;;16623\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;16629\n");
close_archive();
      printf("\nSTMT_EXEC;;16630\n");
names_notfound();
    }
    printf("\nSTMT_EXEC;;16632\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void list_archive(void)
{
  printf("\nFUNC_CALL;list_archive();\n");
printf("\nSTMT_EXEC;;16637\n");
off_t size;
  printf("\nSTMT_EXEC;;16638\n");
size_t written;
  printf("\nSTMT_EXEC;;16639\n");
size_t check;
  printf("\nSTMT_EXEC;;16640\n");
union block *data_block;
  printf("\nSTMT_EXEC;;16641\n");
char *tmp;
  printf("\nSTMT_EXEC;;16642\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;16643\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;16647\n");
decode_header(current_header, &current_stat_info, &current_format, 0);
    }
    printf("\nSTMT_EXEC;;16649\n");
if (verbose_option)
    {
      {
        printf("\nSTMT_EXEC;;16652\n");
print_header(&current_stat_info, (off_t)-1);
      }
    }
    printf("\nSTMT_EXEC;;16655\n");
if (incremental_option)
    {
      printf("\nSTMT_EXEC;;16657\n");
if ((int)current_header->header.typeflag == 68)
      {
        {
          printf("\nSTMT_EXEC;;16660\n");
set_next_block_after(current_header);
        }
        printf("\nSTMT_EXEC;;16662\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;16665\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
            printf("\nSTMT_EXEC;;16666\n");
save_totsize = current_stat_info.stat.st_size;
          }
        }
        printf("\nSTMT_EXEC;;16669\n");
size = current_stat_info.stat.st_size;
        {
          printf("\nSTMT_EXEC;;16671\n");
while (1)
          {
          while_continue: /* CIL Label */;
            printf("\nSTMT_EXEC;;16674\n");
if (!(size > 0L))
            {
              printf("\nSTMT_EXEC;;16676\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;16678\n");
if (multi_volume_option)
            {
              printf("\nSTMT_EXEC;;16680\n");
save_sizeleft = size;
            }
            {
              printf("\nSTMT_EXEC;;16683\n");
data_block = find_next_block();
            }
            printf("\nSTMT_EXEC;;16685\n");
if (!data_block)
            {
              {
                printf("\nSTMT_EXEC;;16688\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;16689\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;16690\n");
exit_status = 2;
              }
              printf("\nSTMT_EXEC;;16692\n");
goto while_break;
            }
            {
              printf("\nSTMT_EXEC;;16695\n");
written = available_space_after(data_block);
            }
            printf("\nSTMT_EXEC;;16697\n");
if (written > (size_t)size)
            {
              printf("\nSTMT_EXEC;;16699\n");
written = (size_t)size;
            }
            {
              printf("\nSTMT_EXEC;;16702\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16703\n");
*tmp___0 = 0;
              printf("\nSTMT_EXEC;;16704\n");
printf("\nFUNC_CALL;fwrite_unlocked(const void *__restrict,size_t,size_t,FILE *__restrict);\n");
check = fwrite_unlocked((void const * /* __restrict  */)(data_block->buffer), sizeof(char), written, (FILE * /* __restrict  */) stdlis);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;16705\n");
set_next_block_after((union block *)((data_block->buffer + written) - 1));
            }
            printf("\nSTMT_EXEC;;16707\n");
if (check != written)
            {
              {
                printf("\nSTMT_EXEC;;16710\n");
write_error_details((char const *)current_stat_info.file_name, check, written);
                printf("\nSTMT_EXEC;;16711\n");
skip_file((off_t)((size_t)size - written));
              }
              printf("\nSTMT_EXEC;;16713\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;16715\n");
size = (off_t)((size_t)size - written);
          }
        while_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;16719\n");
if (multi_volume_option)
        {
          {
            printf("\nSTMT_EXEC;;16722\n");
assign_string(&save_name, (char const *)0);
          }
        }
        {
          printf("\nSTMT_EXEC;;16726\n");
printf("\nFUNC_CALL;fputc_unlocked(int,FILE *);\n");
fputc_unlocked('\n', stdlis);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;16727\n");
printf("\nFUNC_CALL;fflush_unlocked(FILE *);\n");
fflush_unlocked(stdlis);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;16729\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    printf("\nSTMT_EXEC;;16732\n");
if (multi_volume_option)
    {
      {
        printf("\nSTMT_EXEC;;16735\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
      }
    }
    {
      printf("\nSTMT_EXEC;;16739\n");
skip_member();
    }
    printf("\nSTMT_EXEC;;16741\n");
if (multi_volume_option)
    {
      {
        printf("\nSTMT_EXEC;;16744\n");
assign_string(&save_name, (char const *)0);
      }
    }
    printf("\nSTMT_EXEC;;16747\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}













































































































































































































































enum read_header read_header(_Bool raw_extended_headers)
{
  printf("\nFUNC_CALL;read_header(_Bool);\n");
printf("\nSTMT_EXEC;;16989\n");
size_t i;
  printf("\nSTMT_EXEC;;16990\n");
int unsigned_sum;
  printf("\nSTMT_EXEC;;16991\n");
int signed_sum;
  printf("\nSTMT_EXEC;;16992\n");
int recorded_sum;
  printf("\nSTMT_EXEC;;16993\n");
uintmax_t parsed_sum;
  printf("\nSTMT_EXEC;;16994\n");
char *p;
  printf("\nSTMT_EXEC;;16995\n");
union block *header;
  printf("\nSTMT_EXEC;;16996\n");
union block *header_copy;
  printf("\nSTMT_EXEC;;16997\n");
char *bp;
  printf("\nSTMT_EXEC;;16998\n");
union block *data_block;
  printf("\nSTMT_EXEC;;16999\n");
size_t size;
  printf("\nSTMT_EXEC;;17000\n");
size_t written;
  printf("\nSTMT_EXEC;;17001\n");
union block *next_long_name;
  printf("\nSTMT_EXEC;;17002\n");
union block *next_long_link;
  printf("\nSTMT_EXEC;;17003\n");
size_t next_long_name_blocks;
  printf("\nSTMT_EXEC;;17004\n");
size_t next_long_link_blocks;
  printf("\nSTMT_EXEC;;17005\n");
char *tmp;
  printf("\nSTMT_EXEC;;17006\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;17007\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;17008\n");
size_t name_size;
  printf("\nSTMT_EXEC;;17009\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;17010\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;17011\n");
off_t tmp___4;
  printf("\nSTMT_EXEC;;17012\n");
off_t tmp___5;
  printf("\nSTMT_EXEC;;17013\n");
char const *name;
  printf("\nSTMT_EXEC;;17014\n");
struct posix_header const *h;
  printf("\nSTMT_EXEC;;17015\n");
char namebuf[((sizeof(h->prefix) + 1UL) + 100UL) + 1UL];
  printf("\nSTMT_EXEC;;17016\n");
char *np;
  printf("\nSTMT_EXEC;;17017\n");
size_t tmp___6;
  printf("\nSTMT_EXEC;;17018\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;17019\n");
int tmp___8;
  printf("\nSTMT_EXEC;;17020\n");
void *__cil_tmp33;
  printf("\nSTMT_EXEC;;17021\n");
char *__cil_tmp34;

  {
    printf("\nSTMT_EXEC;;17024\n");
next_long_name = (union block *)0;
    printf("\nSTMT_EXEC;;17025\n");
next_long_link = (union block *)0;
    {
      printf("\nSTMT_EXEC;;17027\n");
while (1)
      {
      while_continue: /* CIL Label */;






        {
          printf("\nSTMT_EXEC;;17037\n");
header = find_next_block();
          printf("\nSTMT_EXEC;;17038\n");
current_header = header;
        }
        printf("\nSTMT_EXEC;;17040\n");
if (!header)
        {
          printf("\nSTMT_EXEC;;17042\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)4);
        }
        printf("\nSTMT_EXEC;;17044\n");
unsigned_sum = 0;
        printf("\nSTMT_EXEC;;17045\n");
signed_sum = 0;
        printf("\nSTMT_EXEC;;17046\n");
p = header->buffer;
        printf("\nSTMT_EXEC;;17047\n");
i = sizeof(*header);
        {
          printf("\nSTMT_EXEC;;17049\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;17052\n");
tmp___0 = i;
            printf("\nSTMT_EXEC;;17053\n");
i--;
            printf("\nSTMT_EXEC;;17054\n");
if (!(tmp___0 != 0UL))
            {
              printf("\nSTMT_EXEC;;17056\n");
goto while_break___0;
            }

            printf("\nSTMT_EXEC;;17059\n");
unsigned_sum += (int)((unsigned char)*p);
            printf("\nSTMT_EXEC;;17060\n");
tmp = p;
            printf("\nSTMT_EXEC;;17061\n");
p++;
            printf("\nSTMT_EXEC;;17062\n");
signed_sum += (int)((signed char)*tmp);
          }
        while_break___0: /* CIL Label */;



        }
        printf("\nSTMT_EXEC;;17069\n");
if (unsigned_sum == 0)
        {
          printf("\nSTMT_EXEC;;17071\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)3);
        }
        printf("\nSTMT_EXEC;;17073\n");
i = sizeof(header->header.chksum);
        {
          printf("\nSTMT_EXEC;;17075\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;17078\n");
tmp___1 = i;
            printf("\nSTMT_EXEC;;17079\n");
i--;
            printf("\nSTMT_EXEC;;17080\n");
if (!(tmp___1 != 0UL))
            {
              printf("\nSTMT_EXEC;;17082\n");
goto while_break___1;
            }
            printf("\nSTMT_EXEC;;17084\n");
unsigned_sum -= (int)((unsigned char)header->header.chksum[i]);
            printf("\nSTMT_EXEC;;17085\n");
signed_sum -= (int)((signed char)header->header.chksum[i]);
          }
        while_break___1: /* CIL Label */;
        }
        {
          printf("\nSTMT_EXEC;;17090\n");
unsigned_sum = (int)((unsigned long)unsigned_sum + 32UL * sizeof(header->header.chksum));
          printf("\nSTMT_EXEC;;17091\n");
signed_sum = (int)((unsigned long)signed_sum + 32UL * sizeof(header->header.chksum));
          printf("\nSTMT_EXEC;;17092\n");
parsed_sum = from_header((char const *)(header->header.chksum), sizeof(header->header.chksum), (char const *)0, (uintmax_t)0, (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
        }
        printf("\nSTMT_EXEC;;17094\n");
if (parsed_sum == 0xffffffffffffffffUL)
        {
          printf("\nSTMT_EXEC;;17096\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)5);
        }
        printf("\nSTMT_EXEC;;17098\n");
recorded_sum = (int)parsed_sum;
        printf("\nSTMT_EXEC;;17099\n");
if (unsigned_sum != recorded_sum)
        {
          printf("\nSTMT_EXEC;;17101\n");
if (signed_sum != recorded_sum)
          {
            printf("\nSTMT_EXEC;;17103\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)5);
          }
        }
        printf("\nSTMT_EXEC;;17106\n");
if ((int)header->header.typeflag == 49)
        {
          printf("\nSTMT_EXEC;;17108\n");
current_stat_info.stat.st_size = (__off_t)0;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;17113\n");
current_stat_info.stat.st_size = off_from_header((char const *)(header->header.size), sizeof(header->header.size));
          }
        }
        printf("\nSTMT_EXEC;;17116\n");
if ((int)header->header.typeflag == 76)
        {
          printf("\nSTMT_EXEC;;17118\n");
goto _L___4;
        }
        else
        {
          printf("\nSTMT_EXEC;;17122\n");
if ((int)header->header.typeflag == 75)
          {
            printf("\nSTMT_EXEC;;17124\n");
goto _L___4;
          }
          else
          {
            printf("\nSTMT_EXEC;;17128\n");
if ((int)header->header.typeflag == 120)
            {
              printf("\nSTMT_EXEC;;17130\n");
goto _L___4;
            }
            else
            {
              printf("\nSTMT_EXEC;;17134\n");
if ((int)header->header.typeflag == 103)
              {
              _L___4: /* CIL Label */
                {
printf("\nSTMT_EXEC;;17137\n");
if (raw_extended_headers)
                {
                  printf("\nSTMT_EXEC;;17139\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)2);
                }
                else
                {
                  printf("\nSTMT_EXEC;;17143\n");
if ((int)header->header.typeflag == 76)
                  {
                    printf("\nSTMT_EXEC;;17145\n");
goto _L___3;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;17149\n");
if ((int)header->header.typeflag == 75)
                    {
                    _L___3: /* CIL Label */
                      {
printf("\nSTMT_EXEC;;17152\n");
name_size = (size_t)current_stat_info.stat.st_size;
}

                      printf("\nSTMT_EXEC;;17153\n");
size = (name_size - name_size % 512UL) + 1024UL;
                      printf("\nSTMT_EXEC;;17154\n");
if (name_size != (size_t)current_stat_info.stat.st_size)
                      {
                        {
                          printf("\nSTMT_EXEC;;17157\n");
xalloc_die();
                        }
                      }
                      else
                      {
                        printf("\nSTMT_EXEC;;17162\n");
if (size < name_size)
                        {
                          {
                            printf("\nSTMT_EXEC;;17165\n");
xalloc_die();
                          }
                        }
                      }
                      {
                        printf("\nSTMT_EXEC;;17170\n");
tmp___2 = xmalloc(size + 1UL);
                        printf("\nSTMT_EXEC;;17171\n");
header_copy = (union block *)tmp___2;
                      }
                      printf("\nSTMT_EXEC;;17173\n");
if ((int)header->header.typeflag == 76)
                      {
                        printf("\nSTMT_EXEC;;17175\n");
if (next_long_name)
                        {
                          {
                            printf("\nSTMT_EXEC;;17178\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)next_long_name);printf("\nFUNC_RETURN;;\n");

                          }
                        }
                        printf("\nSTMT_EXEC;;17181\n");
next_long_name = header_copy;
                        printf("\nSTMT_EXEC;;17182\n");
next_long_name_blocks = size / 512UL;
                      }
                      else
                      {
                        printf("\nSTMT_EXEC;;17186\n");
if (next_long_link)
                        {
                          {
                            printf("\nSTMT_EXEC;;17189\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)next_long_link);printf("\nFUNC_RETURN;;\n");

                          }
                        }
                        printf("\nSTMT_EXEC;;17192\n");
next_long_link = header_copy;
                        printf("\nSTMT_EXEC;;17193\n");
next_long_link_blocks = size / 512UL;
                      }
                      {
                        printf("\nSTMT_EXEC;;17196\n");
set_next_block_after(header);
                        printf("\nSTMT_EXEC;;17197\n");
*header_copy = *header;
                        printf("\nSTMT_EXEC;;17198\n");
bp = header_copy->buffer + 512;
                        printf("\nSTMT_EXEC;;17199\n");
size -= 512UL;
                      }
                      {
                        printf("\nSTMT_EXEC;;17202\n");
while (1)
                        {
                        while_continue___2: /* CIL Label */;
                          printf("\nSTMT_EXEC;;17205\n");
if (!(size > 0UL))
                          {
                            printf("\nSTMT_EXEC;;17207\n");
goto while_break___2;
                          }
                          {
                            printf("\nSTMT_EXEC;;17210\n");
data_block = find_next_block();
                          }
                          printf("\nSTMT_EXEC;;17212\n");
if (!data_block)
                          {
                            {
                              printf("\nSTMT_EXEC;;17215\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

                              printf("\nSTMT_EXEC;;17216\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3);printf("\nFUNC_RETURN;;\n");

                              printf("\nSTMT_EXEC;;17217\n");
exit_status = 2;
                            }
                            printf("\nSTMT_EXEC;;17219\n");
goto while_break___2;
                          }
                          {
                            printf("\nSTMT_EXEC;;17222\n");
written = available_space_after(data_block);
                          }
                          printf("\nSTMT_EXEC;;17224\n");
if (written > size)
                          {
                            printf("\nSTMT_EXEC;;17226\n");
written = size;
                          }
                          {
                            printf("\nSTMT_EXEC;;17229\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)bp, (void const * /* __restrict  */)(data_block->buffer), written);printf("\nFUNC_RETURN;;\n");

                            printf("\nSTMT_EXEC;;17230\n");
bp += written;
                            printf("\nSTMT_EXEC;;17231\n");
set_next_block_after((union block *)((data_block->buffer + written) - 1));
                            printf("\nSTMT_EXEC;;17232\n");
size -= written;
                          }
                        }
                      while_break___2: /* CIL Label */;
                      }
                      printf("\nSTMT_EXEC;;17237\n");
*bp = (char)'\000';
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;17241\n");
if ((int)header->header.typeflag == 120)
                      {
                        {
                          printf("\nSTMT_EXEC;;17244\n");
tmp___4 = off_from_header((char const *)(header->header.size), sizeof(header->header.size));
                          printf("\nSTMT_EXEC;;17245\n");
xheader_read(header, (size_t)tmp___4);
                        }
                      }
                      else
                      {
                        printf("\nSTMT_EXEC;;17250\n");
if ((int)header->header.typeflag == 103)
                        {
                          {
                            printf("\nSTMT_EXEC;;17253\n");
tmp___5 = off_from_header((char const *)(header->header.size), sizeof(header->header.size));
                            printf("\nSTMT_EXEC;;17254\n");
xheader_read(header, (size_t)tmp___5);
                            printf("\nSTMT_EXEC;;17255\n");
xheader_decode_global();
                          }
                        }
                      }
                    }
                  }
                }
}

              }
              else
              {

                printf("\nSTMT_EXEC;;17266\n");
h = (struct posix_header const *)(&current_header->header);
                printf("\nSTMT_EXEC;;17267\n");
if (recent_long_name)
                {
                  {
                    printf("\nSTMT_EXEC;;17270\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)recent_long_name);printf("\nFUNC_RETURN;;\n");

                  }
                }
                printf("\nSTMT_EXEC;;17273\n");
if (next_long_name)
                {
                  printf("\nSTMT_EXEC;;17275\n");
name = (char const *)(next_long_name->buffer + 512);
                  printf("\nSTMT_EXEC;;17276\n");
recent_long_name = next_long_name;
                  printf("\nSTMT_EXEC;;17277\n");
recent_long_name_blocks = next_long_name_blocks;
                }
                else
                {
                  printf("\nSTMT_EXEC;;17281\n");
np = namebuf;
                  printf("\nSTMT_EXEC;;17282\n");
if (h->prefix[0])
                  {
                    {
                      printf("\nSTMT_EXEC;;17285\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___8 = strcmp((char const *)(h->magic), "ustar");printf("\nFUNC_RETURN;;\n");

                    }
                    printf("\nSTMT_EXEC;;17287\n");
if (tmp___8 == 0)
                    {
                      {
                        printf("\nSTMT_EXEC;;17290\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)np, (void const * /* __restrict  */)(h->prefix), sizeof(h->prefix));printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;17291\n");
*(np + sizeof(h->prefix)) = (char)'\000';
                        printf("\nSTMT_EXEC;;17292\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___6 = strlen((char const *)np);printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;17293\n");
np += tmp___6;
                        printf("\nSTMT_EXEC;;17294\n");
tmp___7 = np;
                        printf("\nSTMT_EXEC;;17295\n");
np++;
                        printf("\nSTMT_EXEC;;17296\n");
*tmp___7 = (char)'/';
                        printf("\nSTMT_EXEC;;17297\n");
current_header->oldgnu_header.isextended = (char)0;
                      }
                    }
                  }
                  {
                    printf("\nSTMT_EXEC;;17302\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)np, (void const * /* __restrict  */)(h->name), sizeof(h->name));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;17303\n");
*(np + sizeof(h->name)) = (char)'\000';
                    printf("\nSTMT_EXEC;;17304\n");
name = (char const *)(namebuf);
                    printf("\nSTMT_EXEC;;17305\n");
recent_long_name = (union block *)0;
                    printf("\nSTMT_EXEC;;17306\n");
recent_long_name_blocks = (size_t)0;
                  }
                }
                {
                  printf("\nSTMT_EXEC;;17310\n");
assign_string(&current_stat_info.orig_file_name, name);


                  printf("\nSTMT_EXEC;;17313\n");
assign_string(&current_stat_info.file_name, name);
                  printf("\nSTMT_EXEC;;17314\n");
current_stat_info.had_trailing_slash = strip_trailing_slashes(current_stat_info.file_name);
                }
                printf("\nSTMT_EXEC;;17316\n");
if (recent_long_link)
                {
                  {
                    printf("\nSTMT_EXEC;;17319\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)recent_long_link);printf("\nFUNC_RETURN;;\n");

                  }
                }
                printf("\nSTMT_EXEC;;17322\n");
if (next_long_link)
                {
                  printf("\nSTMT_EXEC;;17324\n");
name = (char const *)(next_long_link->buffer + 512);
                  printf("\nSTMT_EXEC;;17325\n");
recent_long_link = next_long_link;
                  printf("\nSTMT_EXEC;;17326\n");
recent_long_link_blocks = next_long_link_blocks;
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;17331\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(namebuf), (void const * /* __restrict  */)(h->linkname), sizeof(h->linkname));printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;17332\n");
namebuf[sizeof(h->linkname)] = (char)'\000';
                    printf("\nSTMT_EXEC;;17333\n");
name = (char const *)(namebuf);
                    printf("\nSTMT_EXEC;;17334\n");
recent_long_link = (union block *)0;
                    printf("\nSTMT_EXEC;;17335\n");
recent_long_link_blocks = (size_t)0;
                  }
                }
                {
                  printf("\nSTMT_EXEC;;17339\n");
assign_string(&current_stat_info.link_name, name);
                }
                printf("\nSTMT_EXEC;;17341\n");
printf("\nFUNC_RETURN;;\n");
return ((enum read_header)1);
              }
            }
          }
        }
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void decode_header(union block *header, struct tar_stat_info *stat_info, enum archive_format *format_pointer, int do_user_group)
{
  printf("\nFUNC_CALL;decode_header(union block *,struct tar_stat_info *,enum archive_format *,int);\n");
printf("\nSTMT_EXEC;;17353\n");
enum archive_format format;
  printf("\nSTMT_EXEC;;17354\n");
int tmp;
  printf("\nSTMT_EXEC;;17355\n");
int tmp___0;
  printf("\nSTMT_EXEC;;17356\n");
int tmp___1;
  printf("\nSTMT_EXEC;;17357\n");
int tmp___2;
  printf("\nSTMT_EXEC;;17358\n");
int tmp___3;
  printf("\nSTMT_EXEC;;17359\n");
int tmp___4;
  printf("\nSTMT_EXEC;;17360\n");
unsigned long long tmp___5;
  printf("\nSTMT_EXEC;;17361\n");
_Bool tmp___6;

  {
    {
      printf("\nSTMT_EXEC;;17365\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp((char const *)(header->header.magic), "ustar");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;17367\n");
if (tmp___0 == 0)
    {
      printf("\nSTMT_EXEC;;17369\n");
if ((int)header->star_header.prefix[130] == 0)
      {
        printf("\nSTMT_EXEC;;17371\n");
if ((int)header->star_header.atime[0] >= 48)
        {
          printf("\nSTMT_EXEC;;17373\n");
if ((int)header->star_header.atime[0] <= 55)
          {
            printf("\nSTMT_EXEC;;17375\n");
if ((int)header->star_header.atime[11] == 32)
            {
              printf("\nSTMT_EXEC;;17377\n");
if ((int)header->star_header.ctime[0] >= 48)
              {
                printf("\nSTMT_EXEC;;17379\n");
if ((int)header->star_header.ctime[0] <= 55)
                {
                  printf("\nSTMT_EXEC;;17381\n");
if ((int)header->star_header.ctime[11] == 32)
                  {
                    printf("\nSTMT_EXEC;;17383\n");
format = (enum archive_format)5;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;17387\n");
goto _L___6;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;17392\n");
goto _L___6;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;17397\n");
goto _L___6;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;17402\n");
goto _L___6;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;17407\n");
goto _L___6;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;17412\n");
goto _L___6;
        }
      }
      else
      {
      _L___6: /* CIL Label */
        {
printf("\nSTMT_EXEC;;17418\n");
if (extended_header.size)
        {
          printf("\nSTMT_EXEC;;17420\n");
format = (enum archive_format)4;
        }
        else
        {
          printf("\nSTMT_EXEC;;17424\n");
format = (enum archive_format)3;
        }
}

      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;17431\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)(header->header.magic), "ustar  ");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;17433\n");
if (tmp == 0)
      {
        printf("\nSTMT_EXEC;;17435\n");
format = (enum archive_format)2;
      }
      else
      {
        printf("\nSTMT_EXEC;;17439\n");
format = (enum archive_format)1;
      }
    }
    {
      printf("\nSTMT_EXEC;;17443\n");
*format_pointer = format;
      printf("\nSTMT_EXEC;;17444\n");
stat_info->stat.st_mode = mode_from_header((char const *)(header->header.mode), sizeof(header->header.mode));
      printf("\nSTMT_EXEC;;17445\n");
stat_info->stat.st_mtim.tv_sec = time_from_header((char const *)(header->header.mtime), sizeof(header->header.mtime));
      printf("\nSTMT_EXEC;;17446\n");
assign_string(&stat_info->uname, (char const *)(header->header.uname));
      printf("\nSTMT_EXEC;;17447\n");
assign_string(&stat_info->gname, (char const *)(header->header.gname));
      printf("\nSTMT_EXEC;;17448\n");
tmp___1 = major_from_header((char const *)(header->header.devmajor), sizeof(header->header.devmajor));
      printf("\nSTMT_EXEC;;17449\n");
stat_info->devmajor = (unsigned int)tmp___1;
      printf("\nSTMT_EXEC;;17450\n");
tmp___2 = minor_from_header((char const *)(header->header.devminor), sizeof(header->header.devminor));
      printf("\nSTMT_EXEC;;17451\n");
stat_info->devminor = (unsigned int)tmp___2;
      printf("\nSTMT_EXEC;;17452\n");
stat_info->stat.st_atim.tv_sec = start_timespec.tv_sec;
      printf("\nSTMT_EXEC;;17453\n");
stat_info->stat.st_ctim.tv_sec = start_timespec.tv_sec;
    }
    printf("\nSTMT_EXEC;;17455\n");
if ((unsigned int)format == 2U)
    {
      printf("\nSTMT_EXEC;;17457\n");
if (incremental_option)
      {
        {
          printf("\nSTMT_EXEC;;17460\n");
stat_info->stat.st_atim.tv_sec = time_from_header((char const *)(header->oldgnu_header.atime), sizeof(header->oldgnu_header.atime));
          printf("\nSTMT_EXEC;;17461\n");
stat_info->stat.st_ctim.tv_sec = time_from_header((char const *)(header->oldgnu_header.ctime), sizeof(header->oldgnu_header.ctime));
        }
      }
    }
    printf("\nSTMT_EXEC;;17465\n");
if ((unsigned int)format == 1U)
    {
      {
        printf("\nSTMT_EXEC;;17468\n");
stat_info->stat.st_uid = uid_from_header((char const *)(header->header.uid), sizeof(header->header.uid));
        printf("\nSTMT_EXEC;;17469\n");
stat_info->stat.st_gid = gid_from_header((char const *)(header->header.gid), sizeof(header->header.gid));
        printf("\nSTMT_EXEC;;17470\n");
stat_info->stat.st_rdev = (__dev_t)0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;17475\n");
if ((unsigned int)format == 5U)
      {
        {
          printf("\nSTMT_EXEC;;17478\n");
stat_info->stat.st_atim.tv_sec = time_from_header((char const *)(header->star_header.atime), sizeof(header->star_header.atime));
          printf("\nSTMT_EXEC;;17479\n");
stat_info->stat.st_ctim.tv_sec = time_from_header((char const *)(header->star_header.ctime), sizeof(header->star_header.ctime));
        }
      }
      printf("\nSTMT_EXEC;;17482\n");
if (do_user_group)
      {
        printf("\nSTMT_EXEC;;17484\n");
if (numeric_owner_option)
        {
          {
            printf("\nSTMT_EXEC;;17487\n");
stat_info->stat.st_uid = uid_from_header((char const *)(header->header.uid), sizeof(header->header.uid));
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;17492\n");
if (!header->header.uname[0])
          {
            {
              printf("\nSTMT_EXEC;;17495\n");
stat_info->stat.st_uid = uid_from_header((char const *)(header->header.uid), sizeof(header->header.uid));
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;17501\n");
tmp___3 = uname_to_uid((char const *)(header->header.uname), &stat_info->stat.st_uid);
            }
            printf("\nSTMT_EXEC;;17503\n");
if (!tmp___3)
            {
              {
                printf("\nSTMT_EXEC;;17506\n");
stat_info->stat.st_uid = uid_from_header((char const *)(header->header.uid), sizeof(header->header.uid));
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;17511\n");
if (numeric_owner_option)
        {
          {
            printf("\nSTMT_EXEC;;17514\n");
stat_info->stat.st_gid = gid_from_header((char const *)(header->header.gid), sizeof(header->header.gid));
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;17519\n");
if (!header->header.gname[0])
          {
            {
              printf("\nSTMT_EXEC;;17522\n");
stat_info->stat.st_gid = gid_from_header((char const *)(header->header.gid), sizeof(header->header.gid));
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;17528\n");
tmp___4 = gname_to_gid((char const *)(header->header.gname), &stat_info->stat.st_gid);
            }
            printf("\nSTMT_EXEC;;17530\n");
if (!tmp___4)
            {
              {
                printf("\nSTMT_EXEC;;17533\n");
stat_info->stat.st_gid = gid_from_header((char const *)(header->header.gid), sizeof(header->header.gid));
              }
            }
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;17540\n");
if ((int)header->header.typeflag == 52)
        {
          printf("\nSTMT_EXEC;;17542\n");
goto case_52;
        }
        printf("\nSTMT_EXEC;;17544\n");
if ((int)header->header.typeflag == 51)
        {
          printf("\nSTMT_EXEC;;17546\n");
goto case_52;
        }
        printf("\nSTMT_EXEC;;17548\n");
goto switch_default;
      case_52: /* CIL Label */
      case_51: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;17552\n");
printf("\nFUNC_CALL;gnu_dev_makedev(unsigned int,unsigned int);\n");
tmp___5 = gnu_dev_makedev(stat_info->devmajor, stat_info->devminor);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;17553\n");
stat_info->stat.st_rdev = (__dev_t)tmp___5;
      }
        printf("\nSTMT_EXEC;;17555\n");
goto switch_break;
      switch_default: /* CIL Label */
        {
printf("\nSTMT_EXEC;;17557\n");
stat_info->stat.st_rdev = (__dev_t)0;
}

      switch_break: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;17562\n");
stat_info->archive_file_size = stat_info->stat.st_size;
      printf("\nSTMT_EXEC;;17563\n");
xheader_decode(stat_info);
      printf("\nSTMT_EXEC;;17564\n");
tmp___6 = sparse_member_p(stat_info);
    }
    printf("\nSTMT_EXEC;;17566\n");
if (tmp___6)
    {
      {
        printf("\nSTMT_EXEC;;17569\n");
sparse_fixup_header(stat_info);
        printf("\nSTMT_EXEC;;17570\n");
stat_info->is_sparse = (_Bool)1;
      }
    }
    printf("\nSTMT_EXEC;;17573\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int warned_once___0;
static struct quoting_options *o;























































































































































































































































































static uintmax_t from_header(char const *where0, size_t digs, char const *type, uintmax_t minus_minval, uintmax_t maxval)
{
  printf("\nFUNC_CALL;from_header(const char *,size_t,const char *,uintmax_t,uintmax_t);\n");
printf("\nSTMT_EXEC;;17859\n");
uintmax_t value;
  printf("\nSTMT_EXEC;;17860\n");
char const *where;
  printf("\nSTMT_EXEC;;17861\n");
char const *lim;
  printf("\nSTMT_EXEC;;17862\n");
int negative;
  printf("\nSTMT_EXEC;;17863\n");
char *tmp;
  printf("\nSTMT_EXEC;;17864\n");
unsigned short const **tmp___0;
  printf("\nSTMT_EXEC;;17865\n");
char const *where1;
  printf("\nSTMT_EXEC;;17866\n");
uintmax_t overflow;
  printf("\nSTMT_EXEC;;17867\n");
char const *tmp___1;
  printf("\nSTMT_EXEC;;17868\n");
int digit;
  printf("\nSTMT_EXEC;;17869\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;17870\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;17871\n");
int dig;
  printf("\nSTMT_EXEC;;17872\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;17873\n");
char const *tmp___5;
  printf("\nSTMT_EXEC;;17874\n");
char *string;
  printf("\nSTMT_EXEC;;17875\n");
void *tmp___6;
  printf("\nSTMT_EXEC;;17876\n");
char const *tmp___7;
  printf("\nSTMT_EXEC;;17877\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;17878\n");
int signbit;
  printf("\nSTMT_EXEC;;17879\n");
uintmax_t topbits;
  printf("\nSTMT_EXEC;;17880\n");
char const *tmp___9;
  printf("\nSTMT_EXEC;;17881\n");
char const *tmp___10;
  printf("\nSTMT_EXEC;;17882\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;17883\n");
char buf[1000];
  printf("\nSTMT_EXEC;;17884\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;17885\n");
unsigned short const **tmp___13;
  printf("\nSTMT_EXEC;;17886\n");
char minval_buf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;17887\n");
char maxval_buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;17888\n");
char value_buf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;17889\n");
char *minval_string;
  printf("\nSTMT_EXEC;;17890\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;17891\n");
char *value_string;
  printf("\nSTMT_EXEC;;17892\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;17893\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;17894\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;17895\n");
uintmax_t tmp___18;
  printf("\nSTMT_EXEC;;17896\n");
uintmax_t tmp___19;
  printf("\nSTMT_EXEC;;17897\n");
void *__cil_tmp44;
  printf("\nSTMT_EXEC;;17898\n");
void *__cil_tmp45;
  printf("\nSTMT_EXEC;;17899\n");
void *__cil_tmp46;
  printf("\nSTMT_EXEC;;17900\n");
void *__cil_tmp47;
  printf("\nSTMT_EXEC;;17901\n");
char *__cil_tmp48;
  printf("\nSTMT_EXEC;;17902\n");
char *__cil_tmp49;
  printf("\nSTMT_EXEC;;17903\n");
char *__cil_tmp50;
  printf("\nSTMT_EXEC;;17904\n");
char *__cil_tmp51;
  printf("\nSTMT_EXEC;;17905\n");
char *__cil_tmp52;
  printf("\nSTMT_EXEC;;17906\n");
char *__cil_tmp53;
  printf("\nSTMT_EXEC;;17907\n");
char *__cil_tmp54;
  printf("\nSTMT_EXEC;;17908\n");
char *__cil_tmp55;

  {
    printf("\nSTMT_EXEC;;17911\n");
where = where0;
    printf("\nSTMT_EXEC;;17912\n");
lim = where + digs;
    printf("\nSTMT_EXEC;;17913\n");
negative = 0;
    printf("\nSTMT_EXEC;;17914\n");
where += !*where;
    {
      printf("\nSTMT_EXEC;;17916\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;17919\n");
if ((unsigned long)where == (unsigned long)lim)
        {
          printf("\nSTMT_EXEC;;17921\n");
if (type)
          {
            {
              printf("\nSTMT_EXEC;;17924\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Blanks in header where numeric %s value expected");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;17925\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, type);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;17926\n");
exit_status = 2;
            }
          }
          printf("\nSTMT_EXEC;;17929\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
        }
        {
          printf("\nSTMT_EXEC;;17932\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___0 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;17934\n");
if (!((int const) * (*tmp___0 + (int)((unsigned char)*where)) & 8192))
        {
          printf("\nSTMT_EXEC;;17936\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;17938\n");
where++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;17942\n");
value = (uintmax_t)0;
    printf("\nSTMT_EXEC;;17943\n");
if ((unsigned int)*where - 48U <= 7U)
    {
      printf("\nSTMT_EXEC;;17945\n");
where1 = where;
      printf("\nSTMT_EXEC;;17946\n");
overflow = (uintmax_t)0;
      {

        printf("\nSTMT_EXEC;;17949\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;17952\n");
tmp___1 = where;
          printf("\nSTMT_EXEC;;17953\n");
where++;
          printf("\nSTMT_EXEC;;17954\n");
value += (uintmax_t)((int const) * tmp___1 - 48);
          printf("\nSTMT_EXEC;;17955\n");
if ((unsigned long)where == (unsigned long)lim)
          {
            printf("\nSTMT_EXEC;;17957\n");
goto while_break___0;
          }
          else
          {
            printf("\nSTMT_EXEC;;17961\n");
if (!((unsigned int)*where - 48U <= 7U))
            {
              printf("\nSTMT_EXEC;;17963\n");
goto while_break___0;
            }
          }
          printf("\nSTMT_EXEC;;17966\n");
overflow |= value ^ ((value << 3) >> 3);
          printf("\nSTMT_EXEC;;17967\n");
value <<= 3;
        }
      while_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;17971\n");
if (overflow)
      {
        printf("\nSTMT_EXEC;;17973\n");
goto _L___3;
      }
      else
      {
        printf("\nSTMT_EXEC;;17977\n");
if (maxval < value)
        {
        _L___3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;17980\n");
if (50 <= (int)*where1)
          {
            printf("\nSTMT_EXEC;;17982\n");
if (type)
            {
              printf("\nSTMT_EXEC;;17984\n");
digit = (int)(((int const) * where1 - 48) | 4);
              printf("\nSTMT_EXEC;;17985\n");
overflow = (uintmax_t)0;
              printf("\nSTMT_EXEC;;17986\n");
value = (uintmax_t)0;
              printf("\nSTMT_EXEC;;17987\n");
where = where1;
              {
                printf("\nSTMT_EXEC;;17989\n");
while (1)
                {
                while_continue___1: /* CIL Label */;
                  printf("\nSTMT_EXEC;;17992\n");
value += (uintmax_t)(7 - digit);
                  printf("\nSTMT_EXEC;;17993\n");
where++;
                  printf("\nSTMT_EXEC;;17994\n");
if ((unsigned long)where == (unsigned long)lim)
                  {
                    printf("\nSTMT_EXEC;;17996\n");
goto while_break___1;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;18000\n");
if (!((unsigned int)*where - 48U <= 7U))
                    {
                      printf("\nSTMT_EXEC;;18002\n");
goto while_break___1;
                    }
                  }
                  printf("\nSTMT_EXEC;;18005\n");
digit = (int)((int const) * where - 48);
                  printf("\nSTMT_EXEC;;18006\n");
overflow |= value ^ ((value << 3) >> 3);
                  printf("\nSTMT_EXEC;;18007\n");
value <<= 3;
                }
              while_break___1: /* CIL Label */;
              }
              printf("\nSTMT_EXEC;;18011\n");
value++;
              printf("\nSTMT_EXEC;;18012\n");
overflow |= (unsigned long)(!value);
              printf("\nSTMT_EXEC;;18013\n");
if (!overflow)
              {
                printf("\nSTMT_EXEC;;18015\n");
if (value <= minus_minval)
                {
                  {
                    printf("\nSTMT_EXEC;;18018\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Archive octal value %.*s is out of %s "
                                      "range; assuming two\'s complement");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;18020\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, (int)(where - where1), where1, type);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;18021\n");
negative = 1;
                  }
                }
              }
            }
          }
}

        }
      }
      printf("\nSTMT_EXEC;;18029\n");
if (overflow)
      {
        printf("\nSTMT_EXEC;;18031\n");
if (type)
        {
          {
            printf("\nSTMT_EXEC;;18034\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Archive octal value %.*s is out of %s range");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;18035\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3, (int)(where - where1), where1, type);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;18036\n");
exit_status = 2;
          }
        }
        printf("\nSTMT_EXEC;;18039\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;18044\n");
if ((int const) * where == 45)
      {
        printf("\nSTMT_EXEC;;18046\n");
goto _L___5;
      }
      else
      {
        printf("\nSTMT_EXEC;;18050\n");
if ((int const) * where == 43)
        {
        _L___5: /* CIL Label */
          {
printf("\nSTMT_EXEC;;18053\n");
if (!warned_once___0)
          {
            {
              printf("\nSTMT_EXEC;;18056\n");
warned_once___0 = 1;
              printf("\nSTMT_EXEC;;18057\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Archive contains obsolescent base-64 headers");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;18058\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4);printf("\nFUNC_RETURN;;\n");

            }
          }
}

          printf("\nSTMT_EXEC;;18061\n");
tmp___5 = where;
          printf("\nSTMT_EXEC;;18062\n");
where++;
          printf("\nSTMT_EXEC;;18063\n");
negative = (int const) * tmp___5 == 45;
          {
            printf("\nSTMT_EXEC;;18065\n");
while (1)
            {
            while_continue___2: /* CIL Label */;
              printf("\nSTMT_EXEC;;18068\n");
if ((unsigned long)where != (unsigned long)lim)
              {
                printf("\nSTMT_EXEC;;18070\n");
dig = (int)base64_map[(unsigned char)*where];
                printf("\nSTMT_EXEC;;18071\n");
if (!(dig < 64))
                {
                  printf("\nSTMT_EXEC;;18073\n");
goto while_break___2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;18078\n");
goto while_break___2;
              }
              printf("\nSTMT_EXEC;;18080\n");
if ((value << 6) >> 6 != value)
              {
                {
                  printf("\nSTMT_EXEC;;18083\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___6 = __builtin_alloca(digs + 1UL);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;18084\n");
string = (char *)tmp___6;
                  printf("\nSTMT_EXEC;;18085\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)string, (void const * /* __restrict  */)where0, digs);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;18086\n");
*(string + digs) = (char)'\000';
                }
                printf("\nSTMT_EXEC;;18088\n");
if (type)
                {
                  {
                    printf("\nSTMT_EXEC;;18091\n");
tmp___7 = quote((char const *)string);
                    printf("\nSTMT_EXEC;;18092\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("Archive signed base-64 string %s is out of %s range");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;18093\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8, tmp___7, type);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;18094\n");
exit_status = 2;
                  }
                }
                printf("\nSTMT_EXEC;;18097\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
              }
              printf("\nSTMT_EXEC;;18099\n");
value = (value << 6) | (unsigned long)dig;
              printf("\nSTMT_EXEC;;18100\n");
where++;
            }
          while_break___2: /* CIL Label */;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;18107\n");
if ((int const) * where == -128)
          {
            printf("\nSTMT_EXEC;;18109\n");
goto _L___4;
          }
          else
          {
            printf("\nSTMT_EXEC;;18113\n");
if ((int const) * where == -1)
            {
            _L___4: /* CIL Label */
              {
printf("\nSTMT_EXEC;;18116\n");
signbit = (int)((int const) * where & (int const)(1 << 6));
}

              printf("\nSTMT_EXEC;;18117\n");
topbits = (uintmax_t)(-signbit) << ((8UL * sizeof(uintmax_t) - 8UL) - 6UL);
              printf("\nSTMT_EXEC;;18118\n");
tmp___9 = where;
              printf("\nSTMT_EXEC;;18119\n");
where++;
              printf("\nSTMT_EXEC;;18120\n");
value = (uintmax_t)(((int const) * tmp___9 & (int const)((1 << 6) - 1)) - (int const)signbit);
              {
                printf("\nSTMT_EXEC;;18122\n");
while (1)
                {
                while_continue___3: /* CIL Label */;
                  printf("\nSTMT_EXEC;;18125\n");
tmp___10 = where;
                  printf("\nSTMT_EXEC;;18126\n");
where++;
                  printf("\nSTMT_EXEC;;18127\n");
value = (value << 8) + (uintmax_t)((unsigned char)*tmp___10);
                  printf("\nSTMT_EXEC;;18128\n");
if ((unsigned long)where == (unsigned long)lim)
                  {
                    printf("\nSTMT_EXEC;;18130\n");
goto while_break___3;
                  }
                  printf("\nSTMT_EXEC;;18132\n");
if ((((value << 8) >> 8) | topbits) != value)
                  {
                    printf("\nSTMT_EXEC;;18134\n");
if (type)
                    {
                      {
                        printf("\nSTMT_EXEC;;18137\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___11 = gettext("Archive base-256 value is out of %s range");printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;18138\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___11, type);printf("\nFUNC_RETURN;;\n");

                        printf("\nSTMT_EXEC;;18139\n");
exit_status = 2;
                      }
                    }
                    printf("\nSTMT_EXEC;;18142\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
                  }
                }
              while_break___3: /* CIL Label */;
              }
              printf("\nSTMT_EXEC;;18147\n");
negative = signbit;
              printf("\nSTMT_EXEC;;18148\n");
if (negative)
              {
                printf("\nSTMT_EXEC;;18150\n");
value = -value;
              }
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;18157\n");
if ((unsigned long)where != (unsigned long)lim)
    {
      printf("\nSTMT_EXEC;;18159\n");
if (*where)
      {
        {
          printf("\nSTMT_EXEC;;18162\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___13 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;18164\n");
if (!((int const) * (*tmp___13 + (int)((unsigned char)*where)) & 8192))
        {
          printf("\nSTMT_EXEC;;18166\n");
if (type)
          {
            printf("\nSTMT_EXEC;;18168\n");
if (!o)
            {
              {
                printf("\nSTMT_EXEC;;18171\n");
o = clone_quoting_options((struct quoting_options *)0);
                printf("\nSTMT_EXEC;;18172\n");
set_quoting_style(o, (enum quoting_style)5);
              }
            }
            {
              printf("\nSTMT_EXEC;;18176\n");
while (1)
              {
              while_continue___4: /* CIL Label */;
                printf("\nSTMT_EXEC;;18179\n");
if ((unsigned long)where0 != (unsigned long)lim)
                {
                  printf("\nSTMT_EXEC;;18181\n");
if (!(!*(lim + -1)))
                  {
                    printf("\nSTMT_EXEC;;18183\n");
goto while_break___4;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;18188\n");
goto while_break___4;
                }
                printf("\nSTMT_EXEC;;18190\n");
lim--;
              }
            while_break___4: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;18195\n");
quotearg_buffer(buf, sizeof(buf), where0, (size_t)(lim - where), (struct quoting_options const *)o);
              printf("\nSTMT_EXEC;;18196\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___12 = gettext("Archive contains %.*s where numeric %s value expected");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;18197\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___12, (int)sizeof(buf), buf, type);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;18198\n");
exit_status = 2;
            }
          }
          printf("\nSTMT_EXEC;;18201\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
        }
      }
    }
    printf("\nSTMT_EXEC;;18205\n");
if (negative)
    {
      printf("\nSTMT_EXEC;;18207\n");
tmp___19 = minus_minval;
    }
    else
    {
      printf("\nSTMT_EXEC;;18211\n");
tmp___19 = maxval;
    }
    printf("\nSTMT_EXEC;;18213\n");
if (value <= tmp___19)
    {
      printf("\nSTMT_EXEC;;18215\n");
if (negative)
      {
        printf("\nSTMT_EXEC;;18217\n");
tmp___18 = -value;
      }
      else
      {
        printf("\nSTMT_EXEC;;18221\n");
tmp___18 = value;
      }
      printf("\nSTMT_EXEC;;18223\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___18);
    }
    printf("\nSTMT_EXEC;;18225\n");
if (type)
    {
      {
        printf("\nSTMT_EXEC;;18228\n");
tmp___14 = stringify_uintmax_t_backwards(minus_minval, (minval_buf + 1) + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;18229\n");
minval_string = tmp___14;
        printf("\nSTMT_EXEC;;18230\n");
tmp___15 = stringify_uintmax_t_backwards(value, (value_buf + 1) + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;18231\n");
value_string = tmp___15;
      }
      printf("\nSTMT_EXEC;;18233\n");
if (negative)
      {
        printf("\nSTMT_EXEC;;18235\n");
value_string--;
        printf("\nSTMT_EXEC;;18236\n");
*value_string = (char)'-';
      }
      printf("\nSTMT_EXEC;;18238\n");
if (minus_minval)
      {
        printf("\nSTMT_EXEC;;18240\n");
minval_string--;
        printf("\nSTMT_EXEC;;18241\n");
*minval_string = (char)'-';
      }
      {
        printf("\nSTMT_EXEC;;18244\n");
tmp___16 = stringify_uintmax_t_backwards(maxval, maxval_buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;18245\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___17 = gettext("Archive value %s is out of %s range %s.%s");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;18246\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___17, value_string, type, minval_string, tmp___16);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;18247\n");
exit_status = 2;
      }
    }
    printf("\nSTMT_EXEC;;18250\n");
printf("\nFUNC_RETURN;;\n");
return ((uintmax_t)-1);
  }
printf("\nFUNC_RETURN;;\n");
}
gid_t gid_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;gid_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18255\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18256\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18260\n");
tmp = from_header(p, s, "gid_t", -((uintmax_t)((gid_t)0)), (uintmax_t)4294967295U);
    }
    printf("\nSTMT_EXEC;;18262\n");
printf("\nFUNC_RETURN;;\n");
return ((gid_t)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
int major_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;major_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18267\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18268\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18272\n");
tmp = from_header(p, s, "major_t", -((uintmax_t)(-1 << (sizeof(int) * 8UL - 1UL))), (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
    }
    printf("\nSTMT_EXEC;;18274\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
int minor_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;minor_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18279\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18280\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18284\n");
tmp = from_header(p, s, "minor_t", -((uintmax_t)(-1 << (sizeof(int) * 8UL - 1UL))), (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
    }
    printf("\nSTMT_EXEC;;18286\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
mode_t mode_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;mode_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18291\n");
unsigned int u;
  printf("\nSTMT_EXEC;;18292\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18293\n");
int tmp___0;
  printf("\nSTMT_EXEC;;18294\n");
int tmp___1;
  printf("\nSTMT_EXEC;;18295\n");
int tmp___2;
  printf("\nSTMT_EXEC;;18296\n");
int tmp___3;
  printf("\nSTMT_EXEC;;18297\n");
int tmp___4;
  printf("\nSTMT_EXEC;;18298\n");
int tmp___5;
  printf("\nSTMT_EXEC;;18299\n");
int tmp___6;
  printf("\nSTMT_EXEC;;18300\n");
int tmp___7;
  printf("\nSTMT_EXEC;;18301\n");
int tmp___8;
  printf("\nSTMT_EXEC;;18302\n");
int tmp___9;
  printf("\nSTMT_EXEC;;18303\n");
int tmp___10;
  printf("\nSTMT_EXEC;;18304\n");
int tmp___11;
  printf("\nSTMT_EXEC;;18305\n");
char *__cil_tmp17;

  {
    {
      printf("\nSTMT_EXEC;;18309\n");
tmp = from_header(p, s, "mode_t", -((uintmax_t)((mode_t)0)), 0xffffffffffffffffUL);
      printf("\nSTMT_EXEC;;18310\n");
u = (unsigned int)tmp;
    }
    printf("\nSTMT_EXEC;;18312\n");
if (u & 2048U)
    {
      printf("\nSTMT_EXEC;;18314\n");
tmp___0 = 2048;
    }
    else
    {
      printf("\nSTMT_EXEC;;18318\n");
tmp___0 = 0;
    }
    printf("\nSTMT_EXEC;;18320\n");
if (u & 1024U)
    {
      printf("\nSTMT_EXEC;;18322\n");
tmp___1 = 1024;
    }
    else
    {
      printf("\nSTMT_EXEC;;18326\n");
tmp___1 = 0;
    }
    printf("\nSTMT_EXEC;;18328\n");
if (u & 512U)
    {
      printf("\nSTMT_EXEC;;18330\n");
tmp___2 = 512;
    }
    else
    {
      printf("\nSTMT_EXEC;;18334\n");
tmp___2 = 0;
    }
    printf("\nSTMT_EXEC;;18336\n");
if (u & 256U)
    {
      printf("\nSTMT_EXEC;;18338\n");
tmp___3 = 256;
    }
    else
    {
      printf("\nSTMT_EXEC;;18342\n");
tmp___3 = 0;
    }
    printf("\nSTMT_EXEC;;18344\n");
if (u & 128U)
    {
      printf("\nSTMT_EXEC;;18346\n");
tmp___4 = 128;
    }
    else
    {
      printf("\nSTMT_EXEC;;18350\n");
tmp___4 = 0;
    }
    printf("\nSTMT_EXEC;;18352\n");
if (u & 64U)
    {
      printf("\nSTMT_EXEC;;18354\n");
tmp___5 = 64;
    }
    else
    {
      printf("\nSTMT_EXEC;;18358\n");
tmp___5 = 0;
    }
    printf("\nSTMT_EXEC;;18360\n");
if (u & 32U)
    {
      printf("\nSTMT_EXEC;;18362\n");
tmp___6 = 256 >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18366\n");
tmp___6 = 0;
    }
    printf("\nSTMT_EXEC;;18368\n");
if (u & 16U)
    {
      printf("\nSTMT_EXEC;;18370\n");
tmp___7 = 128 >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18374\n");
tmp___7 = 0;
    }
    printf("\nSTMT_EXEC;;18376\n");
if (u & 8U)
    {
      printf("\nSTMT_EXEC;;18378\n");
tmp___8 = 64 >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18382\n");
tmp___8 = 0;
    }
    printf("\nSTMT_EXEC;;18384\n");
if (u & 4U)
    {
      printf("\nSTMT_EXEC;;18386\n");
tmp___9 = (256 >> 3) >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18390\n");
tmp___9 = 0;
    }
    printf("\nSTMT_EXEC;;18392\n");
if (u & 2U)
    {
      printf("\nSTMT_EXEC;;18394\n");
tmp___10 = (128 >> 3) >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18398\n");
tmp___10 = 0;
    }
    printf("\nSTMT_EXEC;;18400\n");
if (u & 1U)
    {
      printf("\nSTMT_EXEC;;18402\n");
tmp___11 = (64 >> 3) >> 3;
    }
    else
    {
      printf("\nSTMT_EXEC;;18406\n");
tmp___11 = 0;
    }
    printf("\nSTMT_EXEC;;18408\n");
printf("\nFUNC_RETURN;;\n");
return ((mode_t)(((((((((((tmp___0 | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10) | tmp___11));
  }
printf("\nFUNC_RETURN;;\n");
}





























































































































































































































































































































































off_t off_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;off_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18762\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18763\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18767\n");
tmp = from_header(p, s, "off_t", (uintmax_t)0, (uintmax_t)(-1L - (-1L << (sizeof(off_t) * 8UL - 1UL))));
    }
    printf("\nSTMT_EXEC;;18769\n");
printf("\nFUNC_RETURN;;\n");
return ((off_t)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t size_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;size_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18774\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18775\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18779\n");
tmp = from_header(p, s, "size_t", (uintmax_t)0, 0xffffffffffffffffUL);
    }
    printf("\nSTMT_EXEC;;18781\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
time_t time_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;time_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18786\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18787\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18791\n");
tmp = from_header(p, s, "time_t", -((uintmax_t)(-1L << (sizeof(time_t) * 8UL - 1UL))), (uintmax_t)(-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))));
    }
    printf("\nSTMT_EXEC;;18793\n");
printf("\nFUNC_RETURN;;\n");
return ((time_t)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
uid_t uid_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;uid_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18798\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18799\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18803\n");
tmp = from_header(p, s, "uid_t", -((uintmax_t)((uid_t)0)), (uintmax_t)4294967295U);
    }
    printf("\nSTMT_EXEC;;18805\n");
printf("\nFUNC_RETURN;;\n");
return ((uid_t)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
uintmax_t uintmax_from_header(char const *p, size_t s)
{
  printf("\nFUNC_CALL;uintmax_from_header(const char *,size_t);\n");
printf("\nSTMT_EXEC;;18810\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;18811\n");
char *__cil_tmp4;

  {
    {
      printf("\nSTMT_EXEC;;18815\n");
tmp = from_header(p, s, "uintmax_t", (uintmax_t)0, 0xffffffffffffffffUL);
    }
    printf("\nSTMT_EXEC;;18817\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
char *stringify_uintmax_t_backwards(uintmax_t o___0, char *buf)
{

  printf("\nFUNC_CALL;stringify_uintmax_t_backwards(uintmax_t,char *);\n");
{
    printf("\nSTMT_EXEC;;18824\n");
buf--;
    printf("\nSTMT_EXEC;;18825\n");
*buf = (char)'\000';
    {
      printf("\nSTMT_EXEC;;18827\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;18830\n");
buf--;
        printf("\nSTMT_EXEC;;18831\n");
*buf = (char)(48 + (int)(o___0 % 10UL));
        printf("\nSTMT_EXEC;;18832\n");
o___0 /= 10UL;
        printf("\nSTMT_EXEC;;18833\n");
if (!(o___0 != 0UL))
        {
          printf("\nSTMT_EXEC;;18835\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;18840\n");
printf("\nFUNC_RETURN;;\n");
return (buf);
  }
printf("\nFUNC_RETURN;;\n");
}
static char buffer[27UL];
char const *tartime(time_t t)
{
  printf("\nFUNC_CALL;tartime(time_t);\n");
printf("\nSTMT_EXEC;;18846\n");
char *p;
  printf("\nSTMT_EXEC;;18847\n");
struct tm *tm;
  printf("\nSTMT_EXEC;;18848\n");
struct tm *tmp;
  printf("\nSTMT_EXEC;;18849\n");
struct tm *tmp___0;
  printf("\nSTMT_EXEC;;18850\n");
struct tm *tmp___1;
  printf("\nSTMT_EXEC;;18851\n");
uintmax_t tmp___2;
  printf("\nSTMT_EXEC;;18852\n");
char *__cil_tmp8;

  {
    printf("\nSTMT_EXEC;;18855\n");
if (utc_option)
    {
      {
        printf("\nSTMT_EXEC;;18858\n");
printf("\nFUNC_CALL;gmtime(const time_t *);\n");
tmp = gmtime((time_t const *)(&t));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;18859\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;18865\n");
printf("\nFUNC_CALL;localtime(const time_t *);\n");
tmp___0 = localtime((time_t const *)(&t));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;18866\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;18869\n");
tm = tmp___1;
    printf("\nSTMT_EXEC;;18870\n");
if (tm)
    {
      {
        printf("\nSTMT_EXEC;;18873\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(buffer), (char const * /* __restrict  */) "%04ld-%02d-%02d %02d:%02d:%02d", (long)tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;18875\n");
printf("\nFUNC_RETURN;;\n");
return ((char const *)(buffer));
    }
    printf("\nSTMT_EXEC;;18877\n");
if (t < 0L)
    {
      printf("\nSTMT_EXEC;;18879\n");
tmp___2 = -((uintmax_t)t);
    }
    else
    {
      printf("\nSTMT_EXEC;;18883\n");
tmp___2 = (uintmax_t)t;
    }
    {
      printf("\nSTMT_EXEC;;18886\n");
p = stringify_uintmax_t_backwards(tmp___2, buffer + sizeof(buffer));
    }
    printf("\nSTMT_EXEC;;18888\n");
if (t < 0L)
    {
      printf("\nSTMT_EXEC;;18890\n");
p--;
      printf("\nSTMT_EXEC;;18891\n");
*p = (char)'-';
    }
    {
      printf("\nSTMT_EXEC;;18894\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;18897\n");
if (!((unsigned long)(((buffer + sizeof(buffer)) - 19) - 1) < (unsigned long)p))
        {
          printf("\nSTMT_EXEC;;18899\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;18901\n");
p--;
        printf("\nSTMT_EXEC;;18902\n");
*p = (char)' ';
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;18906\n");
printf("\nFUNC_RETURN;;\n");
return ((char const *)p);
  }
printf("\nFUNC_RETURN;;\n");
}
static int ugswidth = 18;
void print_header(struct tar_stat_info *st, off_t block_ordinal)
{
  printf("\nFUNC_CALL;print_header(struct tar_stat_info *,off_t);\n");
printf("\nSTMT_EXEC;;18912\n");
char modes[11];
  printf("\nSTMT_EXEC;;18913\n");
char const *time_stamp;
  printf("\nSTMT_EXEC;;18914\n");
char *temp_name;
  printf("\nSTMT_EXEC;;18915\n");
char uform[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;18916\n");
char gform[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;18917\n");
char *user;
  printf("\nSTMT_EXEC;;18918\n");
char *group;
  printf("\nSTMT_EXEC;;18919\n");
char size[2UL * ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL)];
  printf("\nSTMT_EXEC;;18920\n");
char uintbuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;18921\n");
int pad;
  printf("\nSTMT_EXEC;;18922\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;18923\n");
char *tmp;
  printf("\nSTMT_EXEC;;18924\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;18925\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;18926\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;18927\n");
size_t tmp___3;
  printf("\nSTMT_EXEC;;18928\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;18929\n");
uintmax_t tmp___4;
  printf("\nSTMT_EXEC;;18930\n");
uid_t tmp___5;
  printf("\nSTMT_EXEC;;18931\n");
uintmax_t g;
  printf("\nSTMT_EXEC;;18932\n");
uintmax_t tmp___6;
  printf("\nSTMT_EXEC;;18933\n");
gid_t tmp___7;
  printf("\nSTMT_EXEC;;18934\n");
unsigned int tmp___8;
  printf("\nSTMT_EXEC;;18935\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;18936\n");
unsigned int tmp___10;
  printf("\nSTMT_EXEC;;18937\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;18938\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;18939\n");
size_t tmp___13;
  printf("\nSTMT_EXEC;;18940\n");
size_t tmp___14;
  printf("\nSTMT_EXEC;;18941\n");
size_t tmp___15;
  printf("\nSTMT_EXEC;;18942\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;18943\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;18944\n");
char *tmp___18;
  printf("\nSTMT_EXEC;;18945\n");
char *tmp___19;
  printf("\nSTMT_EXEC;;18946\n");
char type_string[2];
  printf("\nSTMT_EXEC;;18947\n");
char const *tmp___20;
  printf("\nSTMT_EXEC;;18948\n");
char *tmp___21;
  printf("\nSTMT_EXEC;;18949\n");
char *tmp___22;
  printf("\nSTMT_EXEC;;18950\n");
char *tmp___23;
  printf("\nSTMT_EXEC;;18951\n");
char *tmp___24;
  printf("\nSTMT_EXEC;;18952\n");
uintmax_t tmp___25;
  printf("\nSTMT_EXEC;;18953\n");
char *tmp___26;
  printf("\nSTMT_EXEC;;18954\n");
char *tmp___27;
  printf("\nSTMT_EXEC;;18955\n");
char *tmp___28;
  printf("\nSTMT_EXEC;;18956\n");
void *__cil_tmp47;
  printf("\nSTMT_EXEC;;18957\n");
void *__cil_tmp48;
  printf("\nSTMT_EXEC;;18958\n");
void *__cil_tmp49;
  printf("\nSTMT_EXEC;;18959\n");
void *__cil_tmp50;
  printf("\nSTMT_EXEC;;18960\n");
void *__cil_tmp51;
  printf("\nSTMT_EXEC;;18961\n");
void *__cil_tmp52;
  printf("\nSTMT_EXEC;;18962\n");
void *__cil_tmp53;
  printf("\nSTMT_EXEC;;18963\n");
char *__cil_tmp54;
  printf("\nSTMT_EXEC;;18964\n");
char *__cil_tmp55;
  printf("\nSTMT_EXEC;;18965\n");
char *__cil_tmp56;
  printf("\nSTMT_EXEC;;18966\n");
char *__cil_tmp57;
  printf("\nSTMT_EXEC;;18967\n");
char *__cil_tmp58;
  printf("\nSTMT_EXEC;;18968\n");
char *__cil_tmp59;
  printf("\nSTMT_EXEC;;18969\n");
char *__cil_tmp60;
  printf("\nSTMT_EXEC;;18970\n");
char *__cil_tmp61;
  printf("\nSTMT_EXEC;;18971\n");
char *__cil_tmp62;
  printf("\nSTMT_EXEC;;18972\n");
char *__cil_tmp63;
  printf("\nSTMT_EXEC;;18973\n");
char *__cil_tmp64;
  printf("\nSTMT_EXEC;;18974\n");
char *__cil_tmp65;

  {
    printf("\nSTMT_EXEC;;18977\n");
if (st->orig_file_name)
    {
      printf("\nSTMT_EXEC;;18979\n");
temp_name = st->orig_file_name;
    }
    else
    {
      printf("\nSTMT_EXEC;;18983\n");
temp_name = st->file_name;
    }
    printf("\nSTMT_EXEC;;18985\n");
if (block_number_option)
    {
      printf("\nSTMT_EXEC;;18987\n");
if (block_ordinal < 0L)
      {
        {
          printf("\nSTMT_EXEC;;18990\n");
block_ordinal = current_block_ordinal();
        }
      }
      {
        printf("\nSTMT_EXEC;;18994\n");
block_ordinal = (off_t)((size_t)block_ordinal - recent_long_name_blocks);
        printf("\nSTMT_EXEC;;18995\n");
block_ordinal = (off_t)((size_t)block_ordinal - recent_long_link_blocks);
        printf("\nSTMT_EXEC;;18996\n");
tmp = stringify_uintmax_t_backwards((uintmax_t)block_ordinal, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;18997\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("block %s: ");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;18998\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;19001\n");
if (verbose_option <= 1)
    {
      {
        printf("\nSTMT_EXEC;;19004\n");
tmp___1 = quotearg((char const *)temp_name);
        printf("\nSTMT_EXEC;;19005\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "%s\n", tmp___1);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      printf("\nSTMT_EXEC;;19010\n");
modes[0] = (char)'?';
      {
        printf("\nSTMT_EXEC;;19012\n");
if ((int)current_header->header.typeflag == 86)
        {
          printf("\nSTMT_EXEC;;19014\n");
goto case_86;
        }
        printf("\nSTMT_EXEC;;19016\n");
if ((int)current_header->header.typeflag == 77)
        {
          printf("\nSTMT_EXEC;;19018\n");
goto case_77;
        }
        printf("\nSTMT_EXEC;;19020\n");
if ((int)current_header->header.typeflag == 78)
        {
          printf("\nSTMT_EXEC;;19022\n");
goto case_78;
        }
        printf("\nSTMT_EXEC;;19024\n");
if ((int)current_header->header.typeflag == 76)
        {
          printf("\nSTMT_EXEC;;19026\n");
goto case_76;
        }
        printf("\nSTMT_EXEC;;19028\n");
if ((int)current_header->header.typeflag == 75)
        {
          printf("\nSTMT_EXEC;;19030\n");
goto case_76;
        }
        printf("\nSTMT_EXEC;;19032\n");
if ((int)current_header->header.typeflag == 83)
        {
          printf("\nSTMT_EXEC;;19034\n");
goto case_83;
        }
        printf("\nSTMT_EXEC;;19036\n");
if ((int)current_header->header.typeflag == 48)
        {
          printf("\nSTMT_EXEC;;19038\n");
goto case_83;
        }
        printf("\nSTMT_EXEC;;19040\n");
if ((int)current_header->header.typeflag == 0)
        {
          printf("\nSTMT_EXEC;;19042\n");
goto case_83;
        }
        printf("\nSTMT_EXEC;;19044\n");
if ((int)current_header->header.typeflag == 49)
        {
          printf("\nSTMT_EXEC;;19046\n");
goto case_49;
        }
        printf("\nSTMT_EXEC;;19048\n");
if ((int)current_header->header.typeflag == 68)
        {
          printf("\nSTMT_EXEC;;19050\n");
goto case_68;
        }
        printf("\nSTMT_EXEC;;19052\n");
if ((int)current_header->header.typeflag == 53)
        {
          printf("\nSTMT_EXEC;;19054\n");
goto case_53;
        }
        printf("\nSTMT_EXEC;;19056\n");
if ((int)current_header->header.typeflag == 50)
        {
          printf("\nSTMT_EXEC;;19058\n");
goto case_50;
        }
        printf("\nSTMT_EXEC;;19060\n");
if ((int)current_header->header.typeflag == 52)
        {
          printf("\nSTMT_EXEC;;19062\n");
goto case_52;
        }
        printf("\nSTMT_EXEC;;19064\n");
if ((int)current_header->header.typeflag == 51)
        {
          printf("\nSTMT_EXEC;;19066\n");
goto case_51;
        }
        printf("\nSTMT_EXEC;;19068\n");
if ((int)current_header->header.typeflag == 54)
        {
          printf("\nSTMT_EXEC;;19070\n");
goto case_54;
        }
        printf("\nSTMT_EXEC;;19072\n");
if ((int)current_header->header.typeflag == 55)
        {
          printf("\nSTMT_EXEC;;19074\n");
goto case_55;
        }
        printf("\nSTMT_EXEC;;19076\n");
goto switch_break;
      case_86: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19078\n");
modes[0] = (char)'V';
}

        printf("\nSTMT_EXEC;;19079\n");
goto switch_break;
      case_77: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19081\n");
modes[0] = (char)'M';
}

        printf("\nSTMT_EXEC;;19082\n");
goto switch_break;
      case_78: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19084\n");
modes[0] = (char)'N';
}

        printf("\nSTMT_EXEC;;19085\n");
goto switch_break;
      case_76: /* CIL Label */
      case_75: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19089\n");
modes[0] = (char)'L';
        printf("\nSTMT_EXEC;;19090\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Visible longname error");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19091\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19092\n");
exit_status = 2;
      }
        printf("\nSTMT_EXEC;;19094\n");
goto switch_break;
      case_83: /* CIL Label */
      case_48: /* CIL Label */
      case_0:  /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19099\n");
modes[0] = (char)'-';
        printf("\nSTMT_EXEC;;19100\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___3 = strlen((char const *)temp_name);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19102\n");
if ((int)*(temp_name + (tmp___3 - 1UL)) == 47)
        {
          printf("\nSTMT_EXEC;;19104\n");
modes[0] = (char)'d';
        }
        printf("\nSTMT_EXEC;;19106\n");
goto switch_break;
      case_49: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19108\n");
modes[0] = (char)'h';
}

        printf("\nSTMT_EXEC;;19109\n");
goto switch_break;
      case_68: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19111\n");
modes[0] = (char)'d';
}

        printf("\nSTMT_EXEC;;19112\n");
goto switch_break;
      case_53: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19114\n");
modes[0] = (char)'d';
}

        printf("\nSTMT_EXEC;;19115\n");
goto switch_break;
      case_50: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19117\n");
modes[0] = (char)'l';
}

        printf("\nSTMT_EXEC;;19118\n");
goto switch_break;
      case_52: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19120\n");
modes[0] = (char)'b';
}

        printf("\nSTMT_EXEC;;19121\n");
goto switch_break;
      case_51: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19123\n");
modes[0] = (char)'c';
}

        printf("\nSTMT_EXEC;;19124\n");
goto switch_break;
      case_54: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19126\n");
modes[0] = (char)'p';
}

        printf("\nSTMT_EXEC;;19127\n");
goto switch_break;
      case_55: /* CIL Label */
        {
printf("\nSTMT_EXEC;;19129\n");
modes[0] = (char)'C';
}

        printf("\nSTMT_EXEC;;19130\n");
goto switch_break;
      switch_break: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;19134\n");
decode_mode(st->stat.st_mode, modes + 1);
        printf("\nSTMT_EXEC;;19135\n");
time_stamp = tartime(st->stat.st_mtim.tv_sec);
      }
      printf("\nSTMT_EXEC;;19137\n");
if (st->uname)
      {
        printf("\nSTMT_EXEC;;19139\n");
if ((unsigned int)current_format != 1U)
        {
          printf("\nSTMT_EXEC;;19141\n");
if (!numeric_owner_option)
          {
            printf("\nSTMT_EXEC;;19143\n");
user = st->uname;
          }
          else
          {
            printf("\nSTMT_EXEC;;19147\n");
goto _L___4;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;19152\n");
goto _L___4;
        }
      }
      else
      {
      _L___4: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19159\n");
tmp___4 = from_header((char const *)(current_header->header.uid), sizeof(current_header->header.uid), (char const *)0, (uintmax_t)0, 0xffffffffffffffffUL);
        printf("\nSTMT_EXEC;;19160\n");
u = tmp___4;
      }
        printf("\nSTMT_EXEC;;19162\n");
if (u != 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;19165\n");
user = stringify_uintmax_t_backwards(u, uform + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;19171\n");
tmp___5 = uid_from_header((char const *)(current_header->header.uid), sizeof(current_header->header.uid));
            printf("\nSTMT_EXEC;;19172\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(uform), (char const * /* __restrict  */) "%ld", (long)tmp___5);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19173\n");
user = uform;
          }
        }
      }
      printf("\nSTMT_EXEC;;19177\n");
if (st->gname)
      {
        printf("\nSTMT_EXEC;;19179\n");
if ((unsigned int)current_format != 1U)
        {
          printf("\nSTMT_EXEC;;19181\n");
if (!numeric_owner_option)
          {
            printf("\nSTMT_EXEC;;19183\n");
group = st->gname;
          }
          else
          {
            printf("\nSTMT_EXEC;;19187\n");
goto _L___6;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;19192\n");
goto _L___6;
        }
      }
      else
      {
      _L___6: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19199\n");
tmp___6 = from_header((char const *)(current_header->header.gid), sizeof(current_header->header.gid), (char const *)0, (uintmax_t)0, 0xffffffffffffffffUL);
        printf("\nSTMT_EXEC;;19200\n");
g = tmp___6;
      }
        printf("\nSTMT_EXEC;;19202\n");
if (g != 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;19205\n");
group = stringify_uintmax_t_backwards(g, gform + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;19211\n");
tmp___7 = gid_from_header((char const *)(current_header->header.gid), sizeof(current_header->header.gid));
            printf("\nSTMT_EXEC;;19212\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(gform), (char const * /* __restrict  */) "%ld", (long)tmp___7);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19213\n");
group = gform;
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;19218\n");
if ((int)current_header->header.typeflag == 51)
        {
          printf("\nSTMT_EXEC;;19220\n");
goto case_51___0;
        }
        printf("\nSTMT_EXEC;;19222\n");
if ((int)current_header->header.typeflag == 52)
        {
          printf("\nSTMT_EXEC;;19224\n");
goto case_51___0;
        }
        printf("\nSTMT_EXEC;;19226\n");
goto switch_default;
      case_51___0: /* CIL Label */
      case_52___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19230\n");
printf("\nFUNC_CALL;gnu_dev_major(unsigned long long);\n");
tmp___8 = gnu_dev_major((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19231\n");
tmp___9 = stringify_uintmax_t_backwards((uintmax_t)tmp___8, uintbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;19232\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(size), (char const * /* __restrict  */)tmp___9);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19233\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)(size), (char const * /* __restrict  */) ",");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19234\n");
printf("\nFUNC_CALL;gnu_dev_minor(unsigned long long);\n");
tmp___10 = gnu_dev_minor((unsigned long long)st->stat.st_rdev);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19235\n");
tmp___11 = stringify_uintmax_t_backwards((uintmax_t)tmp___10, uintbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;19236\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)(size), (char const * /* __restrict  */)tmp___11);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19238\n");
goto switch_break___0;
      switch_default: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19241\n");
tmp___12 = stringify_uintmax_t_backwards((uintmax_t)st->stat.st_size, uintbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;19242\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(size), (char const * /* __restrict  */)tmp___12);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19244\n");
goto switch_break___0;
      switch_break___0: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;19248\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___13 = strlen((char const *)user);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19249\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___14 = strlen((char const *)group);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19250\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___15 = strlen((char const *)(size));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19251\n");
pad = (int)(((tmp___13 + tmp___14) + tmp___15) + 1UL);
      }
      printf("\nSTMT_EXEC;;19253\n");
if (pad > ugswidth)
      {
        printf("\nSTMT_EXEC;;19255\n");
ugswidth = pad;
      }
      {
        printf("\nSTMT_EXEC;;19258\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "%s %s/%s %*s%s %s", modes, user, group, ugswidth - pad, "", size, time_stamp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19259\n");
tmp___16 = quotearg((char const *)temp_name);
        printf("\nSTMT_EXEC;;19260\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) " %s", tmp___16);printf("\nFUNC_RETURN;;\n");

      }
      {
        printf("\nSTMT_EXEC;;19263\n");
if ((int)current_header->header.typeflag == 50)
        {
          printf("\nSTMT_EXEC;;19265\n");
goto case_50___0;
        }
        printf("\nSTMT_EXEC;;19267\n");
if ((int)current_header->header.typeflag == 49)
        {
          printf("\nSTMT_EXEC;;19269\n");
goto case_49___0;
        }
        printf("\nSTMT_EXEC;;19271\n");
if ((int)current_header->header.typeflag == 0)
        {
          printf("\nSTMT_EXEC;;19273\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19275\n");
if ((int)current_header->header.typeflag == 48)
        {
          printf("\nSTMT_EXEC;;19277\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19279\n");
if ((int)current_header->header.typeflag == 83)
        {
          printf("\nSTMT_EXEC;;19281\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19283\n");
if ((int)current_header->header.typeflag == 51)
        {
          printf("\nSTMT_EXEC;;19285\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19287\n");
if ((int)current_header->header.typeflag == 52)
        {
          printf("\nSTMT_EXEC;;19289\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19291\n");
if ((int)current_header->header.typeflag == 53)
        {
          printf("\nSTMT_EXEC;;19293\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19295\n");
if ((int)current_header->header.typeflag == 54)
        {
          printf("\nSTMT_EXEC;;19297\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19299\n");
if ((int)current_header->header.typeflag == 55)
        {
          printf("\nSTMT_EXEC;;19301\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19303\n");
if ((int)current_header->header.typeflag == 68)
        {
          printf("\nSTMT_EXEC;;19305\n");
goto case_0___0;
        }
        printf("\nSTMT_EXEC;;19307\n");
if ((int)current_header->header.typeflag == 75)
        {
          printf("\nSTMT_EXEC;;19309\n");
goto case_75___0;
        }
        printf("\nSTMT_EXEC;;19311\n");
if ((int)current_header->header.typeflag == 76)
        {
          printf("\nSTMT_EXEC;;19313\n");
goto case_76___0;
        }
        printf("\nSTMT_EXEC;;19315\n");
if ((int)current_header->header.typeflag == 86)
        {
          printf("\nSTMT_EXEC;;19317\n");
goto case_86___0;
        }
        printf("\nSTMT_EXEC;;19319\n");
if ((int)current_header->header.typeflag == 77)
        {
          printf("\nSTMT_EXEC;;19321\n");
goto case_77___0;
        }
        printf("\nSTMT_EXEC;;19323\n");
if ((int)current_header->header.typeflag == 78)
        {
          printf("\nSTMT_EXEC;;19325\n");
goto case_78___0;
        }
        printf("\nSTMT_EXEC;;19327\n");
goto switch_default___0;
      case_50___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19330\n");
tmp___17 = quotearg((char const *)st->link_name);
        printf("\nSTMT_EXEC;;19331\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) " -> %s\n", tmp___17);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19333\n");
goto switch_break___1;
      case_49___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19336\n");
tmp___18 = quotearg((char const *)st->link_name);
        printf("\nSTMT_EXEC;;19337\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___19 = gettext(" link to %s\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19338\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___19, tmp___18);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19340\n");
goto switch_break___1;
      switch_default___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19343\n");
type_string[0] = current_header->header.typeflag;
        printf("\nSTMT_EXEC;;19344\n");
type_string[1] = (char)'\000';
        printf("\nSTMT_EXEC;;19345\n");
tmp___20 = quote((char const *)(type_string));
        printf("\nSTMT_EXEC;;19346\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___21 = gettext(" unknown file type %s\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19347\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___21, tmp___20);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19349\n");
goto switch_break___1;
      case_0___0:  /* CIL Label */
      case_48___0: /* CIL Label */
      case_83___0: /* CIL Label */
      case_51___1: /* CIL Label */
      case_52___1: /* CIL Label */
      case_53___0: /* CIL Label */
      case_54___0: /* CIL Label */
      case_55___0: /* CIL Label */
      case_68___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19360\n");
printf("\nFUNC_CALL;putc_unlocked(int,FILE *);\n");
putc_unlocked('\n', stdlis);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19362\n");
goto switch_break___1;
      case_75___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19365\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___22 = gettext("--Long Link--\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19366\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___22);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19368\n");
goto switch_break___1;
      case_76___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19371\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___23 = gettext("--Long Name--\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19372\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___23);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19374\n");
goto switch_break___1;
      case_86___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19377\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___24 = gettext("--Volume Header--\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19378\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___24);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19380\n");
goto switch_break___1;
      case_77___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19383\n");
tmp___25 = uintmax_from_header((char const *)(current_header->oldgnu_header.offset), sizeof(current_header->oldgnu_header.offset));
        printf("\nSTMT_EXEC;;19384\n");
tmp___26 = stringify_uintmax_t_backwards(tmp___25, uintbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
        printf("\nSTMT_EXEC;;19385\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(size), (char const * /* __restrict  */)tmp___26);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19386\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___27 = gettext("--Continued at byte %s--\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19387\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___27, size);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19389\n");
goto switch_break___1;
      case_78___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;19392\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___28 = gettext("--Mangled file names--\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19393\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___28);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;19395\n");
goto switch_break___1;
      switch_break___1: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;19400\n");
printf("\nFUNC_CALL;fflush_unlocked(FILE *);\n");
fflush_unlocked(stdlis);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;19402\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void print_for_mkdir(char *pathname, int length, mode_t mode)
{
  printf("\nFUNC_CALL;print_for_mkdir(char *,int,mode_t);\n");
printf("\nSTMT_EXEC;;19407\n");
char modes[11];
  printf("\nSTMT_EXEC;;19408\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;19409\n");
off_t tmp;
  printf("\nSTMT_EXEC;;19410\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;19411\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;19412\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;19413\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;19414\n");
void *__cil_tmp11;
  printf("\nSTMT_EXEC;;19415\n");
void *__cil_tmp12;
  printf("\nSTMT_EXEC;;19416\n");
char *__cil_tmp13;
  printf("\nSTMT_EXEC;;19417\n");
char *__cil_tmp14;

  {
    printf("\nSTMT_EXEC;;19420\n");
if (verbose_option > 1)
    {
      {
        printf("\nSTMT_EXEC;;19423\n");
modes[0] = (char)'d';
        printf("\nSTMT_EXEC;;19424\n");
decode_mode(mode, modes + 1);
      }
      printf("\nSTMT_EXEC;;19426\n");
if (block_number_option)
      {
        {
          printf("\nSTMT_EXEC;;19429\n");
tmp = current_block_ordinal();
          printf("\nSTMT_EXEC;;19430\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)tmp, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
          printf("\nSTMT_EXEC;;19431\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("block %s: ");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;19432\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;19436\n");
tmp___2 = quotearg((char const *)pathname);
        printf("\nSTMT_EXEC;;19437\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("Creating directory:");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;19438\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "%s %*s %.*s\n", modes, ugswidth + 18, tmp___3, length, tmp___2);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;19441\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void skip_file(off_t size)
{
  printf("\nFUNC_CALL;skip_file(off_t);\n");
printf("\nSTMT_EXEC;;19446\n");
union block *x;
  printf("\nSTMT_EXEC;;19447\n");
char *tmp;
  printf("\nSTMT_EXEC;;19448\n");
char *__cil_tmp4;

  {
    printf("\nSTMT_EXEC;;19451\n");
if (multi_volume_option)
    {
      printf("\nSTMT_EXEC;;19453\n");
save_totsize = size;
      printf("\nSTMT_EXEC;;19454\n");
save_sizeleft = size;
    }
    {
      printf("\nSTMT_EXEC;;19457\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;19460\n");
if (!(size > 0L))
        {
          printf("\nSTMT_EXEC;;19462\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;19465\n");
x = find_next_block();
        }
        printf("\nSTMT_EXEC;;19467\n");
if (!x)
        {
          {
            printf("\nSTMT_EXEC;;19470\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19471\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19472\n");
fatal_exit();
          }
        }
        {
          printf("\nSTMT_EXEC;;19476\n");
set_next_block_after(x);
          printf("\nSTMT_EXEC;;19477\n");
size -= 512L;
        }
        printf("\nSTMT_EXEC;;19479\n");
if (multi_volume_option)
        {
          printf("\nSTMT_EXEC;;19481\n");
save_sizeleft -= 512L;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;19486\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}

void skip_member(void)
{
  printf("\nFUNC_CALL;skip_member();\n");
printf("\nSTMT_EXEC;;19492\n");
char save_typeflag;
  printf("\nSTMT_EXEC;;19493\n");
_Bool tmp;

  {
    {
      printf("\nSTMT_EXEC;;19497\n");
save_typeflag = current_header->header.typeflag;
      printf("\nSTMT_EXEC;;19498\n");
set_next_block_after(current_header);
      printf("\nSTMT_EXEC;;19499\n");
assign_string(&save_name, (char const *)current_stat_info.file_name);
      printf("\nSTMT_EXEC;;19500\n");
tmp = sparse_member_p(&current_stat_info);
    }
    printf("\nSTMT_EXEC;;19502\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;19505\n");
sparse_skip_file(&current_stat_info);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;19510\n");
if ((int)save_typeflag != 53)
      {
        {
          printf("\nSTMT_EXEC;;19513\n");
skip_file(current_stat_info.stat.st_size);
        }
      }
    }
    printf("\nSTMT_EXEC;;19517\n");
printf("\nFUNC_RETURN;;\n");
return;
  }






printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","008.mangle.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) rename)(char const *__old, char const *__new);
void extract_mangle(void)
{
  printf("\nFUNC_CALL;extract_mangle();\n");
printf("\nSTMT_EXEC;;19530\n");
off_t size;
  printf("\nSTMT_EXEC;;19531\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;19532\n");
void *tmp;
  printf("\nSTMT_EXEC;;19533\n");
char *copy;
  printf("\nSTMT_EXEC;;19534\n");
char *cursor;
  printf("\nSTMT_EXEC;;19535\n");
union block *block;
  printf("\nSTMT_EXEC;;19536\n");
union block *tmp___0;
  printf("\nSTMT_EXEC;;19537\n");
size_t available;
  printf("\nSTMT_EXEC;;19538\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;19539\n");
char *next_cursor;
  printf("\nSTMT_EXEC;;19540\n");
char *name;
  printf("\nSTMT_EXEC;;19541\n");
char *name_end;
  printf("\nSTMT_EXEC;;19542\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;19543\n");
int tmp___3;
  printf("\nSTMT_EXEC;;19544\n");
char const *tmp___4;
  printf("\nSTMT_EXEC;;19545\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;19546\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;19547\n");
int *tmp___7;
  printf("\nSTMT_EXEC;;19548\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;19549\n");
int tmp___9;
  printf("\nSTMT_EXEC;;19550\n");
int tmp___10;
  printf("\nSTMT_EXEC;;19551\n");
char const *tmp___11;
  printf("\nSTMT_EXEC;;19552\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;19553\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;19554\n");
int *tmp___14;
  printf("\nSTMT_EXEC;;19555\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;19556\n");
int tmp___16;
  printf("\nSTMT_EXEC;;19557\n");
int tmp___17;
  printf("\nSTMT_EXEC;;19558\n");
int tmp___18;
  printf("\nSTMT_EXEC;;19559\n");
char *tmp___19;
  printf("\nSTMT_EXEC;;19560\n");
int tmp___20;
  printf("\nSTMT_EXEC;;19561\n");
int tmp___21;
  printf("\nSTMT_EXEC;;19562\n");
char *__cil_tmp33;
  printf("\nSTMT_EXEC;;19563\n");
char *__cil_tmp34;
  printf("\nSTMT_EXEC;;19564\n");
char *__cil_tmp35;
  printf("\nSTMT_EXEC;;19565\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;19566\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;19567\n");
char *__cil_tmp38;

  {
    {
      printf("\nSTMT_EXEC;;19571\n");
size = current_stat_info.stat.st_size;
      printf("\nSTMT_EXEC;;19572\n");
tmp = xmalloc((size_t)(size + 1L));
      printf("\nSTMT_EXEC;;19573\n");
buffer___2 = (char *)tmp;
      printf("\nSTMT_EXEC;;19574\n");
copy = buffer___2;
      printf("\nSTMT_EXEC;;19575\n");
cursor = buffer___2;
    }
    printf("\nSTMT_EXEC;;19577\n");
if ((size_t)size != (size_t)size)
    {
      {
        printf("\nSTMT_EXEC;;19580\n");
xalloc_die();
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;19585\n");
if ((size_t)size == 0xffffffffffffffffUL)
      {
        {
          printf("\nSTMT_EXEC;;19588\n");
xalloc_die();
        }
      }
    }
    printf("\nSTMT_EXEC;;19592\n");
*(buffer___2 + size) = (char)'\000';
    {
      printf("\nSTMT_EXEC;;19594\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;19597\n");
if (!(size > 0L))
        {
          printf("\nSTMT_EXEC;;19599\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;19602\n");
tmp___0 = find_next_block();
          printf("\nSTMT_EXEC;;19603\n");
block = tmp___0;
        }
        printf("\nSTMT_EXEC;;19605\n");
if (!block)
        {
          {
            printf("\nSTMT_EXEC;;19608\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Unexpected EOF in mangled names");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19609\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;19610\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;19612\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
        {
          printf("\nSTMT_EXEC;;19615\n");
available = available_space_after(block);
        }
        printf("\nSTMT_EXEC;;19617\n");
if (available > (size_t)size)
        {
          printf("\nSTMT_EXEC;;19619\n");
available = (size_t)size;
        }
        {
          printf("\nSTMT_EXEC;;19622\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)copy, (void const * /* __restrict  */)(block->buffer), available);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;19623\n");
copy += available;
          printf("\nSTMT_EXEC;;19624\n");
size = (off_t)((size_t)size - available);
          printf("\nSTMT_EXEC;;19625\n");
set_next_block_after((union block *)((block->buffer + available) - 1));
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;19631\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;19634\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;19636\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;19639\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
next_cursor = strchr((char const *)cursor, '\n');printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;19640\n");
tmp___2 = next_cursor;
          printf("\nSTMT_EXEC;;19641\n");
next_cursor++;
          printf("\nSTMT_EXEC;;19642\n");
*tmp___2 = (char)'\000';
          printf("\nSTMT_EXEC;;19643\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___21 = strncmp((char const *)cursor, "Rename ", (size_t)7);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;19645\n");
if (tmp___21)
        {
          {
            printf("\nSTMT_EXEC;;19648\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___20 = strncmp((char const *)cursor, "Symlink ", (size_t)8);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;19650\n");
if (tmp___20)
          {
            {
              printf("\nSTMT_EXEC;;19653\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___19 = gettext("Unknown demangling command %s");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19654\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___19, cursor);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19655\n");
exit_status = 2;
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;19661\n");
name = cursor + 8;
              printf("\nSTMT_EXEC;;19662\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
name_end = strchr((char const *)name, ' ');printf("\nFUNC_RETURN;;\n");

            }
            {
              printf("\nSTMT_EXEC;;19665\n");
while (1)
              {
              while_continue___1: /* CIL Label */;
                {
                  printf("\nSTMT_EXEC;;19669\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___10 = strncmp((char const *)name_end, " to ", (size_t)4);printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;19671\n");
if (!tmp___10)
                {
                  printf("\nSTMT_EXEC;;19673\n");
goto while_break___1;
                }
                {
                  printf("\nSTMT_EXEC;;19676\n");
name_end++;
                  printf("\nSTMT_EXEC;;19677\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
name_end = strchr((char const *)name_end, ' ');printf("\nFUNC_RETURN;;\n");

                }
              }
            while_break___1: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;19683\n");
*name_end = (char)'\000';
              printf("\nSTMT_EXEC;;19684\n");
unquote_string(name);
              printf("\nSTMT_EXEC;;19685\n");
unquote_string(name_end + 4);
              printf("\nSTMT_EXEC;;19686\n");
printf("\nFUNC_CALL;symlink(const char *,const char *);\n");
tmp___16 = symlink((char const *)name, (char const *)(name_end + 4));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;19688\n");
if (tmp___16)
            {
              {
                printf("\nSTMT_EXEC;;19691\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___17 = unlink((char const *)(name_end + 4));printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;19693\n");
if (tmp___17)
              {
                printf("\nSTMT_EXEC;;19695\n");
goto _L___0;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;19700\n");
printf("\nFUNC_CALL;symlink(const char *,const char *);\n");
tmp___18 = symlink((char const *)name, (char const *)(name_end + 4));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;19702\n");
if (tmp___18)
                {
                _L___0:
                {
                  printf("\nSTMT_EXEC;;19706\n");
tmp___11 = quote_n(1, (char const *)(name_end + 4));
                  printf("\nSTMT_EXEC;;19707\n");
tmp___12 = quotearg_colon((char const *)name);
                  printf("\nSTMT_EXEC;;19708\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("%s: Cannot symlink to %s");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;19709\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___14 = __errno_location();printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;19710\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, *tmp___14, (char const *)tmp___13, tmp___12, tmp___11);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;19711\n");
exit_status = 2;
                }
                }
                else
                {
                  printf("\nSTMT_EXEC;;19716\n");
goto _L;
                }
              }
            }
            else
            {
            _L:
              {
printf("\nSTMT_EXEC;;19723\n");
if (verbose_option)
              {
                {
                  printf("\nSTMT_EXEC;;19726\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___15 = gettext("Symlinked %s to %s");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;19727\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___15, name, name_end + 4);printf("\nFUNC_RETURN;;\n");

                }
              }
}

            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;19736\n");
name = cursor + 7;
            printf("\nSTMT_EXEC;;19737\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
name_end = strchr((char const *)name, ' ');printf("\nFUNC_RETURN;;\n");

          }
          {
            printf("\nSTMT_EXEC;;19740\n");
while (1)
            {
            while_continue___2: /* CIL Label */;
              {
                printf("\nSTMT_EXEC;;19744\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___3 = strncmp((char const *)name_end, " to ", (size_t)4);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;19746\n");
if (!tmp___3)
              {
                printf("\nSTMT_EXEC;;19748\n");
goto while_break___2;
              }
              {
                printf("\nSTMT_EXEC;;19751\n");
name_end++;
                printf("\nSTMT_EXEC;;19752\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
name_end = strchr((char const *)name_end, ' ');printf("\nFUNC_RETURN;;\n");

              }
            }
          while_break___2: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;19757\n");
*name_end = (char)'\000';
          printf("\nSTMT_EXEC;;19758\n");
if ((int)*(next_cursor + -2) == 47)
          {
            printf("\nSTMT_EXEC;;19760\n");
*(next_cursor + -2) = (char)'\000';
          }
          {
            printf("\nSTMT_EXEC;;19763\n");
unquote_string(name_end + 4);
            printf("\nSTMT_EXEC;;19764\n");
printf("\nFUNC_CALL;rename(const char *,const char *);\n");
tmp___9 = rename((char const *)name, (char const *)(name_end + 4));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;19766\n");
if (tmp___9)
          {
            {
              printf("\nSTMT_EXEC;;19769\n");
tmp___4 = quote_n(1, (char const *)(name_end + 4));
              printf("\nSTMT_EXEC;;19770\n");
tmp___5 = quotearg_colon((char const *)name);
              printf("\nSTMT_EXEC;;19771\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("%s: Cannot rename to %s");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19772\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___7 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19773\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, *tmp___7, (char const *)tmp___6, tmp___5, tmp___4);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19774\n");
exit_status = 2;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;19779\n");
if (verbose_option)
            {
              {
                printf("\nSTMT_EXEC;;19782\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("Renamed %s to %s");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;19783\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___8, name, name_end + 4);printf("\nFUNC_RETURN;;\n");

              }
            }
          }
        }
        printf("\nSTMT_EXEC;;19788\n");
cursor = next_cursor;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;19792\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","009.misc.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) pipe)(int *__pipedes);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) chdir)(char const *__path);
extern __attribute__((__nothrow__)) __pid_t fork(void);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) rmdir)(char const *__path);
char *find_backup_file_name(char const *file, enum backup_type backup_type___0);
enum backup_type backup_type;
int chdir_arg(char const *dir);
void chdir_do(int i);
__attribute__((__noreturn__)) void chdir_fatal(char const *name);
__attribute__((__noreturn__)) void exec_fatal(char const *name);
void read_error_details(char const *name, off_t offset, size_t size);
__attribute__((__noreturn__)) void read_fatal(char const *name);
__attribute__((__noreturn__)) void read_fatal_details(char const *name, off_t offset, size_t size);
void read_warn_details(char const *name, off_t offset, size_t size);
void savedir_warn(char const *name);
void seek_warn_details(char const *name, off_t offset);
void seek_diag_details(char const *name, off_t offset);
void waitpid_error(char const *name);
pid_t xfork(void);
void xpipe(int *fd);
char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
int save_cwd(struct saved_cwd *cwd);
int restore_cwd(struct saved_cwd const *cwd);
static __attribute__((__noreturn__)) void call_arg_fatal(char const *call, char const *name);
void assign_string(char **string, char const *value)
{
  printf("\nFUNC_CALL;assign_string(char **,const char *);\n");
printf("\nSTMT_EXEC;;19822\n");
char *tmp;

  {
    printf("\nSTMT_EXEC;;19825\n");
if (*string)
    {
      {
        printf("\nSTMT_EXEC;;19828\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)*string);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;19831\n");
if (value)
    {
      {
        printf("\nSTMT_EXEC;;19834\n");
tmp = xstrdup(value);
        printf("\nSTMT_EXEC;;19835\n");
*string = tmp;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;19840\n");
*string = (char *)0;
    }
    printf("\nSTMT_EXEC;;19842\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
char *quote_copy_string(char const *string)
{
  printf("\nFUNC_CALL;quote_copy_string(const char *);\n");
printf("\nSTMT_EXEC;;19847\n");
char const *source;
  printf("\nSTMT_EXEC;;19848\n");
char *destination;
  printf("\nSTMT_EXEC;;19849\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;19850\n");
int copying;
  printf("\nSTMT_EXEC;;19851\n");
int character;
  printf("\nSTMT_EXEC;;19852\n");
char const *tmp;
  printf("\nSTMT_EXEC;;19853\n");
size_t length;
  printf("\nSTMT_EXEC;;19854\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;19855\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;19856\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;19857\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;19858\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;19859\n");
int tmp___5;

  {
    printf("\nSTMT_EXEC;;19862\n");
source = string;
    printf("\nSTMT_EXEC;;19863\n");
destination = (char *)0;
    printf("\nSTMT_EXEC;;19864\n");
buffer___2 = (char *)0;
    printf("\nSTMT_EXEC;;19865\n");
copying = 0;
    {
      printf("\nSTMT_EXEC;;19867\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;19870\n");
if (!*source)
        {
          printf("\nSTMT_EXEC;;19872\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;19874\n");
tmp = source;
        printf("\nSTMT_EXEC;;19875\n");
source++;
        printf("\nSTMT_EXEC;;19876\n");
character = (int)*tmp;
        {
          printf("\nSTMT_EXEC;;19878\n");
if (character == 10)
          {
            printf("\nSTMT_EXEC;;19880\n");
goto case_10;
          }
          printf("\nSTMT_EXEC;;19882\n");
if (character == 92)
          {
            printf("\nSTMT_EXEC;;19884\n");
goto case_10;
          }
          printf("\nSTMT_EXEC;;19886\n");
goto switch_default;
        case_10: /* CIL Label */
        case_92: /* CIL Label */
          {
printf("\nSTMT_EXEC;;19889\n");
if (!copying)
          {
            {
              printf("\nSTMT_EXEC;;19892\n");
length = (size_t)((source - string) - 1L);
              printf("\nSTMT_EXEC;;19893\n");
copying = 1;
              printf("\nSTMT_EXEC;;19894\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(source);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19895\n");
tmp___1 = xmalloc(((length + 2UL) + 2UL * tmp___0) + 1UL);
              printf("\nSTMT_EXEC;;19896\n");
buffer___2 = (char *)tmp___1;
              printf("\nSTMT_EXEC;;19897\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)buffer___2, (void const * /* __restrict  */)string, length);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;19898\n");
destination = buffer___2 + length;
            }
          }
}

          printf("\nSTMT_EXEC;;19901\n");
tmp___2 = destination;
          printf("\nSTMT_EXEC;;19902\n");
destination++;
          printf("\nSTMT_EXEC;;19903\n");
*tmp___2 = (char)'\\';
          printf("\nSTMT_EXEC;;19904\n");
tmp___3 = destination;
          printf("\nSTMT_EXEC;;19905\n");
destination++;
          printf("\nSTMT_EXEC;;19906\n");
if (character == 92)
          {
            printf("\nSTMT_EXEC;;19908\n");
tmp___5 = '\\';
          }
          else
          {
            printf("\nSTMT_EXEC;;19912\n");
tmp___5 = 'n';
          }
          printf("\nSTMT_EXEC;;19914\n");
*tmp___3 = (char)tmp___5;
          printf("\nSTMT_EXEC;;19915\n");
goto switch_break;
        switch_default: /* CIL Label */
          {
printf("\nSTMT_EXEC;;19917\n");
if (copying)
          {
            printf("\nSTMT_EXEC;;19919\n");
tmp___4 = destination;
            printf("\nSTMT_EXEC;;19920\n");
destination++;
            printf("\nSTMT_EXEC;;19921\n");
*tmp___4 = (char)character;
          }
}

          printf("\nSTMT_EXEC;;19923\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;19929\n");
if (copying)
    {
      printf("\nSTMT_EXEC;;19931\n");
*destination = (char)'\000';
      printf("\nSTMT_EXEC;;19932\n");
printf("\nFUNC_RETURN;;\n");
return (buffer___2);
    }
    printf("\nSTMT_EXEC;;19934\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
int unquote_string(char *string)
{
  printf("\nFUNC_CALL;unquote_string(char *);\n");
printf("\nSTMT_EXEC;;19939\n");
int result;
  printf("\nSTMT_EXEC;;19940\n");
char *source;
  printf("\nSTMT_EXEC;;19941\n");
char *destination;
  printf("\nSTMT_EXEC;;19942\n");
char *tmp;
  printf("\nSTMT_EXEC;;19943\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;19944\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;19945\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;19946\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;19947\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;19948\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;19949\n");
int value;
  printf("\nSTMT_EXEC;;19950\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;19951\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;19952\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;19953\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;19954\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;19955\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;19956\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;19957\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;19958\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;19959\n");
char *tmp___15;
  printf("\nSTMT_EXEC;;19960\n");
char *tmp___16;

  {
    printf("\nSTMT_EXEC;;19963\n");
result = 1;
    printf("\nSTMT_EXEC;;19964\n");
source = string;
    printf("\nSTMT_EXEC;;19965\n");
destination = string;
    {
      printf("\nSTMT_EXEC;;19967\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;19970\n");
if (!*source)
        {
          printf("\nSTMT_EXEC;;19972\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;19974\n");
if ((int)*source == 92)
        {
          printf("\nSTMT_EXEC;;19976\n");
source++;
          {
            printf("\nSTMT_EXEC;;19978\n");
if ((int)*source == 92)
            {
              printf("\nSTMT_EXEC;;19980\n");
goto case_92;
            }
            printf("\nSTMT_EXEC;;19982\n");
if ((int)*source == 110)
            {
              printf("\nSTMT_EXEC;;19984\n");
goto case_110;
            }
            printf("\nSTMT_EXEC;;19986\n");
if ((int)*source == 116)
            {
              printf("\nSTMT_EXEC;;19988\n");
goto case_116;
            }
            printf("\nSTMT_EXEC;;19990\n");
if ((int)*source == 102)
            {
              printf("\nSTMT_EXEC;;19992\n");
goto case_102;
            }
            printf("\nSTMT_EXEC;;19994\n");
if ((int)*source == 98)
            {
              printf("\nSTMT_EXEC;;19996\n");
goto case_98;
            }
            printf("\nSTMT_EXEC;;19998\n");
if ((int)*source == 114)
            {
              printf("\nSTMT_EXEC;;20000\n");
goto case_114;
            }
            printf("\nSTMT_EXEC;;20002\n");
if ((int)*source == 63)
            {
              printf("\nSTMT_EXEC;;20004\n");
goto case_63;
            }
            printf("\nSTMT_EXEC;;20006\n");
if ((int)*source == 48)
            {
              printf("\nSTMT_EXEC;;20008\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20010\n");
if ((int)*source == 49)
            {
              printf("\nSTMT_EXEC;;20012\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20014\n");
if ((int)*source == 50)
            {
              printf("\nSTMT_EXEC;;20016\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20018\n");
if ((int)*source == 51)
            {
              printf("\nSTMT_EXEC;;20020\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20022\n");
if ((int)*source == 52)
            {
              printf("\nSTMT_EXEC;;20024\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20026\n");
if ((int)*source == 53)
            {
              printf("\nSTMT_EXEC;;20028\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20030\n");
if ((int)*source == 54)
            {
              printf("\nSTMT_EXEC;;20032\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20034\n");
if ((int)*source == 55)
            {
              printf("\nSTMT_EXEC;;20036\n");
goto case_48;
            }
            printf("\nSTMT_EXEC;;20038\n");
goto switch_default;
          case_92: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20040\n");
tmp = destination;
}

            printf("\nSTMT_EXEC;;20041\n");
destination++;
            printf("\nSTMT_EXEC;;20042\n");
*tmp = (char)'\\';
            printf("\nSTMT_EXEC;;20043\n");
source++;
            printf("\nSTMT_EXEC;;20044\n");
goto switch_break;
          case_110: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20046\n");
tmp___0 = destination;
}

            printf("\nSTMT_EXEC;;20047\n");
destination++;
            printf("\nSTMT_EXEC;;20048\n");
*tmp___0 = (char)'\n';
            printf("\nSTMT_EXEC;;20049\n");
source++;
            printf("\nSTMT_EXEC;;20050\n");
goto switch_break;
          case_116: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20052\n");
tmp___1 = destination;
}

            printf("\nSTMT_EXEC;;20053\n");
destination++;
            printf("\nSTMT_EXEC;;20054\n");
*tmp___1 = (char)'\t';
            printf("\nSTMT_EXEC;;20055\n");
source++;
            printf("\nSTMT_EXEC;;20056\n");
goto switch_break;
          case_102: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20058\n");
tmp___2 = destination;
}

            printf("\nSTMT_EXEC;;20059\n");
destination++;
            printf("\nSTMT_EXEC;;20060\n");
*tmp___2 = (char)'\f';
            printf("\nSTMT_EXEC;;20061\n");
source++;
            printf("\nSTMT_EXEC;;20062\n");
goto switch_break;
          case_98: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20064\n");
tmp___3 = destination;
}

            printf("\nSTMT_EXEC;;20065\n");
destination++;
            printf("\nSTMT_EXEC;;20066\n");
*tmp___3 = (char)'\b';
            printf("\nSTMT_EXEC;;20067\n");
source++;
            printf("\nSTMT_EXEC;;20068\n");
goto switch_break;
          case_114: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20070\n");
tmp___4 = destination;
}

            printf("\nSTMT_EXEC;;20071\n");
destination++;
            printf("\nSTMT_EXEC;;20072\n");
*tmp___4 = (char)'\r';
            printf("\nSTMT_EXEC;;20073\n");
source++;
            printf("\nSTMT_EXEC;;20074\n");
goto switch_break;
          case_63: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20076\n");
tmp___5 = destination;
}

            printf("\nSTMT_EXEC;;20077\n");
destination++;
            printf("\nSTMT_EXEC;;20078\n");
*tmp___5 = (char)127;
            printf("\nSTMT_EXEC;;20079\n");
source++;
            printf("\nSTMT_EXEC;;20080\n");
goto switch_break;
          case_48: /* CIL Label */
          case_49: /* CIL Label */
          case_50: /* CIL Label */
          case_51: /* CIL Label */
          case_52: /* CIL Label */
          case_53: /* CIL Label */
          case_54: /* CIL Label */
          case_55: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20089\n");
tmp___6 = source;
}

            printf("\nSTMT_EXEC;;20090\n");
source++;
            printf("\nSTMT_EXEC;;20091\n");
value = (int)*tmp___6 - 48;
            printf("\nSTMT_EXEC;;20092\n");
if ((int)*source < 48)
            {
              printf("\nSTMT_EXEC;;20094\n");
tmp___7 = destination;
              printf("\nSTMT_EXEC;;20095\n");
destination++;
              printf("\nSTMT_EXEC;;20096\n");
*tmp___7 = (char)value;
              printf("\nSTMT_EXEC;;20097\n");
goto switch_break;
            }
            else
            {
              printf("\nSTMT_EXEC;;20101\n");
if ((int)*source > 55)
              {
                printf("\nSTMT_EXEC;;20103\n");
tmp___7 = destination;
                printf("\nSTMT_EXEC;;20104\n");
destination++;
                printf("\nSTMT_EXEC;;20105\n");
*tmp___7 = (char)value;
                printf("\nSTMT_EXEC;;20106\n");
goto switch_break;
              }
            }
            printf("\nSTMT_EXEC;;20109\n");
tmp___8 = source;
            printf("\nSTMT_EXEC;;20110\n");
source++;
            printf("\nSTMT_EXEC;;20111\n");
value = (value * 8 + (int)*tmp___8) - 48;
            printf("\nSTMT_EXEC;;20112\n");
if ((int)*source < 48)
            {
              printf("\nSTMT_EXEC;;20114\n");
tmp___9 = destination;
              printf("\nSTMT_EXEC;;20115\n");
destination++;
              printf("\nSTMT_EXEC;;20116\n");
*tmp___9 = (char)value;
              printf("\nSTMT_EXEC;;20117\n");
goto switch_break;
            }
            else
            {
              printf("\nSTMT_EXEC;;20121\n");
if ((int)*source > 55)
              {
                printf("\nSTMT_EXEC;;20123\n");
tmp___9 = destination;
                printf("\nSTMT_EXEC;;20124\n");
destination++;
                printf("\nSTMT_EXEC;;20125\n");
*tmp___9 = (char)value;
                printf("\nSTMT_EXEC;;20126\n");
goto switch_break;
              }
            }
            printf("\nSTMT_EXEC;;20129\n");
tmp___10 = source;
            printf("\nSTMT_EXEC;;20130\n");
source++;
            printf("\nSTMT_EXEC;;20131\n");
value = (value * 8 + (int)*tmp___10) - 48;
            printf("\nSTMT_EXEC;;20132\n");
tmp___11 = destination;
            printf("\nSTMT_EXEC;;20133\n");
destination++;
            printf("\nSTMT_EXEC;;20134\n");
*tmp___11 = (char)value;
            printf("\nSTMT_EXEC;;20135\n");
goto switch_break;
          switch_default: /* CIL Label */
            {
printf("\nSTMT_EXEC;;20137\n");
result = 0;
}

            printf("\nSTMT_EXEC;;20138\n");
tmp___12 = destination;
            printf("\nSTMT_EXEC;;20139\n");
destination++;
            printf("\nSTMT_EXEC;;20140\n");
*tmp___12 = (char)'\\';
            printf("\nSTMT_EXEC;;20141\n");
if (*source)
            {
              printf("\nSTMT_EXEC;;20143\n");
tmp___13 = destination;
              printf("\nSTMT_EXEC;;20144\n");
destination++;
              printf("\nSTMT_EXEC;;20145\n");
tmp___14 = source;
              printf("\nSTMT_EXEC;;20146\n");
source++;
              printf("\nSTMT_EXEC;;20147\n");
*tmp___13 = *tmp___14;
            }
            printf("\nSTMT_EXEC;;20149\n");
goto switch_break;
          switch_break: /* CIL Label */;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;20155\n");
if ((unsigned long)source != (unsigned long)destination)
          {
            printf("\nSTMT_EXEC;;20157\n");
tmp___15 = destination;
            printf("\nSTMT_EXEC;;20158\n");
destination++;
            printf("\nSTMT_EXEC;;20159\n");
tmp___16 = source;
            printf("\nSTMT_EXEC;;20160\n");
source++;
            printf("\nSTMT_EXEC;;20161\n");
*tmp___15 = *tmp___16;
          }
          else
          {
            printf("\nSTMT_EXEC;;20165\n");
source++;
            printf("\nSTMT_EXEC;;20166\n");
destination++;
          }
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;20172\n");
if ((unsigned long)source != (unsigned long)destination)
    {
      printf("\nSTMT_EXEC;;20174\n");
*destination = (char)'\000';
    }
    printf("\nSTMT_EXEC;;20176\n");
printf("\nFUNC_RETURN;;\n");
return (result);
  }
printf("\nFUNC_RETURN;;\n");
}
static char *before_backup_name;
static char *after_backup_name;
static _Bool must_be_dot_or_slash(char const *path)
{
  printf("\nFUNC_CALL;must_be_dot_or_slash(const char *);\n");
printf("\nSTMT_EXEC;;20183\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;20186\n");
path += 0;
    printf("\nSTMT_EXEC;;20187\n");
if ((int const) * (path + 0) == 47)
    {
      {
        printf("\nSTMT_EXEC;;20190\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;20193\n");
if ((int const) * (path + 1) == 47)
          {
            printf("\nSTMT_EXEC;;20195\n");
path++;
          }
          else
          {
            printf("\nSTMT_EXEC;;20199\n");
if ((int const) * (path + 1) == 46)
            {
              printf("\nSTMT_EXEC;;20201\n");
if ((int const) * (path + (2 + ((int const) * (path + 2) == 46))) == 47)
              {
                printf("\nSTMT_EXEC;;20203\n");
path += 2 + ((int const) * (path + 2) == 46);
              }
              else
              {
                printf("\nSTMT_EXEC;;20207\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(!*(path + 1)));
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;20212\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(!*(path + 1)));
            }
          }
        }
      while_break: /* CIL Label */;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;20222\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;20225\n");
if ((int const) * (path + 0) == 46)
          {
            printf("\nSTMT_EXEC;;20227\n");
if (!((int const) * (path + 1) == 47))
            {
              printf("\nSTMT_EXEC;;20229\n");
goto while_break___0;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;20234\n");
goto while_break___0;
          }
          printf("\nSTMT_EXEC;;20236\n");
path += 2;
          {
            printf("\nSTMT_EXEC;;20238\n");
while (1)
            {
            while_continue___1: /* CIL Label */;
              printf("\nSTMT_EXEC;;20241\n");
if (!((int const) * path == 47))
              {
                printf("\nSTMT_EXEC;;20243\n");
goto while_break___1;
              }
              printf("\nSTMT_EXEC;;20245\n");
path++;
            }
          while_break___1: /* CIL Label */;
          }
        }
      while_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;20252\n");
if (!*(path + 0))
      {
        printf("\nSTMT_EXEC;;20254\n");
tmp = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;20258\n");
if ((int const) * (path + 0) == 46)
        {
          printf("\nSTMT_EXEC;;20260\n");
if (!*(path + 1))
          {
            printf("\nSTMT_EXEC;;20262\n");
tmp = 1;
          }
          else
          {
            printf("\nSTMT_EXEC;;20266\n");
tmp = 0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;20271\n");
tmp = 0;
        }
      }
      printf("\nSTMT_EXEC;;20274\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static int safer_rmdir(char const *path)
{
  printf("\nFUNC_CALL;safer_rmdir(const char *);\n");
printf("\nSTMT_EXEC;;20280\n");
int *tmp;
  printf("\nSTMT_EXEC;;20281\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;20282\n");
int tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;20286\n");
tmp___0 = must_be_dot_or_slash(path);
    }
    printf("\nSTMT_EXEC;;20288\n");
if (tmp___0)
    {
      {
        printf("\nSTMT_EXEC;;20291\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20292\n");
*tmp = 0;
      }
      printf("\nSTMT_EXEC;;20294\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
    }
    {
      printf("\nSTMT_EXEC;;20297\n");
printf("\nFUNC_CALL;rmdir(const char *);\n");
tmp___1 = rmdir(path);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;20299\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
  }
printf("\nFUNC_RETURN;;\n");
}
int remove_any_file(char const *path, enum remove_option option)
{
  printf("\nFUNC_CALL;remove_any_file(const char *,enum remove_option);\n");
printf("\nSTMT_EXEC;;20304\n");
int tmp;
  printf("\nSTMT_EXEC;;20305\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;20306\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;20307\n");
int tmp___2;
  printf("\nSTMT_EXEC;;20308\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;20309\n");
int tmp___4;
  printf("\nSTMT_EXEC;;20310\n");
int tmp___5;
  printf("\nSTMT_EXEC;;20311\n");
char *directory;
  printf("\nSTMT_EXEC;;20312\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;20313\n");
char const *entry;
  printf("\nSTMT_EXEC;;20314\n");
size_t entrylen;
  printf("\nSTMT_EXEC;;20315\n");
char *path_buffer;
  printf("\nSTMT_EXEC;;20316\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;20317\n");
int r;
  printf("\nSTMT_EXEC;;20318\n");
int tmp___8;
  printf("\nSTMT_EXEC;;20319\n");
int e;
  printf("\nSTMT_EXEC;;20320\n");
int *tmp___9;
  printf("\nSTMT_EXEC;;20321\n");
int *tmp___10;
  printf("\nSTMT_EXEC;;20322\n");
int tmp___11;

  {
    printf("\nSTMT_EXEC;;20325\n");
if (!we_are_root)
    {
      {
        printf("\nSTMT_EXEC;;20328\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp = unlink(path);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;20330\n");
if (tmp == 0)
      {
        printf("\nSTMT_EXEC;;20332\n");
printf("\nFUNC_RETURN;;\n");
return (1);
      }
      {
        printf("\nSTMT_EXEC;;20335\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;20337\n");
if (*tmp___0 != 1)
      {
        {
          printf("\nSTMT_EXEC;;20340\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;20342\n");
if (*tmp___1 != 21)
        {
          printf("\nSTMT_EXEC;;20344\n");
printf("\nFUNC_RETURN;;\n");
return (0);
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;20349\n");
tmp___2 = safer_rmdir(path);
    }
    printf("\nSTMT_EXEC;;20351\n");
if (tmp___2 == 0)
    {
      printf("\nSTMT_EXEC;;20353\n");
printf("\nFUNC_RETURN;;\n");
return (1);
    }
    {
      printf("\nSTMT_EXEC;;20356\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

    }
    {
      printf("\nSTMT_EXEC;;20359\n");
if (*tmp___3 == 20)
      {
        printf("\nSTMT_EXEC;;20361\n");
goto case_20;
      }
      printf("\nSTMT_EXEC;;20363\n");
if (*tmp___3 == 0)
      {
        printf("\nSTMT_EXEC;;20365\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;20367\n");
if (*tmp___3 == 17)
      {
        printf("\nSTMT_EXEC;;20369\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;20371\n");
if (*tmp___3 == 39)
      {
        printf("\nSTMT_EXEC;;20373\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;20375\n");
goto switch_break;
    case_20: /* CIL Label */
      {
printf("\nSTMT_EXEC;;20377\n");
if (we_are_root)
      {
        {
          printf("\nSTMT_EXEC;;20380\n");
printf("\nFUNC_CALL;unlink(const char *);\n");
tmp___4 = unlink(path);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;20382\n");
if (tmp___4 == 0)
        {
          printf("\nSTMT_EXEC;;20384\n");
tmp___5 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;20388\n");
tmp___5 = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;20393\n");
tmp___5 = 0;
      }
}

      printf("\nSTMT_EXEC;;20395\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___5);
    case_0:  /* CIL Label */
    case_17: /* CIL Label */
    case_39: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;20400\n");
if ((unsigned int)option == 0U)
      {
        printf("\nSTMT_EXEC;;20402\n");
goto case_0___0;
      }
      printf("\nSTMT_EXEC;;20404\n");
if ((unsigned int)option == 2U)
      {
        printf("\nSTMT_EXEC;;20406\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;20408\n");
if ((unsigned int)option == 1U)
      {
        printf("\nSTMT_EXEC;;20410\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;20412\n");
goto switch_break___0;
    case_0___0: /* CIL Label */
      {
printf("\nSTMT_EXEC;;20414\n");
goto switch_break___0;
}

    case_2: /* CIL Label */
      {
printf("\nSTMT_EXEC;;20416\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
}

    case_1: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;20419\n");
tmp___6 = savedir(path);
      printf("\nSTMT_EXEC;;20420\n");
directory = tmp___6;
    }
      printf("\nSTMT_EXEC;;20422\n");
if (!directory)
      {
        printf("\nSTMT_EXEC;;20424\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
      printf("\nSTMT_EXEC;;20426\n");
entry = (char const *)directory;
      {
        printf("\nSTMT_EXEC;;20428\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;20432\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
entrylen = strlen(entry);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;20434\n");
if (!(entrylen != 0UL))
          {
            printf("\nSTMT_EXEC;;20436\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;20439\n");
tmp___7 = new_name(path, entry);
            printf("\nSTMT_EXEC;;20440\n");
path_buffer = tmp___7;
            printf("\nSTMT_EXEC;;20441\n");
tmp___8 = remove_any_file((char const *)path_buffer, (enum remove_option)1);
            printf("\nSTMT_EXEC;;20442\n");
r = tmp___8;
            printf("\nSTMT_EXEC;;20443\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___9 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;20444\n");
e = *tmp___9;
            printf("\nSTMT_EXEC;;20445\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_buffer);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;20447\n");
if (!r)
          {
            {
              printf("\nSTMT_EXEC;;20450\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)directory);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;20451\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___10 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;20452\n");
*tmp___10 = e;
            }
            printf("\nSTMT_EXEC;;20454\n");
printf("\nFUNC_RETURN;;\n");
return (0);
          }
          printf("\nSTMT_EXEC;;20456\n");
entry += entrylen + 1UL;
        }
      while_break: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;20461\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)directory);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20462\n");
tmp___11 = safer_rmdir(path);
      }
      printf("\nSTMT_EXEC;;20464\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___11 == 0);
    switch_break___0: /* CIL Label */;
    }
      printf("\nSTMT_EXEC;;20467\n");
goto switch_break;
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;20470\n");
printf("\nFUNC_RETURN;;\n");
return (0);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool maybe_backup_file(char const *path, int this_is_the_archive)
{
  printf("\nFUNC_CALL;maybe_backup_file(const char *,int);\n");
printf("\nSTMT_EXEC;;20475\n");
struct stat file_stat;
  printf("\nSTMT_EXEC;;20476\n");
void *tmp;
  printf("\nSTMT_EXEC;;20477\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;20478\n");
int tmp___1;
  printf("\nSTMT_EXEC;;20479\n");
char const *tmp___2;
  printf("\nSTMT_EXEC;;20480\n");
char const *tmp___3;
  printf("\nSTMT_EXEC;;20481\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;20482\n");
int e;
  printf("\nSTMT_EXEC;;20483\n");
int *tmp___5;
  printf("\nSTMT_EXEC;;20484\n");
char const *tmp___6;
  printf("\nSTMT_EXEC;;20485\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;20486\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;20487\n");
int tmp___9;
  printf("\nSTMT_EXEC;;20488\n");
void *__cil_tmp16;
  printf("\nSTMT_EXEC;;20489\n");
char *__cil_tmp17;
  printf("\nSTMT_EXEC;;20490\n");
char *__cil_tmp18;

  {
    printf("\nSTMT_EXEC;;20493\n");
if (this_is_the_archive)
    {
      printf("\nSTMT_EXEC;;20495\n");
if (!force_local_option)
      {
        {
          printf("\nSTMT_EXEC;;20498\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(path, ':');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;20500\n");
if (rmt_path__)
        {
          printf("\nSTMT_EXEC;;20502\n");
if ((unsigned long)rmt_path__ > (unsigned long)path)
          {
            {
              printf("\nSTMT_EXEC;;20505\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp = memchr((void const *)path, '/', (size_t)(rmt_path__ - (char *)path));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;20507\n");
if (!tmp)
            {
              printf("\nSTMT_EXEC;;20509\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
            }
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;20516\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___1 = stat((char const * /* __restrict  */)path, (struct stat * /* __restrict  */)(&file_stat));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;20518\n");
if (tmp___1)
    {
      {
        printf("\nSTMT_EXEC;;20521\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;20523\n");
if (*tmp___0 == 2)
      {
        printf("\nSTMT_EXEC;;20525\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
      }
      {
        printf("\nSTMT_EXEC;;20528\n");
stat_error(path);
      }
      printf("\nSTMT_EXEC;;20530\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;20532\n");
if ((file_stat.st_mode & 61440U) == 16384U)
    {
      printf("\nSTMT_EXEC;;20534\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    printf("\nSTMT_EXEC;;20536\n");
if (this_is_the_archive)
    {
      printf("\nSTMT_EXEC;;20538\n");
if ((file_stat.st_mode & 61440U) == 24576U)
      {
        printf("\nSTMT_EXEC;;20540\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
      }
      else
      {
        printf("\nSTMT_EXEC;;20544\n");
if ((file_stat.st_mode & 61440U) == 8192U)
        {
          printf("\nSTMT_EXEC;;20546\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;20551\n");
assign_string(&before_backup_name, path);
      printf("\nSTMT_EXEC;;20552\n");
assign_string(&after_backup_name, (char const *)0);
      printf("\nSTMT_EXEC;;20553\n");
after_backup_name = find_backup_file_name(path, backup_type);
    }
    printf("\nSTMT_EXEC;;20555\n");
if (!after_backup_name)
    {
      {
        printf("\nSTMT_EXEC;;20558\n");
xalloc_die();
      }
    }
    {
      printf("\nSTMT_EXEC;;20562\n");
printf("\nFUNC_CALL;rename(const char *,const char *);\n");
tmp___9 = rename((char const *)before_backup_name, (char const *)after_backup_name);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;20564\n");
if (tmp___9 == 0)
    {
      printf("\nSTMT_EXEC;;20566\n");
if (verbose_option)
      {
        {
          printf("\nSTMT_EXEC;;20569\n");
tmp___2 = quote_n(1, (char const *)after_backup_name);
          printf("\nSTMT_EXEC;;20570\n");
tmp___3 = quote_n(0, (char const *)before_backup_name);
          printf("\nSTMT_EXEC;;20571\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Renaming %s to %s\n");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;20572\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___4, tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

        }
      }
      printf("\nSTMT_EXEC;;20575\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;20580\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___5 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20581\n");
e = *tmp___5;
        printf("\nSTMT_EXEC;;20582\n");
tmp___6 = quote_n(1, (char const *)after_backup_name);
        printf("\nSTMT_EXEC;;20583\n");
tmp___7 = quotearg_colon((char const *)before_backup_name);
        printf("\nSTMT_EXEC;;20584\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("%s: Cannot rename to %s");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20585\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___8, tmp___7, tmp___6);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20586\n");
exit_status = 2;
        printf("\nSTMT_EXEC;;20587\n");
assign_string(&after_backup_name, (char const *)0);
      }
      printf("\nSTMT_EXEC;;20589\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void undo_last_backup(void)
{
  printf("\nFUNC_CALL;undo_last_backup();\n");
printf("\nSTMT_EXEC;;20595\n");
int e;
  printf("\nSTMT_EXEC;;20596\n");
int *tmp;
  printf("\nSTMT_EXEC;;20597\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;20598\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;20599\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;20600\n");
int tmp___3;
  printf("\nSTMT_EXEC;;20601\n");
char const *tmp___4;
  printf("\nSTMT_EXEC;;20602\n");
char const *tmp___5;
  printf("\nSTMT_EXEC;;20603\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;20604\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;20605\n");
char *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;20608\n");
if (after_backup_name)
    {
      {
        printf("\nSTMT_EXEC;;20611\n");
printf("\nFUNC_CALL;rename(const char *,const char *);\n");
tmp___3 = rename((char const *)after_backup_name, (char const *)before_backup_name);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;20613\n");
if (tmp___3 != 0)
      {
        {
          printf("\nSTMT_EXEC;;20616\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;20617\n");
e = *tmp;
          printf("\nSTMT_EXEC;;20618\n");
tmp___0 = quote_n(1, (char const *)before_backup_name);
          printf("\nSTMT_EXEC;;20619\n");
tmp___1 = quotearg_colon((char const *)after_backup_name);
          printf("\nSTMT_EXEC;;20620\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Cannot rename to %s");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;20621\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;20622\n");
exit_status = 2;
        }
      }
      printf("\nSTMT_EXEC;;20625\n");
if (verbose_option)
      {
        {
          printf("\nSTMT_EXEC;;20628\n");
tmp___4 = quote_n(1, (char const *)before_backup_name);
          printf("\nSTMT_EXEC;;20629\n");
tmp___5 = quote_n(0, (char const *)after_backup_name);
          printf("\nSTMT_EXEC;;20630\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("Renaming %s back to %s\n");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;20631\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */)tmp___6, tmp___5, tmp___4);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;20635\n");
assign_string(&after_backup_name, (char const *)0);
      }
    }
    printf("\nSTMT_EXEC;;20638\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}








int deref_stat(_Bool deref, char const *name, struct stat *buf)
{
  printf("\nFUNC_CALL;deref_stat(_Bool,const char *,struct stat *);\n");
printf("\nSTMT_EXEC;;20651\n");
int tmp;
  printf("\nSTMT_EXEC;;20652\n");
int tmp___0;
  printf("\nSTMT_EXEC;;20653\n");
int tmp___1;

  {
    printf("\nSTMT_EXEC;;20656\n");
if (deref)
    {
      {

        printf("\nSTMT_EXEC;;20660\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp = stat((char const * /* __restrict  */)name, (struct stat * /* __restrict  */) buf);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20661\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;20667\n");
printf("\nFUNC_CALL;lstat(const char *__restrict,struct stat *__restrict);\n");
tmp___0 = lstat((char const * /* __restrict  */)name, (struct stat * /* __restrict  */) buf);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;20668\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;20671\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct wd *wd;
static size_t wds;
static size_t wd_alloc;
int chdir_arg(char const *dir)
{
  printf("\nFUNC_CALL;chdir_arg(const char *);\n");
printf("\nSTMT_EXEC;;20679\n");
void *tmp;
  printf("\nSTMT_EXEC;;20680\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;20681\n");
char *__cil_tmp4;

  {
    printf("\nSTMT_EXEC;;20684\n");
if (wds == wd_alloc)
    {
      {
        printf("\nSTMT_EXEC;;20687\n");
wd_alloc = 2UL * (wd_alloc + 1UL);
        printf("\nSTMT_EXEC;;20688\n");
tmp = xrealloc((void *)wd, sizeof(*wd) * wd_alloc);
        printf("\nSTMT_EXEC;;20689\n");
wd = (struct wd *)tmp;
      }
      printf("\nSTMT_EXEC;;20691\n");
if (!wds)
      {
        printf("\nSTMT_EXEC;;20693\n");
(wd + wds)->name = ".";
        printf("\nSTMT_EXEC;;20694\n");
(wd + wds)->saved = 0;
        printf("\nSTMT_EXEC;;20695\n");
wds++;
      }
    }
    printf("\nSTMT_EXEC;;20698\n");
if (*(dir + 0))
    {
      {
        printf("\nSTMT_EXEC;;20701\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;20704\n");
if ((int const) * (dir + 0) == 46)
          {
            printf("\nSTMT_EXEC;;20706\n");
if (!((int const) * (dir + 1) == 47))
            {
              printf("\nSTMT_EXEC;;20708\n");
goto while_break;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;20713\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;20715\n");
dir += 2;
          {
            printf("\nSTMT_EXEC;;20717\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;20720\n");
if (!((int const) * dir == 47))
              {
                printf("\nSTMT_EXEC;;20722\n");
goto while_break___0;
              }
              printf("\nSTMT_EXEC;;20724\n");
goto __Cont;
            __Cont:
              {
printf("\nSTMT_EXEC;;20726\n");
dir++;
}

            }
          while_break___0: /* CIL Label */;
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;20733\n");
if (!*(dir + ((int const) * (dir + 0) == 46)))
      {
        printf("\nSTMT_EXEC;;20735\n");
printf("\nFUNC_RETURN;;\n");
return ((int)(wds - 1UL));
      }
    }
    printf("\nSTMT_EXEC;;20738\n");
(wd + wds)->name = dir;
    printf("\nSTMT_EXEC;;20739\n");
(wd + wds)->saved = 0;
    printf("\nSTMT_EXEC;;20740\n");
tmp___0 = wds;
    printf("\nSTMT_EXEC;;20741\n");
wds++;
    printf("\nSTMT_EXEC;;20742\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
static int previous;
void chdir_do(int i)
{
  printf("\nFUNC_CALL;chdir_do(int);\n");
printf("\nSTMT_EXEC;;20748\n");
struct wd *prev;
  printf("\nSTMT_EXEC;;20749\n");
struct wd *curr;
  printf("\nSTMT_EXEC;;20750\n");
char *tmp;
  printf("\nSTMT_EXEC;;20751\n");
int tmp___0;
  printf("\nSTMT_EXEC;;20752\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;20753\n");
int tmp___2;
  printf("\nSTMT_EXEC;;20754\n");
int tmp___3;
  printf("\nSTMT_EXEC;;20755\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;20756\n");
char *__cil_tmp10;

  {
    printf("\nSTMT_EXEC;;20759\n");
if (previous != i)
    {
      printf("\nSTMT_EXEC;;20761\n");
prev = wd + previous;
      printf("\nSTMT_EXEC;;20762\n");
curr = wd + i;
      printf("\nSTMT_EXEC;;20763\n");
if (!prev->saved)
      {
        {
          printf("\nSTMT_EXEC;;20766\n");
prev->saved = 1;
          printf("\nSTMT_EXEC;;20767\n");
tmp___0 = save_cwd(&prev->saved_cwd);
        }
        printf("\nSTMT_EXEC;;20769\n");
if (tmp___0 != 0)
        {
          {
            printf("\nSTMT_EXEC;;20772\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Cannot save working directory");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;20773\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;20774\n");
fatal_exit();
          }
        }
      }
      printf("\nSTMT_EXEC;;20778\n");
if (curr->saved)
      {
        {
          printf("\nSTMT_EXEC;;20781\n");
tmp___2 = restore_cwd((struct saved_cwd const *)(&curr->saved_cwd));
        }
        printf("\nSTMT_EXEC;;20783\n");
if (tmp___2)
        {
          {
            printf("\nSTMT_EXEC;;20786\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Cannot change working directory");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;20787\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;20788\n");
fatal_exit();
          }
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;20794\n");
if (i)
        {
          printf("\nSTMT_EXEC;;20796\n");
if (!((int const) * (curr->name + 0) == 47))
          {
            {
              printf("\nSTMT_EXEC;;20799\n");
chdir_do(i - 1);
            }
          }
        }
        {
          printf("\nSTMT_EXEC;;20804\n");
printf("\nFUNC_CALL;chdir(const char *);\n");
tmp___3 = chdir(curr->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;20806\n");
if (tmp___3 != 0)
        {
          {
            printf("\nSTMT_EXEC;;20809\n");
chdir_fatal(curr->name);
          }
        }
      }
      printf("\nSTMT_EXEC;;20813\n");
previous = i;
    }
    printf("\nSTMT_EXEC;;20815\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void decode_mode(mode_t mode, char *string)
{
  printf("\nFUNC_CALL;decode_mode(mode_t,char *);\n");
printf("\nSTMT_EXEC;;20820\n");
char *tmp;
  printf("\nSTMT_EXEC;;20821\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;20822\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;20823\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;20824\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;20825\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;20826\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;20827\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;20828\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;20829\n");
int tmp___8;
  printf("\nSTMT_EXEC;;20830\n");
int tmp___9;
  printf("\nSTMT_EXEC;;20831\n");
int tmp___10;
  printf("\nSTMT_EXEC;;20832\n");
int tmp___11;
  printf("\nSTMT_EXEC;;20833\n");
int tmp___12;
  printf("\nSTMT_EXEC;;20834\n");
int tmp___13;
  printf("\nSTMT_EXEC;;20835\n");
int tmp___14;
  printf("\nSTMT_EXEC;;20836\n");
int tmp___15;
  printf("\nSTMT_EXEC;;20837\n");
int tmp___16;
  printf("\nSTMT_EXEC;;20838\n");
int tmp___17;
  printf("\nSTMT_EXEC;;20839\n");
int tmp___18;
  printf("\nSTMT_EXEC;;20840\n");
int tmp___19;
  printf("\nSTMT_EXEC;;20841\n");
int tmp___20;
  printf("\nSTMT_EXEC;;20842\n");
int tmp___21;
  printf("\nSTMT_EXEC;;20843\n");
int tmp___22;

  {
    printf("\nSTMT_EXEC;;20846\n");
tmp = string;
    printf("\nSTMT_EXEC;;20847\n");
string++;
    printf("\nSTMT_EXEC;;20848\n");
if (mode & 256U)
    {
      printf("\nSTMT_EXEC;;20850\n");
tmp___8 = 'r';
    }
    else
    {
      printf("\nSTMT_EXEC;;20854\n");
tmp___8 = '-';
    }
    printf("\nSTMT_EXEC;;20856\n");
*tmp = (char)tmp___8;
    printf("\nSTMT_EXEC;;20857\n");
tmp___0 = string;
    printf("\nSTMT_EXEC;;20858\n");
string++;
    printf("\nSTMT_EXEC;;20859\n");
if (mode & 128U)
    {
      printf("\nSTMT_EXEC;;20861\n");
tmp___9 = 'w';
    }
    else
    {
      printf("\nSTMT_EXEC;;20865\n");
tmp___9 = '-';
    }
    printf("\nSTMT_EXEC;;20867\n");
*tmp___0 = (char)tmp___9;
    printf("\nSTMT_EXEC;;20868\n");
tmp___1 = string;
    printf("\nSTMT_EXEC;;20869\n");
string++;
    printf("\nSTMT_EXEC;;20870\n");
if (mode & 2048U)
    {
      printf("\nSTMT_EXEC;;20872\n");
if (mode & 64U)
      {
        printf("\nSTMT_EXEC;;20874\n");
tmp___10 = 's';
      }
      else
      {
        printf("\nSTMT_EXEC;;20878\n");
tmp___10 = 'S';
      }
      printf("\nSTMT_EXEC;;20880\n");
tmp___12 = tmp___10;
    }
    else
    {
      printf("\nSTMT_EXEC;;20884\n");
if (mode & 64U)
      {
        printf("\nSTMT_EXEC;;20886\n");
tmp___11 = 'x';
      }
      else
      {
        printf("\nSTMT_EXEC;;20890\n");
tmp___11 = '-';
      }
      printf("\nSTMT_EXEC;;20892\n");
tmp___12 = tmp___11;
    }
    printf("\nSTMT_EXEC;;20894\n");
*tmp___1 = (char)tmp___12;
    printf("\nSTMT_EXEC;;20895\n");
tmp___2 = string;
    printf("\nSTMT_EXEC;;20896\n");
string++;
    printf("\nSTMT_EXEC;;20897\n");
if (mode & (unsigned int)(256 >> 3))
    {
      printf("\nSTMT_EXEC;;20899\n");
tmp___13 = 'r';
    }
    else
    {
      printf("\nSTMT_EXEC;;20903\n");
tmp___13 = '-';
    }
    printf("\nSTMT_EXEC;;20905\n");
*tmp___2 = (char)tmp___13;
    printf("\nSTMT_EXEC;;20906\n");
tmp___3 = string;
    printf("\nSTMT_EXEC;;20907\n");
string++;
    printf("\nSTMT_EXEC;;20908\n");
if (mode & (unsigned int)(128 >> 3))
    {
      printf("\nSTMT_EXEC;;20910\n");
tmp___14 = 'w';
    }
    else
    {
      printf("\nSTMT_EXEC;;20914\n");
tmp___14 = '-';
    }
    printf("\nSTMT_EXEC;;20916\n");
*tmp___3 = (char)tmp___14;
    printf("\nSTMT_EXEC;;20917\n");
tmp___4 = string;
    printf("\nSTMT_EXEC;;20918\n");
string++;
    printf("\nSTMT_EXEC;;20919\n");
if (mode & 1024U)
    {
      printf("\nSTMT_EXEC;;20921\n");
if (mode & (unsigned int)(64 >> 3))
      {
        printf("\nSTMT_EXEC;;20923\n");
tmp___15 = 's';
      }
      else
      {
        printf("\nSTMT_EXEC;;20927\n");
tmp___15 = 'S';
      }
      printf("\nSTMT_EXEC;;20929\n");
tmp___17 = tmp___15;
    }
    else
    {
      printf("\nSTMT_EXEC;;20933\n");
if (mode & (unsigned int)(64 >> 3))
      {
        printf("\nSTMT_EXEC;;20935\n");
tmp___16 = 'x';
      }
      else
      {
        printf("\nSTMT_EXEC;;20939\n");
tmp___16 = '-';
      }
      printf("\nSTMT_EXEC;;20941\n");
tmp___17 = tmp___16;
    }
    printf("\nSTMT_EXEC;;20943\n");
*tmp___4 = (char)tmp___17;
    printf("\nSTMT_EXEC;;20944\n");
tmp___5 = string;
    printf("\nSTMT_EXEC;;20945\n");
string++;
    printf("\nSTMT_EXEC;;20946\n");
if (mode & (unsigned int)((256 >> 3) >> 3))
    {
      printf("\nSTMT_EXEC;;20948\n");
tmp___18 = 'r';
    }
    else
    {
      printf("\nSTMT_EXEC;;20952\n");
tmp___18 = '-';
    }
    printf("\nSTMT_EXEC;;20954\n");
*tmp___5 = (char)tmp___18;
    printf("\nSTMT_EXEC;;20955\n");
tmp___6 = string;
    printf("\nSTMT_EXEC;;20956\n");
string++;
    printf("\nSTMT_EXEC;;20957\n");
if (mode & (unsigned int)((128 >> 3) >> 3))
    {
      printf("\nSTMT_EXEC;;20959\n");
tmp___19 = 'w';
    }
    else
    {
      printf("\nSTMT_EXEC;;20963\n");
tmp___19 = '-';
    }
    printf("\nSTMT_EXEC;;20965\n");
*tmp___6 = (char)tmp___19;
    printf("\nSTMT_EXEC;;20966\n");
tmp___7 = string;
    printf("\nSTMT_EXEC;;20967\n");
string++;
    printf("\nSTMT_EXEC;;20968\n");
if (mode & 512U)
    {
      printf("\nSTMT_EXEC;;20970\n");
if (mode & (unsigned int)((64 >> 3) >> 3))
      {
        printf("\nSTMT_EXEC;;20972\n");
tmp___20 = 't';
      }
      else
      {
        printf("\nSTMT_EXEC;;20976\n");
tmp___20 = 'T';
      }
      printf("\nSTMT_EXEC;;20978\n");
tmp___22 = tmp___20;
    }
    else
    {
      printf("\nSTMT_EXEC;;20982\n");
if (mode & (unsigned int)((64 >> 3) >> 3))
      {
        printf("\nSTMT_EXEC;;20984\n");
tmp___21 = 'x';
      }
      else
      {
        printf("\nSTMT_EXEC;;20988\n");
tmp___21 = '-';
      }
      printf("\nSTMT_EXEC;;20990\n");
tmp___22 = tmp___21;
    }
    printf("\nSTMT_EXEC;;20992\n");
*tmp___7 = (char)tmp___22;
    printf("\nSTMT_EXEC;;20993\n");
*string = (char)'\000';
    printf("\nSTMT_EXEC;;20994\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void call_arg_error(char const *call, char const *name)
{
  printf("\nFUNC_CALL;call_arg_error(const char *,const char *);\n");
printf("\nSTMT_EXEC;;20999\n");
int e;
  printf("\nSTMT_EXEC;;21000\n");
int *tmp;
  printf("\nSTMT_EXEC;;21001\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21002\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21003\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;21007\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21008\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21009\n");
tmp___0 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21010\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Cannot %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21011\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1, tmp___0, call);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21012\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21014\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}








static __attribute__((__noreturn__)) void call_arg_fatal(char const *call, char const *name);
static void call_arg_fatal(char const *call, char const *name)
{
  printf("\nFUNC_CALL;call_arg_fatal(const char *,const char *);\n");
printf("\nSTMT_EXEC;;21028\n");
int e;
  printf("\nSTMT_EXEC;;21029\n");
int *tmp;
  printf("\nSTMT_EXEC;;21030\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21031\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21032\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;21036\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21037\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21038\n");
tmp___0 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21039\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Cannot %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21040\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1, tmp___0, call);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21041\n");
fatal_exit();
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static void call_arg_warn(char const *call, char const *name)
{
  printf("\nFUNC_CALL;call_arg_warn(const char *,const char *);\n");
printf("\nSTMT_EXEC;;21047\n");
int e;
  printf("\nSTMT_EXEC;;21048\n");
int *tmp;
  printf("\nSTMT_EXEC;;21049\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21050\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21051\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;21055\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21056\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21057\n");
tmp___0 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21058\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Warning: Cannot %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21059\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1, tmp___0, call);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21061\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void chdir_fatal(char const *name);
void chdir_fatal(char const *name)
{
  printf("\nFUNC_CALL;chdir_fatal(const char *);\n");
printf("\nSTMT_EXEC;;21067\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21071\n");
call_arg_fatal("chdir", name);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void chmod_error_details(char const *name, mode_t mode)
{
  printf("\nFUNC_CALL;chmod_error_details(const char *,mode_t);\n");
printf("\nSTMT_EXEC;;21077\n");
int e;
  printf("\nSTMT_EXEC;;21078\n");
int *tmp;
  printf("\nSTMT_EXEC;;21079\n");
char buf[10];
  printf("\nSTMT_EXEC;;21080\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21081\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21082\n");
void *__cil_tmp8;
  printf("\nSTMT_EXEC;;21083\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;21087\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21088\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21089\n");
decode_mode(mode, buf);
      printf("\nSTMT_EXEC;;21090\n");
tmp___0 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21091\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Cannot change mode to %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21092\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1, tmp___0, buf);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21093\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21095\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void chown_error_details(char const *name, uid_t uid, gid_t gid)
{
  printf("\nFUNC_CALL;chown_error_details(const char *,uid_t,gid_t);\n");
printf("\nSTMT_EXEC;;21100\n");
int e;
  printf("\nSTMT_EXEC;;21101\n");
int *tmp;
  printf("\nSTMT_EXEC;;21102\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21103\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21104\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;21108\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21109\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21110\n");
tmp___0 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21111\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("%s: Cannot change ownership to uid %lu, gid %lu");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21112\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1, tmp___0, (unsigned long)uid, (unsigned long)gid);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21113\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21115\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void close_error(char const *name)
{
  printf("\nFUNC_CALL;close_error(const char *);\n");
printf("\nSTMT_EXEC;;21120\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21124\n");
call_arg_error("close", name);
    }
    printf("\nSTMT_EXEC;;21126\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void close_warn(char const *name)
{
  printf("\nFUNC_CALL;close_warn(const char *);\n");
printf("\nSTMT_EXEC;;21131\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21135\n");
call_arg_warn("close", name);
    }
    printf("\nSTMT_EXEC;;21137\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void close_diag(char const *name)
{

  printf("\nFUNC_CALL;close_diag(const char *);\n");
{
    printf("\nSTMT_EXEC;;21144\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21147\n");
close_warn(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21153\n");
close_error(name);
      }
    }
    printf("\nSTMT_EXEC;;21156\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void exec_fatal(char const *name);
void exec_fatal(char const *name)
{
  printf("\nFUNC_CALL;exec_fatal(const char *);\n");
printf("\nSTMT_EXEC;;21162\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21166\n");
call_arg_fatal("exec", name);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void link_error(char const *target, char const *source)
{
  printf("\nFUNC_CALL;link_error(const char *,const char *);\n");
printf("\nSTMT_EXEC;;21172\n");
int e;
  printf("\nSTMT_EXEC;;21173\n");
int *tmp;
  printf("\nSTMT_EXEC;;21174\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;21175\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21176\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21177\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;21181\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21182\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21183\n");
tmp___0 = quote_n(1, target);
      printf("\nSTMT_EXEC;;21184\n");
tmp___1 = quotearg_colon(source);
      printf("\nSTMT_EXEC;;21185\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Cannot hard link to %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21186\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21187\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21189\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void mkdir_error(char const *name)
{
  printf("\nFUNC_CALL;mkdir_error(const char *);\n");
printf("\nSTMT_EXEC;;21194\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21198\n");
call_arg_error("mkdir", name);
    }
    printf("\nSTMT_EXEC;;21200\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void mkfifo_error(char const *name)
{
  printf("\nFUNC_CALL;mkfifo_error(const char *);\n");
printf("\nSTMT_EXEC;;21205\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21209\n");
call_arg_error("mkfifo", name);
    }
    printf("\nSTMT_EXEC;;21211\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void mknod_error(char const *name)
{
  printf("\nFUNC_CALL;mknod_error(const char *);\n");
printf("\nSTMT_EXEC;;21216\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21220\n");
call_arg_error("mknod", name);
    }
    printf("\nSTMT_EXEC;;21222\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void open_error(char const *name)
{
  printf("\nFUNC_CALL;open_error(const char *);\n");
printf("\nSTMT_EXEC;;21227\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21231\n");
call_arg_error("open", name);
    }
    printf("\nSTMT_EXEC;;21233\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void open_fatal(char const *name);
void open_fatal(char const *name)
{
  printf("\nFUNC_CALL;open_fatal(const char *);\n");
printf("\nSTMT_EXEC;;21239\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21243\n");
call_arg_fatal("open", name);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void open_warn(char const *name)
{
  printf("\nFUNC_CALL;open_warn(const char *);\n");
printf("\nSTMT_EXEC;;21249\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21253\n");
call_arg_warn("open", name);
    }
    printf("\nSTMT_EXEC;;21255\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void open_diag(char const *name)
{

  printf("\nFUNC_CALL;open_diag(const char *);\n");
{
    printf("\nSTMT_EXEC;;21262\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21265\n");
open_warn(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21271\n");
open_error(name);
      }
    }
    printf("\nSTMT_EXEC;;21274\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void read_error(char const *name)
{
  printf("\nFUNC_CALL;read_error(const char *);\n");
printf("\nSTMT_EXEC;;21279\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21283\n");
call_arg_error("read", name);
    }
    printf("\nSTMT_EXEC;;21285\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void read_error_details(char const *name, off_t offset, size_t size)
{
  printf("\nFUNC_CALL;read_error_details(const char *,off_t,size_t);\n");
printf("\nSTMT_EXEC;;21290\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;21291\n");
int e;
  printf("\nSTMT_EXEC;;21292\n");
int *tmp;
  printf("\nSTMT_EXEC;;21293\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21294\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21295\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21296\n");
void *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;21300\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21301\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21302\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)offset, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
      printf("\nSTMT_EXEC;;21303\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21304\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___2 = ngettext("%s: Read error at byte %s, reading %lu byte", "%s: Read error at byte %s, reading %lu bytes", size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21305\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21306\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21308\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void read_warn_details(char const *name, off_t offset, size_t size)
{
  printf("\nFUNC_CALL;read_warn_details(const char *,off_t,size_t);\n");
printf("\nSTMT_EXEC;;21313\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;21314\n");
int e;
  printf("\nSTMT_EXEC;;21315\n");
int *tmp;
  printf("\nSTMT_EXEC;;21316\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21317\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21318\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21319\n");
void *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;21323\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21324\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21325\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)offset, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
      printf("\nSTMT_EXEC;;21326\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21327\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___2 = ngettext("%s: Warning: Read error at byte %s, reading %lu byte", "%s: Warning: Read error at byte %s, reading %lu bytes", size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21328\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21330\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void read_diag_details(char const *name, off_t offset, size_t size)
{

  printf("\nFUNC_CALL;read_diag_details(const char *,off_t,size_t);\n");
{
    printf("\nSTMT_EXEC;;21337\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21340\n");
read_warn_details(name, offset, size);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21346\n");
read_error_details(name, offset, size);
      }
    }
    printf("\nSTMT_EXEC;;21349\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void read_fatal(char const *name);
void read_fatal(char const *name)
{
  printf("\nFUNC_CALL;read_fatal(const char *);\n");
printf("\nSTMT_EXEC;;21355\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21359\n");
call_arg_fatal("read", name);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void read_fatal_details(char const *name, off_t offset, size_t size);
void read_fatal_details(char const *name, off_t offset, size_t size)
{
  printf("\nFUNC_CALL;read_fatal_details(const char *,off_t,size_t);\n");
printf("\nSTMT_EXEC;;21366\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;21367\n");
int e;
  printf("\nSTMT_EXEC;;21368\n");
int *tmp;
  printf("\nSTMT_EXEC;;21369\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21370\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21371\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21372\n");
void *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;21376\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21377\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21378\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)offset, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
      printf("\nSTMT_EXEC;;21379\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21380\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___2 = ngettext("%s: Read error at byte %s, reading %lu byte", "%s: Read error at byte %s, reading %lu bytes", size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21381\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21382\n");
fatal_exit();
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void readlink_error(char const *name)
{
  printf("\nFUNC_CALL;readlink_error(const char *);\n");
printf("\nSTMT_EXEC;;21388\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21392\n");
call_arg_error("readlink", name);
    }
    printf("\nSTMT_EXEC;;21394\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void readlink_warn(char const *name)
{
  printf("\nFUNC_CALL;readlink_warn(const char *);\n");
printf("\nSTMT_EXEC;;21399\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21403\n");
call_arg_warn("readlink", name);
    }
    printf("\nSTMT_EXEC;;21405\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void readlink_diag(char const *name)
{

  printf("\nFUNC_CALL;readlink_diag(const char *);\n");
{
    printf("\nSTMT_EXEC;;21412\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21415\n");
readlink_warn(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21421\n");
readlink_error(name);
      }
    }
    printf("\nSTMT_EXEC;;21424\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void savedir_error(char const *name)
{
  printf("\nFUNC_CALL;savedir_error(const char *);\n");
printf("\nSTMT_EXEC;;21429\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21433\n");
call_arg_error("savedir", name);
    }
    printf("\nSTMT_EXEC;;21435\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void savedir_warn(char const *name)
{
  printf("\nFUNC_CALL;savedir_warn(const char *);\n");
printf("\nSTMT_EXEC;;21440\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21444\n");
call_arg_warn("savedir", name);
    }
    printf("\nSTMT_EXEC;;21446\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void savedir_diag(char const *name)
{

  printf("\nFUNC_CALL;savedir_diag(const char *);\n");
{
    printf("\nSTMT_EXEC;;21453\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21456\n");
savedir_warn(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21462\n");
savedir_error(name);
      }
    }
    printf("\nSTMT_EXEC;;21465\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void seek_error(char const *name)
{
  printf("\nFUNC_CALL;seek_error(const char *);\n");
printf("\nSTMT_EXEC;;21470\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21474\n");
call_arg_error("seek", name);
    }
    printf("\nSTMT_EXEC;;21476\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void seek_error_details(char const *name, off_t offset)
{
  printf("\nFUNC_CALL;seek_error_details(const char *,off_t);\n");
printf("\nSTMT_EXEC;;21481\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;21482\n");
int e;
  printf("\nSTMT_EXEC;;21483\n");
int *tmp;
  printf("\nSTMT_EXEC;;21484\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21485\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21486\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21487\n");
void *__cil_tmp9;
  printf("\nSTMT_EXEC;;21488\n");
char *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;21492\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21493\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21494\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)offset, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
      printf("\nSTMT_EXEC;;21495\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21496\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Cannot seek to %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21497\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21498\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21500\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void seek_warn(char const *name)
{
  printf("\nFUNC_CALL;seek_warn(const char *);\n");
printf("\nSTMT_EXEC;;21505\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21509\n");
call_arg_warn("seek", name);
    }
    printf("\nSTMT_EXEC;;21511\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void seek_warn_details(char const *name, off_t offset)
{
  printf("\nFUNC_CALL;seek_warn_details(const char *,off_t);\n");
printf("\nSTMT_EXEC;;21516\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;21517\n");
int e;
  printf("\nSTMT_EXEC;;21518\n");
int *tmp;
  printf("\nSTMT_EXEC;;21519\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21520\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21521\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21522\n");
void *__cil_tmp9;
  printf("\nSTMT_EXEC;;21523\n");
char *__cil_tmp10;

  {
    {
      printf("\nSTMT_EXEC;;21527\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21528\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21529\n");
tmp___0 = stringify_uintmax_t_backwards((uintmax_t)offset, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
      printf("\nSTMT_EXEC;;21530\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21531\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Warning: Cannot seek to %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21532\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21534\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void seek_diag_details(char const *name, off_t offset)
{

  printf("\nFUNC_CALL;seek_diag_details(const char *,off_t);\n");
{
    printf("\nSTMT_EXEC;;21541\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21544\n");
seek_warn_details(name, offset);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21550\n");
seek_error_details(name, offset);
      }
    }
    printf("\nSTMT_EXEC;;21553\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void symlink_error(char const *contents, char const *name)
{
  printf("\nFUNC_CALL;symlink_error(const char *,const char *);\n");
printf("\nSTMT_EXEC;;21558\n");
int e;
  printf("\nSTMT_EXEC;;21559\n");
int *tmp;
  printf("\nSTMT_EXEC;;21560\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;21561\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;21562\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;21563\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;21567\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21568\n");
e = *tmp;
      printf("\nSTMT_EXEC;;21569\n");
tmp___0 = quote_n(1, contents);
      printf("\nSTMT_EXEC;;21570\n");
tmp___1 = quotearg_colon(name);
      printf("\nSTMT_EXEC;;21571\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Cannot create symlink to %s");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21572\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___2, tmp___1, tmp___0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21573\n");
exit_status = 2;
    }
    printf("\nSTMT_EXEC;;21575\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void stat_error(char const *name)
{
  printf("\nFUNC_CALL;stat_error(const char *);\n");
printf("\nSTMT_EXEC;;21580\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21584\n");
call_arg_error("stat", name);
    }
    printf("\nSTMT_EXEC;;21586\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void stat_warn(char const *name)
{
  printf("\nFUNC_CALL;stat_warn(const char *);\n");
printf("\nSTMT_EXEC;;21591\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21595\n");
call_arg_warn("stat", name);
    }
    printf("\nSTMT_EXEC;;21597\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void stat_diag(char const *name)
{

  printf("\nFUNC_CALL;stat_diag(const char *);\n");
{
    printf("\nSTMT_EXEC;;21604\n");
if (ignore_failed_read_option)
    {
      {
        printf("\nSTMT_EXEC;;21607\n");
stat_warn(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21613\n");
stat_error(name);
      }
    }
    printf("\nSTMT_EXEC;;21616\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void truncate_error(char const *name)
{
  printf("\nFUNC_CALL;truncate_error(const char *);\n");
printf("\nSTMT_EXEC;;21621\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21625\n");
call_arg_error("truncate", name);
    }
    printf("\nSTMT_EXEC;;21627\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void truncate_warn(char const *name)
{
  printf("\nFUNC_CALL;truncate_warn(const char *);\n");
printf("\nSTMT_EXEC;;21632\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21636\n");
call_arg_warn("truncate", name);
    }
    printf("\nSTMT_EXEC;;21638\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void unlink_error(char const *name)
{
  printf("\nFUNC_CALL;unlink_error(const char *);\n");
printf("\nSTMT_EXEC;;21643\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21647\n");
call_arg_error("unlink", name);
    }
    printf("\nSTMT_EXEC;;21649\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void utime_error(char const *name)
{
  printf("\nFUNC_CALL;utime_error(const char *);\n");
printf("\nSTMT_EXEC;;21654\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21658\n");
call_arg_error("utime", name);
    }
    printf("\nSTMT_EXEC;;21660\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void waitpid_error(char const *name)
{
  printf("\nFUNC_CALL;waitpid_error(const char *);\n");
printf("\nSTMT_EXEC;;21665\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21669\n");
call_arg_error("waitpid", name);
    }
    printf("\nSTMT_EXEC;;21671\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void write_error(char const *name)
{
  printf("\nFUNC_CALL;write_error(const char *);\n");
printf("\nSTMT_EXEC;;21676\n");
char *__cil_tmp2;

  {
    {
      printf("\nSTMT_EXEC;;21680\n");
call_arg_error("write", name);
    }
    printf("\nSTMT_EXEC;;21682\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void write_error_details(char const *name, size_t status, size_t size)
{
  printf("\nFUNC_CALL;write_error_details(const char *,size_t,size_t);\n");
printf("\nSTMT_EXEC;;21687\n");
char *tmp;

  {
    printf("\nSTMT_EXEC;;21690\n");
if (status == 0UL)
    {
      {
        printf("\nSTMT_EXEC;;21693\n");
write_error(name);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;21699\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp = ngettext("%s: Wrote only %lu of %lu byte", "%s: Wrote only %lu of %lu bytes", size);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;21700\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, name, status, size);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;21701\n");
exit_status = 2;
      }
    }
    printf("\nSTMT_EXEC;;21704\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
__attribute__((__noreturn__)) void write_fatal_details(char const *name, ssize_t status, size_t size);
void write_fatal_details(char const *name, ssize_t status, size_t size)
{

  printf("\nFUNC_CALL;write_fatal_details(const char *,ssize_t,size_t);\n");
{
    {
      printf("\nSTMT_EXEC;;21713\n");
write_error_details(name, (size_t)status, size);
      printf("\nSTMT_EXEC;;21714\n");
fatal_exit();
    }
  }
printf("\nFUNC_RETURN;;\n");
}
pid_t xfork(void)
{
  printf("\nFUNC_CALL;xfork();\n");
printf("\nSTMT_EXEC;;21720\n");
pid_t p;
  printf("\nSTMT_EXEC;;21721\n");
__pid_t tmp;
  printf("\nSTMT_EXEC;;21722\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;21723\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;21724\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;21728\n");
printf("\nFUNC_CALL;fork();\n");
tmp = fork();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;21729\n");
p = tmp;
    }
    printf("\nSTMT_EXEC;;21731\n");
if (p == -1)
    {
      {
        printf("\nSTMT_EXEC;;21734\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("child process");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;21735\n");
call_arg_fatal("fork", (char const *)tmp___0);
      }
    }
    printf("\nSTMT_EXEC;;21738\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }
printf("\nFUNC_RETURN;;\n");
}
void xpipe(int *fd)
{
  printf("\nFUNC_CALL;xpipe(int *);\n");
printf("\nSTMT_EXEC;;21743\n");
char *tmp;
  printf("\nSTMT_EXEC;;21744\n");
int tmp___0;
  printf("\nSTMT_EXEC;;21745\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;21746\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;21750\n");
printf("\nFUNC_CALL;pipe(int *);\n");
tmp___0 = pipe(fd);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21752\n");
if (tmp___0 < 0)
    {
      {
        printf("\nSTMT_EXEC;;21755\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("interprocess channel");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;21756\n");
call_arg_fatal("pipe", (char const *)tmp);
      }
    }
    printf("\nSTMT_EXEC;;21759\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
char const *quote_n(int n, char const *name)
{
  printf("\nFUNC_CALL;quote_n(int,const char *);\n");
printf("\nSTMT_EXEC;;21764\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;21768\n");
tmp = quotearg_n_style(n, (enum quoting_style)5, name);
    }
    printf("\nSTMT_EXEC;;21770\n");
printf("\nFUNC_RETURN;;\n");
return ((char const *)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
char const *quote(char const *name)
{
  printf("\nFUNC_CALL;quote(const char *);\n");
printf("\nSTMT_EXEC;;21775\n");
char const *tmp;

  {
    {
      printf("\nSTMT_EXEC;;21779\n");
tmp = quote_n(0, name);
    }
    printf("\nSTMT_EXEC;;21781\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","00a.names.o.i","") */
extern int getc_unlocked(FILE *__stream);
extern struct passwd *getpwuid(__uid_t __uid);
extern struct passwd *getpwnam(char const *__name);
extern struct group *getgrgid(__gid_t __gid);
extern struct group *getgrnam(char const *__name);
_Bool excluded_filename(struct exclude const *ex, char const *f);
char filename_terminator;
struct exclude *excluded;
char const *files_from_option;
_Bool same_order_option;
_Bool starting_file_option;
void init_names(void);
void name_add(char const *name);
void name_init(void);
void name_term(void);
void name_close(void);
struct name *addname(char const *string, int change_dir___0);
void add_avoided_name(char const *name);
void request_stdin(char const *option);
static char *cached_uname;
static char *cached_gname;
static uid_t cached_uid;
static gid_t cached_gid;
static char *cached_no_such_uname;
static char *cached_no_such_gname;
static uid_t cached_no_such_uid;
static gid_t cached_no_such_gid;
void uid_to_uname(uid_t uid, char **uname)
{
  printf("\nFUNC_CALL;uid_to_uname(uid_t,char **);\n");
printf("\nSTMT_EXEC;;21814\n");
struct passwd *passwd;
  printf("\nSTMT_EXEC;;21815\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;21816\n");
char *__cil_tmp5;

  {
    printf("\nSTMT_EXEC;;21819\n");
if (uid != 0U)
    {
      printf("\nSTMT_EXEC;;21821\n");
if (uid == cached_no_such_uid)
      {
        {
          printf("\nSTMT_EXEC;;21824\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*uname = strdup("");printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;21826\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    printf("\nSTMT_EXEC;;21829\n");
if (!cached_uname)
    {
      printf("\nSTMT_EXEC;;21831\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;21835\n");
if (uid != cached_uid)
      {
      _L___3: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;21839\n");
printf("\nFUNC_CALL;getpwuid(__uid_t);\n");
passwd = getpwuid(uid);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;21841\n");
if (passwd)
        {
          {
            printf("\nSTMT_EXEC;;21844\n");
cached_uid = uid;
            printf("\nSTMT_EXEC;;21845\n");
assign_string(&cached_uname, (char const *)passwd->pw_name);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;21851\n");
cached_no_such_uid = uid;
            printf("\nSTMT_EXEC;;21852\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*uname = strdup("");printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;21854\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;21859\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*uname = strdup((char const *)cached_uname);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21861\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void gid_to_gname(gid_t gid, char **gname)
{
  printf("\nFUNC_CALL;gid_to_gname(gid_t,char **);\n");
printf("\nSTMT_EXEC;;21866\n");
struct group *group;
  printf("\nSTMT_EXEC;;21867\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;21868\n");
char *__cil_tmp5;

  {
    printf("\nSTMT_EXEC;;21871\n");
if (gid != 0U)
    {
      printf("\nSTMT_EXEC;;21873\n");
if (gid == cached_no_such_gid)
      {
        {
          printf("\nSTMT_EXEC;;21876\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*gname = strdup("");printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;21878\n");
printf("\nFUNC_RETURN;;\n");
return;
      }
    }
    printf("\nSTMT_EXEC;;21881\n");
if (!cached_gname)
    {
      printf("\nSTMT_EXEC;;21883\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;21887\n");
if (gid != cached_gid)
      {
      _L___3: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;21891\n");
printf("\nFUNC_CALL;getgrgid(__gid_t);\n");
group = getgrgid(gid);printf("\nFUNC_RETURN;;\n");

      }
        printf("\nSTMT_EXEC;;21893\n");
if (group)
        {
          {
            printf("\nSTMT_EXEC;;21896\n");
cached_gid = gid;
            printf("\nSTMT_EXEC;;21897\n");
assign_string(&cached_gname, (char const *)group->gr_name);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;21903\n");
cached_no_such_gid = gid;
            printf("\nSTMT_EXEC;;21904\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*gname = strdup("");printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;21906\n");
printf("\nFUNC_RETURN;;\n");
return;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;21911\n");
printf("\nFUNC_CALL;strdup(const char *);\n");
*gname = strdup((char const *)cached_gname);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;21913\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
int uname_to_uid(char const *uname, uid_t *uidp)
{
  printf("\nFUNC_CALL;uname_to_uid(const char *,uid_t *);\n");
printf("\nSTMT_EXEC;;21918\n");
struct passwd *passwd;
  printf("\nSTMT_EXEC;;21919\n");
int tmp;
  printf("\nSTMT_EXEC;;21920\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;21923\n");
if (cached_no_such_uname)
    {
      {
        printf("\nSTMT_EXEC;;21926\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp(uname, (char const *)cached_no_such_uname);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;21928\n");
if (tmp == 0)
      {
        printf("\nSTMT_EXEC;;21930\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
    }
    printf("\nSTMT_EXEC;;21933\n");
if (!cached_uname)
    {
      printf("\nSTMT_EXEC;;21935\n");
goto _L;
    }
    else
    {
      printf("\nSTMT_EXEC;;21939\n");
if ((int const) * (uname + 0) != (int const) * (cached_uname + 0))
      {
        printf("\nSTMT_EXEC;;21941\n");
goto _L;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;21946\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(uname, (char const *)cached_uname);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;21948\n");
if (tmp___0 != 0)
        {
        _L:
        {
          printf("\nSTMT_EXEC;;21952\n");
printf("\nFUNC_CALL;getpwnam(const char *);\n");
passwd = getpwnam(uname);printf("\nFUNC_RETURN;;\n");

        }
          printf("\nSTMT_EXEC;;21954\n");
if (passwd)
          {
            {
              printf("\nSTMT_EXEC;;21957\n");
cached_uid = passwd->pw_uid;
              printf("\nSTMT_EXEC;;21958\n");
assign_string(&cached_uname, (char const *)passwd->pw_name);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;21964\n");
assign_string(&cached_no_such_uname, uname);
            }
            printf("\nSTMT_EXEC;;21966\n");
printf("\nFUNC_RETURN;;\n");
return (0);
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;21971\n");
*uidp = cached_uid;
    printf("\nSTMT_EXEC;;21972\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
int gname_to_gid(char const *gname, gid_t *gidp)
{
  printf("\nFUNC_CALL;gname_to_gid(const char *,gid_t *);\n");
printf("\nSTMT_EXEC;;21977\n");
struct group *group;
  printf("\nSTMT_EXEC;;21978\n");
int tmp;
  printf("\nSTMT_EXEC;;21979\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;21982\n");
if (cached_no_such_gname)
    {
      {
        printf("\nSTMT_EXEC;;21985\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp(gname, (char const *)cached_no_such_gname);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;21987\n");
if (tmp == 0)
      {
        printf("\nSTMT_EXEC;;21989\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
    }
    printf("\nSTMT_EXEC;;21992\n");
if (!cached_gname)
    {
      printf("\nSTMT_EXEC;;21994\n");
goto _L;
    }
    else
    {
      printf("\nSTMT_EXEC;;21998\n");
if ((int const) * (gname + 0) != (int const) * (cached_gname + 0))
      {
        printf("\nSTMT_EXEC;;22000\n");
goto _L;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;22005\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(gname, (char const *)cached_gname);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;22007\n");
if (tmp___0 != 0)
        {
        _L:
        {
          printf("\nSTMT_EXEC;;22011\n");
printf("\nFUNC_CALL;getgrnam(const char *);\n");
group = getgrnam(gname);printf("\nFUNC_RETURN;;\n");

        }
          printf("\nSTMT_EXEC;;22013\n");
if (group)
          {
            {
              printf("\nSTMT_EXEC;;22016\n");
cached_gid = group->gr_gid;
              printf("\nSTMT_EXEC;;22017\n");
assign_string(&cached_gname, gname);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;22023\n");
assign_string(&cached_no_such_gname, gname);
            }
            printf("\nSTMT_EXEC;;22025\n");
printf("\nFUNC_RETURN;;\n");
return (0);
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;22030\n");
*gidp = cached_gid;
    printf("\nSTMT_EXEC;;22031\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct name *namelist;
static struct name **nametail = &namelist;
static char const **name_array;
static int allocated_names;
static int names;
static int name_index;
void init_names(void)
{
  printf("\nFUNC_CALL;init_names();\n");
printf("\nSTMT_EXEC;;22042\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;22046\n");
allocated_names = 10;
      printf("\nSTMT_EXEC;;22047\n");
tmp = xmalloc(sizeof(char const *) * (unsigned long)allocated_names);
      printf("\nSTMT_EXEC;;22048\n");
name_array = (char const **)tmp;
      printf("\nSTMT_EXEC;;22049\n");
names = 0;
    }
    printf("\nSTMT_EXEC;;22051\n");
printf("\nFUNC_RETURN;;\n");
return;

  }
printf("\nFUNC_RETURN;;\n");
}
void name_add(char const *name)
{
  printf("\nFUNC_CALL;name_add(const char *);\n");
printf("\nSTMT_EXEC;;22057\n");
void *tmp;
  printf("\nSTMT_EXEC;;22058\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;22061\n");
if (names == allocated_names)
    {
      {
        printf("\nSTMT_EXEC;;22064\n");
allocated_names *= 2;
        printf("\nSTMT_EXEC;;22065\n");
tmp = xrealloc((void *)name_array, sizeof(char const *) * (unsigned long)allocated_names);
        printf("\nSTMT_EXEC;;22066\n");
name_array = (char const **)tmp;
      }
    }
    printf("\nSTMT_EXEC;;22069\n");
tmp___0 = names;
    printf("\nSTMT_EXEC;;22070\n");
names++;
    printf("\nSTMT_EXEC;;22071\n");
*(name_array + tmp___0) = name;
    printf("\nSTMT_EXEC;;22072\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static FILE *name_file;








static char *name_buffer;
static size_t name_buffer_length;
__inline static int is_pattern(char const *string)
{
  printf("\nFUNC_CALL;is_pattern(const char *);\n");
printf("\nSTMT_EXEC;;22088\n");
char *tmp;
  printf("\nSTMT_EXEC;;22089\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;22090\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;22091\n");
int tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;22095\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp = strchr(string, '*');printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;22097\n");
if (tmp)
    {
      printf("\nSTMT_EXEC;;22099\n");
tmp___2 = 1;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;22104\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___0 = strchr(string, '[');printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;22106\n");
if (tmp___0)
      {
        printf("\nSTMT_EXEC;;22108\n");
tmp___2 = 1;
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;22113\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___1 = strchr(string, '?');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;22115\n");
if (tmp___1)
        {
          printf("\nSTMT_EXEC;;22117\n");
tmp___2 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;22121\n");
tmp___2 = 0;
        }
      }
    }
    printf("\nSTMT_EXEC;;22125\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___2);
  }
printf("\nFUNC_RETURN;;\n");
}
void name_init(void)
{
  printf("\nFUNC_CALL;name_init();\n");
printf("\nSTMT_EXEC;;22130\n");
void *tmp;
  printf("\nSTMT_EXEC;;22131\n");
int tmp___0;
  printf("\nSTMT_EXEC;;22132\n");
char *__cil_tmp3;

  {
    {


      printf("\nSTMT_EXEC;;22138\n");
tmp = xmalloc((size_t)102);
      printf("\nSTMT_EXEC;;22139\n");
name_buffer = (char *)tmp;
      printf("\nSTMT_EXEC;;22140\n");
name_buffer_length = (size_t)100;
    }
    printf("\nSTMT_EXEC;;22142\n");
if (files_from_option)
    {
      {
        printf("\nSTMT_EXEC;;22145\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(files_from_option, "-");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;22147\n");
if (tmp___0)
      {
        {
          printf("\nSTMT_EXEC;;22150\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
name_file = fopen((char const * /* __restrict  */)files_from_option, (char const * /* __restrict  */) "r");printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;22152\n");
if (!name_file)
        {
          {
            printf("\nSTMT_EXEC;;22155\n");
open_fatal(files_from_option);
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;22162\n");
request_stdin("-T");
          printf("\nSTMT_EXEC;;22163\n");
name_file = stdin;
        }
      }
    }
    printf("\nSTMT_EXEC;;22167\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void name_term(void)
{

  printf("\nFUNC_CALL;name_term();\n");
{
    {
      printf("\nSTMT_EXEC;;22175\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_buffer);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;22176\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_array);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;22178\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int read_name_from_file(void)
{
  printf("\nFUNC_CALL;read_name_from_file();\n");
printf("\nSTMT_EXEC;;22183\n");
int character;
  printf("\nSTMT_EXEC;;22184\n");
size_t counter;
  printf("\nSTMT_EXEC;;22185\n");
void *tmp;
  printf("\nSTMT_EXEC;;22186\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;22187\n");
void *tmp___1;

  {
    printf("\nSTMT_EXEC;;22190\n");
counter = (size_t)0;
    {
      printf("\nSTMT_EXEC;;22192\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;22196\n");
printf("\nFUNC_CALL;getc_unlocked(FILE *);\n");
character = getc_unlocked(name_file);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;22198\n");
if (character != -1)
        {
          printf("\nSTMT_EXEC;;22200\n");
if (!(character != (int)filename_terminator))
          {
            printf("\nSTMT_EXEC;;22202\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;22207\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;22209\n");
if (counter == name_buffer_length)
        {
          printf("\nSTMT_EXEC;;22211\n");
if (name_buffer_length * 2UL < name_buffer_length)
          {
            {
              printf("\nSTMT_EXEC;;22214\n");
xalloc_die();
            }
          }
          {
            printf("\nSTMT_EXEC;;22218\n");
name_buffer_length *= 2UL;
            printf("\nSTMT_EXEC;;22219\n");
tmp = xrealloc((void *)name_buffer, name_buffer_length + 2UL);
            printf("\nSTMT_EXEC;;22220\n");
name_buffer = (char *)tmp;
          }
        }
        printf("\nSTMT_EXEC;;22223\n");
tmp___0 = counter;
        printf("\nSTMT_EXEC;;22224\n");
counter++;
        printf("\nSTMT_EXEC;;22225\n");
*(name_buffer + tmp___0) = (char)character;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;22229\n");
if (counter == 0UL)
    {
      printf("\nSTMT_EXEC;;22231\n");
if (character == -1)
      {
        printf("\nSTMT_EXEC;;22233\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
    }
    printf("\nSTMT_EXEC;;22236\n");
if (counter == name_buffer_length)
    {
      printf("\nSTMT_EXEC;;22238\n");
if (name_buffer_length * 2UL < name_buffer_length)
      {
        {
          printf("\nSTMT_EXEC;;22241\n");
xalloc_die();
        }
      }
      {
        printf("\nSTMT_EXEC;;22245\n");
name_buffer_length *= 2UL;
        printf("\nSTMT_EXEC;;22246\n");
tmp___1 = xrealloc((void *)name_buffer, name_buffer_length + 2UL);
        printf("\nSTMT_EXEC;;22247\n");
name_buffer = (char *)tmp___1;
      }
    }
    printf("\nSTMT_EXEC;;22250\n");
*(name_buffer + counter) = (char)'\000';
    printf("\nSTMT_EXEC;;22251\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}


















char *name_next(int change_dirs)
{
  printf("\nFUNC_CALL;name_next(int);\n");
printf("\nSTMT_EXEC;;22274\n");
char const *source;
  printf("\nSTMT_EXEC;;22275\n");
char *cursor;
  printf("\nSTMT_EXEC;;22276\n");
int chdir_flag;
  printf("\nSTMT_EXEC;;22277\n");
int tmp;
  printf("\nSTMT_EXEC;;22278\n");
size_t source_len;
  printf("\nSTMT_EXEC;;22279\n");
int tmp___0;
  printf("\nSTMT_EXEC;;22280\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;22281\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;22282\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;22283\n");
int tmp___4;
  printf("\nSTMT_EXEC;;22284\n");
int tmp___5;
  printf("\nSTMT_EXEC;;22285\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;22286\n");
char *__cil_tmp14;

  {
    printf("\nSTMT_EXEC;;22289\n");
chdir_flag = 0;
    printf("\nSTMT_EXEC;;22290\n");
if ((int)filename_terminator == 0)
    {
      printf("\nSTMT_EXEC;;22292\n");
change_dirs = 0;
    }
    {
      printf("\nSTMT_EXEC;;22295\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;22298\n");
if (name_index == names)
        {
          printf("\nSTMT_EXEC;;22300\n");
if (!name_file)
          {
            printf("\nSTMT_EXEC;;22302\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;22305\n");
tmp = read_name_from_file();
          }
          printf("\nSTMT_EXEC;;22307\n");
if (!tmp)
          {
            printf("\nSTMT_EXEC;;22309\n");
goto while_break;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;22315\n");
tmp___0 = name_index;
            printf("\nSTMT_EXEC;;22316\n");
name_index++;
            printf("\nSTMT_EXEC;;22317\n");
source = *(name_array + tmp___0);
            printf("\nSTMT_EXEC;;22318\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
source_len = strlen(source);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;22320\n");
if (name_buffer_length < source_len)
          {
            {
              printf("\nSTMT_EXEC;;22323\n");
while (1)
              {
              while_continue___0: /* CIL Label */;
                printf("\nSTMT_EXEC;;22326\n");
name_buffer_length *= 2UL;
                printf("\nSTMT_EXEC;;22327\n");
if (!name_buffer_length)
                {
                  {
                    printf("\nSTMT_EXEC;;22330\n");
xalloc_die();
                  }
                }
                printf("\nSTMT_EXEC;;22333\n");
if (!(name_buffer_length < source_len))
                {
                  printf("\nSTMT_EXEC;;22335\n");
goto while_break___0;
                }
              }
            while_break___0: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;22341\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_buffer);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;22342\n");
tmp___1 = xmalloc(name_buffer_length + 2UL);
              printf("\nSTMT_EXEC;;22343\n");
name_buffer = (char *)tmp___1;
            }
          }

          {
            printf("\nSTMT_EXEC;;22348\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)name_buffer, (char const * /* __restrict  */)source);printf("\nFUNC_RETURN;;\n");

          }
        }
        {
          printf("\nSTMT_EXEC;;22352\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen((char const *)name_buffer);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;22353\n");
cursor = (name_buffer + tmp___2) - 1;
        }
        {
          printf("\nSTMT_EXEC;;22356\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;22359\n");
if ((unsigned long)cursor > (unsigned long)name_buffer)
            {
              printf("\nSTMT_EXEC;;22361\n");
if (!((int)*cursor == 47))
              {
                printf("\nSTMT_EXEC;;22363\n");
goto while_break___1;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;22368\n");
goto while_break___1;
            }
            printf("\nSTMT_EXEC;;22370\n");
tmp___3 = cursor;
            printf("\nSTMT_EXEC;;22371\n");
cursor--;
            printf("\nSTMT_EXEC;;22372\n");
*tmp___3 = (char)'\000';
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;22376\n");
if (chdir_flag)
        {
          {
            printf("\nSTMT_EXEC;;22379\n");
printf("\nFUNC_CALL;chdir(const char *);\n");
tmp___4 = chdir((char const *)name_buffer);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;22381\n");
if (tmp___4 < 0)
          {
            {
              printf("\nSTMT_EXEC;;22384\n");
chdir_fatal((char const *)name_buffer);
            }
          }
          printf("\nSTMT_EXEC;;22387\n");
chdir_flag = 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;22391\n");
if (change_dirs)
          {
            {
              printf("\nSTMT_EXEC;;22394\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___5 = strcmp((char const *)name_buffer, "-C");printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;22396\n");
if (tmp___5 == 0)
            {
              printf("\nSTMT_EXEC;;22398\n");
chdir_flag = 1;
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;22403\n");
unquote_string(name_buffer);
              }
              printf("\nSTMT_EXEC;;22405\n");
printf("\nFUNC_RETURN;;\n");
return (name_buffer);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;22411\n");
unquote_string(name_buffer);
            }
            printf("\nSTMT_EXEC;;22413\n");
printf("\nFUNC_RETURN;;\n");
return (name_buffer);
          }
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;22419\n");
if (name_file)
    {
      printf("\nSTMT_EXEC;;22421\n");
if (chdir_flag)
      {
        {
          printf("\nSTMT_EXEC;;22424\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("Missing file name after -C");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;22425\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___6);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;22426\n");
fatal_exit();
        }
      }
    }
    printf("\nSTMT_EXEC;;22430\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
void name_close(void)
{
  printf("\nFUNC_CALL;name_close();\n");
printf("\nSTMT_EXEC;;22435\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;22438\n");
if (name_file)
    {
      printf("\nSTMT_EXEC;;22440\n");
if ((unsigned long)name_file != (unsigned long)stdin)
      {
        {
          printf("\nSTMT_EXEC;;22443\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp = fclose(name_file);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;22445\n");
if (tmp != 0)
        {
          {
            printf("\nSTMT_EXEC;;22448\n");
close_error((char const *)name_buffer);
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;22453\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static struct name *buffer___0;
static size_t allocated_size;
static int change_dir;



































































































void name_gather(void)
{
  printf("\nFUNC_CALL;name_gather();\n");
printf("\nSTMT_EXEC;;22560\n");
char const *name;
  printf("\nSTMT_EXEC;;22561\n");
void *tmp;
  printf("\nSTMT_EXEC;;22562\n");
char const *dir;
  printf("\nSTMT_EXEC;;22563\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;22564\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;22565\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;22566\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;22567\n");
int tmp___4;
  printf("\nSTMT_EXEC;;22568\n");
size_t needed_size;
  printf("\nSTMT_EXEC;;22569\n");
void *tmp___5;
  printf("\nSTMT_EXEC;;22570\n");
int change_dir___0;
  printf("\nSTMT_EXEC;;22571\n");
int change_dir0;
  printf("\nSTMT_EXEC;;22572\n");
char const *dir___0;
  printf("\nSTMT_EXEC;;22573\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;22574\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;22575\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;22576\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;22577\n");
int tmp___10;
  printf("\nSTMT_EXEC;;22578\n");
char *__cil_tmp19;
  printf("\nSTMT_EXEC;;22579\n");
char *__cil_tmp20;

  {
    printf("\nSTMT_EXEC;;22582\n");
if (same_order_option)
    {
      printf("\nSTMT_EXEC;;22584\n");
if (allocated_size == 0UL)
      {
        {
          printf("\nSTMT_EXEC;;22587\n");
allocated_size = ((unsigned long)(&((struct name *)0)->name) + 100UL) + 1UL;
          printf("\nSTMT_EXEC;;22588\n");
tmp = xmalloc(allocated_size);
          printf("\nSTMT_EXEC;;22589\n");
buffer___0 = (struct name *)tmp;
          printf("\nSTMT_EXEC;;22590\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)buffer___0, 0, allocated_size);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;22594\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;22598\n");
tmp___3 = name_next(0);
            printf("\nSTMT_EXEC;;22599\n");
name = (char const *)tmp___3;
          }
          printf("\nSTMT_EXEC;;22601\n");
if (name)
          {
            {
              printf("\nSTMT_EXEC;;22604\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___4 = strcmp(name, "-C");printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;22606\n");
if (!(tmp___4 == 0))
            {
              printf("\nSTMT_EXEC;;22608\n");
goto while_break;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;22613\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;22616\n");
tmp___0 = name_next(0);
            printf("\nSTMT_EXEC;;22617\n");
dir = (char const *)tmp___0;
          }
          printf("\nSTMT_EXEC;;22619\n");
if (!dir)
          {
            {
              printf("\nSTMT_EXEC;;22622\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Missing file name after -C");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;22623\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;22624\n");
fatal_exit();
            }
          }
          {
            printf("\nSTMT_EXEC;;22628\n");
tmp___2 = xstrdup(dir);
            printf("\nSTMT_EXEC;;22629\n");
change_dir = chdir_arg((char const *)tmp___2);
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;22634\n");
if (name)
      {
        {
          printf("\nSTMT_EXEC;;22637\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
buffer___0->length = strlen(name);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;22638\n");
needed_size = ((unsigned long)(&((struct name *)0)->name) + buffer___0->length) + 1UL;
        }
        printf("\nSTMT_EXEC;;22640\n");
if (allocated_size < needed_size)
        {
          {
            printf("\nSTMT_EXEC;;22643\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;22646\n");
allocated_size *= 2UL;
              printf("\nSTMT_EXEC;;22647\n");
if (!allocated_size)
              {
                {
                  printf("\nSTMT_EXEC;;22650\n");
xalloc_die();
                }
              }
              printf("\nSTMT_EXEC;;22653\n");
if (!(allocated_size < needed_size))
              {
                printf("\nSTMT_EXEC;;22655\n");
goto while_break___0;
              }
            }
          while_break___0: /* CIL Label */;
          }
          {
            printf("\nSTMT_EXEC;;22661\n");
tmp___5 = xrealloc((void *)buffer___0, allocated_size);
            printf("\nSTMT_EXEC;;22662\n");
buffer___0 = (struct name *)tmp___5;
          }
        }
        {
          printf("\nSTMT_EXEC;;22666\n");
buffer___0->change_dir = change_dir;
          printf("\nSTMT_EXEC;;22667\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(buffer___0->name), (char const * /* __restrict  */)name);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;22668\n");
buffer___0->next = (struct name *)0;
          printf("\nSTMT_EXEC;;22669\n");
buffer___0->found_count = (uintmax_t)0;
          printf("\nSTMT_EXEC;;22670\n");
namelist = buffer___0;
          printf("\nSTMT_EXEC;;22671\n");
nametail = &namelist->next;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;22676\n");
if (change_dir)
        {
          {
            printf("\nSTMT_EXEC;;22679\n");
addname((char const *)0, change_dir);
          }
        }
      }
    }
    else
    {



      printf("\nSTMT_EXEC;;22689\n");
change_dir___0 = 0;
      {
        printf("\nSTMT_EXEC;;22691\n");
while (1)
        {
        while_continue___1: /* CIL Label */;
          printf("\nSTMT_EXEC;;22694\n");
change_dir0 = change_dir___0;
          {
            printf("\nSTMT_EXEC;;22696\n");
while (1)
            {
            while_continue___2: /* CIL Label */;

              {
                printf("\nSTMT_EXEC;;22701\n");
tmp___9 = name_next(0);
                printf("\nSTMT_EXEC;;22702\n");
name = (char const *)tmp___9;
              }


              printf("\nSTMT_EXEC;;22706\n");
if (name)
              {
                {
                  printf("\nSTMT_EXEC;;22709\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___10 = strcmp(name, "-C");printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;22711\n");
if (!(tmp___10 == 0))
                {
                  printf("\nSTMT_EXEC;;22713\n");
goto while_break___2;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;22718\n");
goto while_break___2;
              }
              {
                printf("\nSTMT_EXEC;;22721\n");
tmp___6 = name_next(0);
                printf("\nSTMT_EXEC;;22722\n");
dir___0 = (char const *)tmp___6;
              }
              printf("\nSTMT_EXEC;;22724\n");
if (!dir___0)
              {
                {
                  printf("\nSTMT_EXEC;;22727\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("Missing file name after -C");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;22728\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___7);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;22729\n");
fatal_exit();
                }
              }
              {
                printf("\nSTMT_EXEC;;22733\n");
tmp___8 = xstrdup(dir___0);
                printf("\nSTMT_EXEC;;22734\n");
change_dir___0 = chdir_arg((char const *)tmp___8);
              }
            }
          while_break___2: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;22739\n");
if (name)
          {
            {
              printf("\nSTMT_EXEC;;22742\n");
addname(name, change_dir___0);
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;22747\n");
if (change_dir___0 != change_dir0)
            {
              {
                printf("\nSTMT_EXEC;;22750\n");
addname((char const *)0, change_dir___0);
              }
            }
            printf("\nSTMT_EXEC;;22753\n");
goto while_break___1;
          }
        }
      while_break___1: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;22759\n");
printf("\nFUNC_RETURN;;\n");
return;




























































































































































  }
printf("\nFUNC_RETURN;;\n");
}
struct name *addname(char const *string, int change_dir___0)
{
  printf("\nFUNC_CALL;addname(const char *,int);\n");
printf("\nSTMT_EXEC;;22920\n");
size_t length;
  printf("\nSTMT_EXEC;;22921\n");
size_t tmp;
  printf("\nSTMT_EXEC;;22922\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;22923\n");
struct name *name;
  printf("\nSTMT_EXEC;;22924\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;22925\n");
int tmp___2;

  {
    printf("\nSTMT_EXEC;;22928\n");
if (string)
    {
      {



        printf("\nSTMT_EXEC;;22934\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(string);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;22935\n");
tmp___0 = tmp;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;22940\n");
tmp___0 = (size_t)0;
    }
    {
      printf("\nSTMT_EXEC;;22943\n");
length = tmp___0;
      printf("\nSTMT_EXEC;;22944\n");
tmp___1 = xmalloc(((unsigned long)(&((struct name *)0)->name) + length) + 1UL);
      printf("\nSTMT_EXEC;;22945\n");
name = (struct name *)tmp___1;
    }
    printf("\nSTMT_EXEC;;22947\n");
if (string)
    {
      {
        printf("\nSTMT_EXEC;;22950\n");
name->fake = (char)0;

        printf("\nSTMT_EXEC;;22952\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(name->name), (char const * /* __restrict  */)string);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      printf("\nSTMT_EXEC;;22957\n");
name->fake = (char)1;
      printf("\nSTMT_EXEC;;22958\n");
name->name[0] = (char)0;
    }
    printf("\nSTMT_EXEC;;22960\n");
name->next = (struct name *)0;
    printf("\nSTMT_EXEC;;22961\n");
name->length = length;
    printf("\nSTMT_EXEC;;22962\n");
name->found_count = (uintmax_t)0;
    printf("\nSTMT_EXEC;;22963\n");
name->regexp = (char)0;
    printf("\nSTMT_EXEC;;22964\n");
name->firstch = (char)1;
    printf("\nSTMT_EXEC;;22965\n");
name->change_dir = change_dir___0;
    printf("\nSTMT_EXEC;;22966\n");
name->dir_contents = (char const *)0;
    printf("\nSTMT_EXEC;;22967\n");
if (string)
    {
      {
        printf("\nSTMT_EXEC;;22970\n");
tmp___2 = is_pattern(string);
      }
      printf("\nSTMT_EXEC;;22972\n");
if (tmp___2)
      {
        printf("\nSTMT_EXEC;;22974\n");
name->regexp = (char)1;
        printf("\nSTMT_EXEC;;22975\n");
if ((int const) * (string + 0) == 42)
        {
          printf("\nSTMT_EXEC;;22977\n");
name->firstch = (char)0;
        }
        else
        {
          printf("\nSTMT_EXEC;;22981\n");
if ((int const) * (string + 0) == 91)
          {
            printf("\nSTMT_EXEC;;22983\n");
name->firstch = (char)0;
          }
          else
          {
            printf("\nSTMT_EXEC;;22987\n");
if ((int const) * (string + 0) == 63)
            {
              printf("\nSTMT_EXEC;;22989\n");
name->firstch = (char)0;
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;22995\n");
*nametail = name;
    printf("\nSTMT_EXEC;;22996\n");
nametail = &name->next;














































    printf("\nSTMT_EXEC;;23043\n");
printf("\nFUNC_RETURN;;\n");
return (name);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct name *namelist_match(char const *path, size_t length)
{
  printf("\nFUNC_CALL;namelist_match(const char *,size_t);\n");
printf("\nSTMT_EXEC;;23048\n");
struct name *p;
  printf("\nSTMT_EXEC;;23049\n");
int tmp;
  printf("\nSTMT_EXEC;;23050\n");
int tmp___0;
  printf("\nSTMT_EXEC;;23051\n");
int tmp___1;
  printf("\nSTMT_EXEC;;23052\n");
int tmp___2;

  {
    printf("\nSTMT_EXEC;;23055\n");
p = namelist;
    {
      printf("\nSTMT_EXEC;;23057\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;23060\n");
if (!p)
        {
          printf("\nSTMT_EXEC;;23062\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23064\n");
if (p->firstch)
        {
          printf("\nSTMT_EXEC;;23066\n");
if ((int)p->name[0] != (int)*(path + 0))
          {
            printf("\nSTMT_EXEC;;23068\n");
goto __Cont;
          }
        }
        printf("\nSTMT_EXEC;;23071\n");
if (p->regexp)
        {
          {

            printf("\nSTMT_EXEC;;23075\n");
printf("\nFUNC_CALL;fnmatch(const char *,const char *,int);\n");
tmp = fnmatch((char const *)(p->name), path, recursion_option);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;23076\n");
tmp___2 = tmp == 0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;23081\n");
if (p->length <= length)
          {
            printf("\nSTMT_EXEC;;23083\n");
if ((int const) * (path + p->length) == 0)
            {
              printf("\nSTMT_EXEC;;23085\n");
goto _L___3;
            }
            else
            {
              printf("\nSTMT_EXEC;;23089\n");
if ((int const) * (path + p->length) == 47)
              {
                printf("\nSTMT_EXEC;;23091\n");
if (recursion_option)
                {
                _L___3: /* CIL Label */
                {
                  printf("\nSTMT_EXEC;;23095\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___0 = memcmp((void const *)path, (void const *)(p->name), p->length);printf("\nFUNC_RETURN;;\n");

                }
                  printf("\nSTMT_EXEC;;23097\n");
if (tmp___0 == 0)
                  {
                    printf("\nSTMT_EXEC;;23099\n");
tmp___1 = 1;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;23103\n");
tmp___1 = 0;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;23108\n");
tmp___1 = 0;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;23113\n");
tmp___1 = 0;
              }
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;23119\n");
tmp___1 = 0;
          }
          printf("\nSTMT_EXEC;;23121\n");
tmp___2 = tmp___1;
        }
        printf("\nSTMT_EXEC;;23123\n");
if (tmp___2)
        {
          printf("\nSTMT_EXEC;;23125\n");
printf("\nFUNC_RETURN;;\n");
return (p);
        }
      __Cont:
        {
printf("\nSTMT_EXEC;;23128\n");
p = p->next;
}

      }
    while_break: /* CIL Label */;



























































    }
    printf("\nSTMT_EXEC;;23191\n");
printf("\nFUNC_RETURN;;\n");
return ((struct name *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
int name_match(char const *path)
{
  printf("\nFUNC_CALL;name_match(const char *);\n");
printf("\nSTMT_EXEC;;23196\n");
size_t length;
  printf("\nSTMT_EXEC;;23197\n");
size_t tmp;
  printf("\nSTMT_EXEC;;23198\n");
struct name *cursor;
  printf("\nSTMT_EXEC;;23199\n");
uintmax_t tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;23203\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(path);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;23204\n");
length = tmp;
    }
    {
      printf("\nSTMT_EXEC;;23207\n");
while (1)
      {
      while_continue: /* CIL Label */;

        printf("\nSTMT_EXEC;;23211\n");
cursor = namelist;
        printf("\nSTMT_EXEC;;23212\n");
if (!cursor)
        {
          printf("\nSTMT_EXEC;;23214\n");
printf("\nFUNC_RETURN;;\n");
return (!files_from_option);
        }
        printf("\nSTMT_EXEC;;23216\n");
if (cursor->fake)
        {
          {
            printf("\nSTMT_EXEC;;23219\n");
chdir_do(cursor->change_dir);
            printf("\nSTMT_EXEC;;23220\n");
namelist = (struct name *)0;
            printf("\nSTMT_EXEC;;23221\n");
nametail = &namelist;
          }
          printf("\nSTMT_EXEC;;23223\n");
printf("\nFUNC_RETURN;;\n");
return (!files_from_option);
        }
        {
          printf("\nSTMT_EXEC;;23226\n");
cursor = namelist_match(path, length);
        }
        printf("\nSTMT_EXEC;;23228\n");
if (cursor)
        {
          printf("\nSTMT_EXEC;;23230\n");
if ((int const) * (path + cursor->length) == 47)
          {
            printf("\nSTMT_EXEC;;23232\n");
if (recursion_option)
            {
              printf("\nSTMT_EXEC;;23234\n");
if (cursor->found_count == 0UL)
              {

                printf("\nSTMT_EXEC;;23237\n");
(cursor->found_count)++;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;23242\n");
(cursor->found_count)++;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;23247\n");
(cursor->found_count)++;
          }
          printf("\nSTMT_EXEC;;23249\n");
if (starting_file_option)
          {
            {
              printf("\nSTMT_EXEC;;23252\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)namelist);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;23253\n");
namelist = (struct name *)0;
              printf("\nSTMT_EXEC;;23254\n");
nametail = &namelist;
            }
          }
          {
            printf("\nSTMT_EXEC;;23258\n");
chdir_do(cursor->change_dir);
          }
          printf("\nSTMT_EXEC;;23260\n");
if (occurrence_option == 0UL)
          {
            printf("\nSTMT_EXEC;;23262\n");
tmp___0 = cursor->found_count;
          }
          else
          {
            printf("\nSTMT_EXEC;;23266\n");
tmp___0 = (uintmax_t)(cursor->found_count == occurrence_option);
          }
          printf("\nSTMT_EXEC;;23268\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp___0);
        }
        printf("\nSTMT_EXEC;;23270\n");
if (same_order_option)
        {
          printf("\nSTMT_EXEC;;23272\n");
if (namelist->found_count)
          {
            {
              printf("\nSTMT_EXEC;;23275\n");
name_gather();
            }
            printf("\nSTMT_EXEC;;23277\n");
if (namelist->found_count)
            {
              printf("\nSTMT_EXEC;;23279\n");
printf("\nFUNC_RETURN;;\n");
return (0);
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;23284\n");
printf("\nFUNC_RETURN;;\n");
return (0);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;23289\n");
printf("\nFUNC_RETURN;;\n");
return (0);
        }
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool all_names_found(struct tar_stat_info *p)
{
  printf("\nFUNC_CALL;all_names_found(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;23298\n");
struct name const *cursor;
  printf("\nSTMT_EXEC;;23299\n");
size_t len;
  printf("\nSTMT_EXEC;;23300\n");
uintmax_t tmp;

  {
    printf("\nSTMT_EXEC;;23303\n");
if (!p->file_name)
    {
      printf("\nSTMT_EXEC;;23305\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    else
    {
      printf("\nSTMT_EXEC;;23309\n");
if (occurrence_option == 0UL)
      {
        printf("\nSTMT_EXEC;;23311\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
      else
      {
        printf("\nSTMT_EXEC;;23315\n");
if (p->had_trailing_slash)
        {
          printf("\nSTMT_EXEC;;23317\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;23322\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
len = strlen((char const *)p->file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;23323\n");
cursor = (struct name const *)namelist;
    }
    {
      printf("\nSTMT_EXEC;;23326\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;23329\n");
if (!cursor)
        {
          printf("\nSTMT_EXEC;;23331\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23333\n");
if (cursor->regexp)
        {
          printf("\nSTMT_EXEC;;23335\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        else
        {
          printf("\nSTMT_EXEC;;23339\n");
if (occurrence_option == 0UL)
          {
            printf("\nSTMT_EXEC;;23341\n");
tmp = cursor->found_count;
          }
          else
          {
            printf("\nSTMT_EXEC;;23345\n");
tmp = (uintmax_t const)(cursor->found_count >= (uintmax_t const)occurrence_option);
          }
          printf("\nSTMT_EXEC;;23347\n");
if (tmp)
          {
          _L___3: /* CIL Label */
            {
printf("\nSTMT_EXEC;;23350\n");
if (len >= (size_t)cursor->length)
            {
              printf("\nSTMT_EXEC;;23352\n");
if ((int)*(p->file_name + cursor->length) == 47)
              {
                printf("\nSTMT_EXEC;;23354\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
              }
            }
}

          }
          else
          {
            printf("\nSTMT_EXEC;;23360\n");
if (!cursor->fake)
            {
              printf("\nSTMT_EXEC;;23362\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
            }
            else
            {
              printf("\nSTMT_EXEC;;23366\n");
goto _L___3;
            }
          }
        }
        printf("\nSTMT_EXEC;;23370\n");
cursor = (struct name const *)cursor->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23374\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
























































void names_notfound(void)
{
  printf("\nFUNC_CALL;names_notfound();\n");
printf("\nSTMT_EXEC;;23435\n");
struct name const *cursor;
  printf("\nSTMT_EXEC;;23436\n");
char *tmp;
  printf("\nSTMT_EXEC;;23437\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;23438\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;23439\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;23440\n");
char *name;
  printf("\nSTMT_EXEC;;23441\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;23442\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;23443\n");
uintmax_t tmp___5;
  printf("\nSTMT_EXEC;;23444\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;23445\n");
char *__cil_tmp11;
  printf("\nSTMT_EXEC;;23446\n");
char *__cil_tmp12;

  {
    printf("\nSTMT_EXEC;;23449\n");
cursor = (struct name const *)namelist;
    {
      printf("\nSTMT_EXEC;;23451\n");
while (1)
      {
      while_continue: /* CIL Label */;

        printf("\nSTMT_EXEC;;23455\n");
if (!cursor)
        {
          printf("\nSTMT_EXEC;;23457\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23459\n");
if (occurrence_option == 0UL)
        {
          printf("\nSTMT_EXEC;;23461\n");
tmp___5 = cursor->found_count;
        }
        else
        {
          printf("\nSTMT_EXEC;;23465\n");
tmp___5 = (uintmax_t const)(cursor->found_count >= (uintmax_t const)occurrence_option);
        }
        printf("\nSTMT_EXEC;;23467\n");
if (!tmp___5)
        {
          printf("\nSTMT_EXEC;;23469\n");
if (!cursor->fake)
          {
            printf("\nSTMT_EXEC;;23471\n");
if (cursor->found_count == 0UL)
            {
              {
                printf("\nSTMT_EXEC;;23474\n");
tmp = quotearg_colon((char const *)(cursor->name));
                printf("\nSTMT_EXEC;;23475\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: Not found in archive");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;23476\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;23477\n");
exit_status = 2;
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;23483\n");
tmp___1 = quotearg_colon((char const *)(cursor->name));
                printf("\nSTMT_EXEC;;23484\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("%s: Required occurrence not found in archive");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;23485\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, tmp___1);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;23486\n");
exit_status = 2;
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;23491\n");
cursor = (struct name const *)cursor->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23495\n");
namelist = (struct name *)0;
    printf("\nSTMT_EXEC;;23496\n");
nametail = &namelist;
    printf("\nSTMT_EXEC;;23497\n");
if (same_order_option)
    {
      {
        printf("\nSTMT_EXEC;;23500\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;23504\n");
name = name_next(1);
          }
          printf("\nSTMT_EXEC;;23506\n");
if (!((unsigned long)name != (unsigned long)((void *)0)))
          {
            printf("\nSTMT_EXEC;;23508\n");
goto while_break___0;
          }
          {
            printf("\nSTMT_EXEC;;23511\n");
tmp___3 = quotearg_colon((char const *)name);
            printf("\nSTMT_EXEC;;23512\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("%s: Not found in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;23513\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4, tmp___3);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;23514\n");
exit_status = 2;
          }
        }
      while_break___0: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;23520\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static struct name *merge_sort(struct name *list, int length, int (*compare)(struct name const *, struct name const *))
{
  printf("\nFUNC_CALL;merge_sort(struct name *,int,int (*)(const struct name *, const struct name *));\n");
printf("\nSTMT_EXEC;;23525\n");
struct name *first_list;
  printf("\nSTMT_EXEC;;23526\n");
struct name *second_list;
  printf("\nSTMT_EXEC;;23527\n");
int first_length;
  printf("\nSTMT_EXEC;;23528\n");
int second_length;
  printf("\nSTMT_EXEC;;23529\n");
struct name *result;
  printf("\nSTMT_EXEC;;23530\n");
struct name **merge_point;
  printf("\nSTMT_EXEC;;23531\n");
struct name *cursor;
  printf("\nSTMT_EXEC;;23532\n");
int counter;
  printf("\nSTMT_EXEC;;23533\n");
int tmp;
  printf("\nSTMT_EXEC;;23534\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;23537\n");
if (length == 1)
    {
      printf("\nSTMT_EXEC;;23539\n");
printf("\nFUNC_RETURN;;\n");
return (list);
    }
    printf("\nSTMT_EXEC;;23541\n");
if (length == 2)
    {
      {
        printf("\nSTMT_EXEC;;23544\n");
tmp = (*compare)((struct name const *)list, (struct name const *)list->next);
      }
      printf("\nSTMT_EXEC;;23546\n");
if (tmp > 0)
      {
        printf("\nSTMT_EXEC;;23548\n");
result = list->next;
        printf("\nSTMT_EXEC;;23549\n");
result->next = list;
        printf("\nSTMT_EXEC;;23550\n");
list->next = (struct name *)0;
        printf("\nSTMT_EXEC;;23551\n");
printf("\nFUNC_RETURN;;\n");
return (result);
      }
      printf("\nSTMT_EXEC;;23553\n");
printf("\nFUNC_RETURN;;\n");
return (list);
    }
    printf("\nSTMT_EXEC;;23555\n");
first_list = list;
    printf("\nSTMT_EXEC;;23556\n");
first_length = (length + 1) / 2;
    printf("\nSTMT_EXEC;;23557\n");
second_length = length / 2;
    printf("\nSTMT_EXEC;;23558\n");
cursor = list;
    printf("\nSTMT_EXEC;;23559\n");
counter = first_length - 1;
    {
      printf("\nSTMT_EXEC;;23561\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;23564\n");
if (!counter)
        {
          printf("\nSTMT_EXEC;;23566\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23568\n");
goto __Cont;
      __Cont:
        {
printf("\nSTMT_EXEC;;23570\n");
cursor = cursor->next;
}

        printf("\nSTMT_EXEC;;23571\n");
counter--;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;23576\n");
second_list = cursor->next;
      printf("\nSTMT_EXEC;;23577\n");
cursor->next = (struct name *)0;
      printf("\nSTMT_EXEC;;23578\n");
first_list = merge_sort(first_list, first_length, compare);
      printf("\nSTMT_EXEC;;23579\n");
second_list = merge_sort(second_list, second_length, compare);
      printf("\nSTMT_EXEC;;23580\n");
merge_point = &result;
    }
    {
      printf("\nSTMT_EXEC;;23583\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;23586\n");
if (first_list)
        {
          printf("\nSTMT_EXEC;;23588\n");
if (!second_list)
          {
            printf("\nSTMT_EXEC;;23590\n");
goto while_break___0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;23595\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;23598\n");
tmp___0 = (*compare)((struct name const *)first_list, (struct name const *)second_list);
        }
        printf("\nSTMT_EXEC;;23600\n");
if (tmp___0 < 0)
        {
          printf("\nSTMT_EXEC;;23602\n");
cursor = first_list->next;
          printf("\nSTMT_EXEC;;23603\n");
*merge_point = first_list;
          printf("\nSTMT_EXEC;;23604\n");
merge_point = &first_list->next;
          printf("\nSTMT_EXEC;;23605\n");
first_list = cursor;
        }
        else
        {
          printf("\nSTMT_EXEC;;23609\n");
cursor = second_list->next;
          printf("\nSTMT_EXEC;;23610\n");
*merge_point = second_list;
          printf("\nSTMT_EXEC;;23611\n");
merge_point = &second_list->next;
          printf("\nSTMT_EXEC;;23612\n");
second_list = cursor;
        }
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23617\n");
if (first_list)
    {
      printf("\nSTMT_EXEC;;23619\n");
*merge_point = first_list;
    }
    else
    {
      printf("\nSTMT_EXEC;;23623\n");
*merge_point = second_list;
    }
    printf("\nSTMT_EXEC;;23625\n");
printf("\nFUNC_RETURN;;\n");
return (result);
  }
printf("\nFUNC_RETURN;;\n");
}
static int compare_names(struct name const *n1, struct name const *n2)
{
  printf("\nFUNC_CALL;compare_names(const struct name *,const struct name *);\n");
printf("\nSTMT_EXEC;;23630\n");
int found_diff;
  printf("\nSTMT_EXEC;;23631\n");
int tmp;
  printf("\nSTMT_EXEC;;23632\n");
int tmp___0;
  printf("\nSTMT_EXEC;;23633\n");
uintmax_t tmp___1;
  printf("\nSTMT_EXEC;;23634\n");
uintmax_t tmp___2;

  {
    printf("\nSTMT_EXEC;;23637\n");
if (occurrence_option == 0UL)
    {
      printf("\nSTMT_EXEC;;23639\n");
tmp___1 = n2->found_count;
    }
    else
    {
      printf("\nSTMT_EXEC;;23643\n");
tmp___1 = (uintmax_t const)(n2->found_count >= (uintmax_t const)occurrence_option);
    }
    printf("\nSTMT_EXEC;;23645\n");
if (occurrence_option == 0UL)
    {
      printf("\nSTMT_EXEC;;23647\n");
tmp___2 = n1->found_count;
    }
    else
    {
      printf("\nSTMT_EXEC;;23651\n");
tmp___2 = (uintmax_t const)(n1->found_count >= (uintmax_t const)occurrence_option);
    }
    printf("\nSTMT_EXEC;;23653\n");
found_diff = (int)(tmp___1 - tmp___2);
    printf("\nSTMT_EXEC;;23654\n");
if (found_diff)
    {
      printf("\nSTMT_EXEC;;23656\n");
tmp___0 = found_diff;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;23661\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)(n1->name), (char const *)(n2->name));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;23662\n");
tmp___0 = tmp;
      }
    }
    printf("\nSTMT_EXEC;;23665\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
static void add_hierarchy_to_namelist(struct name *name, dev_t device)
{
  printf("\nFUNC_CALL;add_hierarchy_to_namelist(struct name *,dev_t);\n");
printf("\nSTMT_EXEC;;23670\n");
char *path;
  printf("\nSTMT_EXEC;;23671\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;23672\n");
char *tmp;
  printf("\nSTMT_EXEC;;23673\n");
size_t name_length;
  printf("\nSTMT_EXEC;;23674\n");
size_t allocated_length;
  printf("\nSTMT_EXEC;;23675\n");
char *namebuf;
  printf("\nSTMT_EXEC;;23676\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;23677\n");
char *string;
  printf("\nSTMT_EXEC;;23678\n");
size_t string_length;
  printf("\nSTMT_EXEC;;23679\n");
int change_dir___0;
  printf("\nSTMT_EXEC;;23680\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;23681\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;23682\n");
struct name *tmp___3;
  printf("\nSTMT_EXEC;;23683\n");
char *__cil_tmp16;

  {
    {
      printf("\nSTMT_EXEC;;23687\n");
path = name->name;
      printf("\nSTMT_EXEC;;23688\n");
tmp = get_directory_contents(path, device);
      printf("\nSTMT_EXEC;;23689\n");
buffer___2 = tmp;
    }
    printf("\nSTMT_EXEC;;23691\n");
if (!buffer___2)
    {
      printf("\nSTMT_EXEC;;23693\n");
name->dir_contents = "\000\000\000\000";
    }
    else
    {
      printf("\nSTMT_EXEC;;23697\n");
name_length = name->length;
      printf("\nSTMT_EXEC;;23698\n");
if (name_length >= 100UL)
      {
        printf("\nSTMT_EXEC;;23700\n");
allocated_length = name_length + 100UL;
      }
      else
      {
        printf("\nSTMT_EXEC;;23704\n");
allocated_length = (size_t)100;
      }
      {
        printf("\nSTMT_EXEC;;23707\n");
tmp___0 = xmalloc(allocated_length + 1UL);
        printf("\nSTMT_EXEC;;23708\n");
namebuf = (char *)tmp___0;
        printf("\nSTMT_EXEC;;23709\n");
change_dir___0 = name->change_dir;
        printf("\nSTMT_EXEC;;23710\n");
name->dir_contents = (char const *)buffer___2;
        printf("\nSTMT_EXEC;;23711\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)namebuf, (char const * /* __restrict  */)path);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;23713\n");
if (!((int)*(namebuf + (name_length - 1UL)) == 47))
      {
        printf("\nSTMT_EXEC;;23715\n");
tmp___1 = name_length;
        printf("\nSTMT_EXEC;;23716\n");
name_length++;
        printf("\nSTMT_EXEC;;23717\n");
*(namebuf + tmp___1) = (char)'/';
        printf("\nSTMT_EXEC;;23718\n");
*(namebuf + name_length) = (char)'\000';
      }
      printf("\nSTMT_EXEC;;23720\n");
string = buffer___2;
      {
        printf("\nSTMT_EXEC;;23722\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;23725\n");
if (!*string)
          {
            printf("\nSTMT_EXEC;;23727\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;23730\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
string_length = strlen((char const *)string);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;23732\n");
if ((int)*string == 68)
          {
            printf("\nSTMT_EXEC;;23734\n");
if (allocated_length <= name_length + string_length)
            {
              {
                printf("\nSTMT_EXEC;;23737\n");
while (1)
                {
                while_continue___0: /* CIL Label */;
                  printf("\nSTMT_EXEC;;23740\n");
allocated_length *= 2UL;
                  printf("\nSTMT_EXEC;;23741\n");
if (!allocated_length)
                  {
                    {
                      printf("\nSTMT_EXEC;;23744\n");
xalloc_die();
                    }
                  }
                  printf("\nSTMT_EXEC;;23747\n");
if (!(allocated_length <= name_length + string_length))
                  {
                    printf("\nSTMT_EXEC;;23749\n");
goto while_break___0;
                  }
                }
              while_break___0: /* CIL Label */;
              }
              {
                printf("\nSTMT_EXEC;;23755\n");
tmp___2 = xrealloc((void *)namebuf, allocated_length + 1UL);
                printf("\nSTMT_EXEC;;23756\n");
namebuf = (char *)tmp___2;
              }
            }
            {
              printf("\nSTMT_EXEC;;23760\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(namebuf + name_length), (char const * /* __restrict  */)(string + 1));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;23761\n");
tmp___3 = addname((char const *)namebuf, change_dir___0);
              printf("\nSTMT_EXEC;;23762\n");
add_hierarchy_to_namelist(tmp___3, device);
            }
          }
          printf("\nSTMT_EXEC;;23765\n");
string += string_length + 1UL;
        }
      while_break: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;23770\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)namebuf);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;23773\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void collect_and_sort_names(void)
{
  printf("\nFUNC_CALL;collect_and_sort_names();\n");
printf("\nSTMT_EXEC;;23778\n");
struct name *name;
  printf("\nSTMT_EXEC;;23779\n");
struct name *next_name;
  printf("\nSTMT_EXEC;;23780\n");
int num_names;
  printf("\nSTMT_EXEC;;23781\n");
struct stat statbuf;
  printf("\nSTMT_EXEC;;23782\n");
int tmp;
  printf("\nSTMT_EXEC;;23783\n");
void *__cil_tmp6;
  printf("\nSTMT_EXEC;;23784\n");
char *__cil_tmp7;

  {
    {
      printf("\nSTMT_EXEC;;23788\n");
name_gather();
    }
    printf("\nSTMT_EXEC;;23790\n");
if (listed_incremental_option)
    {
      {
        printf("\nSTMT_EXEC;;23793\n");
read_directory_file();
      }
    }
    printf("\nSTMT_EXEC;;23796\n");
if (!namelist)
    {
      {
        printf("\nSTMT_EXEC;;23799\n");
addname(".", 0);
      }
    }
    printf("\nSTMT_EXEC;;23802\n");
name = namelist;
    {
      printf("\nSTMT_EXEC;;23804\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;23807\n");
if (!name)
        {
          printf("\nSTMT_EXEC;;23809\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23811\n");
next_name = name->next;
        printf("\nSTMT_EXEC;;23812\n");
if (name->found_count)
        {
          printf("\nSTMT_EXEC;;23814\n");
goto __Cont;
        }
        else
        {
          printf("\nSTMT_EXEC;;23818\n");
if (name->dir_contents)
          {
            printf("\nSTMT_EXEC;;23820\n");
goto __Cont;
          }
        }
        printf("\nSTMT_EXEC;;23823\n");
if (name->regexp)
        {
          printf("\nSTMT_EXEC;;23825\n");
goto __Cont;
        }
        {
          printf("\nSTMT_EXEC;;23828\n");
chdir_do(name->change_dir);
        }
        printf("\nSTMT_EXEC;;23830\n");
if (name->fake)
        {
          printf("\nSTMT_EXEC;;23832\n");
goto __Cont;
        }
        {
          printf("\nSTMT_EXEC;;23835\n");
tmp = deref_stat(dereference_option, (char const *)(name->name), &statbuf);
        }
        printf("\nSTMT_EXEC;;23837\n");
if (tmp != 0)
        {
          {
            printf("\nSTMT_EXEC;;23840\n");
stat_diag((char const *)(name->name));
          }
          printf("\nSTMT_EXEC;;23842\n");
goto __Cont;
        }
        printf("\nSTMT_EXEC;;23844\n");
if ((statbuf.st_mode & 61440U) == 16384U)
        {
          {
            printf("\nSTMT_EXEC;;23847\n");
(name->found_count)++;
            printf("\nSTMT_EXEC;;23848\n");
add_hierarchy_to_namelist(name, statbuf.st_dev);
          }
        }
      __Cont:
        {
printf("\nSTMT_EXEC;;23852\n");
name = next_name;
}

      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23856\n");
num_names = 0;
    printf("\nSTMT_EXEC;;23857\n");
name = namelist;
    {
      printf("\nSTMT_EXEC;;23859\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;23862\n");
if (!name)
        {
          printf("\nSTMT_EXEC;;23864\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;23866\n");
num_names++;
        printf("\nSTMT_EXEC;;23867\n");
name = name->next;
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;23872\n");
namelist = merge_sort(namelist, num_names, &compare_names);
      printf("\nSTMT_EXEC;;23873\n");
name = namelist;
    }
    {
      printf("\nSTMT_EXEC;;23876\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        printf("\nSTMT_EXEC;;23879\n");
if (!name)
        {
          printf("\nSTMT_EXEC;;23881\n");
goto while_break___1;
        }
        printf("\nSTMT_EXEC;;23883\n");
name->found_count = (uintmax_t)0;
        printf("\nSTMT_EXEC;;23884\n");
name = name->next;
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23888\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
struct name *name_scan(char const *path)
{
  printf("\nFUNC_CALL;name_scan(const char *);\n");
printf("\nSTMT_EXEC;;23893\n");
size_t length;
  printf("\nSTMT_EXEC;;23894\n");
size_t tmp;
  printf("\nSTMT_EXEC;;23895\n");
struct name *cursor;
  printf("\nSTMT_EXEC;;23896\n");
struct name *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;23900\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(path);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;23901\n");
length = tmp;
    }
    {
      printf("\nSTMT_EXEC;;23904\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;23908\n");
tmp___0 = namelist_match(path, length);
          printf("\nSTMT_EXEC;;23909\n");
cursor = tmp___0;
        }
        printf("\nSTMT_EXEC;;23911\n");
if (cursor)
        {
          printf("\nSTMT_EXEC;;23913\n");
printf("\nFUNC_RETURN;;\n");
return (cursor);
        }
        printf("\nSTMT_EXEC;;23915\n");
if (same_order_option)
        {
          printf("\nSTMT_EXEC;;23917\n");
if (namelist)
          {
            printf("\nSTMT_EXEC;;23919\n");
if (namelist->found_count)
            {
              {
                printf("\nSTMT_EXEC;;23922\n");
name_gather();
              }
              printf("\nSTMT_EXEC;;23924\n");
if (namelist->found_count)
              {
                printf("\nSTMT_EXEC;;23926\n");
printf("\nFUNC_RETURN;;\n");
return ((struct name *)0);
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;23931\n");
printf("\nFUNC_RETURN;;\n");
return ((struct name *)0);
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;23936\n");
printf("\nFUNC_RETURN;;\n");
return ((struct name *)0);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;23941\n");
printf("\nFUNC_RETURN;;\n");
return ((struct name *)0);
        }
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
char *name_from_list(void)
{

  printf("\nFUNC_CALL;name_from_list();\n");
{
    printf("\nSTMT_EXEC;;23952\n");
if (!gnu_list_name)
    {
      printf("\nSTMT_EXEC;;23954\n");
gnu_list_name = namelist;
    }
    {
      printf("\nSTMT_EXEC;;23957\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;23960\n");
if (gnu_list_name)
        {
          printf("\nSTMT_EXEC;;23962\n");
if (!gnu_list_name->found_count)
          {
            printf("\nSTMT_EXEC;;23964\n");
if (!gnu_list_name->fake)
            {
              printf("\nSTMT_EXEC;;23966\n");
goto while_break;
            }
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;23972\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;23974\n");
gnu_list_name = gnu_list_name->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;23978\n");
if (gnu_list_name)
    {
      {
        printf("\nSTMT_EXEC;;23981\n");
(gnu_list_name->found_count)++;
        printf("\nSTMT_EXEC;;23982\n");
chdir_do(gnu_list_name->change_dir);
      }
      printf("\nSTMT_EXEC;;23984\n");
printf("\nFUNC_RETURN;;\n");
return (gnu_list_name->name);
    }
    printf("\nSTMT_EXEC;;23986\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
void blank_name_list(void)
{
  printf("\nFUNC_CALL;blank_name_list();\n");
printf("\nSTMT_EXEC;;23991\n");
struct name *name;

  {
    printf("\nSTMT_EXEC;;23994\n");
gnu_list_name = (struct name *)0;
    printf("\nSTMT_EXEC;;23995\n");
name = namelist;
    {
      printf("\nSTMT_EXEC;;23997\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;24000\n");
if (!name)
        {
          printf("\nSTMT_EXEC;;24002\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;24004\n");
name->found_count = (uintmax_t)0;
        printf("\nSTMT_EXEC;;24005\n");
name = name->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;24009\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
char *new_name(char const *path, char const *name)
{
  printf("\nFUNC_CALL;new_name(const char *,const char *);\n");
printf("\nSTMT_EXEC;;24014\n");
size_t pathlen;
  printf("\nSTMT_EXEC;;24015\n");
size_t tmp;
  printf("\nSTMT_EXEC;;24016\n");
size_t namesize;
  printf("\nSTMT_EXEC;;24017\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;24018\n");
int slash;
  printf("\nSTMT_EXEC;;24019\n");
char *buffer___2;
  printf("\nSTMT_EXEC;;24020\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;24021\n");
int tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;24025\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(path);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24026\n");
pathlen = tmp;
      printf("\nSTMT_EXEC;;24027\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24028\n");
namesize = tmp___0 + 1UL;
    }
    printf("\nSTMT_EXEC;;24030\n");
if (pathlen)
    {
      printf("\nSTMT_EXEC;;24032\n");
if (!((int const) * (path + (pathlen - 1UL)) == 47))
      {
        printf("\nSTMT_EXEC;;24034\n");
tmp___2 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;24038\n");
tmp___2 = 0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;24043\n");
tmp___2 = 0;
    }
    {
      printf("\nSTMT_EXEC;;24046\n");
slash = tmp___2;
      printf("\nSTMT_EXEC;;24047\n");
tmp___1 = xmalloc((pathlen + (size_t)slash) + namesize);
      printf("\nSTMT_EXEC;;24048\n");
buffer___2 = (char *)tmp___1;
      printf("\nSTMT_EXEC;;24049\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)buffer___2, (void const * /* __restrict  */)path, pathlen);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24050\n");
*(buffer___2 + pathlen) = (char)'/';
      printf("\nSTMT_EXEC;;24051\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)((buffer___2 + pathlen) + slash), (void const * /* __restrict  */)name, namesize);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;24053\n");
printf("\nFUNC_RETURN;;\n");
return (buffer___2);
  }
printf("\nFUNC_RETURN;;\n");
}






















































_Bool excluded_name(char const *name)
{
  printf("\nFUNC_CALL;excluded_name(const char *);\n");
printf("\nSTMT_EXEC;;24112\n");
_Bool tmp;

  {
    {
      printf("\nSTMT_EXEC;;24116\n");
tmp = excluded_filename((struct exclude const *)excluded, name + 0);
    }
    printf("\nSTMT_EXEC;;24118\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static unsigned int hash_string_hasher(void const *name, unsigned int n_buckets)
{
  printf("\nFUNC_CALL;hash_string_hasher(const void *,unsigned int);\n");
printf("\nSTMT_EXEC;;24123\n");
size_t tmp;

  {
    {
      printf("\nSTMT_EXEC;;24127\n");
tmp = hash_string((char const *)name, (size_t)n_buckets);
    }
    printf("\nSTMT_EXEC;;24129\n");
printf("\nFUNC_RETURN;;\n");
return ((unsigned int)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool hash_string_compare(void const *name1, void const *name2)
{
  printf("\nFUNC_CALL;hash_string_compare(const void *,const void *);\n");
printf("\nSTMT_EXEC;;24134\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;24138\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp((char const *)name1, (char const *)name2);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;24140\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(tmp == 0));
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool hash_string_insert(Hash_table **table___0, char const *string)
{
  printf("\nFUNC_CALL;hash_string_insert(Hash_table **,const char *);\n");
printf("\nSTMT_EXEC;;24145\n");
Hash_table *t;
  printf("\nSTMT_EXEC;;24146\n");
char *s;
  printf("\nSTMT_EXEC;;24147\n");
char *tmp;
  printf("\nSTMT_EXEC;;24148\n");
char *e;
  printf("\nSTMT_EXEC;;24149\n");
Hash_table *tmp___0;
  printf("\nSTMT_EXEC;;24150\n");
void *tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;24154\n");
t = *table___0;
      printf("\nSTMT_EXEC;;24155\n");
tmp = xstrdup(string);
      printf("\nSTMT_EXEC;;24156\n");
s = tmp;
    }
    printf("\nSTMT_EXEC;;24158\n");
if (t)
    {
      printf("\nSTMT_EXEC;;24160\n");
goto _L;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;24165\n");
t = hash_initialize((size_t)0, (Hash_tuning const *)0, (size_t(*)(void const *, size_t))(&hash_string_hasher), &hash_string_compare, (void (*)(void *))0);
        printf("\nSTMT_EXEC;;24166\n");
tmp___0 = t;
        printf("\nSTMT_EXEC;;24167\n");
*table___0 = tmp___0;
      }
      printf("\nSTMT_EXEC;;24169\n");
if (tmp___0)
      {
      _L:
      {
        printf("\nSTMT_EXEC;;24173\n");
tmp___1 = hash_insert(t, (void const *)s);
        printf("\nSTMT_EXEC;;24174\n");
e = (char *)tmp___1;
      }
        printf("\nSTMT_EXEC;;24176\n");
if (!e)
        {
          {
            printf("\nSTMT_EXEC;;24179\n");
xalloc_die();
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;24186\n");
xalloc_die();
        }
      }
    }
    printf("\nSTMT_EXEC;;24190\n");
if ((unsigned long)e == (unsigned long)s)
    {
      printf("\nSTMT_EXEC;;24192\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;24197\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)s);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;24199\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool hash_string_lookup(Hash_table const *table___0, char const *string)
{
  printf("\nFUNC_CALL;hash_string_lookup(const Hash_table *,const char *);\n");
printf("\nSTMT_EXEC;;24205\n");
void *tmp;
  printf("\nSTMT_EXEC;;24206\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;24209\n");
if (table___0)
    {
      {
        printf("\nSTMT_EXEC;;24212\n");
tmp = hash_lookup(table___0, (void const *)string);
      }
      printf("\nSTMT_EXEC;;24214\n");
if (tmp)
      {
        printf("\nSTMT_EXEC;;24216\n");
tmp___0 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;24220\n");
tmp___0 = 0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;24225\n");
tmp___0 = 0;
    }
    printf("\nSTMT_EXEC;;24227\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
static Hash_table *avoided_name_table;
void add_avoided_name(char const *name)
{

  printf("\nFUNC_CALL;add_avoided_name(const char *);\n");
{
    {
      printf("\nSTMT_EXEC;;24236\n");
hash_string_insert(&avoided_name_table, name);
    }
    printf("\nSTMT_EXEC;;24238\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool is_avoided_name(char const *name)
{
  printf("\nFUNC_CALL;is_avoided_name(const char *);\n");
printf("\nSTMT_EXEC;;24243\n");
_Bool tmp;

  {
    {
      printf("\nSTMT_EXEC;;24247\n");
tmp = hash_string_lookup((Hash_table const *)avoided_name_table, name);
    }
    printf("\nSTMT_EXEC;;24249\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static Hash_table *prefix_table[2];
static char const *const diagnostic[2] = {(char const * /* const  */) "Removing leading `%s\' from member names", (char const * /* const  */) "Removing leading `%s\' from hard link targets"};
static char const *const diagnostic___0[2] = {(char const * /* const  */) "Substituting `.\' for empty member name", (char const * /* const  */) "Substituting `.\' for empty hard link target"};
char *safer_name_suffix(char const *file_name, _Bool link_target)
{
  printf("\nFUNC_CALL;safer_name_suffix(const char *,_Bool);\n");
printf("\nSTMT_EXEC;;24257\n");
char const *p;
  printf("\nSTMT_EXEC;;24258\n");
size_t prefix_len;
  printf("\nSTMT_EXEC;;24259\n");
char c;
  printf("\nSTMT_EXEC;;24260\n");
char const *tmp;
  printf("\nSTMT_EXEC;;24261\n");
char *prefix;
  printf("\nSTMT_EXEC;;24262\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;24263\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;24264\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;24265\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;24266\n");
char *__cil_tmp12;

  {
    printf("\nSTMT_EXEC;;24269\n");
if (absolute_names_option)









    {
      printf("\nSTMT_EXEC;;24280\n");
p = file_name;
    }
    else
    {
      printf("\nSTMT_EXEC;;24284\n");
prefix_len = (size_t)0;
      printf("\nSTMT_EXEC;;24285\n");
p = file_name + prefix_len;
      {
        printf("\nSTMT_EXEC;;24287\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;24290\n");
if (!*p)
          {
            printf("\nSTMT_EXEC;;24292\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;24294\n");
if ((int const) * (p + 0) == 46)
          {
            printf("\nSTMT_EXEC;;24296\n");
if ((int const) * (p + 1) == 46)
            {
              printf("\nSTMT_EXEC;;24298\n");
if ((int const) * (p + 2) == 47)
              {
                printf("\nSTMT_EXEC;;24300\n");
prefix_len = (size_t)((p + 2) - file_name);
              }
              else
              {
                printf("\nSTMT_EXEC;;24304\n");
if (!*(p + 2))
                {
                  printf("\nSTMT_EXEC;;24306\n");
prefix_len = (size_t)((p + 2) - file_name);
                }
              }
            }
          }
          {
            printf("\nSTMT_EXEC;;24312\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;24315\n");
tmp = p;
              printf("\nSTMT_EXEC;;24316\n");
p++;
              printf("\nSTMT_EXEC;;24317\n");
c = (char)*tmp;
              printf("\nSTMT_EXEC;;24318\n");
if ((int)c == 47)
              {
                printf("\nSTMT_EXEC;;24320\n");
goto while_break___0;
              }
              printf("\nSTMT_EXEC;;24322\n");
if (!*p)
              {
                printf("\nSTMT_EXEC;;24324\n");
goto while_break___0;
              }
            }
          while_break___0: /* CIL Label */;
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;24332\n");
p = file_name + prefix_len;
      {
        printf("\nSTMT_EXEC;;24334\n");
while (1)
        {
        while_continue___1: /* CIL Label */;
          printf("\nSTMT_EXEC;;24337\n");
if (!((int const) * p == 47))
          {
            printf("\nSTMT_EXEC;;24339\n");
goto while_break___1;
          }
          printf("\nSTMT_EXEC;;24341\n");
goto __Cont;
        __Cont:
          {
printf("\nSTMT_EXEC;;24343\n");
p++;
}

        }
      while_break___1: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;24347\n");
prefix_len = (size_t)(p - file_name);
      printf("\nSTMT_EXEC;;24348\n");
if (prefix_len)
      {
        {
          printf("\nSTMT_EXEC;;24351\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___0 = __builtin_alloca(prefix_len + 1UL);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;24352\n");
prefix = (char *)tmp___0;
          printf("\nSTMT_EXEC;;24353\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)prefix, (void const * /* __restrict  */)file_name, prefix_len);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;24354\n");
*(prefix + prefix_len) = (char)'\000';
          printf("\nSTMT_EXEC;;24355\n");
tmp___2 = hash_string_insert(&prefix_table[link_target], (char const *)prefix);
        }
        printf("\nSTMT_EXEC;;24357\n");
if (tmp___2)
        {
          {
            printf("\nSTMT_EXEC;;24360\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext((char const *)diagnostic[link_target]);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;24361\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, prefix);printf("\nFUNC_RETURN;;\n");

          }
        }
      }
    }
    printf("\nSTMT_EXEC;;24366\n");
if (!*p)
    {
      printf("\nSTMT_EXEC;;24368\n");
if ((unsigned long)p == (unsigned long)file_name)
      {
        {
          printf("\nSTMT_EXEC;;24371\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext((char const *)diagnostic___0[link_target]);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;24372\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___3);printf("\nFUNC_RETURN;;\n");

        }
      }
      printf("\nSTMT_EXEC;;24375\n");
p = ".";
    }
    printf("\nSTMT_EXEC;;24377\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)p);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t stripped_prefix_len(char const *file_name, size_t num)
{
  printf("\nFUNC_CALL;stripped_prefix_len(const char *,size_t);\n");
printf("\nSTMT_EXEC;;24382\n");
char const *p;
  printf("\nSTMT_EXEC;;24383\n");
_Bool slash;

  {
    printf("\nSTMT_EXEC;;24386\n");
p = file_name + 0;
    {
      printf("\nSTMT_EXEC;;24388\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;24391\n");
if (!((int const) * p == 47))
        {
          printf("\nSTMT_EXEC;;24393\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;24395\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;24400\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;24403\n");
if (!*p)
        {
          printf("\nSTMT_EXEC;;24405\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;24407\n");
slash = (_Bool)((int const) * p == 47);
        printf("\nSTMT_EXEC;;24408\n");
p++;
        printf("\nSTMT_EXEC;;24409\n");
if (slash)
        {
          printf("\nSTMT_EXEC;;24411\n");
num--;
          printf("\nSTMT_EXEC;;24412\n");
if (num == 0UL)
          {
            printf("\nSTMT_EXEC;;24414\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)(p - file_name));
          }
          {
            printf("\nSTMT_EXEC;;24417\n");
while (1)
            {
            while_continue___1: /* CIL Label */;
              printf("\nSTMT_EXEC;;24420\n");
if (!((int const) * p == 47))
              {
                printf("\nSTMT_EXEC;;24422\n");
goto while_break___1;
              }
              printf("\nSTMT_EXEC;;24424\n");
p++;
            }
          while_break___1: /* CIL Label */;
          }
        }
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;24432\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)-1);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool contains_dot_dot(char const *name)
{
  printf("\nFUNC_CALL;contains_dot_dot(const char *);\n");
printf("\nSTMT_EXEC;;24437\n");
char const *p;
  printf("\nSTMT_EXEC;;24438\n");
char const *tmp;

  {
    printf("\nSTMT_EXEC;;24441\n");
p = name + 0;
    {
      printf("\nSTMT_EXEC;;24443\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;24446\n");
if ((int const) * (p + 0) == 46)
        {
          printf("\nSTMT_EXEC;;24448\n");
if ((int const) * (p + 1) == 46)
          {
            printf("\nSTMT_EXEC;;24450\n");
if ((int const) * (p + 2) == 47)
            {
              printf("\nSTMT_EXEC;;24452\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
            }
            else
            {
              printf("\nSTMT_EXEC;;24456\n");
if (!*(p + 2))
              {
                printf("\nSTMT_EXEC;;24458\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
              }
            }
          }
        }
        {
          printf("\nSTMT_EXEC;;24464\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;24467\n");
tmp = p;
            printf("\nSTMT_EXEC;;24468\n");
p++;
            printf("\nSTMT_EXEC;;24469\n");
if (!*tmp)
            {
              printf("\nSTMT_EXEC;;24471\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
            }
            printf("\nSTMT_EXEC;;24473\n");
if (!(!((int const) * p == 47)))
            {
              printf("\nSTMT_EXEC;;24475\n");
goto while_break___0;
            }
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;24480\n");
p++;
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}








































































































/* #pragma merger("0","00b.rtapelib.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) dup)(int __fd);
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) execl)(char const *__path, char const *__arg, ...);
extern __attribute__((__nothrow__)) __sighandler_t(__attribute__((__leaf__)) signal)(int __sig, void (*__handler)(int));
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) atoi)(char const *__nptr) __attribute__((__pure__));
extern __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__)) atol)(char const *__nptr) __attribute__((__pure__));
char const *rmt_command_option;
void sys_reset_uid_gid(void);
size_t rmt_write__(int handle, char *buffer___2, size_t length);
static int from_remote[4][2] = {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}};
static int to_remote[4][2] = {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}};
static void _rmt_shutdown(int handle, int errno_value)
{
  printf("\nFUNC_CALL;_rmt_shutdown(int,int);\n");
printf("\nSTMT_EXEC;;24603\n");
int *tmp;

  {
    {
      printf("\nSTMT_EXEC;;24607\n");
printf("\nFUNC_CALL;close(int);\n");
close(from_remote[handle][0]);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24608\n");
printf("\nFUNC_CALL;close(int);\n");
close(to_remote[handle][1]);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24609\n");
from_remote[handle][0] = -1;
      printf("\nSTMT_EXEC;;24610\n");
to_remote[handle][1] = -1;
      printf("\nSTMT_EXEC;;24611\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24612\n");
*tmp = errno_value;
    }
    printf("\nSTMT_EXEC;;24614\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int do_command(int handle, char const *buffer___2)
{
  printf("\nFUNC_CALL;do_command(int,const char *);\n");
printf("\nSTMT_EXEC;;24619\n");
size_t length;
  printf("\nSTMT_EXEC;;24620\n");
size_t tmp;
  printf("\nSTMT_EXEC;;24621\n");
void (*pipe_handler)();
  printf("\nSTMT_EXEC;;24622\n");
void (*tmp___0)(int);
  printf("\nSTMT_EXEC;;24623\n");
ssize_t written;
  printf("\nSTMT_EXEC;;24624\n");
size_t tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;24628\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(buffer___2);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24629\n");
length = tmp;
      printf("\nSTMT_EXEC;;24630\n");
printf("\nFUNC_CALL;signal(int,void (*)(int));\n");
tmp___0 = signal(13, (void (*)(int))1);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;24631\n");
pipe_handler = (void (*)())tmp___0;
      printf("\nSTMT_EXEC;;24632\n");
tmp___1 = full_write(to_remote[handle][1], (void const *)buffer___2, length);
      printf("\nSTMT_EXEC;;24633\n");
written = (ssize_t)tmp___1;
      printf("\nSTMT_EXEC;;24634\n");
printf("\nFUNC_CALL;signal(int,void (*)(int));\n");
signal(13, (void (*)(int))pipe_handler);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;24636\n");
if ((size_t)written == length)
    {
      printf("\nSTMT_EXEC;;24638\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;24641\n");
_rmt_shutdown(handle, 5);
    }
    printf("\nSTMT_EXEC;;24643\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
  }
printf("\nFUNC_RETURN;;\n");
}
static char *get_status_string(int handle, char *command_buffer)
{
  printf("\nFUNC_CALL;get_status_string(int,char *);\n");
printf("\nSTMT_EXEC;;24648\n");
char *cursor;
  printf("\nSTMT_EXEC;;24649\n");
int counter;
  printf("\nSTMT_EXEC;;24650\n");
size_t tmp;
  printf("\nSTMT_EXEC;;24651\n");
char character;
  printf("\nSTMT_EXEC;;24652\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;24653\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;24654\n");
int *tmp___2;

  {
    printf("\nSTMT_EXEC;;24657\n");
counter = 0;
    printf("\nSTMT_EXEC;;24658\n");
cursor = command_buffer;
    {
      printf("\nSTMT_EXEC;;24660\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;24663\n");
if (!(counter < 64))
        {
          printf("\nSTMT_EXEC;;24665\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;24668\n");
tmp = safe_read(from_remote[handle][0], (void *)cursor, (size_t)1);
        }
        printf("\nSTMT_EXEC;;24670\n");
if (tmp != 1UL)
        {
          {
            printf("\nSTMT_EXEC;;24673\n");
_rmt_shutdown(handle, 5);
          }
          printf("\nSTMT_EXEC;;24675\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
        }
        printf("\nSTMT_EXEC;;24677\n");
if ((int)*cursor == 10)
        {
          printf("\nSTMT_EXEC;;24679\n");
*cursor = (char)'\000';
          printf("\nSTMT_EXEC;;24680\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;24682\n");
counter++;
        printf("\nSTMT_EXEC;;24683\n");
cursor++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;24687\n");
if (counter == 64)
    {
      {
        printf("\nSTMT_EXEC;;24690\n");
_rmt_shutdown(handle, 5);
      }
      printf("\nSTMT_EXEC;;24692\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
    }
    printf("\nSTMT_EXEC;;24694\n");
cursor = command_buffer;
    {
      printf("\nSTMT_EXEC;;24696\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;24699\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;24701\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;24703\n");
if ((int)*cursor != 32)
        {
          printf("\nSTMT_EXEC;;24705\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;24707\n");
cursor++;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;24711\n");
if ((int)*cursor == 69)
    {
      printf("\nSTMT_EXEC;;24713\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;24717\n");
if ((int)*cursor == 70)
      {
      _L___3: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;24721\n");
while (1)
        {
        while_continue___1: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;24725\n");
tmp___0 = safe_read(from_remote[handle][0], (void *)(&character), (size_t)1);
          }
          printf("\nSTMT_EXEC;;24727\n");
if (!(tmp___0 == 1UL))
          {
            printf("\nSTMT_EXEC;;24729\n");
goto while_break___1;
          }
          printf("\nSTMT_EXEC;;24731\n");
if ((int)character == 10)
          {
            printf("\nSTMT_EXEC;;24733\n");
goto while_break___1;
          }
        }
      while_break___1: /* CIL Label */;
      }
        {
          printf("\nSTMT_EXEC;;24739\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;24740\n");
printf("\nFUNC_CALL;atoi(const char *);\n");
*tmp___1 = atoi((char const *)(cursor + 1));printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;24742\n");
if ((int)*cursor == 70)
        {
          {
            printf("\nSTMT_EXEC;;24745\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;24746\n");
_rmt_shutdown(handle, *tmp___2);
          }
        }
        printf("\nSTMT_EXEC;;24749\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
      }
    }
    printf("\nSTMT_EXEC;;24752\n");
if ((int)*cursor != 65)
    {
      {
        printf("\nSTMT_EXEC;;24755\n");
_rmt_shutdown(handle, 5);
      }
      printf("\nSTMT_EXEC;;24757\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)0);
    }
    printf("\nSTMT_EXEC;;24759\n");
printf("\nFUNC_RETURN;;\n");
return (cursor + 1);
  }
printf("\nFUNC_RETURN;;\n");
}
static long get_status(int handle)
{
  printf("\nFUNC_CALL;get_status(int);\n");
printf("\nSTMT_EXEC;;24764\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;24765\n");
char const *status;
  printf("\nSTMT_EXEC;;24766\n");
char *tmp;
  printf("\nSTMT_EXEC;;24767\n");
long result;
  printf("\nSTMT_EXEC;;24768\n");
long tmp___0;
  printf("\nSTMT_EXEC;;24769\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;24770\n");
void *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;24774\n");
tmp = get_status_string(handle, command_buffer);
      printf("\nSTMT_EXEC;;24775\n");
status = (char const *)tmp;
    }
    printf("\nSTMT_EXEC;;24777\n");
if (status)
    {
      {
        printf("\nSTMT_EXEC;;24780\n");
printf("\nFUNC_CALL;atol(const char *);\n");
tmp___0 = atol(status);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;24781\n");
result = tmp___0;
      }
      printf("\nSTMT_EXEC;;24783\n");
if (0L <= result)
      {
        printf("\nSTMT_EXEC;;24785\n");
printf("\nFUNC_RETURN;;\n");
return (result);
      }
      {
        printf("\nSTMT_EXEC;;24788\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;24789\n");
*tmp___1 = 5;
      }
    }
    printf("\nSTMT_EXEC;;24792\n");
printf("\nFUNC_RETURN;;\n");
return (-1L);
  }
printf("\nFUNC_RETURN;;\n");
}
static off_t get_status_off(int handle)
{
  printf("\nFUNC_CALL;get_status_off(int);\n");
printf("\nSTMT_EXEC;;24797\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;24798\n");
char const *status;
  printf("\nSTMT_EXEC;;24799\n");
char *tmp;
  printf("\nSTMT_EXEC;;24800\n");
off_t count;
  printf("\nSTMT_EXEC;;24801\n");
int negative;
  printf("\nSTMT_EXEC;;24802\n");
int digit;
  printf("\nSTMT_EXEC;;24803\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;24804\n");
off_t c10;
  printf("\nSTMT_EXEC;;24805\n");
off_t nc;
  printf("\nSTMT_EXEC;;24806\n");
int tmp___1;
  printf("\nSTMT_EXEC;;24807\n");
int tmp___2;
  printf("\nSTMT_EXEC;;24808\n");
void *__cil_tmp13;

  {
    {
      printf("\nSTMT_EXEC;;24812\n");
tmp = get_status_string(handle, command_buffer);
      printf("\nSTMT_EXEC;;24813\n");
status = (char const *)tmp;
    }
    printf("\nSTMT_EXEC;;24815\n");
if (!status)
    {
      printf("\nSTMT_EXEC;;24817\n");
printf("\nFUNC_RETURN;;\n");
return ((off_t)-1);
    }
    else
    {
      printf("\nSTMT_EXEC;;24821\n");
count = (off_t)0;
      {
        printf("\nSTMT_EXEC;;24823\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;24826\n");
if (!((int const) * status == 32))
          {
            printf("\nSTMT_EXEC;;24828\n");
if (!((int const) * status == 9))
            {
              printf("\nSTMT_EXEC;;24830\n");
goto while_break;
            }
          }
          printf("\nSTMT_EXEC;;24833\n");
goto __Cont;
        __Cont:
          {
printf("\nSTMT_EXEC;;24835\n");
status++;
}

        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;24839\n");
negative = (int const) * status == 45;
      printf("\nSTMT_EXEC;;24840\n");
if (negative)
      {
        printf("\nSTMT_EXEC;;24842\n");
tmp___1 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;24846\n");
if ((int const) * status == 43)
        {
          printf("\nSTMT_EXEC;;24848\n");
tmp___1 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;24852\n");
tmp___1 = 0;
        }
      }
      printf("\nSTMT_EXEC;;24855\n");
status += tmp___1;
      {
        printf("\nSTMT_EXEC;;24857\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;24860\n");
tmp___0 = status;
          printf("\nSTMT_EXEC;;24861\n");
status++;
          printf("\nSTMT_EXEC;;24862\n");
digit = (int)((int const) * tmp___0 - 48);
          printf("\nSTMT_EXEC;;24863\n");
if (9U < (unsigned int)digit)
          {
            printf("\nSTMT_EXEC;;24865\n");
goto while_break___0;
          }
          else
          {
            printf("\nSTMT_EXEC;;24869\n");
c10 = 10L * count;
            printf("\nSTMT_EXEC;;24870\n");
if (negative)
            {
              printf("\nSTMT_EXEC;;24872\n");
nc = c10 - (off_t)digit;
            }
            else
            {
              printf("\nSTMT_EXEC;;24876\n");
nc = c10 + (off_t)digit;
            }
            printf("\nSTMT_EXEC;;24878\n");
if (c10 / 10L != count)
            {
              printf("\nSTMT_EXEC;;24880\n");
printf("\nFUNC_RETURN;;\n");
return ((off_t)-1);
            }
            else
            {
              printf("\nSTMT_EXEC;;24884\n");
if (negative)
              {
                printf("\nSTMT_EXEC;;24886\n");
tmp___2 = c10 < nc;
              }
              else
              {
                printf("\nSTMT_EXEC;;24890\n");
tmp___2 = nc < c10;
              }
              printf("\nSTMT_EXEC;;24892\n");
if (tmp___2)
              {
                printf("\nSTMT_EXEC;;24894\n");
printf("\nFUNC_RETURN;;\n");
return ((off_t)-1);
              }
            }
            printf("\nSTMT_EXEC;;24897\n");
count = nc;
          }
        }
      while_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;24902\n");
printf("\nFUNC_RETURN;;\n");
return (count);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static void encode_oflag(char *buf, int oflag)
{
  printf("\nFUNC_CALL;encode_oflag(char *,int);\n");
printf("\nSTMT_EXEC;;24908\n");
char *__cil_tmp3;
  printf("\nSTMT_EXEC;;24909\n");
char *__cil_tmp4;
  printf("\nSTMT_EXEC;;24910\n");
char *__cil_tmp5;
  printf("\nSTMT_EXEC;;24911\n");
char *__cil_tmp6;
  printf("\nSTMT_EXEC;;24912\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;24913\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;24914\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;24915\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;24916\n");
char *__cil_tmp11;
  printf("\nSTMT_EXEC;;24917\n");
char *__cil_tmp12;
  printf("\nSTMT_EXEC;;24918\n");
char *__cil_tmp13;
  printf("\nSTMT_EXEC;;24919\n");
char *__cil_tmp14;
  printf("\nSTMT_EXEC;;24920\n");
char *__cil_tmp15;

  {
    {
      printf("\nSTMT_EXEC;;24924\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)buf, (char const * /* __restrict  */) "%d ", oflag);printf("\nFUNC_RETURN;;\n");

    }
    {
      printf("\nSTMT_EXEC;;24927\n");
if ((oflag & 3) == 0)
      {
        printf("\nSTMT_EXEC;;24929\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;24931\n");
if ((oflag & 3) == 2)
      {
        printf("\nSTMT_EXEC;;24933\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;24935\n");
if ((oflag & 3) == 1)
      {
        printf("\nSTMT_EXEC;;24937\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;24939\n");
goto switch_default;
    case_0: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;24942\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "O_RDONLY");printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;24944\n");
goto switch_break;
    case_2: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;24947\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "O_RDWR");printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;24949\n");
goto switch_break;
    case_1: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;24952\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "O_WRONLY");printf("\nFUNC_RETURN;;\n");

    }
      printf("\nSTMT_EXEC;;24954\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;24957\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;24961\n");
if (oflag & 1024)
    {
      {
        printf("\nSTMT_EXEC;;24964\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_APPEND");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24967\n");
if (oflag & 64)
    {
      {
        printf("\nSTMT_EXEC;;24970\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_CREAT");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24973\n");
if (oflag & 4096)
    {
      {
        printf("\nSTMT_EXEC;;24976\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_DSYNC");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24979\n");
if (oflag & 128)
    {
      {
        printf("\nSTMT_EXEC;;24982\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_EXCL");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24985\n");
if (oflag & 256)
    {
      {
        printf("\nSTMT_EXEC;;24988\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_NOCTTY");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24991\n");
if (oflag & 2048)
    {
      {
        printf("\nSTMT_EXEC;;24994\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_NONBLOCK");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;24997\n");
if (oflag & 1052672)
    {
      {
        printf("\nSTMT_EXEC;;25000\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_RSYNC");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;25003\n");
if (oflag & 1052672)
    {
      {
        printf("\nSTMT_EXEC;;25006\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_SYNC");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;25009\n");
if (oflag & 512)
    {
      {
        printf("\nSTMT_EXEC;;25012\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)buf, (char const * /* __restrict  */) "|O_TRUNC");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;25015\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
int rmt_open__(char const *path, int open_mode, int bias, char const *remote_shell)
{
  printf("\nFUNC_CALL;rmt_open__(const char *,int,int,const char *);\n");
printf("\nSTMT_EXEC;;25020\n");
int remote_pipe_number;
  printf("\nSTMT_EXEC;;25021\n");
char *path_copy;
  printf("\nSTMT_EXEC;;25022\n");
char *remote_host;
  printf("\nSTMT_EXEC;;25023\n");
char *remote_file;
  printf("\nSTMT_EXEC;;25024\n");
char *remote_user;
  printf("\nSTMT_EXEC;;25025\n");
int *tmp;
  printf("\nSTMT_EXEC;;25026\n");
char *cursor;
  printf("\nSTMT_EXEC;;25027\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;25028\n");
char const *remote_shell_basename;
  printf("\nSTMT_EXEC;;25029\n");
pid_t status;
  printf("\nSTMT_EXEC;;25030\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;25031\n");
int e;
  printf("\nSTMT_EXEC;;25032\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;25033\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;25034\n");
int tmp___4;
  printf("\nSTMT_EXEC;;25035\n");
int tmp___5;
  printf("\nSTMT_EXEC;;25036\n");
int e___0;
  printf("\nSTMT_EXEC;;25037\n");
int *tmp___6;
  printf("\nSTMT_EXEC;;25038\n");
int *tmp___7;
  printf("\nSTMT_EXEC;;25039\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;25040\n");
int *tmp___9;
  printf("\nSTMT_EXEC;;25041\n");
size_t remote_file_len;
  printf("\nSTMT_EXEC;;25042\n");
size_t tmp___10;
  printf("\nSTMT_EXEC;;25043\n");
char *command_buffer;
  printf("\nSTMT_EXEC;;25044\n");
void *tmp___11;
  printf("\nSTMT_EXEC;;25045\n");
int e___1;
  printf("\nSTMT_EXEC;;25046\n");
int *tmp___12;
  printf("\nSTMT_EXEC;;25047\n");
int tmp___13;
  printf("\nSTMT_EXEC;;25048\n");
long tmp___14;
  printf("\nSTMT_EXEC;;25049\n");
char const *tmp___15;
  printf("\nSTMT_EXEC;;25050\n");
char const *tmp___16;
  printf("\nSTMT_EXEC;;25051\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;25052\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;25053\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;25054\n");
char *__cil_tmp39;
  printf("\nSTMT_EXEC;;25055\n");
char *__cil_tmp40;
  printf("\nSTMT_EXEC;;25056\n");
char *__cil_tmp41;

  {
    printf("\nSTMT_EXEC;;25059\n");
remote_pipe_number = 0;
    {
      printf("\nSTMT_EXEC;;25061\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;25064\n");
if (!(remote_pipe_number < 4))
        {
          printf("\nSTMT_EXEC;;25066\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;25068\n");
if (from_remote[remote_pipe_number][0] == -1)
        {
          printf("\nSTMT_EXEC;;25070\n");
if (to_remote[remote_pipe_number][1] == -1)
          {
            printf("\nSTMT_EXEC;;25072\n");
goto while_break;
          }
        }
        printf("\nSTMT_EXEC;;25075\n");
remote_pipe_number++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25079\n");
if (remote_pipe_number == 4)
    {
      {
        printf("\nSTMT_EXEC;;25082\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25083\n");
*tmp = 24;
      }
      printf("\nSTMT_EXEC;;25085\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
    }
    {
      printf("\nSTMT_EXEC;;25088\n");
path_copy = xstrdup(path);
      printf("\nSTMT_EXEC;;25089\n");
remote_host = path_copy;
      printf("\nSTMT_EXEC;;25090\n");
remote_user = (char *)0;
      printf("\nSTMT_EXEC;;25091\n");
remote_file = (char *)0;
      printf("\nSTMT_EXEC;;25092\n");
cursor = path_copy;
    }
    {
      printf("\nSTMT_EXEC;;25095\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;25098\n");
if (!*cursor)
        {
          printf("\nSTMT_EXEC;;25100\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;25103\n");
if ((int)*cursor == 10)
          {
            printf("\nSTMT_EXEC;;25105\n");
goto case_10;
          }
          printf("\nSTMT_EXEC;;25107\n");
if ((int)*cursor == 64)
          {
            printf("\nSTMT_EXEC;;25109\n");
goto case_64;
          }
          printf("\nSTMT_EXEC;;25111\n");
if ((int)*cursor == 58)
          {
            printf("\nSTMT_EXEC;;25113\n");
goto case_58;
          }
          printf("\nSTMT_EXEC;;25115\n");
goto switch_default;
        switch_default: /* CIL Label */
          {
printf("\nSTMT_EXEC;;25117\n");
goto switch_break;
}

        case_10: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;25120\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_copy);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;25121\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;25122\n");
*tmp___0 = 2;
        }
          printf("\nSTMT_EXEC;;25124\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
        case_64: /* CIL Label */
          {
printf("\nSTMT_EXEC;;25126\n");
if (!remote_user)
          {
            printf("\nSTMT_EXEC;;25128\n");
remote_user = remote_host;
            printf("\nSTMT_EXEC;;25129\n");
*cursor = (char)'\000';
            printf("\nSTMT_EXEC;;25130\n");
remote_host = cursor + 1;
          }
}

          printf("\nSTMT_EXEC;;25132\n");
goto switch_break;
        case_58: /* CIL Label */
          {
printf("\nSTMT_EXEC;;25134\n");
if (!remote_file)
          {
            printf("\nSTMT_EXEC;;25136\n");
*cursor = (char)'\000';
            printf("\nSTMT_EXEC;;25137\n");
remote_file = cursor + 1;
          }
}

          printf("\nSTMT_EXEC;;25139\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;25142\n");
cursor++;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25146\n");
if (remote_user)
    {
      printf("\nSTMT_EXEC;;25148\n");
if ((int)*remote_user == 0)
      {
        printf("\nSTMT_EXEC;;25150\n");
remote_user = (char *)0;
      }
    }
    printf("\nSTMT_EXEC;;25153\n");
if (!remote_shell)
    {
      printf("\nSTMT_EXEC;;25155\n");
remote_shell = "/usr/bin/rsh";
    }
    {
      printf("\nSTMT_EXEC;;25158\n");
tmp___1 = base_name(remote_shell);
      printf("\nSTMT_EXEC;;25159\n");
remote_shell_basename = (char const *)tmp___1;
      printf("\nSTMT_EXEC;;25160\n");
printf("\nFUNC_CALL;pipe(int *);\n");
tmp___4 = pipe(to_remote[remote_pipe_number]);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;25162\n");
if (tmp___4 == -1)
    {
      printf("\nSTMT_EXEC;;25164\n");
goto _L;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;25169\n");
printf("\nFUNC_CALL;pipe(int *);\n");
tmp___5 = pipe(from_remote[remote_pipe_number]);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;25171\n");
if (tmp___5 == -1)
      {
      _L:
      {
        printf("\nSTMT_EXEC;;25175\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25176\n");
e = *tmp___2;
        printf("\nSTMT_EXEC;;25177\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_copy);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25178\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25179\n");
*tmp___3 = e;
      }
        printf("\nSTMT_EXEC;;25181\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
      }
    }
    {
      printf("\nSTMT_EXEC;;25185\n");
printf("\nFUNC_CALL;fork();\n");
status = fork();printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;25187\n");
if (status == -1)
    {
      {
        printf("\nSTMT_EXEC;;25190\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___6 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25191\n");
e___0 = *tmp___6;
        printf("\nSTMT_EXEC;;25192\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_copy);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25193\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___7 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25194\n");
*tmp___7 = e___0;
      }
      printf("\nSTMT_EXEC;;25196\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
    }
    printf("\nSTMT_EXEC;;25198\n");
if (status == 0)
    {
      {
        printf("\nSTMT_EXEC;;25201\n");
printf("\nFUNC_CALL;close(int);\n");
close(0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25202\n");
printf("\nFUNC_CALL;dup(int);\n");
dup(to_remote[remote_pipe_number][0]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25203\n");
printf("\nFUNC_CALL;close(int);\n");
close(to_remote[remote_pipe_number][0]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25204\n");
printf("\nFUNC_CALL;close(int);\n");
close(to_remote[remote_pipe_number][1]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25205\n");
printf("\nFUNC_CALL;close(int);\n");
close(1);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25206\n");
printf("\nFUNC_CALL;dup(int);\n");
dup(from_remote[remote_pipe_number][1]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25207\n");
printf("\nFUNC_CALL;close(int);\n");
close(from_remote[remote_pipe_number][0]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25208\n");
printf("\nFUNC_CALL;close(int);\n");
close(from_remote[remote_pipe_number][1]);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25209\n");
sys_reset_uid_gid();
      }
      printf("\nSTMT_EXEC;;25211\n");
if (remote_user)
      {
        printf("\nSTMT_EXEC;;25213\n");
if (rmt_command_option)
        {
          printf("\nSTMT_EXEC;;25215\n");
tmp___15 = rmt_command_option;
        }
        else
        {
          printf("\nSTMT_EXEC;;25219\n");
tmp___15 = "/etc/rmt";
        }
        {
          printf("\nSTMT_EXEC;;25222\n");
printf("\nFUNC_CALL;execl(const char *,const char *);\n");
execl(remote_shell, remote_shell_basename, remote_host, "-l", remote_user, tmp___15, (char *)0);printf("\nFUNC_RETURN;;\n");

        }
      }
      else
      {
        printf("\nSTMT_EXEC;;25227\n");
if (rmt_command_option)
        {
          printf("\nSTMT_EXEC;;25229\n");
tmp___16 = rmt_command_option;
        }
        else
        {
          printf("\nSTMT_EXEC;;25233\n");
tmp___16 = "/etc/rmt";
        }
        {
          printf("\nSTMT_EXEC;;25236\n");
printf("\nFUNC_CALL;execl(const char *,const char *);\n");
execl(remote_shell, remote_shell_basename, remote_host, tmp___16, (char *)0);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;25240\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("Cannot execute remote shell");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25241\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___9 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25242\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(128, *tmp___9, (char const *)tmp___8);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;25246\n");
printf("\nFUNC_CALL;close(int);\n");
close(from_remote[remote_pipe_number][1]);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25247\n");
printf("\nFUNC_CALL;close(int);\n");
close(to_remote[remote_pipe_number][0]);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25248\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___10 = strlen((char const *)remote_file);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25249\n");
remote_file_len = tmp___10;
      printf("\nSTMT_EXEC;;25250\n");
tmp___11 = xmalloc(remote_file_len + 1000UL);
      printf("\nSTMT_EXEC;;25251\n");
command_buffer = (char *)tmp___11;
      printf("\nSTMT_EXEC;;25252\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)command_buffer, (char const * /* __restrict  */) "O%s\n", remote_file);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25253\n");
encode_oflag((command_buffer + remote_file_len) + 2, open_mode);
      printf("\nSTMT_EXEC;;25254\n");
printf("\nFUNC_CALL;strcat(char *__restrict,const char *__restrict);\n");
strcat((char * /* __restrict  */)command_buffer, (char const * /* __restrict  */) "\n");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25255\n");
tmp___13 = do_command(remote_pipe_number, (char const *)command_buffer);
    }
    printf("\nSTMT_EXEC;;25257\n");
if (tmp___13 == -1)
    {
      printf("\nSTMT_EXEC;;25259\n");
goto _L___0;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;25264\n");
tmp___14 = get_status(remote_pipe_number);
      }
      printf("\nSTMT_EXEC;;25266\n");
if (tmp___14 == -1L)
      {
      _L___0:
      {
        printf("\nSTMT_EXEC;;25270\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___12 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25271\n");
e___1 = *tmp___12;
        printf("\nSTMT_EXEC;;25272\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)command_buffer);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25273\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_copy);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25274\n");
_rmt_shutdown(remote_pipe_number, e___1);
      }
        printf("\nSTMT_EXEC;;25276\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
      }
    }
    {
      printf("\nSTMT_EXEC;;25280\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)command_buffer);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25281\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)path_copy);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;25283\n");
printf("\nFUNC_RETURN;;\n");
return (remote_pipe_number + bias);
  }
printf("\nFUNC_RETURN;;\n");
}
int rmt_close__(int handle)
{
  printf("\nFUNC_CALL;rmt_close__(int);\n");
printf("\nSTMT_EXEC;;25288\n");
long status;
  printf("\nSTMT_EXEC;;25289\n");
int tmp;
  printf("\nSTMT_EXEC;;25290\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;25291\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;25295\n");
tmp = do_command(handle, "C\n");
    }
    printf("\nSTMT_EXEC;;25297\n");
if (tmp == -1)
    {
      printf("\nSTMT_EXEC;;25299\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
    }
    {
      printf("\nSTMT_EXEC;;25302\n");
status = get_status(handle);
      printf("\nSTMT_EXEC;;25303\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25304\n");
_rmt_shutdown(handle, *tmp___0);
    }
    printf("\nSTMT_EXEC;;25306\n");
printf("\nFUNC_RETURN;;\n");
return ((int)status);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t rmt_read__(int handle, char *buffer___2, size_t length)
{
  printf("\nFUNC_CALL;rmt_read__(int,char *,size_t);\n");
printf("\nSTMT_EXEC;;25311\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;25312\n");
size_t status;
  printf("\nSTMT_EXEC;;25313\n");
size_t rlen;
  printf("\nSTMT_EXEC;;25314\n");
size_t counter;
  printf("\nSTMT_EXEC;;25315\n");
int tmp;
  printf("\nSTMT_EXEC;;25316\n");
long tmp___0;
  printf("\nSTMT_EXEC;;25317\n");
void *__cil_tmp10;
  printf("\nSTMT_EXEC;;25318\n");
char *__cil_tmp11;

  {
    {
      printf("\nSTMT_EXEC;;25322\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(command_buffer), (char const * /* __restrict  */) "R%lu\n", length);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25323\n");
tmp = do_command(handle, (char const *)(command_buffer));
    }
    printf("\nSTMT_EXEC;;25325\n");
if (tmp == -1)
    {
      printf("\nSTMT_EXEC;;25327\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)-1);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;25332\n");
tmp___0 = get_status(handle);
        printf("\nSTMT_EXEC;;25333\n");
status = (size_t)tmp___0;
      }
      printf("\nSTMT_EXEC;;25335\n");
if (status == 0xffffffffffffffffUL)
      {
        printf("\nSTMT_EXEC;;25337\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)-1);
      }
    }
    printf("\nSTMT_EXEC;;25340\n");
counter = (size_t)0;
    {
      printf("\nSTMT_EXEC;;25342\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;25345\n");
if (!(counter < status))
        {
          printf("\nSTMT_EXEC;;25347\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;25350\n");
rlen = safe_read(from_remote[handle][0], (void *)buffer___2, status - counter);
        }
        printf("\nSTMT_EXEC;;25352\n");
if (rlen == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;25355\n");
_rmt_shutdown(handle, 5);
          }
          printf("\nSTMT_EXEC;;25357\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)-1);
        }
        else
        {
          printf("\nSTMT_EXEC;;25361\n");
if (rlen == 0UL)
          {
            {
              printf("\nSTMT_EXEC;;25364\n");
_rmt_shutdown(handle, 5);
            }
            printf("\nSTMT_EXEC;;25366\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)-1);
          }
        }
        printf("\nSTMT_EXEC;;25369\n");
counter += rlen;
        printf("\nSTMT_EXEC;;25370\n");
buffer___2 += rlen;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25374\n");
printf("\nFUNC_RETURN;;\n");
return (status);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t rmt_write__(int handle, char *buffer___2, size_t length)
{
  printf("\nFUNC_CALL;rmt_write__(int,char *,size_t);\n");
printf("\nSTMT_EXEC;;25379\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;25380\n");
void (*pipe_handler)();
  printf("\nSTMT_EXEC;;25381\n");
size_t written;
  printf("\nSTMT_EXEC;;25382\n");
int tmp;
  printf("\nSTMT_EXEC;;25383\n");
void (*tmp___0)(int);
  printf("\nSTMT_EXEC;;25384\n");
long r;
  printf("\nSTMT_EXEC;;25385\n");
long tmp___1;
  printf("\nSTMT_EXEC;;25386\n");
void *__cil_tmp11;
  printf("\nSTMT_EXEC;;25387\n");
char *__cil_tmp12;

  {
    {
      printf("\nSTMT_EXEC;;25391\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(command_buffer), (char const * /* __restrict  */) "W%lu\n", length);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25392\n");
tmp = do_command(handle, (char const *)(command_buffer));
    }
    printf("\nSTMT_EXEC;;25394\n");
if (tmp == -1)
    {
      printf("\nSTMT_EXEC;;25396\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)0);
    }
    {
      printf("\nSTMT_EXEC;;25399\n");
printf("\nFUNC_CALL;signal(int,void (*)(int));\n");
tmp___0 = signal(13, (void (*)(int))1);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25400\n");
pipe_handler = (void (*)())tmp___0;
      printf("\nSTMT_EXEC;;25401\n");
written = full_write(to_remote[handle][1], (void const *)buffer___2, length);
      printf("\nSTMT_EXEC;;25402\n");
printf("\nFUNC_CALL;signal(int,void (*)(int));\n");
signal(13, (void (*)(int))pipe_handler);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;25404\n");
if (written == length)
    {
      {
        printf("\nSTMT_EXEC;;25407\n");
tmp___1 = get_status(handle);
        printf("\nSTMT_EXEC;;25408\n");
r = tmp___1;
      }
      printf("\nSTMT_EXEC;;25410\n");
if (r < 0L)
      {
        printf("\nSTMT_EXEC;;25412\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)0);
      }
      printf("\nSTMT_EXEC;;25414\n");
if ((size_t)r == length)
      {
        printf("\nSTMT_EXEC;;25416\n");
printf("\nFUNC_RETURN;;\n");
return (length);
      }
      printf("\nSTMT_EXEC;;25418\n");
written = (size_t)r;
    }
    {
      printf("\nSTMT_EXEC;;25421\n");
_rmt_shutdown(handle, 5);
    }
    printf("\nSTMT_EXEC;;25423\n");
printf("\nFUNC_RETURN;;\n");
return (written);
  }
printf("\nFUNC_RETURN;;\n");
}
off_t rmt_lseek__(int handle, off_t offset, int whence)
{
  printf("\nFUNC_CALL;rmt_lseek__(int,off_t,int);\n");
printf("\nSTMT_EXEC;;25428\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;25429\n");
char operand_buffer[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;25430\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;25431\n");
char *p;
  printf("\nSTMT_EXEC;;25432\n");
int tmp;
  printf("\nSTMT_EXEC;;25433\n");
off_t tmp___0;
  printf("\nSTMT_EXEC;;25434\n");
void *__cil_tmp10;
  printf("\nSTMT_EXEC;;25435\n");
void *__cil_tmp11;
  printf("\nSTMT_EXEC;;25436\n");
char *__cil_tmp12;

  {
    printf("\nSTMT_EXEC;;25439\n");
if (offset < 0L)
    {
      printf("\nSTMT_EXEC;;25441\n");
u = -((uintmax_t)offset);
    }
    else
    {
      printf("\nSTMT_EXEC;;25445\n");
u = (uintmax_t)offset;
    }
    printf("\nSTMT_EXEC;;25447\n");
p = operand_buffer + sizeof(operand_buffer);
    printf("\nSTMT_EXEC;;25448\n");
p--;
    printf("\nSTMT_EXEC;;25449\n");
*p = (char)0;
    {
      printf("\nSTMT_EXEC;;25451\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;25454\n");
p--;
        printf("\nSTMT_EXEC;;25455\n");
*p = (char)(48 + (int)(u % 10UL));
        printf("\nSTMT_EXEC;;25456\n");
u /= 10UL;
        printf("\nSTMT_EXEC;;25457\n");
if (!(u != 0UL))
        {
          printf("\nSTMT_EXEC;;25459\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25464\n");
if (offset < 0L)
    {
      printf("\nSTMT_EXEC;;25466\n");
p--;
      printf("\nSTMT_EXEC;;25467\n");
*p = (char)'-';
    }
    {
      printf("\nSTMT_EXEC;;25470\n");
if (whence == 0)
      {
        printf("\nSTMT_EXEC;;25472\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;25474\n");
if (whence == 1)
      {
        printf("\nSTMT_EXEC;;25476\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;25478\n");
if (whence == 2)
      {
        printf("\nSTMT_EXEC;;25480\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;25482\n");
goto switch_default;
    case_0: /* CIL Label */
      {
printf("\nSTMT_EXEC;;25484\n");
whence = 0;
}

      printf("\nSTMT_EXEC;;25485\n");
goto switch_break;
    case_1: /* CIL Label */
      {
printf("\nSTMT_EXEC;;25487\n");
whence = 1;
}

      printf("\nSTMT_EXEC;;25488\n");
goto switch_break;
    case_2: /* CIL Label */
      {
printf("\nSTMT_EXEC;;25490\n");
whence = 2;
}

      printf("\nSTMT_EXEC;;25491\n");
goto switch_break;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;25494\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;25499\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(command_buffer), (char const * /* __restrict  */) "L%s\n%d\n", p, whence);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25500\n");
tmp = do_command(handle, (char const *)(command_buffer));
    }
    printf("\nSTMT_EXEC;;25502\n");
if (tmp == -1)
    {
      printf("\nSTMT_EXEC;;25504\n");
printf("\nFUNC_RETURN;;\n");
return ((off_t)-1);
    }
    {
      printf("\nSTMT_EXEC;;25507\n");
tmp___0 = get_status_off(handle);
    }
    printf("\nSTMT_EXEC;;25509\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
int rmt_ioctl__(int handle, int operation, char *argument)
{
  printf("\nFUNC_CALL;rmt_ioctl__(int,int,char *);\n");
printf("\nSTMT_EXEC;;25514\n");
int *tmp;
  printf("\nSTMT_EXEC;;25515\n");
char command_buffer[64];
  printf("\nSTMT_EXEC;;25516\n");
char operand_buffer[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;25517\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;25518\n");
char *p;
  printf("\nSTMT_EXEC;;25519\n");
int tmp___0;
  printf("\nSTMT_EXEC;;25520\n");
long tmp___1;
  printf("\nSTMT_EXEC;;25521\n");
ssize_t status;
  printf("\nSTMT_EXEC;;25522\n");
size_t counter;
  printf("\nSTMT_EXEC;;25523\n");
int tmp___2;
  printf("\nSTMT_EXEC;;25524\n");
char copy;
  printf("\nSTMT_EXEC;;25525\n");
void *__cil_tmp15;
  printf("\nSTMT_EXEC;;25526\n");
void *__cil_tmp16;
  printf("\nSTMT_EXEC;;25527\n");
char *__cil_tmp17;
  printf("\nSTMT_EXEC;;25528\n");
char *__cil_tmp18;

  {
    {
      printf("\nSTMT_EXEC;;25532\n");
if (operation == (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) | (sizeof(struct mtop) << 16)))
      {
        printf("\nSTMT_EXEC;;25534\n");
goto case_exp;
      }
      printf("\nSTMT_EXEC;;25536\n");
if (operation == (int)((unsigned long)(((2U << 30) | (unsigned int)(109 << 8)) | 2U) | (sizeof(struct mtget) << 16)))
      {
        printf("\nSTMT_EXEC;;25538\n");
goto case_exp___0;
      }
      printf("\nSTMT_EXEC;;25540\n");
goto switch_default;
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;25543\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25544\n");
*tmp = 95;
    }
      printf("\nSTMT_EXEC;;25546\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
    case_exp: /* CIL Label */
      {
printf("\nSTMT_EXEC;;25548\n");
if (((struct mtop *)argument)->mt_count < 0)
      {
        printf("\nSTMT_EXEC;;25550\n");
u = -((uintmax_t)((struct mtop *)argument)->mt_count);
      }
      else
      {
        printf("\nSTMT_EXEC;;25554\n");
u = (uintmax_t)((struct mtop *)argument)->mt_count;
      }
}

      printf("\nSTMT_EXEC;;25556\n");
p = operand_buffer + sizeof(operand_buffer);
      printf("\nSTMT_EXEC;;25557\n");
p--;
      printf("\nSTMT_EXEC;;25558\n");
*p = (char)0;
      {
        printf("\nSTMT_EXEC;;25560\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;25563\n");
p--;
          printf("\nSTMT_EXEC;;25564\n");
*p = (char)(48 + (int)(u % 10UL));
          printf("\nSTMT_EXEC;;25565\n");
u /= 10UL;
          printf("\nSTMT_EXEC;;25566\n");
if (!(u != 0UL))
          {
            printf("\nSTMT_EXEC;;25568\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;25573\n");
if (((struct mtop *)argument)->mt_count < 0)
      {
        printf("\nSTMT_EXEC;;25575\n");
p--;
        printf("\nSTMT_EXEC;;25576\n");
*p = (char)'-';
      }
      {
        printf("\nSTMT_EXEC;;25579\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)(command_buffer), (char const * /* __restrict  */) "I%d\n%s\n", (int)((struct mtop *)argument)->mt_op, p);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;25580\n");
tmp___0 = do_command(handle, (char const *)(command_buffer));
      }
      printf("\nSTMT_EXEC;;25582\n");
if (tmp___0 == -1)
      {
        printf("\nSTMT_EXEC;;25584\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
      }
      {
        printf("\nSTMT_EXEC;;25587\n");
tmp___1 = get_status(handle);
      }
      printf("\nSTMT_EXEC;;25589\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp___1);
    case_exp___0: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;25592\n");
tmp___2 = do_command(handle, "S");
    }
      printf("\nSTMT_EXEC;;25594\n");
if (tmp___2 == -1)
      {
        printf("\nSTMT_EXEC;;25596\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;25601\n");
status = get_status(handle);
        }
        printf("\nSTMT_EXEC;;25603\n");
if (status == -1L)
        {
          printf("\nSTMT_EXEC;;25605\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
        }
      }
      {
        printf("\nSTMT_EXEC;;25609\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;25612\n");
if (!(status > 0L))
          {
            printf("\nSTMT_EXEC;;25614\n");
goto while_break___0;
          }
          {
            printf("\nSTMT_EXEC;;25617\n");
counter = safe_read(from_remote[handle][0], (void *)argument, (size_t)status);
          }
          printf("\nSTMT_EXEC;;25619\n");
if (counter == 0xffffffffffffffffUL)
          {
            {
              printf("\nSTMT_EXEC;;25622\n");
_rmt_shutdown(handle, 5);
            }
            printf("\nSTMT_EXEC;;25624\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
          }
          else
          {
            printf("\nSTMT_EXEC;;25628\n");
if (counter == 0UL)
            {
              {
                printf("\nSTMT_EXEC;;25631\n");
_rmt_shutdown(handle, 5);
              }
              printf("\nSTMT_EXEC;;25633\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
            }
          }
          printf("\nSTMT_EXEC;;25636\n");
status = (ssize_t)((size_t)status - counter);
          printf("\nSTMT_EXEC;;25637\n");
argument += counter;
        }
      while_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;25641\n");
if (((struct mtget *)argument)->mt_type < 256L)
      {
        printf("\nSTMT_EXEC;;25643\n");
printf("\nFUNC_RETURN;;\n");
return (0);
      }
      printf("\nSTMT_EXEC;;25645\n");
counter = (size_t)0;
      {
        printf("\nSTMT_EXEC;;25647\n");
while (1)
        {
        while_continue___1: /* CIL Label */;
          printf("\nSTMT_EXEC;;25650\n");
if (!(counter < (size_t)status))
          {
            printf("\nSTMT_EXEC;;25652\n");
goto while_break___1;
          }
          printf("\nSTMT_EXEC;;25654\n");
copy = *(argument + counter);
          printf("\nSTMT_EXEC;;25655\n");
*(argument + counter) = *(argument + (counter + 1UL));
          printf("\nSTMT_EXEC;;25656\n");
*(argument + (counter + 1UL)) = copy;
          printf("\nSTMT_EXEC;;25657\n");
counter += 2UL;
        }
      while_break___1: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;25661\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    switch_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","00c.sparse.o.i","") */
static _Bool tar_sparse_member_p(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_member_p(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25669\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25672\n");
if ((file->optab)->sparse_member_p)
    {
      {
        printf("\nSTMT_EXEC;;25675\n");
tmp = (*((file->optab)->sparse_member_p))(file);
      }
      printf("\nSTMT_EXEC;;25677\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25679\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_init(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_init(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25684\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25687\n");
file->dumped_size = (size_t)0;
    printf("\nSTMT_EXEC;;25688\n");
if ((file->optab)->init)
    {
      {
        printf("\nSTMT_EXEC;;25691\n");
tmp = (*((file->optab)->init))(file);
      }
      printf("\nSTMT_EXEC;;25693\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25695\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_done(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_done(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25700\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25703\n");
if ((file->optab)->done)
    {
      {
        printf("\nSTMT_EXEC;;25706\n");
tmp = (*((file->optab)->done))(file);
      }
      printf("\nSTMT_EXEC;;25708\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25710\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_scan(struct tar_sparse_file *file, enum sparse_scan_state state, void *block)
{
  printf("\nFUNC_CALL;tar_sparse_scan(struct tar_sparse_file *,enum sparse_scan_state,void *);\n");
printf("\nSTMT_EXEC;;25715\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25718\n");
if ((file->optab)->scan_block)
    {
      {
        printf("\nSTMT_EXEC;;25721\n");
tmp = (*((file->optab)->scan_block))(file, state, block);
      }
      printf("\nSTMT_EXEC;;25723\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25725\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_dump_region(struct tar_sparse_file *file, size_t i)
{
  printf("\nFUNC_CALL;tar_sparse_dump_region(struct tar_sparse_file *,size_t);\n");
printf("\nSTMT_EXEC;;25730\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25733\n");
if ((file->optab)->dump_region)
    {
      {
        printf("\nSTMT_EXEC;;25736\n");
tmp = (*((file->optab)->dump_region))(file, i);
      }
      printf("\nSTMT_EXEC;;25738\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25740\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_extract_region(struct tar_sparse_file *file, size_t i)
{
  printf("\nFUNC_CALL;tar_sparse_extract_region(struct tar_sparse_file *,size_t);\n");
printf("\nSTMT_EXEC;;25745\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25748\n");
if ((file->optab)->extract_region)
    {
      {
        printf("\nSTMT_EXEC;;25751\n");
tmp = (*((file->optab)->extract_region))(file, i);
      }
      printf("\nSTMT_EXEC;;25753\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25755\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_dump_header(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_dump_header(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25760\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25763\n");
if ((file->optab)->dump_header)
    {
      {
        printf("\nSTMT_EXEC;;25766\n");
tmp = (*((file->optab)->dump_header))(file);
      }
      printf("\nSTMT_EXEC;;25768\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25770\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_decode_header(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_decode_header(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25775\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25778\n");
if ((file->optab)->decode_header)
    {
      {
        printf("\nSTMT_EXEC;;25781\n");
tmp = (*((file->optab)->decode_header))(file);
      }
      printf("\nSTMT_EXEC;;25783\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25785\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool tar_sparse_fixup_header(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;tar_sparse_fixup_header(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25790\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;25793\n");
if ((file->optab)->fixup_header)
    {
      {
        printf("\nSTMT_EXEC;;25796\n");
tmp = (*((file->optab)->fixup_header))(file);
      }
      printf("\nSTMT_EXEC;;25798\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
    }
    printf("\nSTMT_EXEC;;25800\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool lseek_or_error(struct tar_sparse_file *file, off_t offset, int whence)
{
  printf("\nFUNC_CALL;lseek_or_error(struct tar_sparse_file *,off_t,int);\n");
printf("\nSTMT_EXEC;;25805\n");
__off_t tmp;

  {
    {
      printf("\nSTMT_EXEC;;25809\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp = lseek(file->fd, offset, whence);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;25811\n");
if (tmp < 0L)
    {
      {
        printf("\nSTMT_EXEC;;25814\n");
seek_diag_details((char const *)(file->stat_info)->orig_file_name, offset);
      }
      printf("\nSTMT_EXEC;;25816\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;25818\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool zero_block_p(char *buffer___2, size_t size)
{
  printf("\nFUNC_CALL;zero_block_p(char *,size_t);\n");
printf("\nSTMT_EXEC;;25823\n");
char *tmp;
  printf("\nSTMT_EXEC;;25824\n");
size_t tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;25828\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;25831\n");
tmp___0 = size;
        printf("\nSTMT_EXEC;;25832\n");
size--;
        printf("\nSTMT_EXEC;;25833\n");
if (!tmp___0)
        {
          printf("\nSTMT_EXEC;;25835\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;25837\n");
tmp = buffer___2;
        printf("\nSTMT_EXEC;;25838\n");
buffer___2++;
        printf("\nSTMT_EXEC;;25839\n");
if (*tmp)
        {
          printf("\nSTMT_EXEC;;25841\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25846\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static void sparse_add_map(struct tar_sparse_file *file, struct sp_array *sp)
{
  printf("\nFUNC_CALL;sparse_add_map(struct tar_sparse_file *,struct sp_array *);\n");
printf("\nSTMT_EXEC;;25851\n");
void *tmp;
  printf("\nSTMT_EXEC;;25852\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;25853\n");
size_t tmp___1;

  {
    printf("\nSTMT_EXEC;;25856\n");
if ((unsigned long)(file->stat_info)->sparse_map == (unsigned long)((void *)0))
    {
      {
        printf("\nSTMT_EXEC;;25859\n");
tmp = xmalloc(21UL * sizeof(*((file->stat_info)->sparse_map + 0)));
        printf("\nSTMT_EXEC;;25860\n");
(file->stat_info)->sparse_map = (struct sp_array *)tmp;
        printf("\nSTMT_EXEC;;25861\n");
(file->stat_info)->sparse_map_size = (size_t)21;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;25866\n");
if ((file->stat_info)->sparse_map_avail == (file->stat_info)->sparse_map_size)
      {
        {
          printf("\nSTMT_EXEC;;25869\n");
(file->stat_info)->sparse_map_size *= 2UL;
          printf("\nSTMT_EXEC;;25870\n");
tmp___0 = xrealloc((void *)(file->stat_info)->sparse_map, (file->stat_info)->sparse_map_size * sizeof(*((file->stat_info)->sparse_map + 0)));
          printf("\nSTMT_EXEC;;25871\n");
(file->stat_info)->sparse_map = (struct sp_array *)tmp___0;
        }
      }
    }
    printf("\nSTMT_EXEC;;25875\n");
tmp___1 = (file->stat_info)->sparse_map_avail;
    printf("\nSTMT_EXEC;;25876\n");
((file->stat_info)->sparse_map_avail)++;
    printf("\nSTMT_EXEC;;25877\n");
*((file->stat_info)->sparse_map + tmp___1) = *sp;
    printf("\nSTMT_EXEC;;25878\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static char buffer___1[512];
static _Bool sparse_scan_file(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;sparse_scan_file(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25884\n");
size_t count;
  printf("\nSTMT_EXEC;;25885\n");
size_t offset;
  printf("\nSTMT_EXEC;;25886\n");
struct sp_array sp;
  printf("\nSTMT_EXEC;;25887\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;25888\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;25889\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;25890\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;25891\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;25892\n");
_Bool tmp___4;

  {
    {
      printf("\nSTMT_EXEC;;25896\n");
offset = (size_t)0;
      printf("\nSTMT_EXEC;;25897\n");
sp.offset = (off_t)0;
      printf("\nSTMT_EXEC;;25898\n");
sp.numbytes = (size_t)0;
      printf("\nSTMT_EXEC;;25899\n");
tmp = lseek_or_error(file, (off_t)0, 0);
    }
    printf("\nSTMT_EXEC;;25901\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;25903\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;25906\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(buffer___1), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;25907\n");
(file->stat_info)->sparse_map_size = (size_t)0;
      printf("\nSTMT_EXEC;;25908\n");
(file->stat_info)->archive_file_size = (off_t)0;
      printf("\nSTMT_EXEC;;25909\n");
tmp___0 = tar_sparse_scan(file, (enum sparse_scan_state)0, (void *)0);
    }
    printf("\nSTMT_EXEC;;25911\n");
if (!tmp___0)
    {
      printf("\nSTMT_EXEC;;25913\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;25916\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;25920\n");
count = safe_read(file->fd, (void *)(buffer___1), sizeof(buffer___1));
        }
        printf("\nSTMT_EXEC;;25922\n");
if (count != 0UL)
        {
          printf("\nSTMT_EXEC;;25924\n");
if (!(count != 0xffffffffffffffffUL))
          {
            printf("\nSTMT_EXEC;;25926\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;25931\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;25934\n");
tmp___3 = zero_block_p(buffer___1, count);
        }
        printf("\nSTMT_EXEC;;25936\n");
if (tmp___3)
        {
          printf("\nSTMT_EXEC;;25938\n");
if (sp.numbytes)
          {
            {
              printf("\nSTMT_EXEC;;25941\n");
sparse_add_map(file, &sp);
              printf("\nSTMT_EXEC;;25942\n");
sp.numbytes = (size_t)0;
              printf("\nSTMT_EXEC;;25943\n");
tmp___1 = tar_sparse_scan(file, (enum sparse_scan_state)1, (void *)0);
            }
            printf("\nSTMT_EXEC;;25945\n");
if (!tmp___1)
            {
              printf("\nSTMT_EXEC;;25947\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
            }
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;25953\n");
if (sp.numbytes == 0UL)
          {
            printf("\nSTMT_EXEC;;25955\n");
sp.offset = (off_t)offset;
          }
          {
            printf("\nSTMT_EXEC;;25958\n");
sp.numbytes += count;
            printf("\nSTMT_EXEC;;25959\n");
(file->stat_info)->archive_file_size = (off_t)((size_t)(file->stat_info)->archive_file_size + count);
            printf("\nSTMT_EXEC;;25960\n");
tmp___2 = tar_sparse_scan(file, (enum sparse_scan_state)1, (void *)(buffer___1));
          }
          printf("\nSTMT_EXEC;;25962\n");
if (!tmp___2)
          {
            printf("\nSTMT_EXEC;;25964\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
          }
        }
        {
          printf("\nSTMT_EXEC;;25968\n");
offset += count;
          printf("\nSTMT_EXEC;;25969\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(buffer___1), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;25974\n");
if (sp.numbytes == 0UL)
    {
      printf("\nSTMT_EXEC;;25976\n");
sp.offset = (off_t)offset;
    }
    {
      printf("\nSTMT_EXEC;;25979\n");
sparse_add_map(file, &sp);
      printf("\nSTMT_EXEC;;25980\n");
(file->stat_info)->archive_file_size = (off_t)((size_t)(file->stat_info)->archive_file_size + count);
      printf("\nSTMT_EXEC;;25981\n");
tmp___4 = tar_sparse_scan(file, (enum sparse_scan_state)2, (void *)0);
    }
    printf("\nSTMT_EXEC;;25983\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___4);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct tar_sparse_optab oldgnu_optab;
static struct tar_sparse_optab star_optab;
static struct tar_sparse_optab pax_optab;
static _Bool sparse_select_optab(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;sparse_select_optab(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;25991\n");
unsigned int tmp;

  {
    printf("\nSTMT_EXEC;;25994\n");
if ((unsigned int)current_format == 0U)
    {
      printf("\nSTMT_EXEC;;25996\n");
tmp = (unsigned int)archive_format;
    }
    else
    {
      printf("\nSTMT_EXEC;;26000\n");
tmp = (unsigned int)current_format;
    }
    {
      printf("\nSTMT_EXEC;;26003\n");
if (tmp == 1U)
      {
        printf("\nSTMT_EXEC;;26005\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;26007\n");
if (tmp == 3U)
      {
        printf("\nSTMT_EXEC;;26009\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;26011\n");
if (tmp == 2U)
      {
        printf("\nSTMT_EXEC;;26013\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;26015\n");
if (tmp == 6U)
      {
        printf("\nSTMT_EXEC;;26017\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;26019\n");
if (tmp == 4U)
      {
        printf("\nSTMT_EXEC;;26021\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;26023\n");
if (tmp == 5U)
      {
        printf("\nSTMT_EXEC;;26025\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;26027\n");
goto switch_default;
    case_1: /* CIL Label */
    case_3: /* CIL Label */
      {
printf("\nSTMT_EXEC;;26030\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
}

    case_2: /* CIL Label */
    case_6: /* CIL Label */
      {
printf("\nSTMT_EXEC;;26033\n");
file->optab = &oldgnu_optab;
}

      printf("\nSTMT_EXEC;;26034\n");
goto switch_break;
    case_4: /* CIL Label */
      {
printf("\nSTMT_EXEC;;26036\n");
file->optab = &pax_optab;
}

      printf("\nSTMT_EXEC;;26037\n");
goto switch_break;
    case_5: /* CIL Label */
      {
printf("\nSTMT_EXEC;;26039\n");
file->optab = &star_optab;
}

      printf("\nSTMT_EXEC;;26040\n");
goto switch_break;
    switch_default: /* CIL Label */
      {
printf("\nSTMT_EXEC;;26042\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
}

    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26045\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool sparse_dump_region(struct tar_sparse_file *file, size_t i)
{
  printf("\nFUNC_CALL;sparse_dump_region(struct tar_sparse_file *,size_t);\n");
printf("\nSTMT_EXEC;;26050\n");
union block *blk;
  printf("\nSTMT_EXEC;;26051\n");
off_t bytes_left;
  printf("\nSTMT_EXEC;;26052\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26053\n");
size_t bufsize;
  printf("\nSTMT_EXEC;;26054\n");
size_t bytes_read;
  printf("\nSTMT_EXEC;;26055\n");
off_t tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;26059\n");
bytes_left = (off_t)((file->stat_info)->sparse_map + i)->numbytes;
      printf("\nSTMT_EXEC;;26060\n");
tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
    }
    printf("\nSTMT_EXEC;;26062\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26064\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;26067\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26070\n");
if (!(bytes_left > 0L))
        {
          printf("\nSTMT_EXEC;;26072\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;26074\n");
if (bytes_left > 512L)
        {
          printf("\nSTMT_EXEC;;26076\n");
tmp___0 = (off_t)512;
        }
        else
        {
          printf("\nSTMT_EXEC;;26080\n");
tmp___0 = bytes_left;
        }
        {
          printf("\nSTMT_EXEC;;26083\n");
bufsize = (size_t)tmp___0;
          printf("\nSTMT_EXEC;;26084\n");
blk = find_next_block();
          printf("\nSTMT_EXEC;;26085\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;26086\n");
bytes_read = safe_read(file->fd, (void *)(blk->buffer), bufsize);
        }
        printf("\nSTMT_EXEC;;26088\n");
if (bytes_read == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;26091\n");
read_diag_details((char const *)(file->stat_info)->orig_file_name, (off_t)(((size_t)((file->stat_info)->sparse_map + i)->offset + ((file->stat_info)->sparse_map + i)->numbytes) - (size_t)bytes_left), bufsize);
          }
          printf("\nSTMT_EXEC;;26093\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;26096\n");
bytes_left = (off_t)((size_t)bytes_left - bytes_read);
          printf("\nSTMT_EXEC;;26097\n");
file->dumped_size += bytes_read;
          printf("\nSTMT_EXEC;;26098\n");
set_next_block_after(blk);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26103\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool sparse_extract_region(struct tar_sparse_file *file, size_t i)
{
  printf("\nFUNC_CALL;sparse_extract_region(struct tar_sparse_file *,size_t);\n");
printf("\nSTMT_EXEC;;26108\n");
size_t write_size;
  printf("\nSTMT_EXEC;;26109\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26110\n");
int tmp___0;
  printf("\nSTMT_EXEC;;26111\n");
size_t count;
  printf("\nSTMT_EXEC;;26112\n");
size_t wrbytes;
  printf("\nSTMT_EXEC;;26113\n");
union block *blk;
  printf("\nSTMT_EXEC;;26114\n");
union block *tmp___1;
  printf("\nSTMT_EXEC;;26115\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;26116\n");
char *__cil_tmp11;

  {
    {
      printf("\nSTMT_EXEC;;26120\n");
tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
    }
    printf("\nSTMT_EXEC;;26122\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26124\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;26126\n");
write_size = ((file->stat_info)->sparse_map + i)->numbytes;
    printf("\nSTMT_EXEC;;26127\n");
if (write_size == 0UL)
    {
      {
        printf("\nSTMT_EXEC;;26130\n");
tmp___0 = sys_truncate(file->fd);
      }
      printf("\nSTMT_EXEC;;26132\n");
if (tmp___0)
      {
        {
          printf("\nSTMT_EXEC;;26135\n");
truncate_warn((char const *)(file->stat_info)->orig_file_name);
        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;26142\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;26145\n");
if (!(write_size > 0UL))
          {
            printf("\nSTMT_EXEC;;26147\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;26149\n");
if (write_size > 512UL)
          {
            printf("\nSTMT_EXEC;;26151\n");
wrbytes = (size_t)512;
          }
          else
          {
            printf("\nSTMT_EXEC;;26155\n");
wrbytes = write_size;
          }
          {
            printf("\nSTMT_EXEC;;26158\n");
tmp___1 = find_next_block();
            printf("\nSTMT_EXEC;;26159\n");
blk = tmp___1;
          }
          printf("\nSTMT_EXEC;;26161\n");
if (!blk)
          {
            {
              printf("\nSTMT_EXEC;;26164\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;26165\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;26166\n");
exit_status = 2;
            }
            printf("\nSTMT_EXEC;;26168\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
          }
          {
            printf("\nSTMT_EXEC;;26171\n");
set_next_block_after(blk);
            printf("\nSTMT_EXEC;;26172\n");
count = full_write(file->fd, (void const *)(blk->buffer), wrbytes);
            printf("\nSTMT_EXEC;;26173\n");
write_size -= count;
            printf("\nSTMT_EXEC;;26174\n");
file->dumped_size += count;
          }
          printf("\nSTMT_EXEC;;26176\n");
if (count != wrbytes)
          {
            {
              printf("\nSTMT_EXEC;;26179\n");
write_error_details((char const *)(file->stat_info)->orig_file_name, count, wrbytes);
            }
            printf("\nSTMT_EXEC;;26181\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
          }
        }
      while_break: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;26187\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
enum dump_status sparse_dump_file(int fd, struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;sparse_dump_file(int,struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;26192\n");
_Bool rc___1;
  printf("\nSTMT_EXEC;;26193\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26194\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26195\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;26196\n");
size_t i;
  printf("\nSTMT_EXEC;;26197\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;26198\n");
int tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;26202\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26203\n");
file.fd = fd;
      printf("\nSTMT_EXEC;;26204\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26206\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;26209\n");
tmp___0 = tar_sparse_init(&file);
      }
      printf("\nSTMT_EXEC;;26211\n");
if (!tmp___0)
      {
        printf("\nSTMT_EXEC;;26213\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26218\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
    }
    {
      printf("\nSTMT_EXEC;;26221\n");
rc___1 = sparse_scan_file(&file);
    }
    printf("\nSTMT_EXEC;;26223\n");
if (rc___1)
    {
      printf("\nSTMT_EXEC;;26225\n");
if ((file.optab)->dump_region)
      {
        {
          printf("\nSTMT_EXEC;;26228\n");
tar_sparse_dump_header(&file);
        }
        printf("\nSTMT_EXEC;;26230\n");
if (fd >= 0)
        {
          printf("\nSTMT_EXEC;;26232\n");
i = (size_t)0;
          {
            printf("\nSTMT_EXEC;;26234\n");
while (1)
            {
            while_continue: /* CIL Label */;
              printf("\nSTMT_EXEC;;26237\n");
if (rc___1)
              {
                printf("\nSTMT_EXEC;;26239\n");
if (!(i < (file.stat_info)->sparse_map_avail))
                {
                  printf("\nSTMT_EXEC;;26241\n");
goto while_break;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;26246\n");
goto while_break;
              }
              {
                printf("\nSTMT_EXEC;;26249\n");
rc___1 = tar_sparse_dump_region(&file, i);
                printf("\nSTMT_EXEC;;26250\n");
i++;
              }
            }
          while_break: /* CIL Label */;
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;26259\n");
pad_archive((off_t)((size_t)(file.stat_info)->archive_file_size - file.dumped_size));
      printf("\nSTMT_EXEC;;26260\n");
tmp___1 = tar_sparse_done(&file);
    }
    printf("\nSTMT_EXEC;;26262\n");
if (tmp___1)
    {
      printf("\nSTMT_EXEC;;26264\n");
if (rc___1)
      {
        printf("\nSTMT_EXEC;;26266\n");
tmp___2 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;26270\n");
tmp___2 = 1;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26275\n");
tmp___2 = 1;
    }
    printf("\nSTMT_EXEC;;26277\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)tmp___2);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sparse_file_p(struct tar_stat_info *st)
{

  printf("\nFUNC_CALL;sparse_file_p(struct tar_stat_info *);\n");
{
    printf("\nSTMT_EXEC;;26284\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(st->stat.st_blocks < st->stat.st_size / 512L + (__off_t)(st->stat.st_size % 512L != 0L)));
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sparse_member_p(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;sparse_member_p(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;26289\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26290\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26291\n");
_Bool tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;26295\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26297\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26299\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;26302\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26303\n");
tmp___0 = tar_sparse_member_p(&file);
    }
    printf("\nSTMT_EXEC;;26305\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sparse_fixup_header(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;sparse_fixup_header(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;26310\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26311\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26312\n");
_Bool tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;26316\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26318\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26320\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;26323\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26324\n");
tmp___0 = tar_sparse_fixup_header(&file);
    }
    printf("\nSTMT_EXEC;;26326\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
enum dump_status sparse_extract_file(int fd, struct tar_stat_info *st, off_t *size)
{
  printf("\nFUNC_CALL;sparse_extract_file(int,struct tar_stat_info *,off_t *);\n");
printf("\nSTMT_EXEC;;26331\n");
_Bool rc___1;
  printf("\nSTMT_EXEC;;26332\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26333\n");
size_t i;
  printf("\nSTMT_EXEC;;26334\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26335\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;26336\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;26337\n");
int tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;26341\n");
rc___1 = (_Bool)1;
      printf("\nSTMT_EXEC;;26342\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26343\n");
file.fd = fd;
      printf("\nSTMT_EXEC;;26344\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26346\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;26349\n");
tmp___0 = tar_sparse_init(&file);
      }
      printf("\nSTMT_EXEC;;26351\n");
if (!tmp___0)
      {
        printf("\nSTMT_EXEC;;26353\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26358\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
    }
    {
      printf("\nSTMT_EXEC;;26361\n");
rc___1 = tar_sparse_decode_header(&file);
      printf("\nSTMT_EXEC;;26362\n");
i = (size_t)0;
    }
    {
      printf("\nSTMT_EXEC;;26365\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26368\n");
if (rc___1)
        {
          printf("\nSTMT_EXEC;;26370\n");
if (!(i < (file.stat_info)->sparse_map_avail))
          {
            printf("\nSTMT_EXEC;;26372\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;26377\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;26380\n");
rc___1 = tar_sparse_extract_region(&file, i);
          printf("\nSTMT_EXEC;;26381\n");
i++;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;26387\n");
*size = (off_t)((size_t)(file.stat_info)->archive_file_size - file.dumped_size);
      printf("\nSTMT_EXEC;;26388\n");
tmp___1 = tar_sparse_done(&file);
    }
    printf("\nSTMT_EXEC;;26390\n");
if (tmp___1)
    {
      printf("\nSTMT_EXEC;;26392\n");
if (rc___1)
      {
        printf("\nSTMT_EXEC;;26394\n");
tmp___2 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;26398\n");
tmp___2 = 1;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26403\n");
tmp___2 = 1;
    }
    printf("\nSTMT_EXEC;;26405\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)tmp___2);
  }
printf("\nFUNC_RETURN;;\n");
}
enum dump_status sparse_skip_file(struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;sparse_skip_file(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;26410\n");
_Bool rc___1;
  printf("\nSTMT_EXEC;;26411\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26412\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26413\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;26414\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;26415\n");
int tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;26419\n");
rc___1 = (_Bool)1;
      printf("\nSTMT_EXEC;;26420\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26421\n");
file.fd = -1;
      printf("\nSTMT_EXEC;;26422\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26424\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;26427\n");
tmp___0 = tar_sparse_init(&file);
      }
      printf("\nSTMT_EXEC;;26429\n");
if (!tmp___0)
      {
        printf("\nSTMT_EXEC;;26431\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26436\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)3);
    }
    {
      printf("\nSTMT_EXEC;;26439\n");
rc___1 = tar_sparse_decode_header(&file);
      printf("\nSTMT_EXEC;;26440\n");
skip_file((file.stat_info)->archive_file_size);
      printf("\nSTMT_EXEC;;26441\n");
tmp___1 = tar_sparse_done(&file);
    }
    printf("\nSTMT_EXEC;;26443\n");
if (tmp___1)
    {
      printf("\nSTMT_EXEC;;26445\n");
if (rc___1)
      {
        printf("\nSTMT_EXEC;;26447\n");
tmp___2 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;26451\n");
tmp___2 = 1;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26456\n");
tmp___2 = 1;
    }
    printf("\nSTMT_EXEC;;26458\n");
printf("\nFUNC_RETURN;;\n");
return ((enum dump_status)tmp___2);
  }
printf("\nFUNC_RETURN;;\n");
}
static char diff_buffer___0[512];
static _Bool check_sparse_region(struct tar_sparse_file *file, off_t beg, off_t end)
{
  printf("\nFUNC_CALL;check_sparse_region(struct tar_sparse_file *,off_t,off_t);\n");
printf("\nSTMT_EXEC;;26464\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26465\n");
size_t bytes_read;
  printf("\nSTMT_EXEC;;26466\n");
size_t rdsize;
  printf("\nSTMT_EXEC;;26467\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;26468\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;26469\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;26473\n");
tmp = lseek_or_error(file, beg, 0);
    }
    printf("\nSTMT_EXEC;;26475\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26477\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    {
      printf("\nSTMT_EXEC;;26480\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26483\n");
if (!(beg < end))
        {
          printf("\nSTMT_EXEC;;26485\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;26487\n");
rdsize = (size_t)(end - beg);
        printf("\nSTMT_EXEC;;26488\n");
if (rdsize > 512UL)
        {
          printf("\nSTMT_EXEC;;26490\n");
rdsize = (size_t)512;
        }
        {
          printf("\nSTMT_EXEC;;26493\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(diff_buffer___0), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;26494\n");
bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
        }
        printf("\nSTMT_EXEC;;26496\n");
if (bytes_read == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;26499\n");
read_diag_details((char const *)(file->stat_info)->orig_file_name, beg, rdsize);
          }
          printf("\nSTMT_EXEC;;26501\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;26504\n");
tmp___1 = zero_block_p(diff_buffer___0, bytes_read);
        }
        printf("\nSTMT_EXEC;;26506\n");
if (!tmp___1)
        {
          {
            printf("\nSTMT_EXEC;;26509\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("File fragment at %lu is not a hole");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26510\n");
report_difference(file->stat_info, (char const *)tmp___0, beg);
          }
          printf("\nSTMT_EXEC;;26512\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        printf("\nSTMT_EXEC;;26514\n");
beg = (off_t)((size_t)beg + bytes_read);
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26518\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool check_data_region(struct tar_sparse_file *file, size_t i)
{
  printf("\nFUNC_CALL;check_data_region(struct tar_sparse_file *,size_t);\n");
printf("\nSTMT_EXEC;;26523\n");
size_t size_left;
  printf("\nSTMT_EXEC;;26524\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26525\n");
size_t bytes_read;
  printf("\nSTMT_EXEC;;26526\n");
size_t rdsize;
  printf("\nSTMT_EXEC;;26527\n");
union block *blk;
  printf("\nSTMT_EXEC;;26528\n");
union block *tmp___0;
  printf("\nSTMT_EXEC;;26529\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;26530\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;26531\n");
int tmp___3;
  printf("\nSTMT_EXEC;;26532\n");
char *__cil_tmp12;
  printf("\nSTMT_EXEC;;26533\n");
char *__cil_tmp13;

  {
    {
      printf("\nSTMT_EXEC;;26537\n");
tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
    }
    printf("\nSTMT_EXEC;;26539\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;26541\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;26543\n");
size_left = ((file->stat_info)->sparse_map + i)->numbytes;
    {
      printf("\nSTMT_EXEC;;26545\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26548\n");
if (!(size_left > 0UL))
        {
          printf("\nSTMT_EXEC;;26550\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;26552\n");
if (size_left > 512UL)
        {
          printf("\nSTMT_EXEC;;26554\n");
rdsize = (size_t)512;
        }
        else
        {
          printf("\nSTMT_EXEC;;26558\n");
rdsize = size_left;
        }
        {
          printf("\nSTMT_EXEC;;26561\n");
tmp___0 = find_next_block();
          printf("\nSTMT_EXEC;;26562\n");
blk = tmp___0;
        }
        printf("\nSTMT_EXEC;;26564\n");
if (!blk)
        {
          {
            printf("\nSTMT_EXEC;;26567\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26568\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26569\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;26571\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;26574\n");
set_next_block_after(blk);
          printf("\nSTMT_EXEC;;26575\n");
bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
        }
        printf("\nSTMT_EXEC;;26577\n");
if (bytes_read == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;26580\n");
read_diag_details((char const *)(file->stat_info)->orig_file_name, (off_t)(((size_t)((file->stat_info)->sparse_map + i)->offset + ((file->stat_info)->sparse_map + i)->numbytes) - size_left), rdsize);
          }
          printf("\nSTMT_EXEC;;26582\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;26585\n");
file->dumped_size += bytes_read;
          printf("\nSTMT_EXEC;;26586\n");
size_left -= bytes_read;
          printf("\nSTMT_EXEC;;26587\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___3 = memcmp((void const *)(blk->buffer), (void const *)(diff_buffer___0), rdsize);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;26589\n");
if (tmp___3)
        {
          {
            printf("\nSTMT_EXEC;;26592\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Contents differ");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26593\n");
report_difference(file->stat_info, (char const *)tmp___2);
          }
          printf("\nSTMT_EXEC;;26595\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26600\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sparse_diff_file(int fd, struct tar_stat_info *st)
{
  printf("\nFUNC_CALL;sparse_diff_file(int,struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;26605\n");
_Bool rc___1;
  printf("\nSTMT_EXEC;;26606\n");
struct tar_sparse_file file;
  printf("\nSTMT_EXEC;;26607\n");
size_t i;
  printf("\nSTMT_EXEC;;26608\n");
off_t offset;
  printf("\nSTMT_EXEC;;26609\n");
_Bool tmp;
  printf("\nSTMT_EXEC;;26610\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;26611\n");
_Bool tmp___1;
  printf("\nSTMT_EXEC;;26612\n");
_Bool tmp___2;
  printf("\nSTMT_EXEC;;26613\n");
int tmp___3;

  {
    {
      printf("\nSTMT_EXEC;;26617\n");
rc___1 = (_Bool)1;
      printf("\nSTMT_EXEC;;26618\n");
offset = (off_t)0;
      printf("\nSTMT_EXEC;;26619\n");
file.stat_info = st;
      printf("\nSTMT_EXEC;;26620\n");
file.fd = fd;
      printf("\nSTMT_EXEC;;26621\n");
tmp = sparse_select_optab(&file);
    }
    printf("\nSTMT_EXEC;;26623\n");
if (tmp)
    {
      {
        printf("\nSTMT_EXEC;;26626\n");
tmp___0 = tar_sparse_init(&file);
      }
      printf("\nSTMT_EXEC;;26628\n");
if (!tmp___0)
      {
        printf("\nSTMT_EXEC;;26630\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;26635\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    {
      printf("\nSTMT_EXEC;;26638\n");
rc___1 = tar_sparse_decode_header(&file);
      printf("\nSTMT_EXEC;;26639\n");
i = (size_t)0;
    }
    {
      printf("\nSTMT_EXEC;;26642\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26645\n");
if (rc___1)
        {
          printf("\nSTMT_EXEC;;26647\n");
if (!(i < (file.stat_info)->sparse_map_avail))
          {
            printf("\nSTMT_EXEC;;26649\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;26654\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;26657\n");
tmp___1 = check_sparse_region(&file, offset, ((file.stat_info)->sparse_map + i)->offset);
        }
        printf("\nSTMT_EXEC;;26659\n");
if (tmp___1)
        {
          {
            printf("\nSTMT_EXEC;;26662\n");
tmp___2 = check_data_region(&file, i);
          }
          printf("\nSTMT_EXEC;;26664\n");
if (tmp___2)
          {
            printf("\nSTMT_EXEC;;26666\n");
tmp___3 = 1;
          }
          else
          {
            printf("\nSTMT_EXEC;;26670\n");
tmp___3 = 0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;26675\n");
tmp___3 = 0;
        }
        printf("\nSTMT_EXEC;;26677\n");
rc___1 = (_Bool)tmp___3;
        printf("\nSTMT_EXEC;;26678\n");
offset = (off_t)((size_t)((file.stat_info)->sparse_map + i)->offset + ((file.stat_info)->sparse_map + i)->numbytes);
        printf("\nSTMT_EXEC;;26679\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26683\n");
if (!rc___1)
    {
      {
        printf("\nSTMT_EXEC;;26686\n");
skip_file((off_t)((size_t)(file.stat_info)->archive_file_size - file.dumped_size));
      }
    }
    {
      printf("\nSTMT_EXEC;;26690\n");
tar_sparse_done(&file);
    }
    printf("\nSTMT_EXEC;;26692\n");
printf("\nFUNC_RETURN;;\n");
return (rc___1);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool oldgnu_sparse_member_p(struct tar_sparse_file *file __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;oldgnu_sparse_member_p(struct tar_sparse_file *);\n");
{
    printf("\nSTMT_EXEC;;26699\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)((int)current_header->header.typeflag == 83));
  }
printf("\nFUNC_RETURN;;\n");
}
static enum oldgnu_add_status oldgnu_add_sparse(struct tar_sparse_file *file, struct sparse *s)
{
  printf("\nFUNC_CALL;oldgnu_add_sparse(struct tar_sparse_file *,struct sparse *);\n");
printf("\nSTMT_EXEC;;26704\n");
struct sp_array sp;

  {
    printf("\nSTMT_EXEC;;26707\n");
if ((int)s->numbytes[0] == 0)
    {
      printf("\nSTMT_EXEC;;26709\n");
printf("\nFUNC_RETURN;;\n");
return ((enum oldgnu_add_status)1);
    }
    {
      printf("\nSTMT_EXEC;;26712\n");
sp.offset = off_from_header((char const *)(s->offset), sizeof(s->offset));
      printf("\nSTMT_EXEC;;26713\n");
sp.numbytes = size_from_header((char const *)(s->numbytes), sizeof(s->numbytes));
    }
    printf("\nSTMT_EXEC;;26715\n");
if (sp.offset < 0L)
    {
      printf("\nSTMT_EXEC;;26717\n");
printf("\nFUNC_RETURN;;\n");
return ((enum oldgnu_add_status)2);
    }
    else
    {
      printf("\nSTMT_EXEC;;26721\n");
if ((size_t)(file->stat_info)->stat.st_size < (size_t)sp.offset + sp.numbytes)
      {
        printf("\nSTMT_EXEC;;26723\n");
printf("\nFUNC_RETURN;;\n");
return ((enum oldgnu_add_status)2);
      }
      else
      {
        printf("\nSTMT_EXEC;;26727\n");
if ((file->stat_info)->archive_file_size < 0L)
        {
          printf("\nSTMT_EXEC;;26729\n");
printf("\nFUNC_RETURN;;\n");
return ((enum oldgnu_add_status)2);
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;26734\n");
sparse_add_map(file, &sp);
    }
    printf("\nSTMT_EXEC;;26736\n");
printf("\nFUNC_RETURN;;\n");
return ((enum oldgnu_add_status)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool oldgnu_fixup_header(struct tar_sparse_file *file)
{

  printf("\nFUNC_CALL;oldgnu_fixup_header(struct tar_sparse_file *);\n");
{
    {
      printf("\nSTMT_EXEC;;26744\n");
(file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
      printf("\nSTMT_EXEC;;26745\n");
(file->stat_info)->stat.st_size = off_from_header((char const *)(current_header->oldgnu_header.realsize), sizeof(current_header->oldgnu_header.realsize));
    }
    printf("\nSTMT_EXEC;;26747\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static enum oldgnu_add_status rc;
static _Bool oldgnu_get_sparse_info(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;oldgnu_get_sparse_info(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;26753\n");
size_t i;
  printf("\nSTMT_EXEC;;26754\n");
union block *h;
  printf("\nSTMT_EXEC;;26755\n");
int ext_p;
  printf("\nSTMT_EXEC;;26756\n");
char *tmp;
  printf("\nSTMT_EXEC;;26757\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;26758\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;26759\n");
char *__cil_tmp8;

  {
    printf("\nSTMT_EXEC;;26762\n");
h = current_header;
    printf("\nSTMT_EXEC;;26763\n");
(file->stat_info)->sparse_map_size = (size_t)0;
    printf("\nSTMT_EXEC;;26764\n");
i = (size_t)0;
    {
      printf("\nSTMT_EXEC;;26766\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26769\n");
if (!(i < 4UL))
        {
          printf("\nSTMT_EXEC;;26771\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;26774\n");
rc = oldgnu_add_sparse(file, &h->oldgnu_header.sp[i]);
        }
        printf("\nSTMT_EXEC;;26776\n");
if ((unsigned int)rc != 0U)
        {
          printf("\nSTMT_EXEC;;26778\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;26780\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26784\n");
ext_p = (int)h->oldgnu_header.isextended;
    {
      printf("\nSTMT_EXEC;;26786\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;26789\n");
if ((unsigned int)rc == 0U)
        {
          printf("\nSTMT_EXEC;;26791\n");
if (!ext_p)
          {
            printf("\nSTMT_EXEC;;26793\n");
goto while_break___0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;26798\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;26801\n");
h = find_next_block();
        }
        printf("\nSTMT_EXEC;;26803\n");
if (!h)
        {
          {
            printf("\nSTMT_EXEC;;26806\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26807\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;26808\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;26810\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;26813\n");
set_next_block_after(h);
          printf("\nSTMT_EXEC;;26814\n");
i = (size_t)0;
        }
        {
          printf("\nSTMT_EXEC;;26817\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;26820\n");
if (i < 21UL)
            {
              printf("\nSTMT_EXEC;;26822\n");
if (!((unsigned int)rc == 0U))
              {
                printf("\nSTMT_EXEC;;26824\n");
goto while_break___1;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;26829\n");
goto while_break___1;
            }
            {
              printf("\nSTMT_EXEC;;26832\n");
rc = oldgnu_add_sparse(file, &h->sparse_header.sp[i]);
              printf("\nSTMT_EXEC;;26833\n");
i++;
            }
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;26838\n");
ext_p = (int)h->sparse_header.isextended;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26842\n");
if ((unsigned int)rc == 2U)
    {
      {
        printf("\nSTMT_EXEC;;26845\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: invalid sparse archive member");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;26846\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, (file->stat_info)->orig_file_name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;26847\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;26849\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;26851\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static void oldgnu_store_sparse_info(struct tar_sparse_file *file, size_t *pindex, struct sparse *sp, size_t sparse_size)
{

  printf("\nFUNC_CALL;oldgnu_store_sparse_info(struct tar_sparse_file *,size_t *,struct sparse *,size_t);\n");
{
    {
      printf("\nSTMT_EXEC;;26859\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26862\n");
if (*pindex < (file->stat_info)->sparse_map_avail)
        {
          printf("\nSTMT_EXEC;;26864\n");
if (!(sparse_size > 0UL))
          {
            printf("\nSTMT_EXEC;;26866\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;26871\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;26874\n");
off_to_chars(((file->stat_info)->sparse_map + *pindex)->offset, sp->offset, sizeof(sp->offset));
          printf("\nSTMT_EXEC;;26875\n");
size_to_chars(((file->stat_info)->sparse_map + *pindex)->numbytes, sp->numbytes, sizeof(sp->numbytes));
          printf("\nSTMT_EXEC;;26876\n");
sparse_size--;
          printf("\nSTMT_EXEC;;26877\n");
sp++;
          printf("\nSTMT_EXEC;;26878\n");
(*pindex)++;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26883\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool oldgnu_dump_header(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;oldgnu_dump_header(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;26888\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;26889\n");
off_t tmp;
  printf("\nSTMT_EXEC;;26890\n");
union block *blk;
  printf("\nSTMT_EXEC;;26891\n");
size_t i;

  {
    {
      printf("\nSTMT_EXEC;;26895\n");
tmp = current_block_ordinal();
      printf("\nSTMT_EXEC;;26896\n");
block_ordinal = tmp;
      printf("\nSTMT_EXEC;;26897\n");
blk = start_header(file->stat_info);
      printf("\nSTMT_EXEC;;26898\n");
blk->header.typeflag = (char)'S';
    }
    printf("\nSTMT_EXEC;;26900\n");
if ((file->stat_info)->sparse_map_avail > 4UL)
    {
      printf("\nSTMT_EXEC;;26902\n");
blk->oldgnu_header.isextended = (char)1;
    }
    {
      printf("\nSTMT_EXEC;;26905\n");
off_to_chars((file->stat_info)->stat.st_size, blk->oldgnu_header.realsize, sizeof(blk->oldgnu_header.realsize));
      printf("\nSTMT_EXEC;;26906\n");
off_to_chars((file->stat_info)->archive_file_size, blk->header.size, sizeof(blk->header.size));
      printf("\nSTMT_EXEC;;26907\n");
i = (size_t)0;
      printf("\nSTMT_EXEC;;26908\n");
oldgnu_store_sparse_info(file, &i, blk->oldgnu_header.sp, (size_t)4);
      printf("\nSTMT_EXEC;;26909\n");
blk->oldgnu_header.isextended = (char)(i < (file->stat_info)->sparse_map_avail);
      printf("\nSTMT_EXEC;;26910\n");
finish_header(file->stat_info, blk, block_ordinal);
    }
    {
      printf("\nSTMT_EXEC;;26913\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;26916\n");
if (!(i < (file->stat_info)->sparse_map_avail))
        {
          printf("\nSTMT_EXEC;;26918\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;26921\n");
blk = find_next_block();
          printf("\nSTMT_EXEC;;26922\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(blk->buffer), 0, (size_t)512);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;26923\n");
oldgnu_store_sparse_info(file, &i, blk->sparse_header.sp, (size_t)21);
          printf("\nSTMT_EXEC;;26924\n");
set_next_block_after(blk);
        }
        printf("\nSTMT_EXEC;;26926\n");
if (i < (file->stat_info)->sparse_map_avail)
        {
          printf("\nSTMT_EXEC;;26928\n");
blk->sparse_header.isextended = (char)1;
        }
        else
        {
          printf("\nSTMT_EXEC;;26932\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;26937\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct tar_sparse_optab oldgnu_optab = {(_Bool(*)(struct tar_sparse_file *))((void *)0), (_Bool(*)(struct tar_sparse_file *))((void *)0), &oldgnu_sparse_member_p, &oldgnu_dump_header, &oldgnu_fixup_header, &oldgnu_get_sparse_info, (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))((void *)0), &sparse_dump_region, &sparse_extract_region};
static _Bool star_sparse_member_p(struct tar_sparse_file *file __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;star_sparse_member_p(struct tar_sparse_file *);\n");
{
    printf("\nSTMT_EXEC;;26945\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)((int)current_header->header.typeflag == 83));
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool star_fixup_header(struct tar_sparse_file *file)
{

  printf("\nFUNC_CALL;star_fixup_header(struct tar_sparse_file *);\n");
{
    {
      printf("\nSTMT_EXEC;;26953\n");
(file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
      printf("\nSTMT_EXEC;;26954\n");
(file->stat_info)->stat.st_size = off_from_header((char const *)(current_header->star_in_header.realsize), sizeof(current_header->star_in_header.realsize));
    }
    printf("\nSTMT_EXEC;;26956\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static enum oldgnu_add_status rc___0;
static _Bool star_get_sparse_info(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;star_get_sparse_info(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;26962\n");
size_t i;
  printf("\nSTMT_EXEC;;26963\n");
union block *h;
  printf("\nSTMT_EXEC;;26964\n");
int ext_p;
  printf("\nSTMT_EXEC;;26965\n");
char *tmp;
  printf("\nSTMT_EXEC;;26966\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;26967\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;26968\n");
char *__cil_tmp8;

  {
    printf("\nSTMT_EXEC;;26971\n");
h = current_header;
    printf("\nSTMT_EXEC;;26972\n");
(file->stat_info)->sparse_map_size = (size_t)0;
    printf("\nSTMT_EXEC;;26973\n");
if ((int)h->star_in_header.prefix[0] == 0)
    {
      printf("\nSTMT_EXEC;;26975\n");
if ((int)h->star_in_header.sp[0].offset[10] != 0)
      {
        printf("\nSTMT_EXEC;;26977\n");
i = (size_t)0;
        {
          printf("\nSTMT_EXEC;;26979\n");
while (1)
          {
          while_continue: /* CIL Label */;
            printf("\nSTMT_EXEC;;26982\n");
if (!(i < 4UL))
            {
              printf("\nSTMT_EXEC;;26984\n");
goto while_break;
            }
            {
              printf("\nSTMT_EXEC;;26987\n");
rc___0 = oldgnu_add_sparse(file, &h->star_in_header.sp[i]);
            }
            printf("\nSTMT_EXEC;;26989\n");
if ((unsigned int)rc___0 != 0U)
            {
              printf("\nSTMT_EXEC;;26991\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;26993\n");
i++;
          }
        while_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;26997\n");
ext_p = (int)h->star_in_header.isextended;
      }
      else
      {
        printf("\nSTMT_EXEC;;27001\n");
ext_p = 1;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;27006\n");
ext_p = 1;
    }
    {
      printf("\nSTMT_EXEC;;27009\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;27012\n");
if ((unsigned int)rc___0 == 0U)
        {
          printf("\nSTMT_EXEC;;27014\n");
if (!ext_p)
          {
            printf("\nSTMT_EXEC;;27016\n");
goto while_break___0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;27021\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;27024\n");
h = find_next_block();
        }
        printf("\nSTMT_EXEC;;27026\n");
if (!h)
        {
          {
            printf("\nSTMT_EXEC;;27029\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Unexpected EOF in archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27030\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27031\n");
exit_status = 2;
          }
          printf("\nSTMT_EXEC;;27033\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        {
          printf("\nSTMT_EXEC;;27036\n");
set_next_block_after(h);
          printf("\nSTMT_EXEC;;27037\n");
i = (size_t)0;
        }
        {
          printf("\nSTMT_EXEC;;27040\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;27043\n");
if (i < 21UL)
            {
              printf("\nSTMT_EXEC;;27045\n");
if (!((unsigned int)rc___0 == 0U))
              {
                printf("\nSTMT_EXEC;;27047\n");
goto while_break___1;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;27052\n");
goto while_break___1;
            }
            {
              printf("\nSTMT_EXEC;;27055\n");
rc___0 = oldgnu_add_sparse(file, &h->star_ext_header.sp[i]);
              printf("\nSTMT_EXEC;;27056\n");
i++;
            }
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;27061\n");
ext_p = (int)h->star_ext_header.isextended;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;27065\n");
if ((unsigned int)rc___0 == 2U)
    {
      {
        printf("\nSTMT_EXEC;;27068\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: invalid sparse archive member");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27069\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, (file->stat_info)->orig_file_name);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27070\n");
exit_status = 2;
      }
      printf("\nSTMT_EXEC;;27072\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;27074\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct tar_sparse_optab star_optab = {(_Bool(*)(struct tar_sparse_file *))((void *)0), (_Bool(*)(struct tar_sparse_file *))((void *)0), &star_sparse_member_p, (_Bool(*)(struct tar_sparse_file *))((void *)0), &star_fixup_header, &star_get_sparse_info, (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))((void *)0), (_Bool(*)(struct tar_sparse_file *, size_t))((void *)0), &sparse_extract_region};
static _Bool pax_sparse_member_p(struct tar_sparse_file *file)
{

  printf("\nFUNC_CALL;pax_sparse_member_p(struct tar_sparse_file *);\n");
{
    printf("\nSTMT_EXEC;;27082\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)((file->stat_info)->archive_file_size != (file->stat_info)->stat.st_size));
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool pax_dump_header(struct tar_sparse_file *file)
{
  printf("\nFUNC_CALL;pax_dump_header(struct tar_sparse_file *);\n");
printf("\nSTMT_EXEC;;27087\n");
off_t block_ordinal;
  printf("\nSTMT_EXEC;;27088\n");
off_t tmp;
  printf("\nSTMT_EXEC;;27089\n");
union block *blk;
  printf("\nSTMT_EXEC;;27090\n");
size_t i;
  printf("\nSTMT_EXEC;;27091\n");
char *__cil_tmp6;
  printf("\nSTMT_EXEC;;27092\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;27093\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;27094\n");
char *__cil_tmp9;

  {
    {
      printf("\nSTMT_EXEC;;27098\n");
tmp = current_block_ordinal();
      printf("\nSTMT_EXEC;;27099\n");
block_ordinal = tmp;
      printf("\nSTMT_EXEC;;27100\n");
xheader_store("GNU.sparse.size", (struct tar_stat_info const *)file->stat_info, (void *)0);
      printf("\nSTMT_EXEC;;27101\n");
xheader_store("GNU.sparse.numblocks", (struct tar_stat_info const *)file->stat_info, (void *)0);
      printf("\nSTMT_EXEC;;27102\n");
i = (size_t)0;
    }
    {
      printf("\nSTMT_EXEC;;27105\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;27108\n");
if (!(i < (file->stat_info)->sparse_map_avail))
        {
          printf("\nSTMT_EXEC;;27110\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;27113\n");
xheader_store("GNU.sparse.offset", (struct tar_stat_info const *)file->stat_info, (void *)(&i));
          printf("\nSTMT_EXEC;;27114\n");
xheader_store("GNU.sparse.numbytes", (struct tar_stat_info const *)file->stat_info, (void *)(&i));
          printf("\nSTMT_EXEC;;27115\n");
i++;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;27121\n");
blk = start_header(file->stat_info);
      printf("\nSTMT_EXEC;;27122\n");
off_to_chars((file->stat_info)->archive_file_size, blk->header.size, sizeof(blk->header.size));
      printf("\nSTMT_EXEC;;27123\n");
finish_header(file->stat_info, blk, block_ordinal);
    }
    printf("\nSTMT_EXEC;;27125\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct tar_sparse_optab pax_optab = {(_Bool(*)(struct tar_sparse_file *))((void *)0), (_Bool(*)(struct tar_sparse_file *))((void *)0), &pax_sparse_member_p, &pax_dump_header, (_Bool(*)(struct tar_sparse_file *))((void *)0), (_Bool(*)(struct tar_sparse_file *))((void *)0), (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))((void *)0), &sparse_dump_region, &sparse_extract_region};
/* #pragma merger("0","00d.system.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) execlp)(char const *__file, char const *__arg, ...);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) setuid)(__uid_t __uid);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) setgid)(__gid_t __gid);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) ftruncate)(int __fd, __off_t __length);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) kill)(__pid_t __pid, int __sig);
extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options);
extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__)) exit)(int __status);
dev_t ar_dev;
ino_t ar_ino;
void sys_stat_nanoseconds(struct tar_stat_info *st)
{

  printf("\nFUNC_CALL;sys_stat_nanoseconds(struct tar_stat_info *);\n");
{
    printf("\nSTMT_EXEC;;27143\n");
st->atime_nsec = (unsigned long)st->stat.st_atim.tv_nsec;
    printf("\nSTMT_EXEC;;27144\n");
st->mtime_nsec = (unsigned long)st->stat.st_mtim.tv_nsec;
    printf("\nSTMT_EXEC;;27145\n");
st->ctime_nsec = (unsigned long)st->stat.st_ctim.tv_nsec;
    printf("\nSTMT_EXEC;;27146\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static struct stat archive_stat;
_Bool sys_get_archive_stat(void)
{
  printf("\nFUNC_CALL;sys_get_archive_stat();\n");
printf("\nSTMT_EXEC;;27152\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;27156\n");
printf("\nFUNC_CALL;fstat(int,struct stat *);\n");
tmp = fstat(archive, &archive_stat);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27158\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(tmp == 0));
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sys_file_is_archive(struct tar_stat_info *p)
{
  printf("\nFUNC_CALL;sys_file_is_archive(struct tar_stat_info *);\n");
printf("\nSTMT_EXEC;;27163\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;27166\n");
if (ar_dev)
    {
      printf("\nSTMT_EXEC;;27168\n");
if (p->stat.st_dev == ar_dev)
      {
        printf("\nSTMT_EXEC;;27170\n");
if (p->stat.st_ino == ar_ino)
        {
          printf("\nSTMT_EXEC;;27172\n");
tmp = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;27176\n");
tmp = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;27181\n");
tmp = 0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;27186\n");
tmp = 0;
    }
    printf("\nSTMT_EXEC;;27188\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
void sys_save_archive_dev_ino(void)
{

  printf("\nFUNC_CALL;sys_save_archive_dev_ino();\n");
{
    printf("\nSTMT_EXEC;;27195\n");
if (!(archive >= 1 << 30))
    {
      printf("\nSTMT_EXEC;;27197\n");
if ((archive_stat.st_mode & 61440U) == 32768U)
      {
        printf("\nSTMT_EXEC;;27199\n");
ar_dev = archive_stat.st_dev;
        printf("\nSTMT_EXEC;;27200\n");
ar_ino = archive_stat.st_ino;
      }
      else
      {
        printf("\nSTMT_EXEC;;27204\n");
ar_dev = (dev_t)0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;27209\n");
ar_dev = (dev_t)0;
    }
    printf("\nSTMT_EXEC;;27211\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static char const dev_null[10] = {(char const)'/', (char const)'d', (char const)'e', (char const)'v', (char const)'/', (char const)'n', (char const)'u', (char const)'l', (char const)'l', (char const)'\000'};
void sys_detect_dev_null_output(void)
{
  printf("\nFUNC_CALL;sys_detect_dev_null_output();\n");
printf("\nSTMT_EXEC;;27217\n");
struct stat dev_null_stat;
  printf("\nSTMT_EXEC;;27218\n");
int tmp;
  printf("\nSTMT_EXEC;;27219\n");
int tmp___0;
  printf("\nSTMT_EXEC;;27220\n");
int tmp___1;
  printf("\nSTMT_EXEC;;27221\n");
void *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;27225\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp(*(archive_name_array + 0), dev_null);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27227\n");
if (tmp == 0)
    {
      printf("\nSTMT_EXEC;;27229\n");
tmp___1 = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;27233\n");
if (!(archive >= 1 << 30))
      {
        printf("\nSTMT_EXEC;;27235\n");
if ((archive_stat.st_mode & 61440U) == 8192U)
        {
          {
            printf("\nSTMT_EXEC;;27238\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___0 = stat((char const * /* __restrict  */)(dev_null), (struct stat * /* __restrict  */)(&dev_null_stat));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27240\n");
if (tmp___0 == 0)
          {
            printf("\nSTMT_EXEC;;27242\n");
if (archive_stat.st_dev == dev_null_stat.st_dev)
            {
              printf("\nSTMT_EXEC;;27244\n");
if (archive_stat.st_ino == dev_null_stat.st_ino)
              {
                printf("\nSTMT_EXEC;;27246\n");
tmp___1 = 1;
              }
              else
              {
                printf("\nSTMT_EXEC;;27250\n");
tmp___1 = 0;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;27255\n");
tmp___1 = 0;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;27260\n");
tmp___1 = 0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;27265\n");
tmp___1 = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;27270\n");
tmp___1 = 0;
      }
    }
    printf("\nSTMT_EXEC;;27273\n");
dev_null_output = (_Bool)tmp___1;
    printf("\nSTMT_EXEC;;27274\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void sys_drain_input_pipe(void)
{
  printf("\nFUNC_CALL;sys_drain_input_pipe();\n");
printf("\nSTMT_EXEC;;27279\n");
size_t r;
  printf("\nSTMT_EXEC;;27280\n");
size_t tmp;
  printf("\nSTMT_EXEC;;27281\n");
size_t tmp___0;

  {
    printf("\nSTMT_EXEC;;27284\n");
if ((unsigned int)access_mode == 0U)
    {
      printf("\nSTMT_EXEC;;27286\n");
if (!(archive >= 1 << 30))
      {
        printf("\nSTMT_EXEC;;27288\n");
if ((archive_stat.st_mode & 61440U) == 4096U)
        {
          printf("\nSTMT_EXEC;;27290\n");
goto _L___3;
        }
        else
        {
          printf("\nSTMT_EXEC;;27294\n");
if ((archive_stat.st_mode & 61440U) == 49152U)
          {
          _L___3: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;27298\n");
while (1)
            {
            while_continue: /* CIL Label */;
              printf("\nSTMT_EXEC;;27301\n");
if (archive >= 1 << 30)
              {
                {
                  printf("\nSTMT_EXEC;;27304\n");
tmp = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
                  printf("\nSTMT_EXEC;;27305\n");
r = tmp;
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;27311\n");
tmp___0 = safe_read(archive, (void *)(record_start->buffer), record_size);
                  printf("\nSTMT_EXEC;;27312\n");
r = tmp___0;
                }
              }
              printf("\nSTMT_EXEC;;27315\n");
if (r != 0UL)
              {
                printf("\nSTMT_EXEC;;27317\n");
if (!(r != 0xffffffffffffffffUL))
                {
                  printf("\nSTMT_EXEC;;27319\n");
goto while_break;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;27324\n");
goto while_break;
              }
              printf("\nSTMT_EXEC;;27326\n");
goto while_continue;
            }
          while_break: /* CIL Label */;
          }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;27334\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void sys_wait_for_child(pid_t child_pid___0)
{
  printf("\nFUNC_CALL;sys_wait_for_child(pid_t);\n");
printf("\nSTMT_EXEC;;27339\n");
int wait_status;
  printf("\nSTMT_EXEC;;27340\n");
int *tmp;
  printf("\nSTMT_EXEC;;27341\n");
__pid_t tmp___0;
  printf("\nSTMT_EXEC;;27342\n");
union __anonunion_56 __constr_expr_0;
  printf("\nSTMT_EXEC;;27343\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;27344\n");
union __anonunion_57 __constr_expr_1;
  printf("\nSTMT_EXEC;;27345\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;27346\n");
union __anonunion_58 __constr_expr_2;
  printf("\nSTMT_EXEC;;27347\n");
union __anonunion_59 __constr_expr_3;
  printf("\nSTMT_EXEC;;27348\n");
char *__cil_tmp11;
  printf("\nSTMT_EXEC;;27349\n");
char *__cil_tmp12;

  {
    printf("\nSTMT_EXEC;;27352\n");
if (child_pid___0)
    {
      {
        printf("\nSTMT_EXEC;;27355\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;27359\n");
printf("\nFUNC_CALL;waitpid(__pid_t,int *,int);\n");
tmp___0 = waitpid(child_pid___0, &wait_status, 0);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27361\n");
if (!(tmp___0 == -1))
          {
            printf("\nSTMT_EXEC;;27363\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;27366\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27368\n");
if (*tmp != 4)
          {
            {
              printf("\nSTMT_EXEC;;27371\n");
waitpid_error(use_compress_program_option);
            }
            printf("\nSTMT_EXEC;;27373\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;27378\n");
__constr_expr_3.__in = wait_status;
      printf("\nSTMT_EXEC;;27379\n");
if ((int)((signed char)((__constr_expr_3.__i & 127) + 1)) >> 1 > 0)
      {
        {
          printf("\nSTMT_EXEC;;27382\n");
__constr_expr_0.__in = wait_status;
          printf("\nSTMT_EXEC;;27383\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Child died with signal %d");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;27384\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1, __constr_expr_0.__i & 127);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;27385\n");
exit_status = 2;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;27390\n");
__constr_expr_2.__in = wait_status;
        printf("\nSTMT_EXEC;;27391\n");
if ((__constr_expr_2.__i & 65280) >> 8 != 0)
        {
          {
            printf("\nSTMT_EXEC;;27394\n");
__constr_expr_1.__in = wait_status;
            printf("\nSTMT_EXEC;;27395\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Child returned status %d");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27396\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2, (__constr_expr_1.__i & 65280) >> 8);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27397\n");
exit_status = 2;
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;27402\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void sys_spawn_shell(void)
{
  printf("\nFUNC_CALL;sys_spawn_shell();\n");
printf("\nSTMT_EXEC;;27407\n");
pid_t child;
  printf("\nSTMT_EXEC;;27408\n");
char const *shell;
  printf("\nSTMT_EXEC;;27409\n");
char *tmp;
  printf("\nSTMT_EXEC;;27410\n");
int wait_status;
  printf("\nSTMT_EXEC;;27411\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;27412\n");
__pid_t tmp___1;
  printf("\nSTMT_EXEC;;27413\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;27414\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;27418\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp = getenv("SHELL");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27419\n");
shell = (char const *)tmp;
    }
    printf("\nSTMT_EXEC;;27421\n");
if (!shell)
    {
      printf("\nSTMT_EXEC;;27423\n");
shell = "/bin/sh";
    }
    {
      printf("\nSTMT_EXEC;;27426\n");
child = xfork();
    }
    printf("\nSTMT_EXEC;;27428\n");
if (child == 0)
    {
      {
        printf("\nSTMT_EXEC;;27431\n");
printf("\nFUNC_CALL;execlp(const char *,const char *);\n");
execlp(shell, "-sh", "-i", (char *)0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27432\n");
exec_fatal(shell);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;27438\n");
while (1)
        {
        while_continue: /* CIL Label */;
          {
            printf("\nSTMT_EXEC;;27442\n");
printf("\nFUNC_CALL;waitpid(__pid_t,int *,int);\n");
tmp___1 = waitpid(child, &wait_status, 0);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27444\n");
if (!(tmp___1 == -1))
          {
            printf("\nSTMT_EXEC;;27446\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;27449\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27451\n");
if (*tmp___0 != 4)
          {
            {
              printf("\nSTMT_EXEC;;27454\n");
waitpid_error(shell);
            }
            printf("\nSTMT_EXEC;;27456\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;27462\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sys_compare_uid(struct stat *a, struct stat *b)
{

  printf("\nFUNC_CALL;sys_compare_uid(struct stat *,struct stat *);\n");
{
    printf("\nSTMT_EXEC;;27469\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(a->st_uid == b->st_uid));
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sys_compare_gid(struct stat *a, struct stat *b)
{

  printf("\nFUNC_CALL;sys_compare_gid(struct stat *,struct stat *);\n");
{
    printf("\nSTMT_EXEC;;27476\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(a->st_gid == b->st_gid));
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool sys_compare_links(struct stat *link_data, struct stat *stat_data)
{
  printf("\nFUNC_CALL;sys_compare_links(struct stat *,struct stat *);\n");
printf("\nSTMT_EXEC;;27481\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;27484\n");
if (stat_data->st_dev == link_data->st_dev)
    {
      printf("\nSTMT_EXEC;;27486\n");
if (stat_data->st_ino == link_data->st_ino)
      {
        printf("\nSTMT_EXEC;;27488\n");
tmp = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;27492\n");
tmp = 0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;27497\n");
tmp = 0;
    }
    printf("\nSTMT_EXEC;;27499\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
int sys_truncate(int fd)
{
  printf("\nFUNC_CALL;sys_truncate(int);\n");
printf("\nSTMT_EXEC;;27504\n");
off_t pos;
  printf("\nSTMT_EXEC;;27505\n");
__off_t tmp;
  printf("\nSTMT_EXEC;;27506\n");
int tmp___0;
  printf("\nSTMT_EXEC;;27507\n");
int tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;27511\n");
printf("\nFUNC_CALL;lseek(int,__off_t,int);\n");
tmp = lseek(fd, (off_t)0, 1);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27512\n");
pos = tmp;
    }
    printf("\nSTMT_EXEC;;27514\n");
if (pos < 0L)
    {
      printf("\nSTMT_EXEC;;27516\n");
tmp___1 = -1;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;27521\n");
printf("\nFUNC_CALL;ftruncate(int,__off_t);\n");
tmp___0 = ftruncate(fd, pos);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27522\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;27525\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
  }
printf("\nFUNC_RETURN;;\n");
}
void sys_reset_uid_gid(void)
{
  printf("\nFUNC_CALL;sys_reset_uid_gid();\n");
printf("\nSTMT_EXEC;;27530\n");
__uid_t tmp;
  printf("\nSTMT_EXEC;;27531\n");
__gid_t tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;27535\n");
printf("\nFUNC_CALL;getuid();\n");
tmp = getuid();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27536\n");
printf("\nFUNC_CALL;setuid(__uid_t);\n");
setuid(tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27537\n");
printf("\nFUNC_CALL;getgid();\n");
tmp___0 = getgid();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27538\n");
printf("\nFUNC_CALL;setgid(__gid_t);\n");
setgid(tmp___0);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27540\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int is_regular_file(char const *name)
{
  printf("\nFUNC_CALL;is_regular_file(const char *);\n");
printf("\nSTMT_EXEC;;27545\n");
struct stat stbuf;
  printf("\nSTMT_EXEC;;27546\n");
int *tmp;
  printf("\nSTMT_EXEC;;27547\n");
int tmp___0;
  printf("\nSTMT_EXEC;;27548\n");
void *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;27552\n");
printf("\nFUNC_CALL;stat(const char *__restrict,struct stat *__restrict);\n");
tmp___0 = stat((char const * /* __restrict  */)name, (struct stat * /* __restrict  */)(&stbuf));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27554\n");
if (tmp___0 == 0)
    {
      printf("\nSTMT_EXEC;;27556\n");
printf("\nFUNC_RETURN;;\n");
return ((stbuf.st_mode & 61440U) == 32768U);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;27561\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;27563\n");
printf("\nFUNC_RETURN;;\n");
return (*tmp == 2);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
size_t sys_write_archive_buffer(void)
{
  printf("\nFUNC_CALL;sys_write_archive_buffer();\n");
printf("\nSTMT_EXEC;;27569\n");
size_t tmp;
  printf("\nSTMT_EXEC;;27570\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;27571\n");
size_t tmp___1;

  {
    printf("\nSTMT_EXEC;;27574\n");
if (archive >= 1 << 30)
    {
      {
        printf("\nSTMT_EXEC;;27577\n");
tmp = rmt_write__(archive - (1 << 30), record_start->buffer, record_size);
        printf("\nSTMT_EXEC;;27578\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;27584\n");
tmp___0 = full_write(archive, (void const *)(record_start->buffer), record_size);
        printf("\nSTMT_EXEC;;27585\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;27588\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
  }
printf("\nFUNC_RETURN;;\n");
}
static void xdup2(int from, int into)
{
  printf("\nFUNC_CALL;xdup2(int,int);\n");
printf("\nSTMT_EXEC;;27593\n");
int status;
  printf("\nSTMT_EXEC;;27594\n");
int tmp;
  printf("\nSTMT_EXEC;;27595\n");
int e;
  printf("\nSTMT_EXEC;;27596\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;27597\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;27598\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;27599\n");
int e___0;
  printf("\nSTMT_EXEC;;27600\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;27601\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;27602\n");
char *__cil_tmp12;
  printf("\nSTMT_EXEC;;27603\n");
char *__cil_tmp13;

  {
    printf("\nSTMT_EXEC;;27606\n");
if (from != into)
    {
      {
        printf("\nSTMT_EXEC;;27609\n");
printf("\nFUNC_CALL;close(int);\n");
tmp = close(into);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27610\n");
status = tmp;
      }
      printf("\nSTMT_EXEC;;27612\n");
if (status != 0)
      {
        {
          printf("\nSTMT_EXEC;;27615\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;27617\n");
if (*tmp___2 != 9)
        {
          {
            printf("\nSTMT_EXEC;;27620\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27621\n");
e = *tmp___0;
            printf("\nSTMT_EXEC;;27622\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("Cannot close");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27623\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27624\n");
fatal_exit();
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;27629\n");
printf("\nFUNC_CALL;dup(int);\n");
status = dup(from);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;27631\n");
if (status != into)
      {
        printf("\nSTMT_EXEC;;27633\n");
if (status < 0)
        {
          {
            printf("\nSTMT_EXEC;;27636\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27637\n");
e___0 = *tmp___3;
            printf("\nSTMT_EXEC;;27638\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("Cannot dup");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27639\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e___0, (char const *)tmp___4);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27640\n");
fatal_exit();
          }
        }
        {
          printf("\nSTMT_EXEC;;27644\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;27648\n");
xclose(from);
      }
    }
    printf("\nSTMT_EXEC;;27651\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
pid_t sys_child_open_for_compress(void)
{
  printf("\nFUNC_CALL;sys_child_open_for_compress();\n");
printf("\nSTMT_EXEC;;27656\n");
int parent_pipe[2];
  printf("\nSTMT_EXEC;;27657\n");
int child_pipe[2];
  printf("\nSTMT_EXEC;;27658\n");
pid_t grandchild_pid;
  printf("\nSTMT_EXEC;;27659\n");
pid_t child_pid___0;
  printf("\nSTMT_EXEC;;27660\n");
int wait_status;
  printf("\nSTMT_EXEC;;27661\n");
char *tmp;
  printf("\nSTMT_EXEC;;27662\n");
int saved_errno;
  printf("\nSTMT_EXEC;;27663\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;27664\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;27665\n");
int tmp___2;
  printf("\nSTMT_EXEC;;27666\n");
void *tmp___3;
  printf("\nSTMT_EXEC;;27667\n");
int tmp___4;
  printf("\nSTMT_EXEC;;27668\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;27669\n");
int tmp___7;
  printf("\nSTMT_EXEC;;27670\n");
int tmp___8;
  printf("\nSTMT_EXEC;;27671\n");
void *tmp___9;
  printf("\nSTMT_EXEC;;27672\n");
int tmp___10;
  printf("\nSTMT_EXEC;;27673\n");
size_t status;
  printf("\nSTMT_EXEC;;27674\n");
char *cursor;
  printf("\nSTMT_EXEC;;27675\n");
size_t length;
  printf("\nSTMT_EXEC;;27676\n");
size_t size;
  printf("\nSTMT_EXEC;;27677\n");
int *tmp___11;
  printf("\nSTMT_EXEC;;27678\n");
__pid_t tmp___12;
  printf("\nSTMT_EXEC;;27679\n");
union __anonunion_60 __constr_expr_4;
  printf("\nSTMT_EXEC;;27680\n");
union __anonunion_61 __constr_expr_5;
  printf("\nSTMT_EXEC;;27681\n");
union __anonunion_62 __constr_expr_6;
  printf("\nSTMT_EXEC;;27682\n");
union __anonunion_63 __constr_expr_7;
  printf("\nSTMT_EXEC;;27683\n");
void *__cil_tmp28;
  printf("\nSTMT_EXEC;;27684\n");
void *__cil_tmp29;
  printf("\nSTMT_EXEC;;27685\n");
char *__cil_tmp30;
  printf("\nSTMT_EXEC;;27686\n");
char *__cil_tmp31;

  {
    {
      printf("\nSTMT_EXEC;;27690\n");
xpipe(parent_pipe);
      printf("\nSTMT_EXEC;;27691\n");
child_pid___0 = xfork();
    }
    printf("\nSTMT_EXEC;;27693\n");
if (child_pid___0 > 0)
    {
      {
        printf("\nSTMT_EXEC;;27696\n");
archive = parent_pipe[1];
        printf("\nSTMT_EXEC;;27697\n");
xclose(parent_pipe[0]);
      }
      printf("\nSTMT_EXEC;;27699\n");
printf("\nFUNC_RETURN;;\n");
return (child_pid___0);
    }
    {
      printf("\nSTMT_EXEC;;27702\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("tar (child)");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;27703\n");
program_name = (char const *)tmp;
      printf("\nSTMT_EXEC;;27704\n");
xdup2(parent_pipe[0], 0);
      printf("\nSTMT_EXEC;;27705\n");
xclose(parent_pipe[1]);
      printf("\nSTMT_EXEC;;27706\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___2 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27708\n");
if (tmp___2 != 0)
    {
      printf("\nSTMT_EXEC;;27710\n");
if (!force_local_option)
      {
        {
          printf("\nSTMT_EXEC;;27713\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;27715\n");
if (rmt_path__)
        {
          printf("\nSTMT_EXEC;;27717\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
          {
            {
              printf("\nSTMT_EXEC;;27720\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___3 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;27722\n");
if (tmp___3)
            {
              printf("\nSTMT_EXEC;;27724\n");
goto _L___1;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;27729\n");
goto _L___1;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;27734\n");
goto _L___1;
        }
      }
      else
      {
      _L___1:
      {
        printf("\nSTMT_EXEC;;27741\n");
tmp___4 = is_regular_file(*(archive_name_array + 0));
      }
        printf("\nSTMT_EXEC;;27743\n");
if (tmp___4)
        {
          printf("\nSTMT_EXEC;;27745\n");
if (backup_option)
          {
            {
              printf("\nSTMT_EXEC;;27748\n");
maybe_backup_file(*(archive_name_array + 0), 1);
            }
          }
          {
            printf("\nSTMT_EXEC;;27752\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
archive = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;27754\n");
if (archive < 0)
          {
            {
              printf("\nSTMT_EXEC;;27757\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;27758\n");
saved_errno = *tmp___0;
            }
            printf("\nSTMT_EXEC;;27760\n");
if (backup_option)
            {
              {
                printf("\nSTMT_EXEC;;27763\n");
undo_last_backup();
              }
            }
            {
              printf("\nSTMT_EXEC;;27767\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;27768\n");
*tmp___1 = saved_errno;
              printf("\nSTMT_EXEC;;27769\n");
open_fatal(*(archive_name_array + 0));
            }
          }
          {
            printf("\nSTMT_EXEC;;27773\n");
xdup2(archive, 1);
            printf("\nSTMT_EXEC;;27774\n");
printf("\nFUNC_CALL;execlp(const char *,const char *);\n");
execlp(use_compress_program_option, use_compress_program_option, (char *)0);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27775\n");
exec_fatal(use_compress_program_option);
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;27781\n");
xpipe(child_pipe);
      printf("\nSTMT_EXEC;;27782\n");
grandchild_pid = xfork();
    }
    printf("\nSTMT_EXEC;;27784\n");
if (grandchild_pid == 0)
    {
      {
        printf("\nSTMT_EXEC;;27787\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("tar (grandchild)");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27788\n");
program_name = (char const *)tmp___5;
        printf("\nSTMT_EXEC;;27789\n");
xdup2(child_pipe[1], 1);
        printf("\nSTMT_EXEC;;27790\n");
xclose(child_pipe[0]);
        printf("\nSTMT_EXEC;;27791\n");
printf("\nFUNC_CALL;execlp(const char *,const char *);\n");
execlp(use_compress_program_option, use_compress_program_option, (char *)0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27792\n");
exec_fatal(use_compress_program_option);
      }
    }
    {
      printf("\nSTMT_EXEC;;27796\n");
xdup2(child_pipe[0], 0);
      printf("\nSTMT_EXEC;;27797\n");
xclose(child_pipe[1]);
      printf("\nSTMT_EXEC;;27798\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___10 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;27800\n");
if (tmp___10 == 0)
    {
      printf("\nSTMT_EXEC;;27802\n");
archive = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;27806\n");
if (!force_local_option)
      {
        {
          printf("\nSTMT_EXEC;;27809\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;27811\n");
if (rmt_path__)
        {
          printf("\nSTMT_EXEC;;27813\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
          {
            {
              printf("\nSTMT_EXEC;;27816\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___9 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;27818\n");
if (tmp___9)
            {
              {
                printf("\nSTMT_EXEC;;27821\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___8 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;27822\n");
archive = tmp___8;
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;27828\n");
tmp___7 = rmt_open__(*(archive_name_array + 0), 65, 1 << 30, rsh_command_option);
                printf("\nSTMT_EXEC;;27829\n");
archive = tmp___7;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;27836\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___8 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;27837\n");
archive = tmp___8;
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;27844\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___8 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;27845\n");
archive = tmp___8;
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;27852\n");
printf("\nFUNC_CALL;creat(const char *,mode_t);\n");
tmp___8 = creat(*(archive_name_array + 0), (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;27853\n");
archive = tmp___8;
        }
      }
      printf("\nSTMT_EXEC;;27856\n");
if (archive < 0)
      {
        {
          printf("\nSTMT_EXEC;;27859\n");
open_fatal(*(archive_name_array + 0));
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;27864\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;27867\n");
status = (size_t)0;
        printf("\nSTMT_EXEC;;27868\n");
length = (size_t)0;
        printf("\nSTMT_EXEC;;27869\n");
cursor = record_start->buffer;
        {
          printf("\nSTMT_EXEC;;27871\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;27874\n");
if (!(length < record_size))
            {
              printf("\nSTMT_EXEC;;27876\n");
goto while_break___0;
            }
            {
              printf("\nSTMT_EXEC;;27879\n");
size = record_size - length;
              printf("\nSTMT_EXEC;;27880\n");
status = safe_read(0, (void *)cursor, size);
            }
            printf("\nSTMT_EXEC;;27882\n");
if (status == 0xffffffffffffffffUL)
            {
              {
                printf("\nSTMT_EXEC;;27885\n");
read_fatal(use_compress_program_option);
              }
            }
            printf("\nSTMT_EXEC;;27888\n");
if (status == 0UL)
            {
              printf("\nSTMT_EXEC;;27890\n");
goto while_break___0;
            }
            printf("\nSTMT_EXEC;;27892\n");
length += status;
            printf("\nSTMT_EXEC;;27893\n");
cursor += status;
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;27897\n");
if (status == 0UL)
        {
          printf("\nSTMT_EXEC;;27899\n");
if (length > 0UL)
          {
            {
              printf("\nSTMT_EXEC;;27902\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(record_start->buffer + length), 0, record_size - length);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;27903\n");
status = sys_write_archive_buffer();
            }
            printf("\nSTMT_EXEC;;27905\n");
if (status != record_size)
            {
              {
                printf("\nSTMT_EXEC;;27908\n");
archive_write_error((ssize_t)status);
              }
            }
          }
          printf("\nSTMT_EXEC;;27912\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;27915\n");
status = sys_write_archive_buffer();
        }
        printf("\nSTMT_EXEC;;27917\n");
if (status != record_size)
        {
          {
            printf("\nSTMT_EXEC;;27920\n");
archive_write_error((ssize_t)status);
          }
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;27927\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;27931\n");
printf("\nFUNC_CALL;waitpid(__pid_t,int *,int);\n");
tmp___12 = waitpid(grandchild_pid, &wait_status, 0);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;27933\n");
if (!(tmp___12 == -1))
        {
          printf("\nSTMT_EXEC;;27935\n");
goto while_break___1;
        }
        {
          printf("\nSTMT_EXEC;;27938\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___11 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;27940\n");
if (*tmp___11 != 4)
        {
          {
            printf("\nSTMT_EXEC;;27943\n");
waitpid_error(use_compress_program_option);
          }
          printf("\nSTMT_EXEC;;27945\n");
goto while_break___1;
        }
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;27950\n");
__constr_expr_7.__in = wait_status;
    printf("\nSTMT_EXEC;;27951\n");
if ((int)((signed char)((__constr_expr_7.__i & 127) + 1)) >> 1 > 0)
    {
      {
        printf("\nSTMT_EXEC;;27954\n");
__constr_expr_4.__in = wait_status;
        printf("\nSTMT_EXEC;;27955\n");
printf("\nFUNC_CALL;kill(__pid_t,int);\n");
kill(child_pid___0, __constr_expr_4.__i & 127);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;27956\n");
exit_status = 2;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;27961\n");
__constr_expr_6.__in = wait_status;
      printf("\nSTMT_EXEC;;27962\n");
if ((__constr_expr_6.__i & 65280) >> 8 != 0)
      {
        printf("\nSTMT_EXEC;;27964\n");
__constr_expr_5.__in = wait_status;
        printf("\nSTMT_EXEC;;27965\n");
exit_status = (__constr_expr_5.__i & 65280) >> 8;
      }
    }
    {
      printf("\nSTMT_EXEC;;27969\n");
printf("\nFUNC_CALL;exit(int);\n");
exit(exit_status);printf("\nFUNC_RETURN;;\n");

    }
  }
printf("\nFUNC_RETURN;;\n");
}
pid_t sys_child_open_for_uncompress(void)
{
  printf("\nFUNC_CALL;sys_child_open_for_uncompress();\n");
printf("\nSTMT_EXEC;;27975\n");
int parent_pipe[2];
  printf("\nSTMT_EXEC;;27976\n");
int child_pipe[2];
  printf("\nSTMT_EXEC;;27977\n");
pid_t grandchild_pid;
  printf("\nSTMT_EXEC;;27978\n");
pid_t child_pid___0;
  printf("\nSTMT_EXEC;;27979\n");
int wait_status;
  printf("\nSTMT_EXEC;;27980\n");
char *tmp;
  printf("\nSTMT_EXEC;;27981\n");
int tmp___0;
  printf("\nSTMT_EXEC;;27982\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;27983\n");
int tmp___2;
  printf("\nSTMT_EXEC;;27984\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;27985\n");
int tmp___5;
  printf("\nSTMT_EXEC;;27986\n");
int tmp___6;
  printf("\nSTMT_EXEC;;27987\n");
void *tmp___7;
  printf("\nSTMT_EXEC;;27988\n");
int tmp___8;
  printf("\nSTMT_EXEC;;27989\n");
char *cursor;
  printf("\nSTMT_EXEC;;27990\n");
size_t maximum;
  printf("\nSTMT_EXEC;;27991\n");
size_t count;
  printf("\nSTMT_EXEC;;27992\n");
size_t status;
  printf("\nSTMT_EXEC;;27993\n");
size_t tmp___9;
  printf("\nSTMT_EXEC;;27994\n");
size_t tmp___10;
  printf("\nSTMT_EXEC;;27995\n");
size_t tmp___11;
  printf("\nSTMT_EXEC;;27996\n");
int *tmp___12;
  printf("\nSTMT_EXEC;;27997\n");
__pid_t tmp___13;
  printf("\nSTMT_EXEC;;27998\n");
union __anonunion_64 __constr_expr_8;
  printf("\nSTMT_EXEC;;27999\n");
union __anonunion_65 __constr_expr_9;
  printf("\nSTMT_EXEC;;28000\n");
union __anonunion_66 __constr_expr_10;
  printf("\nSTMT_EXEC;;28001\n");
union __anonunion_67 __constr_expr_11;
  printf("\nSTMT_EXEC;;28002\n");
void *__cil_tmp28;
  printf("\nSTMT_EXEC;;28003\n");
void *__cil_tmp29;
  printf("\nSTMT_EXEC;;28004\n");
char *__cil_tmp30;
  printf("\nSTMT_EXEC;;28005\n");
char *__cil_tmp31;

  {
    {
      printf("\nSTMT_EXEC;;28009\n");
xpipe(parent_pipe);
      printf("\nSTMT_EXEC;;28010\n");
child_pid___0 = xfork();
    }
    printf("\nSTMT_EXEC;;28012\n");
if (child_pid___0 > 0)
    {
      {
        printf("\nSTMT_EXEC;;28015\n");
read_full_records_option = (_Bool)1;
        printf("\nSTMT_EXEC;;28016\n");
archive = parent_pipe[0];
        printf("\nSTMT_EXEC;;28017\n");
xclose(parent_pipe[1]);
      }
      printf("\nSTMT_EXEC;;28019\n");
printf("\nFUNC_RETURN;;\n");
return (child_pid___0);
    }
    {
      printf("\nSTMT_EXEC;;28022\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("tar (child)");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;28023\n");
program_name = (char const *)tmp;
      printf("\nSTMT_EXEC;;28024\n");
xdup2(parent_pipe[1], 1);
      printf("\nSTMT_EXEC;;28025\n");
xclose(parent_pipe[0]);
      printf("\nSTMT_EXEC;;28026\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;28028\n");
if (tmp___0 != 0)
    {
      printf("\nSTMT_EXEC;;28030\n");
if (!force_local_option)
      {
        {
          printf("\nSTMT_EXEC;;28033\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;28035\n");
if (rmt_path__)
        {
          printf("\nSTMT_EXEC;;28037\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
          {
            {
              printf("\nSTMT_EXEC;;28040\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___1 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;28042\n");
if (tmp___1)
            {
              printf("\nSTMT_EXEC;;28044\n");
goto _L___1;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;28049\n");
goto _L___1;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;28054\n");
goto _L___1;
        }
      }
      else
      {
      _L___1:
      {
        printf("\nSTMT_EXEC;;28061\n");
tmp___2 = is_regular_file(*(archive_name_array + 0));
      }
        printf("\nSTMT_EXEC;;28063\n");
if (tmp___2)
        {
          {
            printf("\nSTMT_EXEC;;28066\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
archive = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;28068\n");
if (archive < 0)
          {
            {
              printf("\nSTMT_EXEC;;28071\n");
open_fatal(*(archive_name_array + 0));
            }
          }
          {
            printf("\nSTMT_EXEC;;28075\n");
xdup2(archive, 0);
            printf("\nSTMT_EXEC;;28076\n");
printf("\nFUNC_CALL;execlp(const char *,const char *);\n");
execlp(use_compress_program_option, use_compress_program_option, "-d", (char *)0);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;28077\n");
exec_fatal(use_compress_program_option);
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;28083\n");
xpipe(child_pipe);
      printf("\nSTMT_EXEC;;28084\n");
grandchild_pid = xfork();
    }
    printf("\nSTMT_EXEC;;28086\n");
if (grandchild_pid == 0)
    {
      {
        printf("\nSTMT_EXEC;;28089\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("tar (grandchild)");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28090\n");
program_name = (char const *)tmp___3;
        printf("\nSTMT_EXEC;;28091\n");
xdup2(child_pipe[0], 0);
        printf("\nSTMT_EXEC;;28092\n");
xclose(child_pipe[1]);
        printf("\nSTMT_EXEC;;28093\n");
printf("\nFUNC_CALL;execlp(const char *,const char *);\n");
execlp(use_compress_program_option, use_compress_program_option, "-d", (char *)0);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28094\n");
exec_fatal(use_compress_program_option);
      }
    }
    {
      printf("\nSTMT_EXEC;;28098\n");
xdup2(child_pipe[1], 1);
      printf("\nSTMT_EXEC;;28099\n");
xclose(child_pipe[0]);
      printf("\nSTMT_EXEC;;28100\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___8 = strcmp(*(archive_name_array + 0), "-");printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;28102\n");
if (tmp___8 == 0)
    {
      printf("\nSTMT_EXEC;;28104\n");
archive = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;28108\n");
if (!force_local_option)
      {
        {
          printf("\nSTMT_EXEC;;28111\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
rmt_path__ = strchr(*(archive_name_array + 0), ':');printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;28113\n");
if (rmt_path__)
        {
          printf("\nSTMT_EXEC;;28115\n");
if ((unsigned long)rmt_path__ > (unsigned long)*(archive_name_array + 0))
          {
            {
              printf("\nSTMT_EXEC;;28118\n");
printf("\nFUNC_CALL;memchr(const void *,int,size_t);\n");
tmp___7 = memchr((void const *)*(archive_name_array + 0), '/', (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;28120\n");
if (tmp___7)
            {
              {
                printf("\nSTMT_EXEC;;28123\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___6 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;28124\n");
archive = tmp___6;
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;28130\n");
tmp___5 = rmt_open__(*(archive_name_array + 0), 0, 1 << 30, rsh_command_option);
                printf("\nSTMT_EXEC;;28131\n");
archive = tmp___5;
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;28138\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___6 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;28139\n");
archive = tmp___6;
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;28146\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___6 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;28147\n");
archive = tmp___6;
          }
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;28154\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp___6 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;28155\n");
archive = tmp___6;
        }
      }
    }
    printf("\nSTMT_EXEC;;28159\n");
if (archive < 0)
    {
      {
        printf("\nSTMT_EXEC;;28162\n");
open_fatal(*(archive_name_array + 0));
      }
    }
    {
      printf("\nSTMT_EXEC;;28166\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;28170\n");
clear_read_error_count();
        }
      error_loop:
        {
printf("\nSTMT_EXEC;;28173\n");
if (archive >= 1 << 30)
        {
          {
            printf("\nSTMT_EXEC;;28176\n");
tmp___9 = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
            printf("\nSTMT_EXEC;;28177\n");
status = tmp___9;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;28183\n");
tmp___10 = safe_read(archive, (void *)(record_start->buffer), record_size);
            printf("\nSTMT_EXEC;;28184\n");
status = tmp___10;
          }
        }
}

        printf("\nSTMT_EXEC;;28187\n");
if (status == 0xffffffffffffffffUL)
        {
          {
            printf("\nSTMT_EXEC;;28190\n");
archive_read_error();
          }
          printf("\nSTMT_EXEC;;28192\n");
goto error_loop;
        }
        printf("\nSTMT_EXEC;;28194\n");
if (status == 0UL)
        {
          printf("\nSTMT_EXEC;;28196\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;28198\n");
cursor = record_start->buffer;
        printf("\nSTMT_EXEC;;28199\n");
maximum = status;
        {
          printf("\nSTMT_EXEC;;28201\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;28204\n");
if (!maximum)
            {
              printf("\nSTMT_EXEC;;28206\n");
goto while_break___0;
            }
            printf("\nSTMT_EXEC;;28208\n");
if (maximum < 512UL)
            {
              printf("\nSTMT_EXEC;;28210\n");
count = maximum;
            }
            else
            {
              printf("\nSTMT_EXEC;;28214\n");
count = (size_t)512;
            }
            {
              printf("\nSTMT_EXEC;;28217\n");
tmp___11 = full_write(1, (void const *)cursor, count);
            }
            printf("\nSTMT_EXEC;;28219\n");
if (tmp___11 != count)
            {
              {
                printf("\nSTMT_EXEC;;28222\n");
write_error(use_compress_program_option);
              }
            }
            printf("\nSTMT_EXEC;;28225\n");
cursor += count;
            printf("\nSTMT_EXEC;;28226\n");
maximum -= count;
          }
        while_break___0: /* CIL Label */;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;28234\n");
xclose(1);
    }
    {
      printf("\nSTMT_EXEC;;28237\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;28241\n");
printf("\nFUNC_CALL;waitpid(__pid_t,int *,int);\n");
tmp___13 = waitpid(grandchild_pid, &wait_status, 0);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;28243\n");
if (!(tmp___13 == -1))
        {
          printf("\nSTMT_EXEC;;28245\n");
goto while_break___1;
        }
        {
          printf("\nSTMT_EXEC;;28248\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___12 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;28250\n");
if (*tmp___12 != 4)
        {
          {
            printf("\nSTMT_EXEC;;28253\n");
waitpid_error(use_compress_program_option);
          }
          printf("\nSTMT_EXEC;;28255\n");
goto while_break___1;
        }
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;28260\n");
__constr_expr_11.__in = wait_status;
    printf("\nSTMT_EXEC;;28261\n");
if ((int)((signed char)((__constr_expr_11.__i & 127) + 1)) >> 1 > 0)
    {
      {
        printf("\nSTMT_EXEC;;28264\n");
__constr_expr_8.__in = wait_status;
        printf("\nSTMT_EXEC;;28265\n");
printf("\nFUNC_CALL;kill(__pid_t,int);\n");
kill(child_pid___0, __constr_expr_8.__i & 127);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28266\n");
exit_status = 2;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;28271\n");
__constr_expr_10.__in = wait_status;
      printf("\nSTMT_EXEC;;28272\n");
if ((__constr_expr_10.__i & 65280) >> 8 != 0)
      {
        printf("\nSTMT_EXEC;;28274\n");
__constr_expr_9.__in = wait_status;
        printf("\nSTMT_EXEC;;28275\n");
exit_status = (__constr_expr_9.__i & 65280) >> 8;
      }
    }
    {
      printf("\nSTMT_EXEC;;28279\n");
printf("\nFUNC_CALL;exit(int);\n");
exit(exit_status);printf("\nFUNC_RETURN;;\n");

    }
  }
printf("\nFUNC_RETURN;;\n");
}








/* #pragma merger("0","00e.tar.o.i","") */
extern char *optarg;
extern int optind;
extern int printf(char const *__restrict __format, ...);
extern int puts(char const *__s);
extern int fputs_unlocked(char const *__restrict __s, FILE *__restrict __stream);
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) setlocale)(int __category, char const *__locale);
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) textdomain)(char const *__domainname);
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(int ___argc, char *const *___argv, char const *__shortopts, struct option const *__longopts, int *__longind);
char const *simple_backup_suffix;
enum backup_type xget_version(char const *context, char const *version);
struct exclude *new_exclude(void);
void add_exclude(struct exclude *ex, char const *pattern, int options);
int add_exclude_file(void (*add_func)(struct exclude *, char const *, int), struct exclude *ex, char const *filename, int options, char line_end);
struct mode_change *mode_compile(char const *mode_string, unsigned int masked_ops);
int check_links_option;
int allocated_archive_names;
void update_archive(void);
_Bool get_date(struct timespec *result, char const *p, struct timespec const *now);
void prepend_default_options(char const *options, int *pargc, char ***pargv);
static char const *stdin_used_by;
void request_stdin(char const *option)
{
  printf("\nFUNC_CALL;request_stdin(const char *);\n");
printf("\nSTMT_EXEC;;28315\n");
char *tmp;
  printf("\nSTMT_EXEC;;28316\n");
char *__cil_tmp3;

  {
    printf("\nSTMT_EXEC;;28319\n");
if (stdin_used_by)
    {
      {
        printf("\nSTMT_EXEC;;28322\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Options `-%s\' and `-%s\' both want standard input");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28323\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp, stdin_used_by, option);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28324\n");
usage(2);
      }
    }
    printf("\nSTMT_EXEC;;28327\n");
stdin_used_by = option;
    printf("\nSTMT_EXEC;;28328\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static FILE *confirm_file;
static int confirm_file_EOF;
int confirm(char const *message_action, char const *message_name)
{
  printf("\nFUNC_CALL;confirm(const char *,const char *);\n");
printf("\nSTMT_EXEC;;28335\n");
char const *tmp;
  printf("\nSTMT_EXEC;;28336\n");
int reply;
  printf("\nSTMT_EXEC;;28337\n");
int tmp___0;
  printf("\nSTMT_EXEC;;28338\n");
int tmp___1;
  printf("\nSTMT_EXEC;;28339\n");
int character;
  printf("\nSTMT_EXEC;;28340\n");
int tmp___2;
  printf("\nSTMT_EXEC;;28341\n");
char *__cil_tmp9;
  printf("\nSTMT_EXEC;;28342\n");
char *__cil_tmp10;

  {
    printf("\nSTMT_EXEC;;28345\n");
if (!confirm_file)
    {
      printf("\nSTMT_EXEC;;28347\n");
if (archive == 0)
      {
        printf("\nSTMT_EXEC;;28349\n");
goto _L___3;
      }
      else
      {
        printf("\nSTMT_EXEC;;28353\n");
if (stdin_used_by)
        {
        _L___3: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;28357\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
confirm_file = fopen((char const * /* __restrict  */) "/dev/tty", (char const * /* __restrict  */) "r");printf("\nFUNC_RETURN;;\n");

        }
          printf("\nSTMT_EXEC;;28359\n");
if (!confirm_file)
          {
            {
              printf("\nSTMT_EXEC;;28362\n");
open_fatal("/dev/tty");
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;28369\n");
request_stdin("-w");
            printf("\nSTMT_EXEC;;28370\n");
confirm_file = stdin;
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;28376\n");
tmp = quote(message_name);
      printf("\nSTMT_EXEC;;28377\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stdlis, (char const * /* __restrict  */) "%s %s?", message_action, tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;28378\n");
printf("\nFUNC_CALL;fflush_unlocked(FILE *);\n");
fflush_unlocked(stdlis);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;28380\n");
if (confirm_file_EOF)
    {
      printf("\nSTMT_EXEC;;28382\n");
tmp___1 = -1;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;28387\n");
printf("\nFUNC_CALL;getc_unlocked(FILE *);\n");
tmp___0 = getc_unlocked(confirm_file);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28388\n");
tmp___1 = tmp___0;
      }
    }
    printf("\nSTMT_EXEC;;28391\n");
reply = tmp___1;
    printf("\nSTMT_EXEC;;28392\n");
character = reply;
    {
      printf("\nSTMT_EXEC;;28394\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;28397\n");
if (!(character != 10))
        {
          printf("\nSTMT_EXEC;;28399\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;28401\n");
if (character == -1)
        {
          {
            printf("\nSTMT_EXEC;;28404\n");
confirm_file_EOF = 1;
            printf("\nSTMT_EXEC;;28405\n");
printf("\nFUNC_CALL;fputc_unlocked(int,FILE *);\n");
fputc_unlocked('\n', stdlis);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;28406\n");
printf("\nFUNC_CALL;fflush_unlocked(FILE *);\n");
fflush_unlocked(stdlis);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;28408\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;28411\n");
printf("\nFUNC_CALL;getc_unlocked(FILE *);\n");
character = getc_unlocked(confirm_file);printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;28416\n");
if (reply == 121)
    {
      printf("\nSTMT_EXEC;;28418\n");
tmp___2 = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;28422\n");
if (reply == 89)
      {
        printf("\nSTMT_EXEC;;28424\n");
tmp___2 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;28428\n");
tmp___2 = 0;
      }
    }
    printf("\nSTMT_EXEC;;28431\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___2);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct fmttab const fmttab[6] = {{"v7", (enum archive_format)1}, {"oldgnu", (enum archive_format)2}, {"ustar", (enum archive_format)3}, {"posix", (enum archive_format)4}, {"gnu", (enum archive_format)6}, {(char const *)((void *)0), (enum archive_format)0}};
static void set_archive_format(char const *name)
{
  printf("\nFUNC_CALL;set_archive_format(const char *);\n");
printf("\nSTMT_EXEC;;28437\n");
struct fmttab const *p;
  printf("\nSTMT_EXEC;;28438\n");
char *tmp;
  printf("\nSTMT_EXEC;;28439\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;28440\n");
int tmp___1;
  printf("\nSTMT_EXEC;;28441\n");
char *__cil_tmp6;

  {
    printf("\nSTMT_EXEC;;28444\n");
p = fmttab;
    {
      printf("\nSTMT_EXEC;;28446\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;28450\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___1 = strcmp((char const *)p->name, name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;28452\n");
if (!(tmp___1 != 0))
        {
          printf("\nSTMT_EXEC;;28454\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;28456\n");
p++;
        printf("\nSTMT_EXEC;;28457\n");
if (!p->name)
        {
          {
            printf("\nSTMT_EXEC;;28460\n");
tmp = quotearg_colon(name);
            printf("\nSTMT_EXEC;;28461\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("%s: Invalid archive format");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;28462\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___0, tmp);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;28463\n");
usage(2);
          }
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;28469\n");
archive_format = (enum archive_format)p->fmt;
    printf("\nSTMT_EXEC;;28470\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static char const *archive_format_string(enum archive_format fmt)
{
  printf("\nFUNC_CALL;archive_format_string(enum archive_format);\n");
printf("\nSTMT_EXEC;;28475\n");
struct fmttab const *p;
  printf("\nSTMT_EXEC;;28476\n");
char *__cil_tmp3;

  {
    printf("\nSTMT_EXEC;;28479\n");
p = fmttab;
    {
      printf("\nSTMT_EXEC;;28481\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;28484\n");
if (!p->name)
        {
          printf("\nSTMT_EXEC;;28486\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;28488\n");
if ((unsigned int const)p->fmt == (unsigned int const)fmt)
        {
          printf("\nSTMT_EXEC;;28490\n");
printf("\nFUNC_RETURN;;\n");
return ((char const *)p->name);
        }
        printf("\nSTMT_EXEC;;28492\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;28496\n");
printf("\nFUNC_RETURN;;\n");
return ("unknown?");
  }
printf("\nFUNC_RETURN;;\n");
}
static void assert_format(unsigned int fmt_mask)
{
  printf("\nFUNC_CALL;assert_format(unsigned int);\n");
printf("\nSTMT_EXEC;;28501\n");
char *tmp;
  printf("\nSTMT_EXEC;;28502\n");
char *__cil_tmp3;

  {
    printf("\nSTMT_EXEC;;28505\n");
if (((unsigned int)(1 << (unsigned int)archive_format) & fmt_mask) == 0U)
    {
      {
        printf("\nSTMT_EXEC;;28508\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("GNU features wanted on incompatible archive format");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28509\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28510\n");
usage(2);
      }
    }
    printf("\nSTMT_EXEC;;28513\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static int show_help;
static int show_version;
static struct option long_options[104] = {{"absolute-names", 0, (int *)0, 'P'}, {"after-date", 1, (int *)0, 'N'}, {"anchored", 0, (int *)0, 128}, {"append", 0, (int *)0, 'r'}, {"atime-preserve", 0, (int *)0, 129}, {"backup", 2, (int *)0, 130}, {"block-number", 0, (int *)0, 'R'}, {"blocking-factor", 1, (int *)0, 'b'}, {"bzip2", 0, (int *)0, 'j'}, {"catenate", 0, (int *)0, 'A'}, {"checkpoint", 0, (int *)0, 131}, {"check-links", 0, &check_links_option, 1}, {"compare", 0, (int *)0, 'd'}, {"compress", 0, (int *)0, 'Z'}, {"concatenate", 0, (int *)0, 'A'}, {"confirmation", 0, (int *)0, 'w'}, {"create", 0, (int *)0, 'c'}, {"delete", 0, (int *)0, 132}, {"dereference", 0, (int *)0, 'h'}, {"diff", 0, (int *)0, 'd'}, {"directory", 1, (int *)0, 'C'}, {"exclude", 1, (int *)0, 133}, {"exclude-from", 1, (int *)0, 'X'}, {"extract", 0, (int *)0, 'x'}, {"file", 1, (int *)0, 'f'}, {"files-from", 1, (int *)0, 'T'}, {"force-local", 0, (int *)0, 134}, {"format", 1, (int *)0, 135}, {"get", 0, (int *)0, 'x'}, {"group", 1, (int *)0, 136}, {"gunzip", 0, (int *)0, 'z'}, {"gzip", 0, (int *)0, 'z'}, {"help", 0, &show_help, 1}, {"ignore-case", 0, (int *)0, 137}, {"ignore-failed-read", 0, (int *)0, 138}, {"ignore-zeros", 0, (int *)0, 'i'}, {"incremental", 0, (int *)0, 'G'}, {"index-file", 1, (int *)0, 139}, {"info-script", 1, (int *)0, 'F'}, {"interactive", 0, (int *)0, 'w'}, {"keep-newer-files", 0, (int *)0, 140}, {"keep-old-files", 0, (int *)0, 'k'}, {"label", 1, (int *)0, 'V'}, {"list", 0, (int *)0, 't'}, {"listed-incremental", 1, (int *)0, 'g'}, {"mode", 1, (int *)0, 141}, {"multi-volume", 0, (int *)0, 'M'}, {"new-volume-script", 1, (int *)0, 'F'}, {"newer", 1, (int *)0, 'N'}, {"newer-mtime", 1, (int *)0, 142}, {"null", 0, (int *)0, 148}, {"no-anchored", 0, (int *)0, 143}, {"no-ignore-case", 0, (int *)0, 144}, {"no-overwrite-dir", 0, (int *)0, 145}, {"no-wildcards", 0, (int *)0, 146}, {"no-wildcards-match-slash", 0, (int *)0, 147}, {"no-recursion", 0, &recursion_option, 0}, {"no-same-owner", 0, &same_owner_option, -1}, {"no-same-permissions", 0, &same_permissions_option, -1}, {"numeric-owner", 0, (int *)0, 149}, {"occurrence", 2, (int *)0, 150}, {"old-archive", 0, (int *)0, 'o'}, {"one-file-system", 0, (int *)0, 'l'}, {"overwrite", 0, (int *)0, 151}, {"owner", 1, (int *)0, 152}, {"pax-option", 1, (int *)0, 153}, {"portability", 0, (int *)0, 'o'}, {"posix", 0, (int *)0, 154}, {"preserve", 0, (int *)0, 155}, {"preserve-order", 0, (int *)0, 's'}, {"preserve-permissions", 0, (int *)0, 'p'}, {"recursion", 0, &recursion_option, 1 << 3}, {"recursive-unlink", 0, (int *)0, 157}, {"read-full-records", 0, (int *)0, 'B'}, {"record-size", 1, (int *)0, 156}, {"remove-files", 0, (int *)0, 158}, {"rmt-command", 1, (int *)0, 159}, {"rsh-command", 1, (int *)0, 160}, {"same-order", 0, (int *)0, 's'}, {"same-owner", 0, &same_owner_option, 1}, {"same-permissions", 0, (int *)0, 'p'}, {"show-defaults", 0, (int *)0, 161}, {"show-omitted-dirs", 0, (int *)0, 162}, {"sparse", 0, (int *)0, 'S'}, {"starting-file", 1, (int *)0, 'K'}, {"strip-path", 1, (int *)0, 163}, {"suffix", 1, (int *)0, 164}, {"tape-length", 1, (int *)0, 'L'}, {"to-stdout", 0, (int *)0, 'O'}, {"totals", 0, (int *)0, 165}, {"touch", 0, (int *)0, 'm'}, {"uncompress", 0, (int *)0, 'Z'}, {"ungzip", 0, (int *)0, 'z'}, {"unlink-first", 0, (int *)0, 'U'}, {"update", 0, (int *)0, 'u'}, {"utc", 0, (int *)0, 167}, {"use-compress-program", 1, (int *)0, 166}, {"verbose", 0, (int *)0, 'v'}, {"verify", 0, (int *)0, 'W'}, {"version", 0, &show_version, 1}, {"volno-file", 1, (int *)0, 168}, {"wildcards", 0, (int *)0, 169}, {"wildcards-match-slash", 0, (int *)0, 170}, {(char const *)0, 0, (int *)0, 0}};
__attribute__((__noreturn__)) void usage(int status);
void usage(int status)
{
  printf("\nFUNC_CALL;usage(int);\n");
printf("\nSTMT_EXEC;;28522\n");
char *tmp;
  printf("\nSTMT_EXEC;;28523\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;28524\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;28525\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;28526\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;28527\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;28528\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;28529\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;28530\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;28531\n");
char *tmp___8;
  printf("\nSTMT_EXEC;;28532\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;28533\n");
char *tmp___10;
  printf("\nSTMT_EXEC;;28534\n");
char *tmp___11;
  printf("\nSTMT_EXEC;;28535\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;28536\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;28537\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;28538\n");
char const *tmp___15;
  printf("\nSTMT_EXEC;;28539\n");
char *tmp___16;
  printf("\nSTMT_EXEC;;28540\n");
char *tmp___17;
  printf("\nSTMT_EXEC;;28541\n");
char *__cil_tmp21;
  printf("\nSTMT_EXEC;;28542\n");
char *__cil_tmp22;
  printf("\nSTMT_EXEC;;28543\n");
char *__cil_tmp23;
  printf("\nSTMT_EXEC;;28544\n");
char *__cil_tmp24;
  printf("\nSTMT_EXEC;;28545\n");
char *__cil_tmp25;
  printf("\nSTMT_EXEC;;28546\n");
char *__cil_tmp26;
  printf("\nSTMT_EXEC;;28547\n");
char *__cil_tmp27;
  printf("\nSTMT_EXEC;;28548\n");
char *__cil_tmp28;
  printf("\nSTMT_EXEC;;28549\n");
char *__cil_tmp29;
  printf("\nSTMT_EXEC;;28550\n");
char *__cil_tmp30;
  printf("\nSTMT_EXEC;;28551\n");
char *__cil_tmp31;
  printf("\nSTMT_EXEC;;28552\n");
char *__cil_tmp32;
  printf("\nSTMT_EXEC;;28553\n");
char *__cil_tmp33;
  printf("\nSTMT_EXEC;;28554\n");
char *__cil_tmp34;
  printf("\nSTMT_EXEC;;28555\n");
char *__cil_tmp35;
  printf("\nSTMT_EXEC;;28556\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;28557\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;28558\n");
char *__cil_tmp38;

  {
    printf("\nSTMT_EXEC;;28561\n");
if (status != 0)
    {
      {
        printf("\nSTMT_EXEC;;28564\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Try `%s --help\' for more information.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28565\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */)tmp, program_name);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;28571\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("GNU `tar\' saves many files together into a single tape or disk "
                          "archive, and\ncan restore individual files from the archive.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28573\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___0, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28574\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("\nUsage: %s [OPTION]... [FILE]...\n\nExamples:\n  %s -cf "
                          "archive.tar foo bar  # Create archive.tar from files foo "
                          "and bar.\n  %s -tvf archive.tar         # List all files "
                          "in archive.tar verbosely.\n  %s -xf archive.tar          "
                          "# Extract all files from archive.tar.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28579\n");
printf((char const * /* __restrict  */)tmp___1, program_name, program_name, program_name, program_name);
        printf("\nSTMT_EXEC;;28580\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("\nIf a long option shows an argument as mandatory, "
                          "then it is mandatory\nfor the equivalent short "
                          "option also.  Similarly for optional arguments.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28583\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___2, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28584\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___3 = gettext("\nMain operation mode:\n  -t, --list              list the "
                          "contents of an archive\n  -x, --extract, --get    extract files "
                          "from an archive\n  -c, --create            create a new archive\n "
                          " -d, --diff, --compare   find differences between archive and "
                          "file system\n  -r, --append            append files to the end of "
                          "an archive\n  -u, --update            only append files newer "
                          "than copy in archive\n  -A, --catenate          append tar files "
                          "to an archive\n      --concatenate       same as -A\n      "
                          "--delete            delete from the archive (not on mag "
                          "tapes!)\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28594\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___3, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28595\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___4 = gettext("\nOperation modifiers:\n  -W, --verify               attempt to "
                          "verify the archive after writing it\n      --remove-files         "
                          "remove files after adding them to the archive\n  -k, "
                          "--keep-old-files       don\'t replace existing files when "
                          "extracting\n      --keep-newer-files     don\'t replace existing "
                          "files that are newer\n                             than their "
                          "archive copies\n      --overwrite            overwrite existing "
                          "files when extracting\n      --no-overwrite-dir     preserve "
                          "metadata of existing directories\n  -U, --unlink-first         "
                          "remove each file prior to extracting over it\n      "
                          "--recursive-unlink     empty hierarchies prior to extracting "
                          "directory\n  -S, --sparse               handle sparse files "
                          "efficiently\n  -O, --to-stdout            extract files to "
                          "standard output\n  -G, --incremental          handle old "
                          "GNU-format incremental backup\n  -g, --listed-incremental=FILE\n  "
                          "                           handle new GNU-format incremental "
                          "backup\n      --ignore-failed-read   do not exit with nonzero on "
                          "unreadable files\n      --occurrence[=NUM]     process only the "
                          "NUMth occurrence of each file in\n                             "
                          "the archive. This option is valid only in\n                       "
                          "      conjunction with one of the subcommands --delete,\n         "
                          "                    --diff, --extract or --list and when a list "
                          "of\n                             files is given either on the "
                          "command line or\n                             via -T option.\n    "
                          "                         NUM defaults to 1.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28620\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___4, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28621\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("\nHandling of file attributes:\n      --owner=NAME             "
                          "force NAME as owner for added files\n      --group=NAME           "
                          "  force NAME as group for added files\n      --mode=CHANGES       "
                          "    force (symbolic) mode CHANGES for added files\n      "
                          "--atime-preserve         don\'t change access times on dumped "
                          "files\n  -m, --modification-time      don\'t extract file "
                          "modified time\n      --same-owner             try extracting "
                          "files with the same ownership\n      --no-same-owner          "
                          "extract files as yourself\n      --numeric-owner          always "
                          "use numbers for user/group names\n  -p, --same-permissions       "
                          "extract permissions information\n      --no-same-permissions    "
                          "do not extract permissions information\n      "
                          "--preserve-permissions   same as -p\n  -s, --same-order           "
                          "  sort names to extract to match archive\n      --preserve-order  "
                          "       same as -s\n      --preserve               same as both -p "
                          "and -s\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28637\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___5, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28638\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___6 = gettext("\nDevice selection and switching:\n  -f, --file=ARCHIVE           "
                          "  use archive file or device ARCHIVE\n      --force-local         "
                          "     archive file is local even if has a colon\n      "
                          "--rmt-command=COMMAND      use given rmt COMMAND instead of "
                          "/etc/rmt\n      --rsh-command=COMMAND      use remote COMMAND "
                          "instead of rsh\n  -[0-7][lmh]                    specify drive "
                          "and density\n  -M, --multi-volume             create/list/extract "
                          "multi-volume archive\n  -L, --tape-length=NUM          change "
                          "tape after writing NUM x 1024 bytes\n  -F, --info-script=FILE     "
                          "    run script at end of each tape (implies -M)\n      "
                          "--new-volume-script=FILE   same as -F FILE\n      "
                          "--volno-file=FILE          use/update the volume number in "
                          "FILE\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28651\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___6, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28652\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___7 = gettext("\nDevice blocking:\n  -b, --blocking-factor=BLOCKS   BLOCKS x 512 "
                          "bytes per record\n      --record-size=SIZE         SIZE bytes per "
                          "record, multiple of 512\n  -i, --ignore-zeros             ignore "
                          "zeroed blocks in archive (means EOF)\n  -B, --read-full-records   "
                          "     reblock as we read (for 4.2BSD pipes)\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28657\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___7, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28658\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___8 = gettext("\nArchive format selection:\n      --format=FMTNAME               "
                          "create archive of the given format.\n                             "
                          "        FMTNAME is one of the following:\n                        "
                          "             v7        old V7 tar format\n                        "
                          "             oldgnu    GNU format as per tar <= 1.12\n            "
                          "                         gnu       GNU tar 1.13 format\n          "
                          "                           ustar     POSIX 1003.1-1988 (ustar) "
                          "format\n                                     posix     POSIX "
                          "1003.1-2001 (pax) format\n      --old-archive, --portability   "
                          "same as --format=v7\n      --posix                        same as "
                          "--format=posix\n  --pax-option "
                          "keyword[[:]=value][,keyword[[:]=value], ...]\n                    "
                          "                 control pax keywords\n  -V, --label=NAME         "
                          "          create archive with volume name NAME\n              "
                          "PATTERN                at list/extract time, a globbing PATTERN\n "
                          " -j, --bzip2                        filter the archive through "
                          "bzip2\n  -z, --gzip, --ungzip               filter the archive "
                          "through gzip\n  -Z, --compress, --uncompress       filter the "
                          "archive through compress\n      --use-compress-program=PROG    "
                          "filter through PROG (must accept -d)\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28678\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___8, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28679\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("\nLocal file selection:\n  -C, --directory=DIR          change to "
                          "directory DIR\n  -T, --files-from=NAME        get names to "
                          "extract or create from file NAME\n      --null                   "
                          "-T reads null-terminated names, disable -C\n      "
                          "--exclude=PATTERN        exclude files, given as a PATTERN\n  -X, "
                          "--exclude-from=FILE      exclude patterns listed in FILE\n      "
                          "--anchored               exclude patterns match file name start "
                          "(default)\n      --no-anchored            exclude patterns match "
                          "after any /\n      --ignore-case            exclusion ignores "
                          "case\n      --no-ignore-case         exclusion is case sensitive "
                          "(default)\n      --wildcards              exclude patterns use "
                          "wildcards (default)\n      --no-wildcards           exclude "
                          "patterns are plain strings\n      --wildcards-match-slash  "
                          "exclude pattern wildcards match \'/\' (default)\n      "
                          "--no-wildcards-match-slash exclude pattern wildcards do not match "
                          "\'/\'\n  -P, --absolute-names         don\'t strip leading `/\'s "
                          "from file names\n  -h, --dereference            dump instead the "
                          "files symlinks point to\n      --no-recursion           avoid "
                          "descending automatically in directories\n  -l, --one-file-system  "
                          "      stay in local file system when creating archive\n  -K, "
                          "--starting-file=NAME     begin at file NAME in the archive\n      "
                          "--strip-path=NUM         strip NUM leading components from file "
                          "names\n                               before extraction\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28702\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___9, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28703\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___10 = gettext("  -N, --newer=DATE-OR-FILE     only store files "
                           "newer than DATE-OR-FILE\n      --newer-mtime=DATE  "
                           "     compare date and time when data changed "
                           "only\n      --after-date=DATE        same as -N\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28707\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___10, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28708\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___11 = gettext("      --backup[=CONTROL]       backup before removal, "
                           "choose version control\n      --suffix=SUFFIX          "
                           "backup before removal, override usual suffix\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28711\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___11, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28712\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___12 = gettext("\nInformative output:\n      --help            print this help, "
                           "then exit\n      --version         print tar program version "
                           "number, then exit\n  -v, --verbose         verbosely list files "
                           "processed\n      --checkpoint      print directory names while "
                           "reading the archive\n      --check-links     print a message if "
                           "not all links are dumped\n      --totals          print total "
                           "bytes written while creating archive\n      --index-file=FILE "
                           "send verbose output to FILE\n      --utc             print file "
                           "modification dates in UTC\n  -R, --block-number    show block "
                           "number within archive with each message\n  -w, --interactive     "
                           "ask for confirmation for every action\n      --confirmation    "
                           "same as -w\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28724\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___12, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28725\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("\nCompatibility options:\n  -o                                 "
                           "when creating, same as --old-archive\n                            "
                           "         when extracting, same as --no-same-owner\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28728\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___13, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28729\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___14 = gettext("\nThe backup suffix is `~\', unless set with --suffix or "
                           "SIMPLE_BACKUP_SUFFIX.\nThe version control may be set "
                           "with --backup or VERSION_CONTROL, values are:\n\n  t, "
                           "numbered     make numbered backups\n  nil, existing   "
                           "numbered if numbered backups exist, simple otherwise\n  "
                           "never, simple   always make simple backups\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28735\n");
printf("\nFUNC_CALL;fputs_unlocked(const char *__restrict,FILE *__restrict);\n");
fputs_unlocked((char const * /* __restrict  */)tmp___14, (FILE * /* __restrict  */) stdout);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28736\n");
tmp___15 = archive_format_string((enum archive_format)6);
        printf("\nSTMT_EXEC;;28737\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___16 = gettext("\nARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE "
                           "may be a textual date\nor a file name starting with `/\' "
                           "or `.\', in which case the file\'s date is used.\n*This* "
                           "`tar\' defaults to `--format=%s -f%s -b%d\'.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28741\n");
printf((char const * /* __restrict  */)tmp___16, tmp___15, "-", 20);
        printf("\nSTMT_EXEC;;28742\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___17 = gettext("\nReport bugs to <%s>.\n");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;28743\n");
printf((char const * /* __restrict  */)tmp___17, "bug-tar@gnu.org");
      }
    }
    {
      printf("\nSTMT_EXEC;;28747\n");
printf("\nFUNC_CALL;exit(int);\n");
exit(status);printf("\nFUNC_RETURN;;\n");

    }
  }
printf("\nFUNC_RETURN;;\n");
}
static void set_subcommand_option(enum subcommand subcommand)
{
  printf("\nFUNC_CALL;set_subcommand_option(enum subcommand);\n");
printf("\nSTMT_EXEC;;28753\n");
char *tmp;
  printf("\nSTMT_EXEC;;28754\n");
char *__cil_tmp3;

  {
    printf("\nSTMT_EXEC;;28757\n");
if ((unsigned int)subcommand_option != 0U)
    {
      printf("\nSTMT_EXEC;;28759\n");
if ((unsigned int)subcommand_option != (unsigned int)subcommand)
      {
        {
          printf("\nSTMT_EXEC;;28762\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("You may not specify more than one `-Acdtrux\' option");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;28763\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;28764\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;28768\n");
subcommand_option = subcommand;
    printf("\nSTMT_EXEC;;28769\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void set_use_compress_program_option(char const *string)
{
  printf("\nFUNC_CALL;set_use_compress_program_option(const char *);\n");
printf("\nSTMT_EXEC;;28774\n");
char *tmp;
  printf("\nSTMT_EXEC;;28775\n");
int tmp___0;
  printf("\nSTMT_EXEC;;28776\n");
char *__cil_tmp4;

  {
    printf("\nSTMT_EXEC;;28779\n");
if (use_compress_program_option)
    {
      {
        printf("\nSTMT_EXEC;;28782\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(use_compress_program_option, string);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;28784\n");
if (tmp___0 != 0)
      {
        {
          printf("\nSTMT_EXEC;;28787\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Conflicting compression options");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;28788\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;28789\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;28793\n");
use_compress_program_option = string;
    printf("\nSTMT_EXEC;;28794\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}






static void decode_options(int argc, char **argv)
{
  printf("\nFUNC_CALL;decode_options(int,char **);\n");
printf("\nSTMT_EXEC;;28805\n");
int optchar;
  printf("\nSTMT_EXEC;;28806\n");
int input_files;
  printf("\nSTMT_EXEC;;28807\n");
char const *textual_date_option;
  printf("\nSTMT_EXEC;;28808\n");
char const *backup_suffix_string;
  printf("\nSTMT_EXEC;;28809\n");
char const *version_control_string;
  printf("\nSTMT_EXEC;;28810\n");
int exclude_options;
  printf("\nSTMT_EXEC;;28811\n");
_Bool o_option;
  printf("\nSTMT_EXEC;;28812\n");
int pax_option;
  printf("\nSTMT_EXEC;;28813\n");
char *tmp;
  printf("\nSTMT_EXEC;;28814\n");
int new_argc;
  printf("\nSTMT_EXEC;;28815\n");
char **new_argv;
  printf("\nSTMT_EXEC;;28816\n");
char *const *in;
  printf("\nSTMT_EXEC;;28817\n");
char **out;
  printf("\nSTMT_EXEC;;28818\n");
char const *letter;
  printf("\nSTMT_EXEC;;28819\n");
char buffer___2[3];
  printf("\nSTMT_EXEC;;28820\n");
char const *cursor;
  printf("\nSTMT_EXEC;;28821\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;28822\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;28823\n");
char **tmp___2;
  printf("\nSTMT_EXEC;;28824\n");
char *const *tmp___3;
  printf("\nSTMT_EXEC;;28825\n");
char *const *tmp___4;
  printf("\nSTMT_EXEC;;28826\n");
char **tmp___5;
  printf("\nSTMT_EXEC;;28827\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;28828\n");
char **tmp___7;
  printf("\nSTMT_EXEC;;28829\n");
char *const *tmp___8;
  printf("\nSTMT_EXEC;;28830\n");
char *tmp___9;
  printf("\nSTMT_EXEC;;28831\n");
char **tmp___10;
  printf("\nSTMT_EXEC;;28832\n");
char *const *tmp___11;
  printf("\nSTMT_EXEC;;28833\n");
char *tmp___12;
  printf("\nSTMT_EXEC;;28834\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;28835\n");
char *tmp___13;
  printf("\nSTMT_EXEC;;28836\n");
char *tmp___14;
  printf("\nSTMT_EXEC;;28837\n");
strtol_error tmp___15;
  printf("\nSTMT_EXEC;;28838\n");
void *tmp___16;
  printf("\nSTMT_EXEC;;28839\n");
int tmp___17;
  printf("\nSTMT_EXEC;;28840\n");
char *tmp___18;
  printf("\nSTMT_EXEC;;28841\n");
uintmax_t u___0;
  printf("\nSTMT_EXEC;;28842\n");
char *tmp___19;
  printf("\nSTMT_EXEC;;28843\n");
char *tmp___20;
  printf("\nSTMT_EXEC;;28844\n");
strtol_error tmp___21;
  printf("\nSTMT_EXEC;;28845\n");
char *tmp___22;
  printf("\nSTMT_EXEC;;28846\n");
struct stat st;
  printf("\nSTMT_EXEC;;28847\n");
char *tmp___23;
  printf("\nSTMT_EXEC;;28848\n");
int tmp___24;
  printf("\nSTMT_EXEC;;28849\n");
char const *tmp___25;
  printf("\nSTMT_EXEC;;28850\n");
char const *tmp___26;
  printf("\nSTMT_EXEC;;28851\n");
char *tmp___27;
  printf("\nSTMT_EXEC;;28852\n");
_Bool tmp___28;
  printf("\nSTMT_EXEC;;28853\n");
int e;
  printf("\nSTMT_EXEC;;28854\n");
int *tmp___29;
  printf("\nSTMT_EXEC;;28855\n");
char *tmp___30;
  printf("\nSTMT_EXEC;;28856\n");
int tmp___31;
  printf("\nSTMT_EXEC;;28857\n");
char *tmp___32;
  printf("\nSTMT_EXEC;;28858\n");
uintmax_t g;
  printf("\nSTMT_EXEC;;28859\n");
char *tmp___33;
  printf("\nSTMT_EXEC;;28860\n");
char *tmp___34;
  printf("\nSTMT_EXEC;;28861\n");
strtol_error tmp___35;
  printf("\nSTMT_EXEC;;28862\n");
size_t tmp___36;
  printf("\nSTMT_EXEC;;28863\n");
int tmp___37;
  printf("\nSTMT_EXEC;;28864\n");
char *tmp___38;
  printf("\nSTMT_EXEC;;28865\n");
uintmax_t u___1;
  printf("\nSTMT_EXEC;;28866\n");
char *tmp___39;
  printf("\nSTMT_EXEC;;28867\n");
char *tmp___40;
  printf("\nSTMT_EXEC;;28868\n");
strtol_error tmp___41;
  printf("\nSTMT_EXEC;;28869\n");
uintmax_t u___2;
  printf("\nSTMT_EXEC;;28870\n");
char *tmp___42;
  printf("\nSTMT_EXEC;;28871\n");
char *tmp___43;
  printf("\nSTMT_EXEC;;28872\n");
strtol_error tmp___44;
  printf("\nSTMT_EXEC;;28873\n");
size_t tmp___45;
  printf("\nSTMT_EXEC;;28874\n");
int tmp___46;
  printf("\nSTMT_EXEC;;28875\n");
uintmax_t u___3;
  printf("\nSTMT_EXEC;;28876\n");
char *tmp___47;
  printf("\nSTMT_EXEC;;28877\n");
char *tmp___48;
  printf("\nSTMT_EXEC;;28878\n");
strtol_error tmp___49;
  printf("\nSTMT_EXEC;;28879\n");
char *tmp___50;
  printf("\nSTMT_EXEC;;28880\n");
char const *tmp___51;
  printf("\nSTMT_EXEC;;28881\n");
uintmax_t u___4;
  printf("\nSTMT_EXEC;;28882\n");
char *tmp___52;
  printf("\nSTMT_EXEC;;28883\n");
char *tmp___53;
  printf("\nSTMT_EXEC;;28884\n");
strtol_error tmp___54;
  printf("\nSTMT_EXEC;;28885\n");
char *tmp___55;
  printf("\nSTMT_EXEC;;28886\n");
char *tmp___56;
  printf("\nSTMT_EXEC;;28887\n");
char *tmp___57;
  printf("\nSTMT_EXEC;;28888\n");
char *tmp___58;
  printf("\nSTMT_EXEC;;28889\n");
char *tmp___59;
  printf("\nSTMT_EXEC;;28890\n");
char *tmp___60;
  printf("\nSTMT_EXEC;;28891\n");
char *tmp___61;
  printf("\nSTMT_EXEC;;28892\n");
char *tmp___62;
  printf("\nSTMT_EXEC;;28893\n");
size_t volume_label_max_len;
  printf("\nSTMT_EXEC;;28894\n");
char *tmp___63;
  printf("\nSTMT_EXEC;;28895\n");
char *tmp___64;
  printf("\nSTMT_EXEC;;28896\n");
size_t tmp___65;
  printf("\nSTMT_EXEC;;28897\n");
char *tmp___66;
  printf("\nSTMT_EXEC;;28898\n");
char *tmp___67;
  printf("\nSTMT_EXEC;;28899\n");
char *tmp___68;
  printf("\nSTMT_EXEC;;28900\n");
char *tmp___69;
  printf("\nSTMT_EXEC;;28901\n");
char *tmp___70;
  printf("\nSTMT_EXEC;;28902\n");
char *tmp___71;
  printf("\nSTMT_EXEC;;28903\n");
int tmp___72;
  printf("\nSTMT_EXEC;;28904\n");
char *tmp___73;
  printf("\nSTMT_EXEC;;28905\n");
int tmp___74;
  printf("\nSTMT_EXEC;;28906\n");
char *tmp___75;
  printf("\nSTMT_EXEC;;28907\n");
char const *treated_as;
  printf("\nSTMT_EXEC;;28908\n");
char const *tmp___76;
  printf("\nSTMT_EXEC;;28909\n");
char *tmp___77;
  printf("\nSTMT_EXEC;;28910\n");
int tmp___78;
  printf("\nSTMT_EXEC;;28911\n");
unsigned long tmp___79;
  printf("\nSTMT_EXEC;;28912\n");
void *__cil_tmp110;
  printf("\nSTMT_EXEC;;28913\n");
void *__cil_tmp111;
  printf("\nSTMT_EXEC;;28914\n");
char *__cil_tmp112;
  printf("\nSTMT_EXEC;;28915\n");
char *__cil_tmp113;
  printf("\nSTMT_EXEC;;28916\n");
char *__cil_tmp114;
  printf("\nSTMT_EXEC;;28917\n");
char *__cil_tmp115;
  printf("\nSTMT_EXEC;;28918\n");
char *__cil_tmp116;
  printf("\nSTMT_EXEC;;28919\n");
char *__cil_tmp117;
  printf("\nSTMT_EXEC;;28920\n");
char *__cil_tmp118;
  printf("\nSTMT_EXEC;;28921\n");
char *__cil_tmp119;
  printf("\nSTMT_EXEC;;28922\n");
char *__cil_tmp120;
  printf("\nSTMT_EXEC;;28923\n");
char *__cil_tmp121;
  printf("\nSTMT_EXEC;;28924\n");
char *__cil_tmp122;
  printf("\nSTMT_EXEC;;28925\n");
char *__cil_tmp123;
  printf("\nSTMT_EXEC;;28926\n");
char *__cil_tmp124;
  printf("\nSTMT_EXEC;;28927\n");
char *__cil_tmp125;
  printf("\nSTMT_EXEC;;28928\n");
char *__cil_tmp126;
  printf("\nSTMT_EXEC;;28929\n");
char *__cil_tmp127;
  printf("\nSTMT_EXEC;;28930\n");
char *__cil_tmp128;
  printf("\nSTMT_EXEC;;28931\n");
char *__cil_tmp129;
  printf("\nSTMT_EXEC;;28932\n");
char *__cil_tmp130;
  printf("\nSTMT_EXEC;;28933\n");
char *__cil_tmp131;
  printf("\nSTMT_EXEC;;28934\n");
char *__cil_tmp132;
  printf("\nSTMT_EXEC;;28935\n");
char *__cil_tmp133;
  printf("\nSTMT_EXEC;;28936\n");
char *__cil_tmp134;
  printf("\nSTMT_EXEC;;28937\n");
char *__cil_tmp135;
  printf("\nSTMT_EXEC;;28938\n");
char *__cil_tmp136;
  printf("\nSTMT_EXEC;;28939\n");
char *__cil_tmp137;
  printf("\nSTMT_EXEC;;28940\n");
char *__cil_tmp138;
  printf("\nSTMT_EXEC;;28941\n");
char *__cil_tmp139;
  printf("\nSTMT_EXEC;;28942\n");
char *__cil_tmp140;
  printf("\nSTMT_EXEC;;28943\n");
char *__cil_tmp141;
  printf("\nSTMT_EXEC;;28944\n");
char *__cil_tmp142;
  printf("\nSTMT_EXEC;;28945\n");
char *__cil_tmp143;
  printf("\nSTMT_EXEC;;28946\n");
char *__cil_tmp144;
  printf("\nSTMT_EXEC;;28947\n");
char *__cil_tmp145;
  printf("\nSTMT_EXEC;;28948\n");
char *__cil_tmp146;
  printf("\nSTMT_EXEC;;28949\n");
char *__cil_tmp147;
  printf("\nSTMT_EXEC;;28950\n");
char *__cil_tmp148;
  printf("\nSTMT_EXEC;;28951\n");
char *__cil_tmp149;
  printf("\nSTMT_EXEC;;28952\n");
char *__cil_tmp150;
  printf("\nSTMT_EXEC;;28953\n");
char *__cil_tmp151;
  printf("\nSTMT_EXEC;;28954\n");
char *__cil_tmp152;
  printf("\nSTMT_EXEC;;28955\n");
char *__cil_tmp153;
  printf("\nSTMT_EXEC;;28956\n");
char *__cil_tmp154;
  printf("\nSTMT_EXEC;;28957\n");
char *__cil_tmp155;
  printf("\nSTMT_EXEC;;28958\n");
char *__cil_tmp156;
  printf("\nSTMT_EXEC;;28959\n");
char *__cil_tmp157;
  printf("\nSTMT_EXEC;;28960\n");
char *__cil_tmp158;
  printf("\nSTMT_EXEC;;28961\n");
char *__cil_tmp159;
  printf("\nSTMT_EXEC;;28962\n");
char *__cil_tmp160;
  printf("\nSTMT_EXEC;;28963\n");
char *__cil_tmp161;
  printf("\nSTMT_EXEC;;28964\n");
char *__cil_tmp162;
  printf("\nSTMT_EXEC;;28965\n");
char *__cil_tmp163;
  printf("\nSTMT_EXEC;;28966\n");
char *__cil_tmp164;
  printf("\nSTMT_EXEC;;28967\n");
char *__cil_tmp165;
  printf("\nSTMT_EXEC;;28968\n");
char *__cil_tmp166;
  printf("\nSTMT_EXEC;;28969\n");
char *__cil_tmp167;
  printf("\nSTMT_EXEC;;28970\n");
char *__cil_tmp168;
  printf("\nSTMT_EXEC;;28971\n");
char *__cil_tmp169;
  printf("\nSTMT_EXEC;;28972\n");
char *__cil_tmp170;
  printf("\nSTMT_EXEC;;28973\n");
char *__cil_tmp171;
  printf("\nSTMT_EXEC;;28974\n");
char *__cil_tmp172;

  {
    {
      printf("\nSTMT_EXEC;;28978\n");
textual_date_option = (char const *)0;
      printf("\nSTMT_EXEC;;28979\n");
version_control_string = (char const *)0;






















































































































      printf("\nSTMT_EXEC;;29098\n");
exclude_options = 1 << 28;
      printf("\nSTMT_EXEC;;29099\n");
o_option = (_Bool)0;
      printf("\nSTMT_EXEC;;29100\n");
pax_option = 0;
      printf("\nSTMT_EXEC;;29101\n");
subcommand_option = (enum subcommand)0;
      printf("\nSTMT_EXEC;;29102\n");
archive_format = (enum archive_format)0;
      printf("\nSTMT_EXEC;;29103\n");
blocking_factor = 20;
      printf("\nSTMT_EXEC;;29104\n");
record_size = (size_t)10240;
      printf("\nSTMT_EXEC;;29105\n");
excluded = new_exclude();
      printf("\nSTMT_EXEC;;29106\n");
newer_mtime_option.tv_sec = -1L << (sizeof(time_t) * 8UL - 1UL);
      printf("\nSTMT_EXEC;;29107\n");
newer_mtime_option.tv_nsec = (__syscall_slong_t)-1;
      printf("\nSTMT_EXEC;;29108\n");
recursion_option = 1 << 3;
      printf("\nSTMT_EXEC;;29109\n");
owner_option = (uid_t)-1;
      printf("\nSTMT_EXEC;;29110\n");
group_option = (gid_t)-1;
      printf("\nSTMT_EXEC;;29111\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp = getenv("SIMPLE_BACKUP_SUFFIX");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;29112\n");
backup_suffix_string = (char const *)tmp;
    }
    printf("\nSTMT_EXEC;;29114\n");
if (argc > 1)







    {
      printf("\nSTMT_EXEC;;29123\n");
if ((int)*(*(argv + 1) + 0) != 45)
      {
        {
          printf("\nSTMT_EXEC;;29126\n");
buffer___2[0] = (char)'-';
          printf("\nSTMT_EXEC;;29127\n");
buffer___2[2] = (char)'\000';
          printf("\nSTMT_EXEC;;29128\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen((char const *)*(argv + 1));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;29129\n");
new_argc = (int)((size_t)(argc - 1) + tmp___0);
          printf("\nSTMT_EXEC;;29130\n");
tmp___1 = xmalloc((unsigned long)(new_argc + 1) * sizeof(char *));
          printf("\nSTMT_EXEC;;29131\n");
new_argv = (char **)tmp___1;
          printf("\nSTMT_EXEC;;29132\n");
in = (char *const *)argv;
          printf("\nSTMT_EXEC;;29133\n");
out = new_argv;
          printf("\nSTMT_EXEC;;29134\n");
tmp___2 = out;
          printf("\nSTMT_EXEC;;29135\n");
out++;
          printf("\nSTMT_EXEC;;29136\n");
tmp___3 = in;
          printf("\nSTMT_EXEC;;29137\n");
in++;
          printf("\nSTMT_EXEC;;29138\n");
*tmp___2 = (char *)*tmp___3;
          printf("\nSTMT_EXEC;;29139\n");
tmp___4 = in;
          printf("\nSTMT_EXEC;;29140\n");
in++;
          printf("\nSTMT_EXEC;;29141\n");
letter = (char const *)*tmp___4;
        }
        {
          printf("\nSTMT_EXEC;;29144\n");
while (1)
          {
          while_continue: /* CIL Label */;
            printf("\nSTMT_EXEC;;29147\n");
if (!*letter)
            {
              printf("\nSTMT_EXEC;;29149\n");
goto while_break;
            }
            {
              printf("\nSTMT_EXEC;;29152\n");
buffer___2[1] = (char)*letter;
              printf("\nSTMT_EXEC;;29153\n");
tmp___5 = out;
              printf("\nSTMT_EXEC;;29154\n");
out++;
              printf("\nSTMT_EXEC;;29155\n");
*tmp___5 = xstrdup((char const *)(buffer___2));
              printf("\nSTMT_EXEC;;29156\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___6 = strchr("-01234567ABC:F:GIK:L:MN:OPRST:UV:WX:Zb:cdf:g:"
                               "hijklmoprstuvwxyz",
                               (int)*letter);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29159\n");
cursor = (char const *)tmp___6;
            }
            printf("\nSTMT_EXEC;;29161\n");
if (cursor)
            {
              printf("\nSTMT_EXEC;;29163\n");
if ((int const) * (cursor + 1) == 58)
              {
                printf("\nSTMT_EXEC;;29165\n");
if ((unsigned long)in < (unsigned long)(argv + argc))
                {
                  printf("\nSTMT_EXEC;;29167\n");
tmp___7 = out;
                  printf("\nSTMT_EXEC;;29168\n");
out++;
                  printf("\nSTMT_EXEC;;29169\n");
tmp___8 = in;
                  printf("\nSTMT_EXEC;;29170\n");
in++;
                  printf("\nSTMT_EXEC;;29171\n");
*tmp___7 = (char *)*tmp___8;
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;29176\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___9 = gettext("Old option `%c\' requires an argument.");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;29177\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___9, (int const) * letter);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;29178\n");
usage(2);
                  }
                }
              }
            }




            printf("\nSTMT_EXEC;;29187\n");
letter++;
          }
        while_break: /* CIL Label */;
        }
        {
          printf("\nSTMT_EXEC;;29192\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;29195\n");
if (!((unsigned long)in < (unsigned long)(argv + argc)))
            {
              printf("\nSTMT_EXEC;;29197\n");
goto while_break___0;
            }
            printf("\nSTMT_EXEC;;29199\n");
tmp___10 = out;
            printf("\nSTMT_EXEC;;29200\n");
out++;
            printf("\nSTMT_EXEC;;29201\n");
tmp___11 = in;
            printf("\nSTMT_EXEC;;29202\n");
in++;
            printf("\nSTMT_EXEC;;29203\n");
*tmp___10 = (char *)*tmp___11;
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;29207\n");
*out = (char *)0;
        printf("\nSTMT_EXEC;;29208\n");
argc = new_argc;
        printf("\nSTMT_EXEC;;29209\n");
argv = new_argv;
      }
    }
    {
      printf("\nSTMT_EXEC;;29213\n");
input_files = 0;
      printf("\nSTMT_EXEC;;29214\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp___12 = getenv("TAR_OPTIONS");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;29215\n");
prepend_default_options((char const *)tmp___12, &argc, &argv);
    }
    {
      printf("\nSTMT_EXEC;;29218\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;29222\n");
printf("\nFUNC_CALL;getopt_long(int,char *const *,const char *,const struct option *,int *);\n");
optchar = getopt_long(argc, (char *const *)argv, "-01234567ABC:F:GIK:L:MN:OPRST:UV:WX:Zb:cdf:g:hijklmoprstuvwxyz", (struct option const *)(long_options), (int *)0);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;29224\n");
if (!(optchar != -1))
        {
          printf("\nSTMT_EXEC;;29226\n");
goto while_break___1;
        }
        {
          printf("\nSTMT_EXEC;;29229\n");
if (optchar == 63)
          {
            printf("\nSTMT_EXEC;;29231\n");
goto case_63;
          }
          printf("\nSTMT_EXEC;;29233\n");
if (optchar == 0)
          {
            printf("\nSTMT_EXEC;;29235\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;29237\n");
if (optchar == 1)
          {
            printf("\nSTMT_EXEC;;29239\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;29241\n");
if (optchar == 65)
          {
            printf("\nSTMT_EXEC;;29243\n");
goto case_65;
          }
          printf("\nSTMT_EXEC;;29245\n");
if (optchar == 98)
          {
            printf("\nSTMT_EXEC;;29247\n");
goto case_98;
          }
          printf("\nSTMT_EXEC;;29249\n");
if (optchar == 66)
          {
            printf("\nSTMT_EXEC;;29251\n");
goto case_66;
          }
          printf("\nSTMT_EXEC;;29253\n");
if (optchar == 99)
          {
            printf("\nSTMT_EXEC;;29255\n");
goto case_99;
          }
          printf("\nSTMT_EXEC;;29257\n");
if (optchar == 67)
          {
            printf("\nSTMT_EXEC;;29259\n");
goto case_67;
          }
          printf("\nSTMT_EXEC;;29261\n");
if (optchar == 100)
          {
            printf("\nSTMT_EXEC;;29263\n");
goto case_100;
          }
          printf("\nSTMT_EXEC;;29265\n");
if (optchar == 102)
          {
            printf("\nSTMT_EXEC;;29267\n");
goto case_102;
          }
          printf("\nSTMT_EXEC;;29269\n");
if (optchar == 70)
          {
            printf("\nSTMT_EXEC;;29271\n");
goto case_70;
          }
          printf("\nSTMT_EXEC;;29273\n");
if (optchar == 103)
          {
            printf("\nSTMT_EXEC;;29275\n");
goto case_103;
          }
          printf("\nSTMT_EXEC;;29277\n");
if (optchar == 71)
          {
            printf("\nSTMT_EXEC;;29279\n");
goto case_71;
          }
          printf("\nSTMT_EXEC;;29281\n");
if (optchar == 104)
          {
            printf("\nSTMT_EXEC;;29283\n");
goto case_104;
          }
          printf("\nSTMT_EXEC;;29285\n");
if (optchar == 105)
          {
            printf("\nSTMT_EXEC;;29287\n");
goto case_105;
          }
          printf("\nSTMT_EXEC;;29289\n");
if (optchar == 73)
          {
            printf("\nSTMT_EXEC;;29291\n");
goto case_73;
          }
          printf("\nSTMT_EXEC;;29293\n");
if (optchar == 106)
          {
            printf("\nSTMT_EXEC;;29295\n");
goto case_106;
          }
          printf("\nSTMT_EXEC;;29297\n");
if (optchar == 107)
          {
            printf("\nSTMT_EXEC;;29299\n");
goto case_107;
          }
          printf("\nSTMT_EXEC;;29301\n");
if (optchar == 75)
          {
            printf("\nSTMT_EXEC;;29303\n");
goto case_75;
          }
          printf("\nSTMT_EXEC;;29305\n");
if (optchar == 108)
          {
            printf("\nSTMT_EXEC;;29307\n");
goto case_108;
          }
          printf("\nSTMT_EXEC;;29309\n");
if (optchar == 76)
          {
            printf("\nSTMT_EXEC;;29311\n");
goto case_76;
          }
          printf("\nSTMT_EXEC;;29313\n");
if (optchar == 109)
          {
            printf("\nSTMT_EXEC;;29315\n");
goto case_109;
          }
          printf("\nSTMT_EXEC;;29317\n");
if (optchar == 77)
          {
            printf("\nSTMT_EXEC;;29319\n");
goto case_77;
          }
          printf("\nSTMT_EXEC;;29321\n");
if (optchar == 78)
          {
            printf("\nSTMT_EXEC;;29323\n");
goto case_78;
          }
          printf("\nSTMT_EXEC;;29325\n");
if (optchar == 142)
          {
            printf("\nSTMT_EXEC;;29327\n");
goto case_142;
          }
          printf("\nSTMT_EXEC;;29329\n");
if (optchar == 111)
          {
            printf("\nSTMT_EXEC;;29331\n");
goto case_111;
          }
          printf("\nSTMT_EXEC;;29333\n");
if (optchar == 79)
          {
            printf("\nSTMT_EXEC;;29335\n");
goto case_79;
          }
          printf("\nSTMT_EXEC;;29337\n");
if (optchar == 112)
          {
            printf("\nSTMT_EXEC;;29339\n");
goto case_112;
          }
          printf("\nSTMT_EXEC;;29341\n");
if (optchar == 80)
          {
            printf("\nSTMT_EXEC;;29343\n");
goto case_80;
          }
          printf("\nSTMT_EXEC;;29345\n");
if (optchar == 114)
          {
            printf("\nSTMT_EXEC;;29347\n");
goto case_114;
          }
          printf("\nSTMT_EXEC;;29349\n");
if (optchar == 82)
          {
            printf("\nSTMT_EXEC;;29351\n");
goto case_82;
          }
          printf("\nSTMT_EXEC;;29353\n");
if (optchar == 115)
          {
            printf("\nSTMT_EXEC;;29355\n");
goto case_115;
          }
          printf("\nSTMT_EXEC;;29357\n");
if (optchar == 83)
          {
            printf("\nSTMT_EXEC;;29359\n");
goto case_83;
          }
          printf("\nSTMT_EXEC;;29361\n");
if (optchar == 116)
          {
            printf("\nSTMT_EXEC;;29363\n");
goto case_116;
          }
          printf("\nSTMT_EXEC;;29365\n");
if (optchar == 84)
          {
            printf("\nSTMT_EXEC;;29367\n");
goto case_84;
          }
          printf("\nSTMT_EXEC;;29369\n");
if (optchar == 117)
          {
            printf("\nSTMT_EXEC;;29371\n");
goto case_117;
          }
          printf("\nSTMT_EXEC;;29373\n");
if (optchar == 85)
          {
            printf("\nSTMT_EXEC;;29375\n");
goto case_85;
          }
          printf("\nSTMT_EXEC;;29377\n");
if (optchar == 167)
          {
            printf("\nSTMT_EXEC;;29379\n");
goto case_167;
          }
          printf("\nSTMT_EXEC;;29381\n");
if (optchar == 118)
          {
            printf("\nSTMT_EXEC;;29383\n");
goto case_118;
          }
          printf("\nSTMT_EXEC;;29385\n");
if (optchar == 86)
          {
            printf("\nSTMT_EXEC;;29387\n");
goto case_86;
          }
          printf("\nSTMT_EXEC;;29389\n");
if (optchar == 119)
          {
            printf("\nSTMT_EXEC;;29391\n");
goto case_119;
          }
          printf("\nSTMT_EXEC;;29393\n");
if (optchar == 87)
          {
            printf("\nSTMT_EXEC;;29395\n");
goto case_87;
          }
          printf("\nSTMT_EXEC;;29397\n");
if (optchar == 120)
          {
            printf("\nSTMT_EXEC;;29399\n");
goto case_120;
          }
          printf("\nSTMT_EXEC;;29401\n");
if (optchar == 88)
          {
            printf("\nSTMT_EXEC;;29403\n");
goto case_88;
          }
          printf("\nSTMT_EXEC;;29405\n");
if (optchar == 121)
          {
            printf("\nSTMT_EXEC;;29407\n");
goto case_121;
          }
          printf("\nSTMT_EXEC;;29409\n");
if (optchar == 122)
          {
            printf("\nSTMT_EXEC;;29411\n");
goto case_122;
          }
          printf("\nSTMT_EXEC;;29413\n");
if (optchar == 90)
          {
            printf("\nSTMT_EXEC;;29415\n");
goto case_90;
          }
          printf("\nSTMT_EXEC;;29417\n");
if (optchar == 128)
          {
            printf("\nSTMT_EXEC;;29419\n");
goto case_128;
          }
          printf("\nSTMT_EXEC;;29421\n");
if (optchar == 129)
          {
            printf("\nSTMT_EXEC;;29423\n");
goto case_129;
          }
          printf("\nSTMT_EXEC;;29425\n");
if (optchar == 131)
          {
            printf("\nSTMT_EXEC;;29427\n");
goto case_131;
          }
          printf("\nSTMT_EXEC;;29429\n");
if (optchar == 130)
          {
            printf("\nSTMT_EXEC;;29431\n");
goto case_130;
          }
          printf("\nSTMT_EXEC;;29433\n");
if (optchar == 132)
          {
            printf("\nSTMT_EXEC;;29435\n");
goto case_132;
          }
          printf("\nSTMT_EXEC;;29437\n");
if (optchar == 133)
          {
            printf("\nSTMT_EXEC;;29439\n");
goto case_133;
          }
          printf("\nSTMT_EXEC;;29441\n");
if (optchar == 134)
          {
            printf("\nSTMT_EXEC;;29443\n");
goto case_134;
          }
          printf("\nSTMT_EXEC;;29445\n");
if (optchar == 135)
          {
            printf("\nSTMT_EXEC;;29447\n");
goto case_135;
          }
          printf("\nSTMT_EXEC;;29449\n");
if (optchar == 139)
          {
            printf("\nSTMT_EXEC;;29451\n");
goto case_139;
          }
          printf("\nSTMT_EXEC;;29453\n");
if (optchar == 137)
          {
            printf("\nSTMT_EXEC;;29455\n");
goto case_137;
          }
          printf("\nSTMT_EXEC;;29457\n");
if (optchar == 138)
          {
            printf("\nSTMT_EXEC;;29459\n");
goto case_138;
          }
          printf("\nSTMT_EXEC;;29461\n");
if (optchar == 140)
          {
            printf("\nSTMT_EXEC;;29463\n");
goto case_140;
          }
          printf("\nSTMT_EXEC;;29465\n");
if (optchar == 136)
          {
            printf("\nSTMT_EXEC;;29467\n");
goto case_136;
          }
          printf("\nSTMT_EXEC;;29469\n");
if (optchar == 141)
          {
            printf("\nSTMT_EXEC;;29471\n");
goto case_141;
          }
          printf("\nSTMT_EXEC;;29473\n");
if (optchar == 143)
          {
            printf("\nSTMT_EXEC;;29475\n");
goto case_143;
          }
          printf("\nSTMT_EXEC;;29477\n");
if (optchar == 144)
          {
            printf("\nSTMT_EXEC;;29479\n");
goto case_144;
          }
          printf("\nSTMT_EXEC;;29481\n");
if (optchar == 145)
          {
            printf("\nSTMT_EXEC;;29483\n");
goto case_145;
          }
          printf("\nSTMT_EXEC;;29485\n");
if (optchar == 146)
          {
            printf("\nSTMT_EXEC;;29487\n");
goto case_146;
          }
          printf("\nSTMT_EXEC;;29489\n");
if (optchar == 147)
          {
            printf("\nSTMT_EXEC;;29491\n");
goto case_147;
          }
          printf("\nSTMT_EXEC;;29493\n");
if (optchar == 148)
          {
            printf("\nSTMT_EXEC;;29495\n");
goto case_148;
          }
          printf("\nSTMT_EXEC;;29497\n");
if (optchar == 149)
          {
            printf("\nSTMT_EXEC;;29499\n");
goto case_149;
          }
          printf("\nSTMT_EXEC;;29501\n");
if (optchar == 150)
          {
            printf("\nSTMT_EXEC;;29503\n");
goto case_150;
          }
          printf("\nSTMT_EXEC;;29505\n");
if (optchar == 151)
          {
            printf("\nSTMT_EXEC;;29507\n");
goto case_151;
          }
          printf("\nSTMT_EXEC;;29509\n");
if (optchar == 152)
          {
            printf("\nSTMT_EXEC;;29511\n");
goto case_152;
          }
          printf("\nSTMT_EXEC;;29513\n");
if (optchar == 153)
          {
            printf("\nSTMT_EXEC;;29515\n");
goto case_153;
          }
          printf("\nSTMT_EXEC;;29517\n");
if (optchar == 154)
          {
            printf("\nSTMT_EXEC;;29519\n");
goto case_154;
          }
          printf("\nSTMT_EXEC;;29521\n");
if (optchar == 155)
          {
            printf("\nSTMT_EXEC;;29523\n");
goto case_155;
          }
          printf("\nSTMT_EXEC;;29525\n");
if (optchar == 156)
          {
            printf("\nSTMT_EXEC;;29527\n");
goto case_156;
          }
          printf("\nSTMT_EXEC;;29529\n");
if (optchar == 157)
          {
            printf("\nSTMT_EXEC;;29531\n");
goto case_157;
          }
          printf("\nSTMT_EXEC;;29533\n");
if (optchar == 158)
          {
            printf("\nSTMT_EXEC;;29535\n");
goto case_158;
          }
          printf("\nSTMT_EXEC;;29537\n");
if (optchar == 159)
          {
            printf("\nSTMT_EXEC;;29539\n");
goto case_159;
          }
          printf("\nSTMT_EXEC;;29541\n");
if (optchar == 160)
          {
            printf("\nSTMT_EXEC;;29543\n");
goto case_160;
          }
          printf("\nSTMT_EXEC;;29545\n");
if (optchar == 161)
          {
            printf("\nSTMT_EXEC;;29547\n");
goto case_161;
          }
          printf("\nSTMT_EXEC;;29549\n");
if (optchar == 163)
          {
            printf("\nSTMT_EXEC;;29551\n");
goto case_163;
          }
          printf("\nSTMT_EXEC;;29553\n");
if (optchar == 164)
          {
            printf("\nSTMT_EXEC;;29555\n");
goto case_164;
          }
          printf("\nSTMT_EXEC;;29557\n");
if (optchar == 165)
          {
            printf("\nSTMT_EXEC;;29559\n");
goto case_165;
          }
          printf("\nSTMT_EXEC;;29561\n");
if (optchar == 166)
          {
            printf("\nSTMT_EXEC;;29563\n");
goto case_166;
          }
          printf("\nSTMT_EXEC;;29565\n");
if (optchar == 168)
          {
            printf("\nSTMT_EXEC;;29567\n");
goto case_168;
          }
          printf("\nSTMT_EXEC;;29569\n");
if (optchar == 169)
          {
            printf("\nSTMT_EXEC;;29571\n");
goto case_169;
          }
          printf("\nSTMT_EXEC;;29573\n");
if (optchar == 170)
          {
            printf("\nSTMT_EXEC;;29575\n");
goto case_170;
          }
          printf("\nSTMT_EXEC;;29577\n");
if (optchar == 48)
          {
            printf("\nSTMT_EXEC;;29579\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29581\n");
if (optchar == 49)
          {
            printf("\nSTMT_EXEC;;29583\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29585\n");
if (optchar == 50)
          {
            printf("\nSTMT_EXEC;;29587\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29589\n");
if (optchar == 51)
          {
            printf("\nSTMT_EXEC;;29591\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29593\n");
if (optchar == 52)
          {
            printf("\nSTMT_EXEC;;29595\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29597\n");
if (optchar == 53)
          {
            printf("\nSTMT_EXEC;;29599\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29601\n");
if (optchar == 54)
          {
            printf("\nSTMT_EXEC;;29603\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29605\n");
if (optchar == 55)
          {
            printf("\nSTMT_EXEC;;29607\n");
goto case_48;
          }
          printf("\nSTMT_EXEC;;29609\n");
goto switch_break;
        case_63: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29612\n");
usage(2);
        }
        case_0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29615\n");
goto switch_break;
}

        case_1: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29618\n");
name_add((char const *)optarg);
          printf("\nSTMT_EXEC;;29619\n");
input_files++;
        }
          printf("\nSTMT_EXEC;;29621\n");
goto switch_break;
        case_65: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29624\n");
set_subcommand_option((enum subcommand)2);
        }
          printf("\nSTMT_EXEC;;29626\n");
goto switch_break;
        case_98: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29629\n");
tmp___15 = xstrtoumax((char const *)optarg, (char **)0, 10, &u, "");
        }
          printf("\nSTMT_EXEC;;29631\n");
if ((unsigned int)tmp___15 == 0U)
          {
            printf("\nSTMT_EXEC;;29633\n");
blocking_factor = (int)u;
            printf("\nSTMT_EXEC;;29634\n");
if (u == (uintmax_t)blocking_factor)
            {
              printf("\nSTMT_EXEC;;29636\n");
if (0 < blocking_factor)
              {
                printf("\nSTMT_EXEC;;29638\n");
record_size = u * 512UL;
                printf("\nSTMT_EXEC;;29639\n");
if (!(u == record_size / 512UL))
                {
                  {
                    printf("\nSTMT_EXEC;;29642\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("Invalid blocking factor");printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;29643\n");
tmp___14 = quotearg_colon((char const *)optarg);
                    printf("\nSTMT_EXEC;;29644\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___14, tmp___13);printf("\nFUNC_RETURN;;\n");

                    printf("\nSTMT_EXEC;;29645\n");
usage(2);
                  }
                }
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;29652\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("Invalid blocking factor");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29653\n");
tmp___14 = quotearg_colon((char const *)optarg);
                  printf("\nSTMT_EXEC;;29654\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___14, tmp___13);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29655\n");
usage(2);
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;29662\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("Invalid blocking factor");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;29663\n");
tmp___14 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;29664\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___14, tmp___13);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;29665\n");
usage(2);
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;29672\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___13 = gettext("Invalid blocking factor");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29673\n");
tmp___14 = quotearg_colon((char const *)optarg);
              printf("\nSTMT_EXEC;;29674\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___14, tmp___13);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29675\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;29678\n");
goto switch_break;
        case_66: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29680\n");
read_full_records_option = (_Bool)1;
}


          printf("\nSTMT_EXEC;;29682\n");
goto switch_break;
        case_99: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29685\n");
set_subcommand_option((enum subcommand)3);
        }
          printf("\nSTMT_EXEC;;29687\n");
goto switch_break;
        case_67: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29690\n");
name_add("-C");
          printf("\nSTMT_EXEC;;29691\n");
name_add((char const *)optarg);
        }
          printf("\nSTMT_EXEC;;29693\n");
goto switch_break;
        case_100: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29696\n");
set_subcommand_option((enum subcommand)5);
        }
          printf("\nSTMT_EXEC;;29698\n");
goto switch_break;

        case_102: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29701\n");
if (archive_names == allocated_archive_names)
          {
            {
              printf("\nSTMT_EXEC;;29704\n");
allocated_archive_names *= 2;
              printf("\nSTMT_EXEC;;29705\n");
tmp___16 = xrealloc((void *)archive_name_array, sizeof(char const *) * (unsigned long)allocated_archive_names);
              printf("\nSTMT_EXEC;;29706\n");
archive_name_array = (char const **)tmp___16;
            }

          }
}

          printf("\nSTMT_EXEC;;29710\n");
tmp___17 = archive_names;
          printf("\nSTMT_EXEC;;29711\n");
archive_names++;
          printf("\nSTMT_EXEC;;29712\n");
*(archive_name_array + tmp___17) = (char const *)optarg;
          printf("\nSTMT_EXEC;;29713\n");
goto switch_break;
        case_70: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29715\n");
info_script_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;29716\n");
multi_volume_option = (_Bool)1;
          printf("\nSTMT_EXEC;;29717\n");
goto switch_break;
        case_103: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29719\n");
listed_incremental_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;29720\n");
after_date_option = 1;
        case_71: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29722\n");
incremental_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29723\n");
goto switch_break;
        case_104: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29725\n");
dereference_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29726\n");
goto switch_break;
        case_105: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29728\n");
ignore_zeros_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29729\n");
goto switch_break;
        case_73: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29732\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___18 = gettext("Warning: the -I option is not supported; perhaps "
                             "you meant -j or -T?");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;29734\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___18);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;29735\n");
usage(2);
        }
          printf("\nSTMT_EXEC;;29737\n");
goto switch_break;
        case_106: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29740\n");
set_use_compress_program_option("bzip2");
        }
          printf("\nSTMT_EXEC;;29742\n");
goto switch_break;
        case_107: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29744\n");
old_files_option = (enum old_files)4;
}

          printf("\nSTMT_EXEC;;29745\n");
goto switch_break;
        case_75: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29748\n");
starting_file_option = (_Bool)1;
          printf("\nSTMT_EXEC;;29749\n");
addname((char const *)optarg, 0);
        }
          printf("\nSTMT_EXEC;;29751\n");
goto switch_break;
        case_108: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29753\n");
one_file_system_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29754\n");
goto switch_break;
        case_76: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29757\n");
tmp___21 = xstrtoumax((char const *)optarg, (char **)0, 10, &u___0, "");
        }
          printf("\nSTMT_EXEC;;29759\n");
if ((unsigned int)tmp___21 != 0U)
          {
            {
              printf("\nSTMT_EXEC;;29762\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___19 = gettext("Invalid tape length");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29763\n");
tmp___20 = quotearg_colon((char const *)optarg);
              printf("\nSTMT_EXEC;;29764\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___20, tmp___19);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29765\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;29768\n");
tape_length_option = (tarlong)1024 * (tarlong)u___0;
          printf("\nSTMT_EXEC;;29769\n");
multi_volume_option = (_Bool)1;
          printf("\nSTMT_EXEC;;29770\n");
goto switch_break;
        case_109: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29772\n");
touch_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29773\n");
goto switch_break;
        case_77: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29775\n");
multi_volume_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29776\n");
goto switch_break;
        case_78: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29778\n");
after_date_option = 1;
}

        case_142: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29780\n");
if (0L <= newer_mtime_option.tv_nsec)
          {
            {
              printf("\nSTMT_EXEC;;29783\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___22 = gettext("More than one threshold date");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29784\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___22);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29785\n");
usage(2);
            }
          }
}

          printf("\nSTMT_EXEC;;29788\n");
if ((int)*optarg == 47)
          {
            printf("\nSTMT_EXEC;;29790\n");
goto _L___3;
          }
          else
          {
            printf("\nSTMT_EXEC;;29794\n");
if ((int)*optarg == 46)
            {
            _L___3: /* CIL Label */
            {
              printf("\nSTMT_EXEC;;29798\n");
tmp___24 = deref_stat(dereference_option, (char const *)optarg, &st);
            }
              printf("\nSTMT_EXEC;;29800\n");
if (tmp___24 != 0)
              {
                {
                  printf("\nSTMT_EXEC;;29803\n");
stat_error((char const *)optarg);
                  printf("\nSTMT_EXEC;;29804\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___23 = gettext("Date file not found");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29805\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___23);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29806\n");
usage(2);
                }
              }
              printf("\nSTMT_EXEC;;29809\n");
newer_mtime_option.tv_sec = st.st_mtim.tv_sec;
              printf("\nSTMT_EXEC;;29810\n");
newer_mtime_option.tv_nsec = st.st_mtim.tv_nsec;
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;29815\n");
tmp___28 = get_date(&newer_mtime_option, (char const *)optarg, (struct timespec const *)((void *)0));
              }
              printf("\nSTMT_EXEC;;29817\n");
if (tmp___28)
              {
                printf("\nSTMT_EXEC;;29819\n");
textual_date_option = (char const *)optarg;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;29824\n");
tmp___25 = quote((char const *)optarg);
                  printf("\nSTMT_EXEC;;29825\n");
tmp___26 = tartime(newer_mtime_option.tv_sec);
                  printf("\nSTMT_EXEC;;29826\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___27 = gettext("Substituting %s for unknown date format %s");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29827\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___27, tmp___26, tmp___25);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;29828\n");
newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
                }
              }
            }
          }
          printf("\nSTMT_EXEC;;29833\n");
goto switch_break;
        case_111: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29835\n");
o_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29836\n");
goto switch_break;
        case_79: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29838\n");
to_stdout_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29839\n");
goto switch_break;
        case_112: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29841\n");
same_permissions_option = 1;
}

          printf("\nSTMT_EXEC;;29842\n");
goto switch_break;
        case_80: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29844\n");
absolute_names_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29845\n");
goto switch_break;
        case_114: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29848\n");
set_subcommand_option((enum subcommand)1);
        }
          printf("\nSTMT_EXEC;;29850\n");
goto switch_break;
        case_82: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29852\n");
block_number_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29853\n");
goto switch_break;
        case_115: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29855\n");
same_order_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29856\n");
goto switch_break;
        case_83: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29858\n");
sparse_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29859\n");
goto switch_break;
        case_116: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29862\n");
set_subcommand_option((enum subcommand)7);
          printf("\nSTMT_EXEC;;29863\n");
verbose_option++;
        }
          printf("\nSTMT_EXEC;;29865\n");
goto switch_break;
        case_84: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29867\n");
files_from_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;29868\n");
goto switch_break;
        case_117: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29871\n");
set_subcommand_option((enum subcommand)8);
        }
          printf("\nSTMT_EXEC;;29873\n");
goto switch_break;
        case_85: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29875\n");
old_files_option = (enum old_files)3;
}

          printf("\nSTMT_EXEC;;29876\n");
goto switch_break;
        case_167: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29878\n");
utc_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29879\n");
goto switch_break;
        case_118: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29881\n");
verbose_option++;
}

          printf("\nSTMT_EXEC;;29882\n");
goto switch_break;
        case_86: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29884\n");
volume_label_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;29885\n");
goto switch_break;
        case_119: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29887\n");
interactive_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29888\n");
goto switch_break;
        case_87: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29890\n");
verify_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29891\n");
goto switch_break;


        case_120: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29896\n");
set_subcommand_option((enum subcommand)6);
        }
          printf("\nSTMT_EXEC;;29898\n");
goto switch_break;
        case_88: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29901\n");
tmp___31 = add_exclude_file(&add_exclude, excluded, (char const *)optarg, exclude_options | recursion_option, (char)'\n');
        }
          printf("\nSTMT_EXEC;;29903\n");
if (tmp___31 != 0)
          {
            {
              printf("\nSTMT_EXEC;;29906\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___29 = __errno_location();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29907\n");
e = *tmp___29;
              printf("\nSTMT_EXEC;;29908\n");
tmp___30 = quotearg_colon((char const *)optarg);
              printf("\nSTMT_EXEC;;29909\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, e, "%s", tmp___30);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;29910\n");
fatal_exit();
            }
          }
          printf("\nSTMT_EXEC;;29913\n");
goto switch_break;
        case_121: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29916\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___32 = gettext("Warning: the -y option is not supported; perhaps you meant -j?");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;29917\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___32);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;29918\n");
usage(2);
        }
          printf("\nSTMT_EXEC;;29920\n");
goto switch_break;
        case_122: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29923\n");
set_use_compress_program_option("gzip");
        }
          printf("\nSTMT_EXEC;;29925\n");
goto switch_break;
        case_90: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29928\n");
set_use_compress_program_option("compress");
        }
          printf("\nSTMT_EXEC;;29930\n");
goto switch_break;
        case_128: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29932\n");
exclude_options |= 1 << 30;
}

          printf("\nSTMT_EXEC;;29933\n");
goto switch_break;
        case_129: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29935\n");
atime_preserve_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29936\n");
goto switch_break;
        case_131: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29938\n");
checkpoint_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29939\n");
goto switch_break;
        case_130: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29941\n");
backup_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29942\n");
if (optarg)
          {
            printf("\nSTMT_EXEC;;29944\n");
version_control_string = (char const *)optarg;
          }
          printf("\nSTMT_EXEC;;29946\n");
goto switch_break;
        case_132: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29949\n");
set_subcommand_option((enum subcommand)4);
        }
          printf("\nSTMT_EXEC;;29951\n");
goto switch_break;
        case_133: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29954\n");
add_exclude(excluded, (char const *)optarg, exclude_options | recursion_option);
        }
          printf("\nSTMT_EXEC;;29956\n");
goto switch_break;
        case_134: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29958\n");
force_local_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29959\n");
goto switch_break;
        case_135: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29962\n");
set_archive_format((char const *)optarg);
        }
          printf("\nSTMT_EXEC;;29964\n");
goto switch_break;
        case_139: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29966\n");
index_file_name = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;29967\n");
goto switch_break;
        case_137: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29969\n");
exclude_options |= 1 << 4;
}

          printf("\nSTMT_EXEC;;29970\n");
goto switch_break;
        case_138: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29972\n");
ignore_failed_read_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;29973\n");
goto switch_break;
        case_140: /* CIL Label */
          {
printf("\nSTMT_EXEC;;29975\n");
old_files_option = (enum old_files)5;
}

          printf("\nSTMT_EXEC;;29976\n");
goto switch_break;
        case_136: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;29979\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___36 = strlen((char const *)optarg);printf("\nFUNC_RETURN;;\n");

        }
          printf("\nSTMT_EXEC;;29981\n");
if (tmp___36 < 32UL)
          {
            {
              printf("\nSTMT_EXEC;;29984\n");
tmp___37 = gname_to_gid((char const *)optarg, &group_option);
            }
            printf("\nSTMT_EXEC;;29986\n");
if (!tmp___37)
            {
              printf("\nSTMT_EXEC;;29988\n");
goto _L;
            }
          }
          else
          {
          _L:
          {
            printf("\nSTMT_EXEC;;29995\n");
tmp___35 = xstrtoumax((char const *)optarg, (char **)0, 10, &g, "");
          }
            printf("\nSTMT_EXEC;;29997\n");
if ((unsigned int)tmp___35 == 0U)
            {
              printf("\nSTMT_EXEC;;29999\n");
if (g == (uintmax_t)((gid_t)g))
              {
                printf("\nSTMT_EXEC;;30001\n");
group_option = (gid_t)g;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;30006\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___33 = gettext("%s: Invalid group");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;30007\n");
tmp___34 = quotearg_colon((char const *)optarg);
                  printf("\nSTMT_EXEC;;30008\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___34, tmp___33);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;30009\n");
fatal_exit();
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;30016\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___33 = gettext("%s: Invalid group");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30017\n");
tmp___34 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;30018\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___34, tmp___33);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30019\n");
fatal_exit();
              }
            }
          }
          printf("\nSTMT_EXEC;;30023\n");
goto switch_break;
        case_141: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30026\n");
mode_option = mode_compile((char const *)optarg, 7U);
        }
          printf("\nSTMT_EXEC;;30028\n");
if ((unsigned long)mode_option == (unsigned long)((struct mode_change *)0))
          {
            {
              printf("\nSTMT_EXEC;;30031\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___38 = gettext("Invalid mode given on option");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30032\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___38);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30033\n");
fatal_exit();
            }
          }
          printf("\nSTMT_EXEC;;30036\n");
if ((unsigned long)mode_option == (unsigned long)((struct mode_change *)1))
          {
            {
              printf("\nSTMT_EXEC;;30039\n");
xalloc_die();
            }
          }
          printf("\nSTMT_EXEC;;30042\n");
goto switch_break;
        case_143: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30044\n");
exclude_options &= ~(1 << 30);
}

          printf("\nSTMT_EXEC;;30045\n");
goto switch_break;
        case_144: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30047\n");
exclude_options &= ~(1 << 4);
}

          printf("\nSTMT_EXEC;;30048\n");
goto switch_break;
        case_145: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30050\n");
old_files_option = (enum old_files)1;
}

          printf("\nSTMT_EXEC;;30051\n");
goto switch_break;
        case_146: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30053\n");
exclude_options &= ~(1 << 28);
}

          printf("\nSTMT_EXEC;;30054\n");
goto switch_break;
        case_147: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30056\n");
exclude_options |= 1;
}

          printf("\nSTMT_EXEC;;30057\n");
goto switch_break;
        case_148: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30059\n");
filename_terminator = (char)'\000';
}

          printf("\nSTMT_EXEC;;30060\n");
goto switch_break;
        case_149: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30062\n");
numeric_owner_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;30063\n");
goto switch_break;
        case_150: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30065\n");
if (!optarg)
          {
            printf("\nSTMT_EXEC;;30067\n");
occurrence_option = (uintmax_t)1;
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;30072\n");
tmp___41 = xstrtoumax((char const *)optarg, (char **)0, 10, &u___1, "");
            }
            printf("\nSTMT_EXEC;;30074\n");
if ((unsigned int)tmp___41 == 0U)
            {
              printf("\nSTMT_EXEC;;30076\n");
occurrence_option = u___1;
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;30081\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___39 = gettext("Invalid number");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30082\n");
tmp___40 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;30083\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___40, tmp___39);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30084\n");
fatal_exit();
              }
            }
          }
}

          printf("\nSTMT_EXEC;;30088\n");
goto switch_break;
        case_151: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30090\n");
old_files_option = (enum old_files)2;
}

          printf("\nSTMT_EXEC;;30091\n");
goto switch_break;
        case_152: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30094\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___45 = strlen((char const *)optarg);printf("\nFUNC_RETURN;;\n");

        }
          printf("\nSTMT_EXEC;;30096\n");
if (tmp___45 < 32UL)
          {
            {
              printf("\nSTMT_EXEC;;30099\n");
tmp___46 = uname_to_uid((char const *)optarg, &owner_option);
            }
            printf("\nSTMT_EXEC;;30101\n");
if (!tmp___46)
            {
              printf("\nSTMT_EXEC;;30103\n");
goto _L___0;
            }
          }
          else
          {
          _L___0:
          {
            printf("\nSTMT_EXEC;;30110\n");
tmp___44 = xstrtoumax((char const *)optarg, (char **)0, 10, &u___2, "");
          }
            printf("\nSTMT_EXEC;;30112\n");
if ((unsigned int)tmp___44 == 0U)
            {
              printf("\nSTMT_EXEC;;30114\n");
if (u___2 == (uintmax_t)((uid_t)u___2))
              {
                printf("\nSTMT_EXEC;;30116\n");
owner_option = (uid_t)u___2;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;30121\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___42 = gettext("Invalid owner");printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;30122\n");
tmp___43 = quotearg_colon((char const *)optarg);
                  printf("\nSTMT_EXEC;;30123\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___43, tmp___42);printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;30124\n");
fatal_exit();
                }
              }
            }
            else
            {
              {
                printf("\nSTMT_EXEC;;30131\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___42 = gettext("Invalid owner");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30132\n");
tmp___43 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;30133\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___43, tmp___42);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30134\n");
fatal_exit();
              }
            }
          }
          printf("\nSTMT_EXEC;;30138\n");
goto switch_break;
        case_153: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30141\n");
pax_option++;
          printf("\nSTMT_EXEC;;30142\n");
xheader_set_option(optarg);
        }
          printf("\nSTMT_EXEC;;30144\n");
goto switch_break;
        case_154: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30147\n");
set_archive_format("posix");
        }
          printf("\nSTMT_EXEC;;30149\n");
goto switch_break;
        case_155: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30151\n");
same_permissions_option = 1;
}

          printf("\nSTMT_EXEC;;30152\n");
same_order_option = (_Bool)1;
          printf("\nSTMT_EXEC;;30153\n");
goto switch_break;
        case_156: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30156\n");
tmp___49 = xstrtoumax((char const *)optarg, (char **)0, 10, &u___3, "");
        }
          printf("\nSTMT_EXEC;;30158\n");
if ((unsigned int)tmp___49 == 0U)
          {
            printf("\nSTMT_EXEC;;30160\n");
if (!(u___3 == u___3))
            {
              {
                printf("\nSTMT_EXEC;;30163\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___47 = gettext("Invalid record size");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30164\n");
tmp___48 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;30165\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___48, tmp___47);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30166\n");
usage(2);
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;30173\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___47 = gettext("Invalid record size");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30174\n");
tmp___48 = quotearg_colon((char const *)optarg);
              printf("\nSTMT_EXEC;;30175\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___48, tmp___47);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30176\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;30179\n");
record_size = u___3;
          printf("\nSTMT_EXEC;;30180\n");
if (record_size % 512UL != 0UL)
          {
            {
              printf("\nSTMT_EXEC;;30183\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___50 = gettext("Record size must be a multiple of %d.");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30184\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___50, 512);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30185\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;30188\n");
blocking_factor = (int)(record_size / 512UL);
          printf("\nSTMT_EXEC;;30189\n");
goto switch_break;
        case_157: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30191\n");
recursive_unlink_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;30192\n");
goto switch_break;
        case_158: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30194\n");
remove_files_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;30195\n");
goto switch_break;
        case_159: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30197\n");
rmt_command_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;30198\n");
goto switch_break;
        case_160: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30200\n");
rsh_command_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;30201\n");
goto switch_break;
        case_161: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30204\n");
tmp___51 = archive_format_string((enum archive_format)6);
          printf("\nSTMT_EXEC;;30205\n");
printf((char const * /* __restrict  */) "--format=%s -f%s -b%d\n", tmp___51, "-", 20);
          printf("\nSTMT_EXEC;;30206\n");
printf("\nFUNC_CALL;exit(int);\n");
exit(0);printf("\nFUNC_RETURN;;\n");

        }
        case_163: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30210\n");
tmp___54 = xstrtoumax((char const *)optarg, (char **)0, 10, &u___4, "");
        }
          printf("\nSTMT_EXEC;;30212\n");
if ((unsigned int)tmp___54 == 0U)
          {
            printf("\nSTMT_EXEC;;30214\n");
if (!(u___4 == u___4))
            {
              {
                printf("\nSTMT_EXEC;;30217\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___52 = gettext("Invalid number of elements");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30218\n");
tmp___53 = quotearg_colon((char const *)optarg);
                printf("\nSTMT_EXEC;;30219\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___53, tmp___52);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30220\n");
usage(2);
              }
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;30227\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___52 = gettext("Invalid number of elements");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30228\n");
tmp___53 = quotearg_colon((char const *)optarg);
              printf("\nSTMT_EXEC;;30229\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, "%s: %s", tmp___53, tmp___52);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30230\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;30233\n");
strip_path_elements = u___4;
          printf("\nSTMT_EXEC;;30234\n");
goto switch_break;
        case_164: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30236\n");
backup_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;30237\n");
backup_suffix_string = (char const *)optarg;
          printf("\nSTMT_EXEC;;30238\n");
goto switch_break;
        case_165: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30240\n");
totals_option = (_Bool)1;
}

          printf("\nSTMT_EXEC;;30241\n");
goto switch_break;
        case_166: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30244\n");
set_use_compress_program_option((char const *)optarg);
        }
          printf("\nSTMT_EXEC;;30246\n");
goto switch_break;
        case_168: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30248\n");
volno_file_option = (char const *)optarg;
}

          printf("\nSTMT_EXEC;;30249\n");
goto switch_break;
        case_169: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30251\n");
exclude_options |= 1 << 28;
}

          printf("\nSTMT_EXEC;;30252\n");
goto switch_break;
        case_170: /* CIL Label */
          {
printf("\nSTMT_EXEC;;30254\n");
exclude_options &= -2;
}

          printf("\nSTMT_EXEC;;30255\n");
goto switch_break;
        case_48: /* CIL Label */
        case_49: /* CIL Label */
        case_50: /* CIL Label */
        case_51: /* CIL Label */
        case_52: /* CIL Label */
        case_53: /* CIL Label */
        case_54: /* CIL Label */
        case_55: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;30265\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___55 = gettext("Options `-[0-7][lmh]\' not supported by *this* tar");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30266\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___55);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30267\n");
usage(2);
        }
        switch_break: /* CIL Label */;
        }
      }
    while_break___1: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;30274\n");
if (o_option)
    {
      printf("\nSTMT_EXEC;;30276\n");
if ((unsigned int)subcommand_option == 3U)
      {
        {
          printf("\nSTMT_EXEC;;30279\n");
set_archive_format("v7");
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;30284\n");
same_owner_option = 1;
      }
    }
    {
      printf("\nSTMT_EXEC;;30288\n");
while (1)
      {
      while_continue___2: /* CIL Label */;
        printf("\nSTMT_EXEC;;30291\n");
if (!(optind < argc))
        {
          printf("\nSTMT_EXEC;;30293\n");
goto while_break___2;
        }
        {
          printf("\nSTMT_EXEC;;30296\n");
name_add((char const *)*(argv + optind));
          printf("\nSTMT_EXEC;;30297\n");
input_files++;
          printf("\nSTMT_EXEC;;30298\n");
optind++;
        }
      }
    while_break___2: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;30303\n");
if (show_version)
    {
      {
        printf("\nSTMT_EXEC;;30306\n");
printf((char const * /* __restrict  */) "tar (%s) %s\n%s\n", "GNU tar", "1.14", "Copyright (C) 2004 Free Software Foundation, Inc.");
        printf("\nSTMT_EXEC;;30307\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___56 = gettext("This program comes with NO WARRANTY, to the extent permitted by "
                           "law.\nYou may redistribute it under the terms of the GNU General "
                           "Public License;\nsee the file named COPYING for details.");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;30310\n");
printf("\nFUNC_CALL;puts(const char *);\n");
puts((char const *)tmp___56);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;30311\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___57 = gettext("Written by John Gilmore and Jay Fenlason.");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;30312\n");
printf("\nFUNC_CALL;puts(const char *);\n");
puts((char const *)tmp___57);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;30313\n");
printf("\nFUNC_CALL;exit(int);\n");
exit(0);printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;30316\n");
if (show_help)
    {
      {
        printf("\nSTMT_EXEC;;30319\n");
usage(0);
      }
    }
    printf("\nSTMT_EXEC;;30322\n");
if ((unsigned int)archive_format == 0U)
    {
      printf("\nSTMT_EXEC;;30324\n");
if (pax_option)
      {
        printf("\nSTMT_EXEC;;30326\n");
archive_format = (enum archive_format)4;
      }
      else
      {
        printf("\nSTMT_EXEC;;30330\n");
archive_format = (enum archive_format)6;
      }
    }
    printf("\nSTMT_EXEC;;30333\n");
if (volume_label_option)
    {
      printf("\nSTMT_EXEC;;30335\n");
if ((unsigned int)subcommand_option == 3U)
      {
        {
          printf("\nSTMT_EXEC;;30338\n");
assert_format((unsigned int)((1 << 2) | (1 << 6)));
        }
      }
    }
    printf("\nSTMT_EXEC;;30342\n");
if (incremental_option)
    {
      {
        printf("\nSTMT_EXEC;;30345\n");
assert_format((unsigned int)((1 << 2) | (1 << 6)));
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;30350\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;30353\n");
assert_format((unsigned int)((1 << 2) | (1 << 6)));
        }
      }
    }
    printf("\nSTMT_EXEC;;30357\n");
if (sparse_option)
    {
      {
        printf("\nSTMT_EXEC;;30360\n");
assert_format((unsigned int)(((1 << 2) | (1 << 6)) | (1 << 4)));
      }
    }
    printf("\nSTMT_EXEC;;30363\n");
if (occurrence_option)
    {
      printf("\nSTMT_EXEC;;30365\n");
if (!input_files)
      {
        printf("\nSTMT_EXEC;;30367\n");
if (!files_from_option)
        {
          {
            printf("\nSTMT_EXEC;;30370\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___58 = gettext("--occurrence is meaningless without a file list");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30371\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___58);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30372\n");
usage(2);
          }
        }
      }
      printf("\nSTMT_EXEC;;30376\n");
if ((unsigned int)subcommand_option != 4U)
      {
        printf("\nSTMT_EXEC;;30378\n");
if ((unsigned int)subcommand_option != 5U)
        {
          printf("\nSTMT_EXEC;;30380\n");
if ((unsigned int)subcommand_option != 6U)
          {
            printf("\nSTMT_EXEC;;30382\n");
if ((unsigned int)subcommand_option != 7U)
            {
              {
                printf("\nSTMT_EXEC;;30385\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___59 = gettext("--occurrence cannot be used in the "
                                   "requested operation mode");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30387\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___59);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30388\n");
usage(2);
              }
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;30395\n");
if (archive_names == 0)
    {
      {
        printf("\nSTMT_EXEC;;30398\n");
archive_names = 1;
        printf("\nSTMT_EXEC;;30399\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp___60 = getenv("TAPE");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;30400\n");
*(archive_name_array + 0) = (char const *)tmp___60;
      }
      printf("\nSTMT_EXEC;;30402\n");
if (!*(archive_name_array + 0))
      {
        printf("\nSTMT_EXEC;;30404\n");
*(archive_name_array + 0) = "-";
      }
    }
    printf("\nSTMT_EXEC;;30407\n");
if (archive_names > 1)
    {
      printf("\nSTMT_EXEC;;30409\n");
if (!multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;30412\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___61 = gettext("Multiple archive files require `-M\' option");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30413\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___61);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30414\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;30418\n");
if (listed_incremental_option)
    {
      printf("\nSTMT_EXEC;;30420\n");
if (0L <= newer_mtime_option.tv_nsec)
      {
        {
          printf("\nSTMT_EXEC;;30423\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___62 = gettext("Cannot combine --listed-incremental with --newer");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30424\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___62);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30425\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;30429\n");
if (volume_label_option)
    {
      printf("\nSTMT_EXEC;;30431\n");
if (multi_volume_option)
      {
        printf("\nSTMT_EXEC;;30433\n");
tmp___79 = ((sizeof(" Volume ") - 1UL) + ((((sizeof(int) * 8UL - 1UL) * 302UL) / 1000UL + 1UL) + 1UL)) - 1UL;
      }
      else
      {
        printf("\nSTMT_EXEC;;30437\n");
tmp___79 = 0UL;
      }
      {
        printf("\nSTMT_EXEC;;30440\n");
volume_label_max_len = (sizeof(current_header->header.name) - 1UL) - tmp___79;
        printf("\nSTMT_EXEC;;30441\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___65 = strlen(volume_label_option);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;30443\n");
if (volume_label_max_len < tmp___65)
      {
        {
          printf("\nSTMT_EXEC;;30446\n");
tmp___63 = quotearg_colon(volume_label_option);
          printf("\nSTMT_EXEC;;30447\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___64 = ngettext("%s: Volume label is too long (limit is %lu byte)", "%s: Volume label is too long (limit is %lu bytes)", volume_label_max_len);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30448\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___64, tmp___63, volume_label_max_len);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30449\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;30453\n");
if (verify_option)
    {
      printf("\nSTMT_EXEC;;30455\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;30458\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___66 = gettext("Cannot verify multi-volume archives");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30459\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___66);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30460\n");
usage(2);
        }
      }
      printf("\nSTMT_EXEC;;30463\n");
if (use_compress_program_option)
      {
        {
          printf("\nSTMT_EXEC;;30466\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___67 = gettext("Cannot verify compressed archives");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30467\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___67);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30468\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;30472\n");
if (use_compress_program_option)
    {
      printf("\nSTMT_EXEC;;30474\n");
if (multi_volume_option)
      {
        {
          printf("\nSTMT_EXEC;;30477\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___68 = gettext("Cannot use multi-volume compressed archives");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30478\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___68);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30479\n");
usage(2);
        }
      }
      printf("\nSTMT_EXEC;;30482\n");
if ((unsigned int)subcommand_option == 8U)
      {
        {
          printf("\nSTMT_EXEC;;30485\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___69 = gettext("Cannot update compressed archives");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30486\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___69);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;30487\n");
usage(2);
        }
      }
    }
    printf("\nSTMT_EXEC;;30491\n");
if (pax_option)
    {
      printf("\nSTMT_EXEC;;30493\n");
if ((unsigned int)archive_format != 4U)
      {
        printf("\nSTMT_EXEC;;30495\n");
if ((unsigned int)subcommand_option != 6U)
        {
          {
            printf("\nSTMT_EXEC;;30498\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___70 = gettext("--pax-option can be used only on POSIX archives");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30499\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___70);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30500\n");
usage(2);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;30505\n");
if ((unsigned int)subcommand_option != 5U)
          {
            {
              printf("\nSTMT_EXEC;;30508\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___70 = gettext("--pax-option can be used only on POSIX archives");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30509\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___70);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30510\n");
usage(2);
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;30515\n");
if ((unsigned int)subcommand_option != 7U)
            {
              {
                printf("\nSTMT_EXEC;;30518\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___70 = gettext("--pax-option can be used only on POSIX archives");printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30519\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___70);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;30520\n");
usage(2);
              }
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;30527\n");
if (recursive_unlink_option)
    {
      printf("\nSTMT_EXEC;;30529\n");
old_files_option = (enum old_files)3;
    }
    printf("\nSTMT_EXEC;;30531\n");
if (utc_option)
    {
      printf("\nSTMT_EXEC;;30533\n");
verbose_option = 2;
    }
    printf("\nSTMT_EXEC;;30535\n");
if (!rmt_command_option)
    {
      printf("\nSTMT_EXEC;;30537\n");
rmt_command_option = "/usr/local/libexec/rmt";
    }
    {
      printf("\nSTMT_EXEC;;30540\n");
if ((unsigned int)subcommand_option == 3U)
      {
        printf("\nSTMT_EXEC;;30542\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;30544\n");
if ((unsigned int)subcommand_option == 6U)
      {
        printf("\nSTMT_EXEC;;30546\n");
goto case_6;
      }
      printf("\nSTMT_EXEC;;30548\n");
if ((unsigned int)subcommand_option == 7U)
      {
        printf("\nSTMT_EXEC;;30550\n");
goto case_6;
      }
      printf("\nSTMT_EXEC;;30552\n");
if ((unsigned int)subcommand_option == 5U)
      {
        printf("\nSTMT_EXEC;;30554\n");
goto case_6;
      }
      printf("\nSTMT_EXEC;;30556\n");
if ((unsigned int)subcommand_option == 2U)
      {
        printf("\nSTMT_EXEC;;30558\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;30560\n");
if ((unsigned int)subcommand_option == 8U)
      {
        printf("\nSTMT_EXEC;;30562\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;30564\n");
if ((unsigned int)subcommand_option == 1U)
      {
        printf("\nSTMT_EXEC;;30566\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;30568\n");
goto switch_default;
    case_3: /* CIL Label */
      {
printf("\nSTMT_EXEC;;30570\n");
if (input_files == 0)
      {
        printf("\nSTMT_EXEC;;30572\n");
if (!files_from_option)
        {
          {
            printf("\nSTMT_EXEC;;30575\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___71 = gettext("Cowardly refusing to create an empty archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30576\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___71);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30577\n");
usage(2);
          }
        }
      }
}

      printf("\nSTMT_EXEC;;30581\n");
goto switch_break___0;
    case_6: /* CIL Label */
    case_7: /* CIL Label */
    case_5: /* CIL Label */
      {
printf("\nSTMT_EXEC;;30585\n");
archive_name_cursor = archive_name_array;
}

      {
        printf("\nSTMT_EXEC;;30587\n");
while (1)
        {
        while_continue___3: /* CIL Label */;
          printf("\nSTMT_EXEC;;30590\n");
if (!((unsigned long)archive_name_cursor < (unsigned long)(archive_name_array + archive_names)))
          {
            printf("\nSTMT_EXEC;;30592\n");
goto while_break___3;
          }
          {
            printf("\nSTMT_EXEC;;30595\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___72 = strcmp(*archive_name_cursor, "-");printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;30597\n");
if (!tmp___72)
          {
            {
              printf("\nSTMT_EXEC;;30600\n");
request_stdin("-f");
            }
          }
          printf("\nSTMT_EXEC;;30603\n");
archive_name_cursor++;
        }
      while_break___3: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;30607\n");
goto switch_break___0;
    case_2:     /* CIL Label */
    case_8:     /* CIL Label */
    case_1___0: /* CIL Label */
      {
printf("\nSTMT_EXEC;;30611\n");
archive_name_cursor = archive_name_array;
}

      {
        printf("\nSTMT_EXEC;;30613\n");
while (1)
        {
        while_continue___4: /* CIL Label */;
          printf("\nSTMT_EXEC;;30616\n");
if (!((unsigned long)archive_name_cursor < (unsigned long)(archive_name_array + archive_names)))
          {
            printf("\nSTMT_EXEC;;30618\n");
goto while_break___4;
          }
          {
            printf("\nSTMT_EXEC;;30621\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___74 = strcmp(*archive_name_cursor, "-");printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;30623\n");
if (!tmp___74)
          {
            {
              printf("\nSTMT_EXEC;;30626\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___73 = gettext("Options `-Aru\' are incompatible with `-f -\'");printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30627\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___73);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;30628\n");
usage(2);
            }
          }
          printf("\nSTMT_EXEC;;30631\n");
archive_name_cursor++;
        }
      while_break___4: /* CIL Label */;
      }
    switch_default: /* CIL Label */
      {
printf("\nSTMT_EXEC;;30636\n");
goto switch_break___0;
}

    switch_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;30639\n");
archive_name_cursor = archive_name_array;
    printf("\nSTMT_EXEC;;30640\n");
if (backup_suffix_string)
    {
      {
        printf("\nSTMT_EXEC;;30643\n");
tmp___75 = xstrdup(backup_suffix_string);
        printf("\nSTMT_EXEC;;30644\n");
simple_backup_suffix = (char const *)tmp___75;
      }
    }
    printf("\nSTMT_EXEC;;30647\n");
if (backup_option)
    {
      {
        printf("\nSTMT_EXEC;;30650\n");
backup_type = xget_version("--backup", version_control_string);
      }
    }
    printf("\nSTMT_EXEC;;30653\n");
if (verbose_option)
    {
      printf("\nSTMT_EXEC;;30655\n");
if (textual_date_option)
      {
        {
          printf("\nSTMT_EXEC;;30658\n");
tmp___76 = tartime(newer_mtime_option.tv_sec);
          printf("\nSTMT_EXEC;;30659\n");
treated_as = tmp___76;
          printf("\nSTMT_EXEC;;30660\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___78 = strcmp(textual_date_option, treated_as);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;30662\n");
if (tmp___78 != 0)
        {
          {
            printf("\nSTMT_EXEC;;30665\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___77 = gettext("Treating date `%s\' as %s + %ld nanoseconds");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;30666\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___77, textual_date_option, treated_as, newer_mtime_option.tv_nsec);printf("\nFUNC_RETURN;;\n");

          }
        }
      }
    }
    printf("\nSTMT_EXEC;;30671\n");
printf("\nFUNC_RETURN;;\n");
return;





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































  }
printf("\nFUNC_RETURN;;\n");
}
int main(int argc, char **argv)
{
  printf("\nFUNC_CALL;main(int,char **);\n");
printf("\nSTMT_EXEC;;39\n");
AFL_INIT_SET0("tar");
  printf("\nSTMT_EXEC;;31946\n");
int tmp;
  printf("\nSTMT_EXEC;;31947\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;31948\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;31949\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;31950\n");
int tmp___3;
  printf("\nSTMT_EXEC;;31951\n");
int tmp___4;
  printf("\nSTMT_EXEC;;31952\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;31953\n");
int tmp___6;
  printf("\nSTMT_EXEC;;31954\n");
int tmp___7;
  printf("\nSTMT_EXEC;;31955\n");
char *__cil_tmp12;
  printf("\nSTMT_EXEC;;31956\n");
char *__cil_tmp13;
  printf("\nSTMT_EXEC;;31957\n");
char *__cil_tmp14;
  printf("\nSTMT_EXEC;;31958\n");
char *__cil_tmp15;

  {

    {
      printf("\nSTMT_EXEC;;31963\n");
printf("\nFUNC_CALL;clock_gettime(clockid_t,struct timespec *);\n");
tmp = clock_gettime(0, &start_timespec);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;31965\n");
if (tmp != 0)
    {
      {
        printf("\nSTMT_EXEC;;31968\n");
printf("\nFUNC_CALL;time(time_t *);\n");
start_timespec.tv_sec = time((time_t *)0);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;31972\n");
program_name = (char const *)*(argv + 0);
      printf("\nSTMT_EXEC;;31973\n");
printf("\nFUNC_CALL;setlocale(int,const char *);\n");
setlocale(6, "");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;31974\n");
printf("\nFUNC_CALL;bindtextdomain(const char *,const char *);\n");
bindtextdomain("tar", "/usr/local/share/locale");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;31975\n");
printf("\nFUNC_CALL;textdomain(const char *);\n");
textdomain("tar");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;31976\n");
exit_status = 0;
      printf("\nSTMT_EXEC;;31977\n");
filename_terminator = (char)'\n';
      printf("\nSTMT_EXEC;;31978\n");
set_quoting_style((struct quoting_options *)0, (enum quoting_style)4);
      printf("\nSTMT_EXEC;;31979\n");
allocated_archive_names = 10;






      printf("\nSTMT_EXEC;;31986\n");
tmp___0 = xmalloc(sizeof(char const *) * (unsigned long)allocated_archive_names);
      printf("\nSTMT_EXEC;;31987\n");
archive_name_array = (char const **)tmp___0;
      printf("\nSTMT_EXEC;;31988\n");
archive_names = 0;
      printf("\nSTMT_EXEC;;31989\n");
printf("\nFUNC_CALL;signal(int,void (*)(int));\n");
signal(17, (void (*)(int))0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;31990\n");
init_names();
      printf("\nSTMT_EXEC;;31991\n");
decode_options(argc, argv);
      printf("\nSTMT_EXEC;;31992\n");
name_init();
    }
    printf("\nSTMT_EXEC;;31994\n");
if (volno_file_option)
    {
      {
        printf("\nSTMT_EXEC;;31997\n");
init_volume_number();
      }
    }
    {
      printf("\nSTMT_EXEC;;32001\n");
if ((unsigned int)subcommand_option == 0U)
      {
        printf("\nSTMT_EXEC;;32003\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;32005\n");
if ((unsigned int)subcommand_option == 2U)
      {
        printf("\nSTMT_EXEC;;32007\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;32009\n");
if ((unsigned int)subcommand_option == 8U)
      {
        printf("\nSTMT_EXEC;;32011\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;32013\n");
if ((unsigned int)subcommand_option == 1U)
      {
        printf("\nSTMT_EXEC;;32015\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;32017\n");
if ((unsigned int)subcommand_option == 4U)
      {
        printf("\nSTMT_EXEC;;32019\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;32021\n");
if ((unsigned int)subcommand_option == 3U)
      {
        printf("\nSTMT_EXEC;;32023\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;32025\n");
if ((unsigned int)subcommand_option == 6U)
      {
        printf("\nSTMT_EXEC;;32027\n");
goto case_6;
      }
      printf("\nSTMT_EXEC;;32029\n");
if ((unsigned int)subcommand_option == 7U)
      {
        printf("\nSTMT_EXEC;;32031\n");
goto case_7;
      }
      printf("\nSTMT_EXEC;;32033\n");
if ((unsigned int)subcommand_option == 5U)
      {
        printf("\nSTMT_EXEC;;32035\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;32037\n");
goto switch_break;
    case_0: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32040\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("You must specify one of the `-Acdtrux\' options");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32041\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32042\n");
usage(2);
    }
    case_2: /* CIL Label */
    case_8: /* CIL Label */
    case_1: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32048\n");
update_archive();
    }
      printf("\nSTMT_EXEC;;32050\n");
goto switch_break;
    case_4: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32053\n");
delete_archive_members();
    }
      printf("\nSTMT_EXEC;;32055\n");
goto switch_break;
    case_3: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32058\n");
create_archive();
      printf("\nSTMT_EXEC;;32059\n");
name_close();
    }
      printf("\nSTMT_EXEC;;32061\n");
if (totals_option)
      {
        {
          printf("\nSTMT_EXEC;;32064\n");
print_total_written();
        }
      }
      printf("\nSTMT_EXEC;;32067\n");
goto switch_break;

    case_6: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32071\n");
extr_init();
      printf("\nSTMT_EXEC;;32072\n");
read_and(&extract_archive);
      printf("\nSTMT_EXEC;;32073\n");
extract_finish();
    }
      printf("\nSTMT_EXEC;;32075\n");
goto switch_break;
    case_7: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32078\n");
read_and(&list_archive);
    }
      printf("\nSTMT_EXEC;;32080\n");
goto switch_break;
    case_5: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;32083\n");
diff_init();
      printf("\nSTMT_EXEC;;32084\n");
read_and(&diff_archive);
    }
      printf("\nSTMT_EXEC;;32086\n");
goto switch_break;
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;32089\n");
if (check_links_option)
    {
      {
        printf("\nSTMT_EXEC;;32092\n");
check_links();
      }
    }
    printf("\nSTMT_EXEC;;32095\n");
if (volno_file_option)
    {
      {
        printf("\nSTMT_EXEC;;32098\n");
closeout_volume_number();
      }
    }
    {
      printf("\nSTMT_EXEC;;32102\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)archive_name_array);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32103\n");
name_term();
    }
    printf("\nSTMT_EXEC;;32105\n");
if ((unsigned long)stdlis != (unsigned long)stderr)
    {
      {
        printf("\nSTMT_EXEC;;32108\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___3 = ferror_unlocked(stdlis);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;32110\n");
if (tmp___3)
      {
        {
          printf("\nSTMT_EXEC;;32113\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Error in writing to standard output");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;32114\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;32115\n");
fatal_exit();
        }
      }
      else
      {




















        {
          printf("\nSTMT_EXEC;;32141\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___4 = fclose(stdlis);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;32143\n");
if (tmp___4 != 0)
        {
          {
            printf("\nSTMT_EXEC;;32146\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Error in writing to standard output");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32147\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32148\n");
fatal_exit();
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;32153\n");
if (exit_status == 2)
    {
      {
        printf("\nSTMT_EXEC;;32156\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___5 = gettext("Error exit delayed from previous errors");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;32157\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___5);printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;32161\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___6 = ferror_unlocked(stderr);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32163\n");
if (tmp___6)
    {
      printf("\nSTMT_EXEC;;32165\n");
exit_status = 2;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;32170\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___7 = fclose(stderr);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;32172\n");
if (tmp___7 != 0)
      {
        printf("\nSTMT_EXEC;;32174\n");
exit_status = 2;
      }
    }
    printf("\nSTMT_EXEC;;32177\n");
printf("\nFUNC_RETURN;;\n");
return (exit_status);
  }
printf("\nFUNC_RETURN;;\n");
}
void tar_stat_init(struct tar_stat_info *st)
{

  printf("\nFUNC_CALL;tar_stat_init(struct tar_stat_info *);\n");
{
    {
      printf("\nSTMT_EXEC;;32185\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)st, 0, sizeof(*st));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32187\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void tar_stat_destroy(struct tar_stat_info *st)
{

  printf("\nFUNC_CALL;tar_stat_destroy(struct tar_stat_info *);\n");
{
    {
      printf("\nSTMT_EXEC;;32195\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->orig_file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32196\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->file_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32197\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->link_name);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32198\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->uname);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32199\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->gname);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32200\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)st->sparse_map);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32201\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)st, 0, sizeof(*st));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32203\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
















































































































































/* #pragma merger("0","00f.update.o.i","") */
static void append_file(char *path)
{
  printf("\nFUNC_CALL;append_file(char *);\n");
printf("\nSTMT_EXEC;;32353\n");
int handle;
  printf("\nSTMT_EXEC;;32354\n");
int tmp;
  printf("\nSTMT_EXEC;;32355\n");
struct stat stat_data;
  printf("\nSTMT_EXEC;;32356\n");
off_t bytes_left;
  printf("\nSTMT_EXEC;;32357\n");
union block *start;
  printf("\nSTMT_EXEC;;32358\n");
union block *tmp___0;
  printf("\nSTMT_EXEC;;32359\n");
size_t buffer_size;
  printf("\nSTMT_EXEC;;32360\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;32361\n");
size_t status;
  printf("\nSTMT_EXEC;;32362\n");
char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
  printf("\nSTMT_EXEC;;32363\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;32364\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;32365\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;32366\n");
int tmp___5;
  printf("\nSTMT_EXEC;;32367\n");
int tmp___6;
  printf("\nSTMT_EXEC;;32368\n");
void *__cil_tmp17;
  printf("\nSTMT_EXEC;;32369\n");
void *__cil_tmp18;

  {
    {
      printf("\nSTMT_EXEC;;32373\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
tmp = open((char const *)path, 0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32374\n");
handle = tmp;
    }
    printf("\nSTMT_EXEC;;32376\n");
if (handle < 0)
    {
      {
        printf("\nSTMT_EXEC;;32379\n");
open_error((char const *)path);
      }
      printf("\nSTMT_EXEC;;32381\n");
printf("\nFUNC_RETURN;;\n");
return;
    }
    {
      printf("\nSTMT_EXEC;;32384\n");
printf("\nFUNC_CALL;fstat(int,struct stat *);\n");
tmp___5 = fstat(handle, &stat_data);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32386\n");
if (tmp___5 != 0)
    {
      {
        printf("\nSTMT_EXEC;;32389\n");
stat_error((char const *)path);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;32394\n");
bytes_left = stat_data.st_size;
      {
        printf("\nSTMT_EXEC;;32396\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;32399\n");
if (!(bytes_left > 0L))
          {
            printf("\nSTMT_EXEC;;32401\n");
goto while_break;
          }
          {
            printf("\nSTMT_EXEC;;32404\n");
tmp___0 = find_next_block();
            printf("\nSTMT_EXEC;;32405\n");
start = tmp___0;
            printf("\nSTMT_EXEC;;32406\n");
tmp___1 = available_space_after(start);
            printf("\nSTMT_EXEC;;32407\n");
buffer_size = tmp___1;
          }
          printf("\nSTMT_EXEC;;32409\n");
if ((size_t)bytes_left < buffer_size)
          {
            printf("\nSTMT_EXEC;;32411\n");
buffer_size = (size_t)bytes_left;
            printf("\nSTMT_EXEC;;32412\n");
status = buffer_size % 512UL;
            printf("\nSTMT_EXEC;;32413\n");
if (status)
            {
              {
                printf("\nSTMT_EXEC;;32416\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(start->buffer + bytes_left), 0, 512UL - status);printf("\nFUNC_RETURN;;\n");

              }
            }
          }
          {
            printf("\nSTMT_EXEC;;32421\n");
status = safe_read(handle, (void *)(start->buffer), buffer_size);
          }
          printf("\nSTMT_EXEC;;32423\n");
if (status == 0xffffffffffffffffUL)
          {
            {
              printf("\nSTMT_EXEC;;32426\n");
read_fatal_details((char const *)path, stat_data.st_size - bytes_left, buffer_size);
            }
          }
          printf("\nSTMT_EXEC;;32429\n");
if (status == 0UL)
          {
            {
              printf("\nSTMT_EXEC;;32432\n");
tmp___2 = stringify_uintmax_t_backwards((uintmax_t)bytes_left, buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
              printf("\nSTMT_EXEC;;32433\n");
tmp___3 = quotearg_colon((char const *)path);
              printf("\nSTMT_EXEC;;32434\n");
printf("\nFUNC_CALL;ngettext(const char *,const char *,unsigned long);\n");
tmp___4 = ngettext("%s: File shrank by %s byte", "%s: File shrank by %s bytes", (unsigned long)bytes_left);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;32435\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___4, tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;32436\n");
fatal_exit();
            }
          }
          {
            printf("\nSTMT_EXEC;;32440\n");
bytes_left = (off_t)((size_t)bytes_left - status);
            printf("\nSTMT_EXEC;;32441\n");
set_next_block_after(start + (status - 1UL) / 512UL);
          }
        }
      while_break: /* CIL Label */;
      }
    }
    {
      printf("\nSTMT_EXEC;;32448\n");
printf("\nFUNC_CALL;close(int);\n");
tmp___6 = close(handle);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32450\n");
if (tmp___6 != 0)
    {
      {
        printf("\nSTMT_EXEC;;32453\n");
close_error((char const *)path);
      }
    }
    printf("\nSTMT_EXEC;;32456\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void update_archive(void)
{
  printf("\nFUNC_CALL;update_archive();\n");
printf("\nSTMT_EXEC;;32461\n");
enum read_header previous_status;
  printf("\nSTMT_EXEC;;32462\n");
int found_end;
  printf("\nSTMT_EXEC;;32463\n");
enum read_header status;
  printf("\nSTMT_EXEC;;32464\n");
enum read_header tmp;
  printf("\nSTMT_EXEC;;32465\n");
struct name *name;
  printf("\nSTMT_EXEC;;32466\n");
struct stat s;
  printf("\nSTMT_EXEC;;32467\n");
enum archive_format unused;
  printf("\nSTMT_EXEC;;32468\n");
int tmp___0;
  printf("\nSTMT_EXEC;;32469\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;32470\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;32471\n");
char *path;
  printf("\nSTMT_EXEC;;32472\n");
_Bool tmp___3;
  printf("\nSTMT_EXEC;;32473\n");
int tmp___4;
  printf("\nSTMT_EXEC;;32474\n");
void *__cil_tmp14;
  printf("\nSTMT_EXEC;;32475\n");
char *__cil_tmp15;
  printf("\nSTMT_EXEC;;32476\n");
char *__cil_tmp16;
  printf("\nSTMT_EXEC;;32477\n");
char *__cil_tmp17;

  {
    {
      printf("\nSTMT_EXEC;;32481\n");
previous_status = (enum read_header)0;
      printf("\nSTMT_EXEC;;32482\n");
found_end = 0;
      printf("\nSTMT_EXEC;;32483\n");
name_gather();
      printf("\nSTMT_EXEC;;32484\n");
open_archive((enum access_mode)2);
      printf("\nSTMT_EXEC;;32485\n");
xheader_write_global();
    }
    {
      printf("\nSTMT_EXEC;;32488\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;32491\n");
if (!(!found_end))
        {
          printf("\nSTMT_EXEC;;32493\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;32496\n");
tmp = read_header((_Bool)0);
          printf("\nSTMT_EXEC;;32497\n");
status = tmp;
        }
        {
          printf("\nSTMT_EXEC;;32500\n");
if ((unsigned int)status == 0U)
          {
            printf("\nSTMT_EXEC;;32502\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;32504\n");
if ((unsigned int)status == 2U)
          {
            printf("\nSTMT_EXEC;;32506\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;32508\n");
if ((unsigned int)status == 1U)
          {
            printf("\nSTMT_EXEC;;32510\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;32512\n");
if ((unsigned int)status == 3U)
          {
            printf("\nSTMT_EXEC;;32514\n");
goto case_3;
          }
          printf("\nSTMT_EXEC;;32516\n");
if ((unsigned int)status == 4U)
          {
            printf("\nSTMT_EXEC;;32518\n");
goto case_4;
          }
          printf("\nSTMT_EXEC;;32520\n");
if ((unsigned int)status == 5U)
          {
            printf("\nSTMT_EXEC;;32522\n");
goto case_5;
          }
          printf("\nSTMT_EXEC;;32524\n");
goto switch_break;
        case_0: /* CIL Label */
        case_2: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;32528\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

        }
        case_1: /* CIL Label */
          {
printf("\nSTMT_EXEC;;32531\n");
if ((unsigned int)subcommand_option == 8U)
          {
            {
              printf("\nSTMT_EXEC;;32534\n");
name = name_scan((char const *)current_stat_info.file_name);
            }
            printf("\nSTMT_EXEC;;32536\n");
if ((unsigned long)name != (unsigned long)((void *)0))
            {
              {
                printf("\nSTMT_EXEC;;32539\n");
decode_header(current_header, &current_stat_info, &unused, 0);
                printf("\nSTMT_EXEC;;32540\n");
chdir_do(name->change_dir);
                printf("\nSTMT_EXEC;;32541\n");
tmp___0 = deref_stat(dereference_option, (char const *)current_stat_info.file_name, &s);
              }
              printf("\nSTMT_EXEC;;32543\n");
if (tmp___0 == 0)
              {
                printf("\nSTMT_EXEC;;32545\n");
if (s.st_mtim.tv_sec <= current_stat_info.stat.st_mtim.tv_sec)
                {
                  {
                    printf("\nSTMT_EXEC;;32548\n");
add_avoided_name((char const *)current_stat_info.file_name);
                  }
                }
              }
            }
          }
}

          {
            printf("\nSTMT_EXEC;;32555\n");
skip_member();
          }
          printf("\nSTMT_EXEC;;32557\n");
goto switch_break;
        case_3: /* CIL Label */
          {
printf("\nSTMT_EXEC;;32559\n");
current_block = current_header;
}

          printf("\nSTMT_EXEC;;32560\n");
found_end = 1;
          printf("\nSTMT_EXEC;;32561\n");
goto switch_break;
        case_4: /* CIL Label */
          {
printf("\nSTMT_EXEC;;32563\n");
found_end = 1;
}

          printf("\nSTMT_EXEC;;32564\n");
goto switch_break;
        case_5: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;32567\n");
set_next_block_after(current_header);
        }
          {
            printf("\nSTMT_EXEC;;32570\n");
if ((unsigned int)previous_status == 0U)
            {
              printf("\nSTMT_EXEC;;32572\n");
goto case_0___0;
            }
            printf("\nSTMT_EXEC;;32574\n");
if ((unsigned int)previous_status == 1U)
            {
              printf("\nSTMT_EXEC;;32576\n");
goto case_1___0;
            }
            printf("\nSTMT_EXEC;;32578\n");
if ((unsigned int)previous_status == 3U)
            {
              printf("\nSTMT_EXEC;;32580\n");
goto case_1___0;
            }
            printf("\nSTMT_EXEC;;32582\n");
if ((unsigned int)previous_status == 5U)
            {
              printf("\nSTMT_EXEC;;32584\n");
goto case_5___0;
            }
            printf("\nSTMT_EXEC;;32586\n");
if ((unsigned int)previous_status == 4U)
            {
              printf("\nSTMT_EXEC;;32588\n");
goto case_4___0;
            }
            printf("\nSTMT_EXEC;;32590\n");
if ((unsigned int)previous_status == 2U)
            {
              printf("\nSTMT_EXEC;;32592\n");
goto case_4___0;
            }
            printf("\nSTMT_EXEC;;32594\n");
goto switch_break___0;
          case_0___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;32597\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___1 = gettext("This does not look like a tar archive");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32598\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___1);printf("\nFUNC_RETURN;;\n");

          }
          case_1___0: /* CIL Label */
          case_3___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;32603\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___2 = gettext("Skipping to next header");printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32604\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, (char const *)tmp___2);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32605\n");
exit_status = 2;
          }
          case_5___0: /* CIL Label */
            {
printf("\nSTMT_EXEC;;32608\n");
goto switch_break___0;
}

          case_4___0: /* CIL Label */
          case_2___0: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;32612\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

          }
          switch_break___0: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;32616\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;32619\n");
previous_status = status;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;32624\n");
reset_eof();
      printf("\nSTMT_EXEC;;32625\n");
time_to_start_writing = (_Bool)1;
      printf("\nSTMT_EXEC;;32626\n");
output_start = current_block->buffer;
    }
    {
      printf("\nSTMT_EXEC;;32629\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;32633\n");
path = name_from_list();
        }
        printf("\nSTMT_EXEC;;32635\n");
if (!((unsigned long)path != (unsigned long)((void *)0)))
        {
          printf("\nSTMT_EXEC;;32637\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;32640\n");
tmp___3 = excluded_name((char const *)path);
        }
        printf("\nSTMT_EXEC;;32642\n");
if (tmp___3)
        {
          printf("\nSTMT_EXEC;;32644\n");
goto while_continue___0;
        }
        printf("\nSTMT_EXEC;;32646\n");
if (interactive_option)
        {
          {
            printf("\nSTMT_EXEC;;32649\n");
tmp___4 = confirm("add", (char const *)path);
          }
          printf("\nSTMT_EXEC;;32651\n");
if (!tmp___4)
          {
            printf("\nSTMT_EXEC;;32653\n");
goto while_continue___0;
          }
        }
        printf("\nSTMT_EXEC;;32656\n");
if ((unsigned int)subcommand_option == 2U)
        {
          {
            printf("\nSTMT_EXEC;;32659\n");
append_file(path);
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;32665\n");
dump_file(path, 1, (dev_t)0);
          }
        }
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;32672\n");
write_eot();
      printf("\nSTMT_EXEC;;32673\n");
close_archive();
      printf("\nSTMT_EXEC;;32674\n");
names_notfound();
    }
    printf("\nSTMT_EXEC;;32676\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","010.utf8.o.i","") */
static iconv_t conv_desc[2] = {(iconv_t)-1, (iconv_t)-1};
static iconv_t utf8_init(_Bool to_utf)
{

  printf("\nFUNC_CALL;utf8_init(_Bool);\n");
{
    printf("\nSTMT_EXEC;;32685\n");
if ((unsigned long)conv_desc[(int)to_utf] == (unsigned long)((iconv_t)-1))
    {
      printf("\nSTMT_EXEC;;32687\n");
if (to_utf)
      {
        printf("\nSTMT_EXEC;;32689\n");
conv_desc[(int)to_utf] = (iconv_t)-1;
      }
      else
      {
        printf("\nSTMT_EXEC;;32693\n");
conv_desc[(int)to_utf] = (iconv_t)-1;
      }
    }
    printf("\nSTMT_EXEC;;32696\n");
printf("\nFUNC_RETURN;;\n");
return (conv_desc[(int)to_utf]);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool utf8_convert(_Bool to_utf, char const *input, char **output)
{
  printf("\nFUNC_CALL;utf8_convert(_Bool,const char *,char **);\n");
printf("\nSTMT_EXEC;;32701\n");
char *ib;
  printf("\nSTMT_EXEC;;32702\n");
char *ob;
  printf("\nSTMT_EXEC;;32703\n");
size_t inlen;
  printf("\nSTMT_EXEC;;32704\n");
size_t outlen;
  printf("\nSTMT_EXEC;;32705\n");
size_t rc___1;
  printf("\nSTMT_EXEC;;32706\n");
iconv_t cd;
  printf("\nSTMT_EXEC;;32707\n");
iconv_t tmp;
  printf("\nSTMT_EXEC;;32708\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;32709\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;32710\n");
void *tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;32714\n");
tmp = utf8_init(to_utf);
      printf("\nSTMT_EXEC;;32715\n");
cd = tmp;
    }
    printf("\nSTMT_EXEC;;32717\n");
if ((unsigned long)cd == (unsigned long)((iconv_t)0))
    {
      {
        printf("\nSTMT_EXEC;;32720\n");
*output = xstrdup(input);
      }
      printf("\nSTMT_EXEC;;32722\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    else
    {
      printf("\nSTMT_EXEC;;32726\n");
if ((unsigned long)cd == (unsigned long)((iconv_t)-1))
      {
        printf("\nSTMT_EXEC;;32728\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
    }
    {
      printf("\nSTMT_EXEC;;32732\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(input);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32733\n");
inlen = tmp___0 + 1UL;
      printf("\nSTMT_EXEC;;32734\n");
outlen = inlen * 16UL + 1UL;
      printf("\nSTMT_EXEC;;32735\n");
tmp___2 = xmalloc(outlen);
      printf("\nSTMT_EXEC;;32736\n");
tmp___1 = (char *)tmp___2;
      printf("\nSTMT_EXEC;;32737\n");
*output = tmp___1;
      printf("\nSTMT_EXEC;;32738\n");
ob = tmp___1;
      printf("\nSTMT_EXEC;;32739\n");
ib = (char *)input;
      printf("\nSTMT_EXEC;;32740\n");
rc___1 = (size_t)0;
      printf("\nSTMT_EXEC;;32741\n");
*ob = (char)0;
    }
    printf("\nSTMT_EXEC;;32743\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(rc___1 != 0xffffffffffffffffUL));
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool string_ascii_p(char const *str)
{
  printf("\nFUNC_CALL;string_ascii_p(const char *);\n");
printf("\nSTMT_EXEC;;32748\n");
unsigned char const *p;

  {
    printf("\nSTMT_EXEC;;32751\n");
p = (unsigned char const *)str;
    {
      printf("\nSTMT_EXEC;;32753\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;32756\n");
if (!*p)
        {
          printf("\nSTMT_EXEC;;32758\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;32760\n");
if ((int const) * p > 127)
        {
          printf("\nSTMT_EXEC;;32762\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        printf("\nSTMT_EXEC;;32764\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;32768\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","011.addext.o.i","") */
extern __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__)) pathconf)(char const *__path, int __name);
void addext(char *filename, char const *ext, int e);
size_t base_len(char const *name);
void addext(char *filename, char const *ext, int e)
{
  printf("\nFUNC_CALL;addext(char *,const char *,int);\n");
printf("\nSTMT_EXEC;;32777\n");
char *s;
  printf("\nSTMT_EXEC;;32778\n");
char *tmp;
  printf("\nSTMT_EXEC;;32779\n");
size_t slen;
  printf("\nSTMT_EXEC;;32780\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;32781\n");
size_t extlen;
  printf("\nSTMT_EXEC;;32782\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;32783\n");
size_t slen_max;
  printf("\nSTMT_EXEC;;32784\n");
long name_max;
  printf("\nSTMT_EXEC;;32785\n");
int *tmp___2;
  printf("\nSTMT_EXEC;;32786\n");
char c;
  printf("\nSTMT_EXEC;;32787\n");
long size;
  printf("\nSTMT_EXEC;;32788\n");
int *tmp___3;

  {
    {
      printf("\nSTMT_EXEC;;32792\n");
tmp = base_name((char const *)filename);
      printf("\nSTMT_EXEC;;32793\n");
s = tmp;
      printf("\nSTMT_EXEC;;32794\n");
tmp___0 = base_len((char const *)s);
      printf("\nSTMT_EXEC;;32795\n");
slen = tmp___0;
      printf("\nSTMT_EXEC;;32796\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen(ext);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32797\n");
extlen = tmp___1;
      printf("\nSTMT_EXEC;;32798\n");
slen_max = (size_t)255;
    }
    printf("\nSTMT_EXEC;;32800\n");
if (14UL < slen + extlen)
    {
      printf("\nSTMT_EXEC;;32802\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;32806\n");
if (0)
      {
      _L___3: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;32810\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___2 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;32811\n");
*tmp___2 = 0;
      }
        printf("\nSTMT_EXEC;;32813\n");
if ((unsigned long)s == (unsigned long)filename)
        {
          {
            printf("\nSTMT_EXEC;;32816\n");
printf("\nFUNC_CALL;pathconf(const char *,int);\n");
name_max = pathconf(".", 3);printf("\nFUNC_RETURN;;\n");

          }
        }
        else
        {
          printf("\nSTMT_EXEC;;32821\n");
c = *s;
          printf("\nSTMT_EXEC;;32822\n");
if (!((int)c == 47))
          {
            printf("\nSTMT_EXEC;;32824\n");
*s = (char)0;
          }
          {
            printf("\nSTMT_EXEC;;32827\n");
printf("\nFUNC_CALL;pathconf(const char *,int);\n");
name_max = pathconf((char const *)filename, 3);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;32828\n");
*s = c;
          }
        }
        printf("\nSTMT_EXEC;;32831\n");
if (0L <= name_max)
        {
          printf("\nSTMT_EXEC;;32833\n");
goto _L;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;32838\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;32840\n");
if (*tmp___3 == 0)
          {
          _L:
            {
printf("\nSTMT_EXEC;;32843\n");
slen_max = (size_t)name_max;
}

            printf("\nSTMT_EXEC;;32844\n");
size = (long)slen_max;
            printf("\nSTMT_EXEC;;32845\n");
if (name_max != size)
            {
              printf("\nSTMT_EXEC;;32847\n");
slen_max = (size_t)-1;
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;32853\n");
if (slen + extlen <= slen_max)
    {
      {
        printf("\nSTMT_EXEC;;32856\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)(s + slen), (char const * /* __restrict  */)ext);printf("\nFUNC_RETURN;;\n");

      }
    }
    else
    {
      printf("\nSTMT_EXEC;;32861\n");
if (slen_max <= slen)
      {
        printf("\nSTMT_EXEC;;32863\n");
slen = slen_max - 1UL;
      }
      printf("\nSTMT_EXEC;;32865\n");
*(s + slen) = (char)e;
      printf("\nSTMT_EXEC;;32866\n");
*(s + (slen + 1UL)) = (char)0;
    }
    printf("\nSTMT_EXEC;;32868\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","012.argmatch.o.i","") */
int argmatch(char const *arg, char const *const *arglist, char const *vallist, size_t valsize);
void (*argmatch_die)(void);
void argmatch_invalid(char const *context, char const *value, int problem);
void argmatch_valid(char const *const *arglist, char const *vallist, size_t valsize);
int __xargmatch_internal(char const *context, char const *arg, char const *const *arglist, char const *vallist, size_t valsize, void (*exit_fn)(void));
int volatile exit_failure;
static void __argmatch_die(void)
{

  printf("\nFUNC_CALL;__argmatch_die();\n");
{
    {
      printf("\nSTMT_EXEC;;32883\n");
printf("\nFUNC_CALL;exit(int);\n");
exit((int)exit_failure);printf("\nFUNC_RETURN;;\n");

    }
  }
printf("\nFUNC_RETURN;;\n");
}
void (*argmatch_die)(void) = &__argmatch_die;
int argmatch(char const *arg, char const *const *arglist, char const *vallist, size_t valsize)
{
  printf("\nFUNC_CALL;argmatch(const char *,const char *const *,const char *,size_t);\n");
printf("\nSTMT_EXEC;;32890\n");
int i;
  printf("\nSTMT_EXEC;;32891\n");
size_t arglen;
  printf("\nSTMT_EXEC;;32892\n");
int matchind;
  printf("\nSTMT_EXEC;;32893\n");
int ambiguous;
  printf("\nSTMT_EXEC;;32894\n");
int tmp;
  printf("\nSTMT_EXEC;;32895\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;32896\n");
int tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;32900\n");
matchind = -1;
      printf("\nSTMT_EXEC;;32901\n");
ambiguous = 0;
      printf("\nSTMT_EXEC;;32902\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
arglen = strlen(arg);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;32903\n");
i = 0;
    }
    {
      printf("\nSTMT_EXEC;;32906\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;32909\n");
if (!*(arglist + i))
        {
          printf("\nSTMT_EXEC;;32911\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;32914\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___1 = strncmp((char const *)*(arglist + i), arg, arglen);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;32916\n");
if (!tmp___1)
        {
          {
            printf("\nSTMT_EXEC;;32919\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen((char const *)*(arglist + i));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;32921\n");
if (tmp___0 == arglen)
          {
            printf("\nSTMT_EXEC;;32923\n");
printf("\nFUNC_RETURN;;\n");
return (i);
          }
          else
          {
            printf("\nSTMT_EXEC;;32927\n");
if (matchind == -1)
            {
              printf("\nSTMT_EXEC;;32929\n");
matchind = i;
            }
            else
            {
              printf("\nSTMT_EXEC;;32933\n");
if ((unsigned long)vallist == (unsigned long)((void *)0))
              {
                printf("\nSTMT_EXEC;;32935\n");
ambiguous = 1;
              }
              else
              {
                {
                  printf("\nSTMT_EXEC;;32940\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp = memcmp((void const *)(vallist + valsize * (size_t)matchind), (void const *)(vallist + valsize * (size_t)i), valsize);printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;32942\n");
if (tmp)
                {
                  printf("\nSTMT_EXEC;;32944\n");
ambiguous = 1;
                }
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;32950\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;32954\n");
if (ambiguous)
    {
      printf("\nSTMT_EXEC;;32956\n");
printf("\nFUNC_RETURN;;\n");
return (-2);
    }
    else
    {
      printf("\nSTMT_EXEC;;32960\n");
printf("\nFUNC_RETURN;;\n");
return (matchind);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void argmatch_invalid(char const *context, char const *value, int problem)
{
  printf("\nFUNC_CALL;argmatch_invalid(const char *,const char *,int);\n");
printf("\nSTMT_EXEC;;32966\n");
char const *format;
  printf("\nSTMT_EXEC;;32967\n");
char *tmp;
  printf("\nSTMT_EXEC;;32968\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;32969\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;32970\n");
char const *tmp___2;
  printf("\nSTMT_EXEC;;32971\n");
char *tmp___3;
  printf("\nSTMT_EXEC;;32972\n");
char *__cil_tmp10;
  printf("\nSTMT_EXEC;;32973\n");
char *__cil_tmp11;

  {
    printf("\nSTMT_EXEC;;32976\n");
if (problem == -1)
    {
      {
        printf("\nSTMT_EXEC;;32979\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("invalid argument %s for %s");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;32980\n");
tmp___1 = tmp;
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;32986\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp___0 = gettext("ambiguous argument %s for %s");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;32987\n");
tmp___1 = tmp___0;
      }
    }
    {
      printf("\nSTMT_EXEC;;32991\n");
format = (char const *)tmp___1;
      printf("\nSTMT_EXEC;;32992\n");
tmp___2 = quote_n(1, context);
      printf("\nSTMT_EXEC;;32993\n");
tmp___3 = quotearg_n_style(0, (enum quoting_style)5, value);
      printf("\nSTMT_EXEC;;32994\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error(0, 0, format, tmp___3, tmp___2);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;32996\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
void argmatch_valid(char const *const *arglist, char const *vallist, size_t valsize)
{
  printf("\nFUNC_CALL;argmatch_valid(const char *const *,const char *,size_t);\n");
printf("\nSTMT_EXEC;;33001\n");
int i;
  printf("\nSTMT_EXEC;;33002\n");
char const *last_val;
  printf("\nSTMT_EXEC;;33003\n");
char *tmp;
  printf("\nSTMT_EXEC;;33004\n");
int tmp___0;
  printf("\nSTMT_EXEC;;33005\n");
char *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;33009\n");
last_val = (char const *)((void *)0);
      printf("\nSTMT_EXEC;;33010\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext("Valid arguments are:");printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33011\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */)tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33012\n");
i = 0;
    }
    {
      printf("\nSTMT_EXEC;;33015\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;33018\n");
if (!*(arglist + i))
        {
          printf("\nSTMT_EXEC;;33020\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33022\n");
if (i == 0)
        {
          {
            printf("\nSTMT_EXEC;;33025\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */) "\n  - `%s\'", *(arglist + i));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;33026\n");
last_val = vallist + valsize * (size_t)i;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;33032\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___0 = memcmp((void const *)last_val, (void const *)(vallist + valsize * (size_t)i), valsize);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;33034\n");
if (tmp___0)
          {
            {
              printf("\nSTMT_EXEC;;33037\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */) "\n  - `%s\'", *(arglist + i));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;33038\n");
last_val = vallist + valsize * (size_t)i;
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;33044\n");
printf("\nFUNC_CALL;fprintf(FILE *__restrict,const char *__restrict);\n");
fprintf((FILE * /* __restrict  */) stderr, (char const * /* __restrict  */) ", `%s\'", *(arglist + i));printf("\nFUNC_RETURN;;\n");

            }
          }
        }
        printf("\nSTMT_EXEC;;33048\n");
i++;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;33053\n");
printf("\nFUNC_CALL;putc_unlocked(int,FILE *);\n");
putc_unlocked('\n', stderr);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33055\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
int __xargmatch_internal(char const *context, char const *arg, char const *const *arglist, char const *vallist, size_t valsize, void (*exit_fn)(void))
{
  printf("\nFUNC_CALL;__xargmatch_internal(const char *,const char *,const char *const *,const char *,size_t,void (*)(void));\n");
printf("\nSTMT_EXEC;;33060\n");
int res;
  printf("\nSTMT_EXEC;;33061\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;33065\n");
tmp = argmatch(arg, arglist, vallist, valsize);
      printf("\nSTMT_EXEC;;33066\n");
res = tmp;
    }
    printf("\nSTMT_EXEC;;33068\n");
if (res >= 0)
    {
      printf("\nSTMT_EXEC;;33070\n");
printf("\nFUNC_RETURN;;\n");
return (res);
    }
    {
      printf("\nSTMT_EXEC;;33073\n");
argmatch_invalid(context, arg, res);
      printf("\nSTMT_EXEC;;33074\n");
argmatch_valid(arglist, vallist, valsize);
      printf("\nSTMT_EXEC;;33075\n");
(*exit_fn)();
    }
    printf("\nSTMT_EXEC;;33077\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","013.backupfile.o.i","") */
extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) malloc)(size_t __size) __attribute__((__malloc__));
enum backup_type get_version(char const *context, char const *version);
size_t dir_len(char const *path);
char const *simple_backup_suffix = "~";
static int max_backup_version(char const *file, char const *dir);
static int version_number(char const *base, char const *backup, size_t base_length);
char *find_backup_file_name(char const *file, enum backup_type backup_type___0)
{
  printf("\nFUNC_CALL;find_backup_file_name(const char *,enum backup_type);\n");
printf("\nSTMT_EXEC;;33092\n");
size_t backup_suffix_size_max;
  printf("\nSTMT_EXEC;;33093\n");
size_t file_len;
  printf("\nSTMT_EXEC;;33094\n");
size_t tmp;
  printf("\nSTMT_EXEC;;33095\n");
size_t numbered_suffix_size_max;
  printf("\nSTMT_EXEC;;33096\n");
char *s;
  printf("\nSTMT_EXEC;;33097\n");
char const *suffix;
  printf("\nSTMT_EXEC;;33098\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;33099\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;33100\n");
int highest_backup;
  printf("\nSTMT_EXEC;;33101\n");
size_t dirlen;
  printf("\nSTMT_EXEC;;33102\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;33103\n");
size_t tmp___3;
  printf("\nSTMT_EXEC;;33104\n");
char *tmp___4;
  printf("\nSTMT_EXEC;;33105\n");
char *numbered_suffix;
  printf("\nSTMT_EXEC;;33106\n");
char *__cil_tmp17;
  printf("\nSTMT_EXEC;;33107\n");
char *__cil_tmp18;

  {
    {
      printf("\nSTMT_EXEC;;33111\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(file);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33112\n");
file_len = tmp;
      printf("\nSTMT_EXEC;;33113\n");
numbered_suffix_size_max = (((sizeof(int) * 8UL - 1UL) * 302UL) / 1000UL + 2UL) + 4UL;
      printf("\nSTMT_EXEC;;33114\n");
suffix = simple_backup_suffix;
      printf("\nSTMT_EXEC;;33115\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen(simple_backup_suffix);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33116\n");
backup_suffix_size_max = tmp___0 + 1UL;
    }
    printf("\nSTMT_EXEC;;33118\n");
if (backup_suffix_size_max < numbered_suffix_size_max)
    {
      printf("\nSTMT_EXEC;;33120\n");
backup_suffix_size_max = numbered_suffix_size_max;
    }
    {
      printf("\nSTMT_EXEC;;33123\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
tmp___1 = malloc(((file_len + 1UL) + backup_suffix_size_max) + numbered_suffix_size_max);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33124\n");
s = (char *)tmp___1;
    }
    printf("\nSTMT_EXEC;;33126\n");
if (s)
    {
      printf("\nSTMT_EXEC;;33128\n");
if ((unsigned int)backup_type___0 != 1U)
      {
        {
          printf("\nSTMT_EXEC;;33131\n");
tmp___2 = dir_len(file);
          printf("\nSTMT_EXEC;;33132\n");
dirlen = tmp___2;
          printf("\nSTMT_EXEC;;33133\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)s, (void const * /* __restrict  */)file, dirlen);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;33135\n");
if (dirlen == 0UL)
        {
          printf("\nSTMT_EXEC;;33137\n");
tmp___3 = dirlen;
          printf("\nSTMT_EXEC;;33138\n");
dirlen++;
          printf("\nSTMT_EXEC;;33139\n");
*(s + tmp___3) = (char)'.';
        }
        {
          printf("\nSTMT_EXEC;;33142\n");
*(s + dirlen) = (char)'\000';
          printf("\nSTMT_EXEC;;33143\n");
tmp___4 = base_name(file);
          printf("\nSTMT_EXEC;;33144\n");
highest_backup = max_backup_version((char const *)tmp___4, (char const *)s);
        }
        printf("\nSTMT_EXEC;;33146\n");
if ((unsigned int)backup_type___0 == 2U)
        {
          printf("\nSTMT_EXEC;;33148\n");
if (!(highest_backup == 0))
          {
            {
              printf("\nSTMT_EXEC;;33151\n");
numbered_suffix = s + (file_len + backup_suffix_size_max);
              printf("\nSTMT_EXEC;;33152\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)numbered_suffix, (char const * /* __restrict  */) ".~%d~", highest_backup + 1);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;33153\n");
suffix = (char const *)numbered_suffix;
            }
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;33160\n");
numbered_suffix = s + (file_len + backup_suffix_size_max);
            printf("\nSTMT_EXEC;;33161\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)numbered_suffix, (char const * /* __restrict  */) ".~%d~", highest_backup + 1);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;33162\n");
suffix = (char const *)numbered_suffix;
          }
        }
      }
      {
        printf("\nSTMT_EXEC;;33167\n");
printf("\nFUNC_CALL;strcpy(char *__restrict,const char *__restrict);\n");
strcpy((char * /* __restrict  */)s, (char const * /* __restrict  */)file);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;33168\n");
addext(s, suffix, '~');
      }
    }
    printf("\nSTMT_EXEC;;33171\n");
printf("\nFUNC_RETURN;;\n");
return (s);
  }
printf("\nFUNC_RETURN;;\n");
}
static int max_backup_version(char const *file, char const *dir)
{
  printf("\nFUNC_CALL;max_backup_version(const char *,const char *);\n");
printf("\nSTMT_EXEC;;33176\n");
DIR *dirp;
  printf("\nSTMT_EXEC;;33177\n");
struct dirent *dp;
  printf("\nSTMT_EXEC;;33178\n");
int highest_version;
  printf("\nSTMT_EXEC;;33179\n");
int this_version;
  printf("\nSTMT_EXEC;;33180\n");
size_t file_name_length;
  printf("\nSTMT_EXEC;;33181\n");
size_t tmp;
  printf("\nSTMT_EXEC;;33182\n");
int tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;33186\n");
printf("\nFUNC_CALL;opendir(const char *);\n");
dirp = opendir(dir);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33188\n");
if (!dirp)
    {
      printf("\nSTMT_EXEC;;33190\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;33193\n");
highest_version = 0;
      printf("\nSTMT_EXEC;;33194\n");
file_name_length = base_len(file);
    }
    {
      printf("\nSTMT_EXEC;;33197\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;33201\n");
printf("\nFUNC_CALL;readdir(DIR *);\n");
dp = readdir(dirp);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;33203\n");
if (!((unsigned long)dp != (unsigned long)((struct dirent *)0)))
        {
          printf("\nSTMT_EXEC;;33205\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33207\n");
if (!(dp->d_ino != 0UL))
        {
          printf("\nSTMT_EXEC;;33209\n");
goto while_continue;
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;33214\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen((char const *)(dp->d_name));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;33216\n");
if (tmp < file_name_length + 4UL)
          {
            printf("\nSTMT_EXEC;;33218\n");
goto while_continue;
          }
        }
        {
          printf("\nSTMT_EXEC;;33222\n");
this_version = version_number(file, (char const *)(dp->d_name), file_name_length);
        }
        printf("\nSTMT_EXEC;;33224\n");
if (this_version > highest_version)
        {
          printf("\nSTMT_EXEC;;33226\n");
highest_version = this_version;
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;33232\n");
printf("\nFUNC_CALL;closedir(DIR *);\n");
tmp___0 = closedir(dirp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33234\n");
if (tmp___0)
    {
      printf("\nSTMT_EXEC;;33236\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    printf("\nSTMT_EXEC;;33238\n");
printf("\nFUNC_RETURN;;\n");
return (highest_version);
  }
printf("\nFUNC_RETURN;;\n");
}
static int version_number(char const *base, char const *backup, size_t base_length)
{
  printf("\nFUNC_CALL;version_number(const char *,const char *,size_t);\n");
printf("\nSTMT_EXEC;;33243\n");
int version;
  printf("\nSTMT_EXEC;;33244\n");
char const *p;
  printf("\nSTMT_EXEC;;33245\n");
int tmp;

  {
    {
      printf("\nSTMT_EXEC;;33249\n");
version = 0;
      printf("\nSTMT_EXEC;;33250\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp = strncmp(base, backup, base_length);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33252\n");
if (tmp == 0)
    {
      printf("\nSTMT_EXEC;;33254\n");
if ((int const) * (backup + base_length) == 46)
      {
        printf("\nSTMT_EXEC;;33256\n");
if ((int const) * (backup + (base_length + 1UL)) == 126)
        {
          printf("\nSTMT_EXEC;;33258\n");
p = backup + (base_length + 2UL);
          {
            printf("\nSTMT_EXEC;;33260\n");
while (1)
            {
            while_continue: /* CIL Label */;
              printf("\nSTMT_EXEC;;33263\n");
if (!((unsigned int)*p - 48U <= 9U))
              {
                printf("\nSTMT_EXEC;;33265\n");
goto while_break;
              }
              printf("\nSTMT_EXEC;;33267\n");
version = (version * 10 + (int)*p) - 48;
              printf("\nSTMT_EXEC;;33268\n");
p++;
            }
          while_break: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;33272\n");
if ((int const) * (p + 0) != 126)
          {
            printf("\nSTMT_EXEC;;33274\n");
version = 0;
          }
          else
          {
            printf("\nSTMT_EXEC;;33278\n");
if (*(p + 1))
            {
              printf("\nSTMT_EXEC;;33280\n");
version = 0;
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;33286\n");
printf("\nFUNC_RETURN;;\n");
return (version);
  }
printf("\nFUNC_RETURN;;\n");
}
static char const *const backup_args[9] = {(char const * /* const  */) "none", (char const * /* const  */) "off", (char const * /* const  */) "simple", (char const * /* const  */) "never", (char const * /* const  */) "existing", (char const * /* const  */) "nil", (char const * /* const  */) "numbered", (char const * /* const  */) "t", (char const * /* const  */)0};
static enum backup_type const backup_types[8] = {(enum backup_type const)0, (enum backup_type const)0, (enum backup_type const)1, (enum backup_type const)1, (enum backup_type const)2, (enum backup_type const)2, (enum backup_type const)3, (enum backup_type const)3};
enum backup_type get_version(char const *context, char const *version)
{
  printf("\nFUNC_CALL;get_version(const char *,const char *);\n");
printf("\nSTMT_EXEC;;33293\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;33296\n");
if ((unsigned long)version == (unsigned long)((char const *)0))
    {
      printf("\nSTMT_EXEC;;33298\n");
printf("\nFUNC_RETURN;;\n");
return ((enum backup_type)2);
    }
    else
    {
      printf("\nSTMT_EXEC;;33302\n");
if ((int const) * version == 0)
      {
        printf("\nSTMT_EXEC;;33304\n");
printf("\nFUNC_RETURN;;\n");
return ((enum backup_type)2);
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;33309\n");
tmp = __xargmatch_internal(context, version, backup_args, (char const *)(backup_types), sizeof(backup_types[0]), argmatch_die);
        }
        printf("\nSTMT_EXEC;;33311\n");
printf("\nFUNC_RETURN;;\n");
return ((enum backup_type)backup_types[tmp]);
      }
    }
  }
printf("\nFUNC_RETURN;;\n");
}
enum backup_type xget_version(char const *context, char const *version)
{
  printf("\nFUNC_CALL;xget_version(const char *,const char *);\n");
printf("\nSTMT_EXEC;;33318\n");
enum backup_type tmp;
  printf("\nSTMT_EXEC;;33319\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;33320\n");
enum backup_type tmp___1;
  printf("\nSTMT_EXEC;;33321\n");
char *__cil_tmp6;
  printf("\nSTMT_EXEC;;33322\n");
char *__cil_tmp7;
  printf("\nSTMT_EXEC;;33323\n");
char *__cil_tmp8;
  printf("\nSTMT_EXEC;;33324\n");
char *__cil_tmp9;

  {
    printf("\nSTMT_EXEC;;33327\n");
if (version)
    {
      printf("\nSTMT_EXEC;;33329\n");
if (*version)
      {
        {
          printf("\nSTMT_EXEC;;33332\n");
tmp = get_version(context, version);
        }
        printf("\nSTMT_EXEC;;33334\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;33339\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp___0 = getenv("VERSION_CONTROL");printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33340\n");
tmp___1 = get_version("$VERSION_CONTROL", (char const *)tmp___0);
        }
        printf("\nSTMT_EXEC;;33342\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;33348\n");
printf("\nFUNC_CALL;getenv(const char *);\n");
tmp___0 = getenv("VERSION_CONTROL");printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;33349\n");
tmp___1 = get_version("$VERSION_CONTROL", (char const *)tmp___0);
      }
      printf("\nSTMT_EXEC;;33351\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","014.basename.o.i","") */
char *base_name(char const *name)
{
  printf("\nFUNC_CALL;base_name(const char *);\n");
printf("\nSTMT_EXEC;;33358\n");
char const *base;
  printf("\nSTMT_EXEC;;33359\n");
char const *p;

  {
    printf("\nSTMT_EXEC;;33362\n");
base = name + 0;
    printf("\nSTMT_EXEC;;33363\n");
p = base;
    {
      printf("\nSTMT_EXEC;;33365\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;33368\n");
if (!*p)
        {
          printf("\nSTMT_EXEC;;33370\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33372\n");
if ((int const) * p == 47)
        {
          {
            printf("\nSTMT_EXEC;;33375\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;33378\n");
p++;
              printf("\nSTMT_EXEC;;33379\n");
if (!((int const) * p == 47))
              {
                printf("\nSTMT_EXEC;;33381\n");
goto while_break___0;
              }
            }
          while_break___0: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;33386\n");
if (!*p)
          {
            printf("\nSTMT_EXEC;;33388\n");
if ((int const) * base == 47)
            {
              printf("\nSTMT_EXEC;;33390\n");
base = p - 1;
            }
            printf("\nSTMT_EXEC;;33392\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;33394\n");
base = p;
        }
        printf("\nSTMT_EXEC;;33396\n");
p++;
      }
    while_break: /* CIL Label */;
    }

    printf("\nSTMT_EXEC;;33401\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)base);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t base_len(char const *name)
{
  printf("\nFUNC_CALL;base_len(const char *);\n");
printf("\nSTMT_EXEC;;33406\n");
size_t len;

  {
    {
      printf("\nSTMT_EXEC;;33410\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
len = strlen(name);printf("\nFUNC_RETURN;;\n");

    }
    {
      printf("\nSTMT_EXEC;;33413\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;33416\n");
if (1UL < len)

        {
          printf("\nSTMT_EXEC;;33419\n");
if (!((int const) * (name + (len - 1UL)) == 47))
          {
            printf("\nSTMT_EXEC;;33421\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;33426\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33428\n");
goto __Cont;
      __Cont:


        {
printf("\nSTMT_EXEC;;33432\n");
len--;
}

      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;33436\n");
printf("\nFUNC_RETURN;;\n");
return (len);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","015.dirname.o.i","") */
size_t dir_len(char const *path)
{
  printf("\nFUNC_CALL;dir_len(const char *);\n");
printf("\nSTMT_EXEC;;33442\n");
size_t prefix_length;
  printf("\nSTMT_EXEC;;33443\n");
size_t length;
  printf("\nSTMT_EXEC;;33444\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;33448\n");
prefix_length = (size_t)0;
      printf("\nSTMT_EXEC;;33449\n");
tmp = base_name(path);
      printf("\nSTMT_EXEC;;33450\n");
length = (size_t)(tmp - (char *)path);
    }
    {
      printf("\nSTMT_EXEC;;33453\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;33456\n");
if (!(prefix_length < length))
        {
          printf("\nSTMT_EXEC;;33458\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33460\n");
if (!((int const) * (path + (length - 1UL)) == 47))
        {
          printf("\nSTMT_EXEC;;33462\n");
printf("\nFUNC_RETURN;;\n");
return (length);
        }
        printf("\nSTMT_EXEC;;33464\n");
length--;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;33468\n");
printf("\nFUNC_RETURN;;\n");
return (prefix_length + (size_t)((int const) * (path + prefix_length) == 47));
  }
printf("\nFUNC_RETURN;;\n");
}
char *dir_name(char const *path)
{
  printf("\nFUNC_CALL;dir_name(const char *);\n");
printf("\nSTMT_EXEC;;33473\n");
size_t length;
  printf("\nSTMT_EXEC;;33474\n");
size_t tmp;
  printf("\nSTMT_EXEC;;33475\n");
int append_dot;
  printf("\nSTMT_EXEC;;33476\n");
char *newpath;
  printf("\nSTMT_EXEC;;33477\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;33478\n");
size_t tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;33482\n");
tmp = dir_len(path);
      printf("\nSTMT_EXEC;;33483\n");
length = tmp;
      printf("\nSTMT_EXEC;;33484\n");
append_dot = length == 0UL;
      printf("\nSTMT_EXEC;;33485\n");
tmp___0 = xmalloc((length + (size_t)append_dot) + 1UL);
      printf("\nSTMT_EXEC;;33486\n");
newpath = (char *)tmp___0;
      printf("\nSTMT_EXEC;;33487\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)newpath, (void const * /* __restrict  */)path, length);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33489\n");
if (append_dot)
    {
      printf("\nSTMT_EXEC;;33491\n");
tmp___1 = length;
      printf("\nSTMT_EXEC;;33492\n");
length++;
      printf("\nSTMT_EXEC;;33493\n");
*(newpath + tmp___1) = (char)'.';
    }
    printf("\nSTMT_EXEC;;33495\n");
*(newpath + length) = (char)0;
    printf("\nSTMT_EXEC;;33496\n");
printf("\nFUNC_RETURN;;\n");
return (newpath);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","016.exclude.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) strcasecmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2), __leaf__)) strncasecmp)(char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
void *xzalloc(size_t s);
void *x2realloc(void *p, size_t *pn);
void *x2nrealloc(void *p, size_t *pn, size_t s);
__inline static _Bool is_space(unsigned char c)
{
  printf("\nFUNC_CALL;is_space(unsigned char);\n");
printf("\nSTMT_EXEC;;33507\n");
unsigned short const **tmp;

  {
    {
      printf("\nSTMT_EXEC;;33511\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33513\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)(((int const) * (*tmp + (int)c) & 8192) != 0));
  }
printf("\nFUNC_RETURN;;\n");
}
struct exclude *new_exclude(void)
{
  printf("\nFUNC_CALL;new_exclude();\n");
printf("\nSTMT_EXEC;;33518\n");
struct exclude *tmp;
  printf("\nSTMT_EXEC;;33519\n");
void *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;33523\n");
tmp___0 = xzalloc(sizeof(*tmp));
    }
    printf("\nSTMT_EXEC;;33525\n");
printf("\nFUNC_RETURN;;\n");
return ((struct exclude *)tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
static int fnmatch_no_wildcards(char const *pattern, char const *f, int options)
{
  printf("\nFUNC_CALL;fnmatch_no_wildcards(const char *,const char *,int);\n");
printf("\nSTMT_EXEC;;33530\n");
int tmp;
  printf("\nSTMT_EXEC;;33531\n");
int tmp___0;
  printf("\nSTMT_EXEC;;33532\n");
int tmp___1;
  printf("\nSTMT_EXEC;;33533\n");
size_t patlen;
  printf("\nSTMT_EXEC;;33534\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;33535\n");
int r;
  printf("\nSTMT_EXEC;;33536\n");
int tmp___3;
  printf("\nSTMT_EXEC;;33537\n");
int tmp___4;
  printf("\nSTMT_EXEC;;33538\n");
int tmp___5;

  {
    printf("\nSTMT_EXEC;;33541\n");
if (!(options & (1 << 3)))
    {
      printf("\nSTMT_EXEC;;33543\n");
if (options & (1 << 4))
      {
        {
          printf("\nSTMT_EXEC;;33546\n");
printf("\nFUNC_CALL;strcasecmp(const char *,const char *);\n");
tmp = strcasecmp(pattern, f);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33547\n");
tmp___1 = tmp;
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;33553\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(pattern, f);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33554\n");
tmp___1 = tmp___0;
        }
      }
      printf("\nSTMT_EXEC;;33557\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___1);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;33562\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___2 = strlen(pattern);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;33563\n");
patlen = tmp___2;
      }
      printf("\nSTMT_EXEC;;33565\n");
if (options & (1 << 4))
      {
        {
          printf("\nSTMT_EXEC;;33568\n");
printf("\nFUNC_CALL;strncasecmp(const char *,const char *,size_t);\n");
tmp___3 = strncasecmp(pattern, f, patlen);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33569\n");
tmp___5 = tmp___3;
        }
      }
      else
      {
        {
          printf("\nSTMT_EXEC;;33575\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___4 = strncmp(pattern, f, patlen);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33576\n");
tmp___5 = tmp___4;
        }
      }
      printf("\nSTMT_EXEC;;33579\n");
r = tmp___5;
      printf("\nSTMT_EXEC;;33580\n");
if (!r)
      {
        printf("\nSTMT_EXEC;;33582\n");
r = (int)*(f + patlen);
        printf("\nSTMT_EXEC;;33583\n");
if (r == 47)
        {
          printf("\nSTMT_EXEC;;33585\n");
r = 0;
        }
      }
      printf("\nSTMT_EXEC;;33588\n");
printf("\nFUNC_RETURN;;\n");
return (r);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool excluded_filename(struct exclude const *ex, char const *f)
{
  printf("\nFUNC_CALL;excluded_filename(const struct exclude *,const char *);\n");
printf("\nSTMT_EXEC;;33594\n");
size_t exclude_count;
  printf("\nSTMT_EXEC;;33595\n");
struct patopts const *exclude;
  printf("\nSTMT_EXEC;;33596\n");
size_t i;
  printf("\nSTMT_EXEC;;33597\n");
_Bool excluded___0;
  printf("\nSTMT_EXEC;;33598\n");
char const *pattern;
  printf("\nSTMT_EXEC;;33599\n");
int options;
  printf("\nSTMT_EXEC;;33600\n");
int (*matcher)(char const *, char const *, int);
  printf("\nSTMT_EXEC;;33601\n");
_Bool matched;
  printf("\nSTMT_EXEC;;33602\n");
int tmp;
  printf("\nSTMT_EXEC;;33603\n");
char const *p;
  printf("\nSTMT_EXEC;;33604\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;33607\n");
exclude_count = (size_t)ex->exclude_count;
    printf("\nSTMT_EXEC;;33608\n");
if (exclude_count == 0UL)
    {
      printf("\nSTMT_EXEC;;33610\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    else
    {
      printf("\nSTMT_EXEC;;33614\n");
exclude = (struct patopts const *)ex->exclude;
      printf("\nSTMT_EXEC;;33615\n");
excluded___0 = (_Bool)(!(!((exclude + 0)->options & (int const)(1 << 29))));
      printf("\nSTMT_EXEC;;33616\n");
i = (size_t)0;
      {
        printf("\nSTMT_EXEC;;33618\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;33621\n");
if (!(i < exclude_count))
          {
            printf("\nSTMT_EXEC;;33623\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;33625\n");
pattern = (char const *)(exclude + i)->pattern;
          printf("\nSTMT_EXEC;;33626\n");
options = (int)(exclude + i)->options;
          printf("\nSTMT_EXEC;;33627\n");
if ((int)excluded___0 == !(!(options & (1 << 29))))
          {
            printf("\nSTMT_EXEC;;33629\n");
if (options & (1 << 28))

            {
              printf("\nSTMT_EXEC;;33632\n");
matcher = &fnmatch;
            }
            else
            {
              printf("\nSTMT_EXEC;;33636\n");
matcher = &fnmatch_no_wildcards;
            }
            {
              printf("\nSTMT_EXEC;;33639\n");
tmp = (*matcher)(pattern, f, options);
              printf("\nSTMT_EXEC;;33640\n");
matched = (_Bool)(tmp == 0);
            }
            printf("\nSTMT_EXEC;;33642\n");
if (!(options & (1 << 30)))
            {
              printf("\nSTMT_EXEC;;33644\n");
p = f;
              {
                printf("\nSTMT_EXEC;;33646\n");
while (1)
                {
                while_continue___0: /* CIL Label */;
                  printf("\nSTMT_EXEC;;33649\n");
if (*p)
                  {
                    printf("\nSTMT_EXEC;;33651\n");
if (!(!matched))
                    {
                      printf("\nSTMT_EXEC;;33653\n");
goto while_break___0;
                    }
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;33658\n");
goto while_break___0;
                  }
                  printf("\nSTMT_EXEC;;33660\n");
if ((int const) * p == 47)
                  {
                    printf("\nSTMT_EXEC;;33662\n");
if ((int const) * (p + 1) != 47)
                    {
                      {
                        printf("\nSTMT_EXEC;;33665\n");
tmp___0 = (*matcher)(pattern, p + 1, options);
                        printf("\nSTMT_EXEC;;33666\n");
matched = (_Bool)(tmp___0 == 0);
                      }
                    }
                  }
                  printf("\nSTMT_EXEC;;33670\n");
p++;
                }
              while_break___0: /* CIL Label */;
              }
            }







            printf("\nSTMT_EXEC;;33682\n");
excluded___0 = (_Bool)((int)excluded___0 ^ (int)matched);
          }
          printf("\nSTMT_EXEC;;33684\n");
i++;
        }
      while_break: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;33688\n");
printf("\nFUNC_RETURN;;\n");
return (excluded___0);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void add_exclude(struct exclude *ex, char const *pattern, int options)
{
  printf("\nFUNC_CALL;add_exclude(struct exclude *,const char *,int);\n");
printf("\nSTMT_EXEC;;33694\n");
struct patopts *patopts;
  printf("\nSTMT_EXEC;;33695\n");
void *tmp;
  printf("\nSTMT_EXEC;;33696\n");
size_t tmp___0;

  {
    printf("\nSTMT_EXEC;;33699\n");
if (ex->exclude_count == ex->exclude_alloc)
    {
      {

        printf("\nSTMT_EXEC;;33703\n");
tmp = x2nrealloc((void *)ex->exclude, &ex->exclude_alloc, sizeof(*(ex->exclude)));
        printf("\nSTMT_EXEC;;33704\n");
ex->exclude = (struct patopts *)tmp;
      }
    }
    printf("\nSTMT_EXEC;;33707\n");
tmp___0 = ex->exclude_count;
    printf("\nSTMT_EXEC;;33708\n");
(ex->exclude_count)++;
    printf("\nSTMT_EXEC;;33709\n");
patopts = ex->exclude + tmp___0;
    printf("\nSTMT_EXEC;;33710\n");
patopts->pattern = pattern;
    printf("\nSTMT_EXEC;;33711\n");
patopts->options = options;
    printf("\nSTMT_EXEC;;33712\n");
printf("\nFUNC_RETURN;;\n");
return;


  }
printf("\nFUNC_RETURN;;\n");
}
int add_exclude_file(void (*add_func)(struct exclude *, char const *, int), struct exclude *ex, char const *filename, int options, char line_end)
{
  printf("\nFUNC_CALL;add_exclude_file(void (*)(struct exclude *, const char *, int),struct exclude *,const char *,int,char);\n");
printf("\nSTMT_EXEC;;33719\n");
_Bool use_stdin;
  printf("\nSTMT_EXEC;;33720\n");
FILE *in;
  printf("\nSTMT_EXEC;;33721\n");
char *buf;
  printf("\nSTMT_EXEC;;33722\n");
char *p;
  printf("\nSTMT_EXEC;;33723\n");
char const *pattern;
  printf("\nSTMT_EXEC;;33724\n");
char const *lim;
  printf("\nSTMT_EXEC;;33725\n");
size_t buf_alloc;
  printf("\nSTMT_EXEC;;33726\n");
size_t buf_count;
  printf("\nSTMT_EXEC;;33727\n");
int c;
  printf("\nSTMT_EXEC;;33728\n");
int e;
  printf("\nSTMT_EXEC;;33729\n");
void *tmp;
  printf("\nSTMT_EXEC;;33730\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;33731\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;33732\n");
int tmp___2;
  printf("\nSTMT_EXEC;;33733\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;33734\n");
int tmp___4;
  printf("\nSTMT_EXEC;;33735\n");
void *tmp___5;
  printf("\nSTMT_EXEC;;33736\n");
char *pattern_end;
  printf("\nSTMT_EXEC;;33737\n");
_Bool tmp___6;
  printf("\nSTMT_EXEC;;33738\n");
_Bool tmp___7;
  printf("\nSTMT_EXEC;;33739\n");
int *tmp___8;
  printf("\nSTMT_EXEC;;33740\n");
int tmp___9;
  printf("\nSTMT_EXEC;;33741\n");
int tmp___10;
  printf("\nSTMT_EXEC;;33742\n");
int tmp___11;

  {
    printf("\nSTMT_EXEC;;33745\n");
if ((int const) * (filename + 0) == 45)
    {
      printf("\nSTMT_EXEC;;33747\n");
if (!*(filename + 1))
      {
        printf("\nSTMT_EXEC;;33749\n");
tmp___9 = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;33753\n");
tmp___9 = 0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;33758\n");
tmp___9 = 0;
    }
    printf("\nSTMT_EXEC;;33760\n");
use_stdin = (_Bool)tmp___9;

    printf("\nSTMT_EXEC;;33762\n");
buf = (char *)((void *)0);
    printf("\nSTMT_EXEC;;33763\n");
buf_alloc = (size_t)0;
    printf("\nSTMT_EXEC;;33764\n");
buf_count = (size_t)0;
    printf("\nSTMT_EXEC;;33765\n");
e = 0;
    printf("\nSTMT_EXEC;;33766\n");
if (use_stdin)
    {
      printf("\nSTMT_EXEC;;33768\n");
in = stdin;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;33773\n");
printf("\nFUNC_CALL;fopen(const char *__restrict,const char *__restrict);\n");
in = fopen((char const * /* __restrict  */)filename, (char const * /* __restrict  */) "r");printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;33775\n");
if (!in)
      {
        printf("\nSTMT_EXEC;;33777\n");
printf("\nFUNC_RETURN;;\n");
return (-1);
      }
    }
    {
      printf("\nSTMT_EXEC;;33781\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;33785\n");
printf("\nFUNC_CALL;getc_unlocked(FILE *);\n");
c = getc_unlocked(in);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;33787\n");
if (!(c != -1))
        {
          printf("\nSTMT_EXEC;;33789\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;33791\n");
if (buf_count == buf_alloc)
        {
          {

            printf("\nSTMT_EXEC;;33795\n");
tmp = x2realloc((void *)buf, &buf_alloc);
            printf("\nSTMT_EXEC;;33796\n");
buf = (char *)tmp;
          }
        }
        printf("\nSTMT_EXEC;;33799\n");
tmp___0 = buf_count;
        printf("\nSTMT_EXEC;;33800\n");
buf_count++;
        printf("\nSTMT_EXEC;;33801\n");
*(buf + tmp___0) = (char)c;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;33806\n");
printf("\nFUNC_CALL;ferror_unlocked(FILE *);\n");
tmp___2 = ferror_unlocked(in);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;33808\n");
if (tmp___2)
    {
      {
        printf("\nSTMT_EXEC;;33811\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;33812\n");
e = *tmp___1;
      }
    }
    printf("\nSTMT_EXEC;;33815\n");
if (!use_stdin)
    {
      {
        printf("\nSTMT_EXEC;;33818\n");
printf("\nFUNC_CALL;fclose(FILE *);\n");
tmp___4 = fclose(in);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;33820\n");
if (tmp___4 != 0)
      {
        {
          printf("\nSTMT_EXEC;;33823\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;33824\n");
e = *tmp___3;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;33829\n");
tmp___5 = xrealloc((void *)buf, buf_count + 1UL);
      printf("\nSTMT_EXEC;;33830\n");
buf = (char *)tmp___5;
      printf("\nSTMT_EXEC;;33831\n");
*(buf + buf_count) = line_end;
    }
    printf("\nSTMT_EXEC;;33833\n");
if (buf_count == 0UL)
    {
      printf("\nSTMT_EXEC;;33835\n");
tmp___10 = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;33839\n");
if ((int)*(buf + (buf_count - 1UL)) == (int)line_end)
      {
        printf("\nSTMT_EXEC;;33841\n");
tmp___10 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;33845\n");
tmp___10 = 1;
      }
    }
    printf("\nSTMT_EXEC;;33848\n");
lim = (char const *)((buf + buf_count) + tmp___10);
    printf("\nSTMT_EXEC;;33849\n");
pattern = (char const *)buf;
    printf("\nSTMT_EXEC;;33850\n");
p = buf;
    {
      printf("\nSTMT_EXEC;;33852\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;33855\n");
if (!((unsigned long)p < (unsigned long)lim))
        {
          printf("\nSTMT_EXEC;;33857\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;33859\n");
if ((int)*p == (int)line_end)
        {
          {
            printf("\nSTMT_EXEC;;33862\n");
pattern_end = p;
            printf("\nSTMT_EXEC;;33863\n");
tmp___7 = is_space((unsigned char)line_end);
          }
          printf("\nSTMT_EXEC;;33865\n");
if (tmp___7)
          {
            {
              printf("\nSTMT_EXEC;;33868\n");
while (1)
              {
              while_continue___1: /* CIL Label */;
                printf("\nSTMT_EXEC;;33871\n");
if ((unsigned long)pattern_end == (unsigned long)pattern)
                {
                  printf("\nSTMT_EXEC;;33873\n");
goto next_pattern;
                }
                else
                {
                  {
                    printf("\nSTMT_EXEC;;33878\n");
tmp___6 = is_space((unsigned char)*(pattern_end + -1));
                  }
                  printf("\nSTMT_EXEC;;33880\n");
if (!tmp___6)
                  {
                    printf("\nSTMT_EXEC;;33882\n");
goto while_break___1;
                  }
                }
                printf("\nSTMT_EXEC;;33885\n");
pattern_end--;
              }
            while_break___1: /* CIL Label */;
            }
          }

          {
            printf("\nSTMT_EXEC;;33892\n");
*pattern_end = (char)'\000';
            printf("\nSTMT_EXEC;;33893\n");
(*add_func)(ex, pattern, options);
          }
        next_pattern:
          {
printf("\nSTMT_EXEC;;33896\n");
pattern = (char const *)(p + 1);
}

        }
        printf("\nSTMT_EXEC;;33898\n");
p++;
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;33903\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___8 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;33904\n");
*tmp___8 = e;
    }
    printf("\nSTMT_EXEC;;33906\n");
if (e)
    {
      printf("\nSTMT_EXEC;;33908\n");
tmp___11 = -1;
    }
    else
    {
      printf("\nSTMT_EXEC;;33912\n");
tmp___11 = 0;
    }
    printf("\nSTMT_EXEC;;33914\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___11);































































































  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","017.exitfail.o.i","") */
int volatile exit_failure = (int volatile)1;
/* #pragma merger("0","018.full-write.o.i","") */
size_t safe_write(int fd, void const *buf, size_t count);
size_t full_write(int fd, void const *buf, size_t count)
{
  printf("\nFUNC_CALL;full_write(int,const void *,size_t);\n");
printf("\nSTMT_EXEC;;34018\n");
size_t total;
  printf("\nSTMT_EXEC;;34019\n");
char const *ptr;
  printf("\nSTMT_EXEC;;34020\n");
size_t n_rw;
  printf("\nSTMT_EXEC;;34021\n");
size_t tmp;
  printf("\nSTMT_EXEC;;34022\n");
int *tmp___0;

  {
    printf("\nSTMT_EXEC;;34025\n");
total = (size_t)0;

    printf("\nSTMT_EXEC;;34027\n");
ptr = (char const *)buf;
    {
      printf("\nSTMT_EXEC;;34029\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;34032\n");
if (!(count > 0UL))
        {
          printf("\nSTMT_EXEC;;34034\n");
goto while_break;
        }

        {
          printf("\nSTMT_EXEC;;34038\n");
tmp = safe_write(fd, (void const *)ptr, count);
          printf("\nSTMT_EXEC;;34039\n");
n_rw = tmp;
        }
        printf("\nSTMT_EXEC;;34041\n");
if (n_rw == 0xffffffffffffffffUL)
        {
          printf("\nSTMT_EXEC;;34043\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;34045\n");
if (n_rw == 0UL)
        {
          {
            printf("\nSTMT_EXEC;;34048\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;34049\n");
*tmp___0 = 28;
          }
          printf("\nSTMT_EXEC;;34051\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;34053\n");
total += n_rw;
        printf("\nSTMT_EXEC;;34054\n");
ptr += n_rw;
        printf("\nSTMT_EXEC;;34055\n");
count -= n_rw;
      }
    while_break: /* CIL Label */;


















    }
    printf("\nSTMT_EXEC;;34077\n");
printf("\nFUNC_RETURN;;\n");
return (total);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","019.getdate.o.i","") */
__attribute__((__nothrow__)) time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp);
int gettime(struct timespec *ts);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) toupper)(int __c);
static int yyerror(char *s __attribute__((__unused__)));
static int yylex(YYSTYPE *lvalp, parser_control *pc);
static char const yytranslate[275] = {(char const)0, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)23, (char const)2, (char const)2, (char const)24, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)22, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)21, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)2, (char const)1, (char const)3, (char const)4, (char const)5, (char const)6, (char const)7, (char const)8, (char const)9, (char const)10, (char const)11, (char const)12, (char const)13, (char const)14, (char const)15, (char const)16, (char const)17, (char const)18, (char const)19, (char const)20};
static short const yyr1[66] = {(short const)0, (short const)25, (short const)25, (short const)26, (short const)27, (short const)27, (short const)28, (short const)28, (short const)28, (short const)28, (short const)28, (short const)28, (short const)28, (short const)29, (short const)29, (short const)29, (short const)29, (short const)29, (short const)30, (short const)30, (short const)31, (short const)31, (short const)31, (short const)32, (short const)32, (short const)32, (short const)33, (short const)33, (short const)33, (short const)33, (short const)33, (short const)33, (short const)33, (short const)33, (short const)33, (short const)34, (short const)34, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)35, (short const)36, (short const)36, (short const)37, (short const)37, (short const)38, (short const)38, (short const)39, (short const)40, (short const)40};
static short const yyr2[66] = {(short const)0, (short const)1, (short const)1, (short const)2, (short const)0, (short const)2, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)2, (short const)4, (short const)4, (short const)6, (short const)6, (short const)1, (short const)2, (short const)1, (short const)1, (short const)2, (short const)1, (short const)2, (short const)2, (short const)3, (short const)5, (short const)3, (short const)3, (short const)3, (short const)2, (short const)4, (short const)2, (short const)3, (short const)2, (short const)1, (short const)2, (short const)2, (short const)1, (short const)2, (short const)2, (short const)1, (short const)2, (short const)2, (short const)1, (short const)2, (short const)2, (short const)1, (short const)2, (short const)2, (short const)1, (short const)2, (short const)2, (short const)2, (short const)2, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)1, (short const)0, (short const)1};
static short const yydefact[81] = {(short const)4, (short const)0, (short const)1, (short const)2, (short const)60, (short const)62, (short const)59, (short const)61, (short const)3, (short const)57, (short const)58, (short const)23, (short const)45, (short const)21, (short const)48, (short const)18, (short const)51, (short const)0, (short const)42, (short const)56, (short const)39, (short const)20, (short const)0, (short const)63, (short const)0, (short const)0, (short const)5, (short const)6, (short const)7, (short const)8, (short const)10, (short const)9, (short const)11, (short const)36, (short const)12, (short const)24, (short const)19, (short const)0, (short const)31, (short const)22, (short const)44, (short const)47, (short const)50, (short const)41, (short const)53, (short const)38, (short const)25, (short const)43, (short const)46, (short const)13, (short const)49, (short const)33, (short const)40, (short const)52, (short const)37, (short const)0, (short const)0, (short const)0, (short const)54, (short const)55, (short const)35, (short const)30, (short const)0, (short const)29, (short const)34, (short const)28, (short const)64, (short const)26, (short const)32, (short const)65, (short const)15, (short const)0, (short const)14, (short const)0, (short const)64, (short const)27, (short const)17, (short const)16, (short const)0, (short const)0, (short const)0};
static short const yydefgoto[16] = {(short const)78, (short const)2, (short const)3, (short const)26, (short const)27, (short const)28, (short const)29, (short const)30, (short const)31, (short const)32, (short const)33, (short const)8, (short const)9, (short const)10, (short const)34, (short const)72};
static short const yypact[81] = {(short const) - 19, (short const)29, (short const) - 32768, (short const)15, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 8, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)36, (short const) - 32768, (short const) - 4, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)38, (short const)30, (short const) - 5, (short const)39, (short const)40, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)49, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)41, (short const)32, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)33, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)42, (short const)43, (short const)44, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)45, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 6, (short const)46, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)19, (short const) - 32768, (short const)47, (short const)8, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const)56, (short const)57, (short const) - 32768};
static short const yypgoto[16] = {(short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 32768, (short const) - 11, (short const) - 32768, (short const) - 10};
static short const yytable[71] = {(short const)46, (short const)47, (short const)1, (short const)48, (short const)69, (short const)49, (short const)50, (short const)51, (short const)52, (short const)53, (short const)54, (short const)70, (short const)55, (short const)37, (short const)38, (short const)35, (short const)71, (short const)56, (short const)69, (short const)57, (short const)11, (short const)12, (short const)13, (short const)14, (short const)15, (short const)76, (short const)16, (short const)17, (short const)18, (short const)19, (short const)20, (short const)21, (short const)22, (short const)23, (short const)24, (short const)25, (short const)40, (short const)5, (short const)41, (short const)7, (short const)36, (short const)42, (short const)39, (short const)43, (short const)44, (short const)45, (short const)4, (short const)5, (short const)6, (short const)7, (short const)63, (short const)64, (short const)60, (short const)58, (short const)59, (short const)62, (short const)79, (short const)80, (short const)61, (short const)65, (short const)74, (short const)66, (short const)67, (short const)68, (short const)77, (short const)75, (short const)0, (short const)0, (short const)0, (short const)0, (short const)73};
static short const yycheck[71] = {(short const)5, (short const)6, (short const)21, (short const)8, (short const)10, (short const)10, (short const)11, (short const)12, (short const)13, (short const)14, (short const)15, (short const)17, (short const)17, (short const)17, (short const)18, (short const)23, (short const)22, (short const)22, (short const)10, (short const)24, (short const)5, (short const)6, (short const)7, (short const)8, (short const)9, (short const)17, (short const)11, (short const)12, (short const)13, (short const)14, (short const)15, (short const)16, (short const)17, (short const)18, (short const)19, (short const)20, (short const)6, (short const)18, (short const)8, (short const)20, (short const)4, (short const)11, (short const)4, (short const)13, (short const)14, (short const)15, (short const)17, (short const)18, (short const)19, (short const)20, (short const)17, (short const)18, (short const)3, (short const)14, (short const)14, (short const)23, (short const)0, (short const)0, (short const)17, (short const)17, (short const)71, (short const)18, (short const)18, (short const)18, (short const)74, (short const)18, (short const) - 1, (short const) - 1, (short const) - 1, (short const) - 1, (short const)24};
int yyparse(void *parm);
int yyparse(void *parm)
{
  printf("\nFUNC_CALL;yyparse(void *);\n");
printf("\nSTMT_EXEC;;34098\n");
register int yystate;
  printf("\nSTMT_EXEC;;34099\n");
register int yyn;
  printf("\nSTMT_EXEC;;34100\n");
register short *yyssp;
  printf("\nSTMT_EXEC;;34101\n");
register YYSTYPE *yyvsp;
  printf("\nSTMT_EXEC;;34102\n");
int yyerrstatus;
  printf("\nSTMT_EXEC;;34103\n");
int yychar1;
  printf("\nSTMT_EXEC;;34104\n");
short yyssa[200];
  printf("\nSTMT_EXEC;;34105\n");
YYSTYPE yyvsa[200];
  printf("\nSTMT_EXEC;;34106\n");
short *yyss;
  printf("\nSTMT_EXEC;;34107\n");
YYSTYPE *yyvs;
  printf("\nSTMT_EXEC;;34108\n");
int yystacksize;
  printf("\nSTMT_EXEC;;34109\n");
int yyfree_stacks;
  printf("\nSTMT_EXEC;;34110\n");
int yychar;
  printf("\nSTMT_EXEC;;34111\n");
YYSTYPE yylval;
  printf("\nSTMT_EXEC;;34112\n");
int yynerrs;
  printf("\nSTMT_EXEC;;34113\n");
YYSTYPE yyval;
  printf("\nSTMT_EXEC;;34114\n");
int yylen;
  printf("\nSTMT_EXEC;;34115\n");
YYSTYPE *yyvs1;
  printf("\nSTMT_EXEC;;34116\n");
short *yyss1;
  printf("\nSTMT_EXEC;;34117\n");
int size;
  printf("\nSTMT_EXEC;;34118\n");
void *tmp;
  printf("\nSTMT_EXEC;;34119\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;34120\n");
int tmp___1;
  printf("\nSTMT_EXEC;;34121\n");
long tmp___2;
  printf("\nSTMT_EXEC;;34122\n");
void *__cil_tmp26;
  printf("\nSTMT_EXEC;;34123\n");
void *__cil_tmp27;
  printf("\nSTMT_EXEC;;34124\n");
int __cil_tmp28;
  printf("\nSTMT_EXEC;;34125\n");
char *__cil_tmp29;
  printf("\nSTMT_EXEC;;34126\n");
char *__cil_tmp30;

  {
    printf("\nSTMT_EXEC;;34129\n");
yychar1 = 0;
    printf("\nSTMT_EXEC;;34130\n");
yyss = yyssa;
    printf("\nSTMT_EXEC;;34131\n");
yyvs = yyvsa;
    printf("\nSTMT_EXEC;;34132\n");
yystacksize = 200;
    printf("\nSTMT_EXEC;;34133\n");
yyfree_stacks = 0;
    printf("\nSTMT_EXEC;;34134\n");
yystate = 0;
    printf("\nSTMT_EXEC;;34135\n");
yyerrstatus = 0;
    printf("\nSTMT_EXEC;;34136\n");
yynerrs = 0;
    printf("\nSTMT_EXEC;;34137\n");
yychar = -2;
    printf("\nSTMT_EXEC;;34138\n");
yyssp = yyss - 1;
    printf("\nSTMT_EXEC;;34139\n");
yyvsp = yyvs;
  yynewstate:
    {
printf("\nSTMT_EXEC;;34141\n");
yyssp++;
}

    printf("\nSTMT_EXEC;;34142\n");
*yyssp = (short)yystate;
    printf("\nSTMT_EXEC;;34143\n");
if ((unsigned long)yyssp >= (unsigned long)((yyss + yystacksize) - 1))
    {
      printf("\nSTMT_EXEC;;34145\n");
yyvs1 = yyvs;
      printf("\nSTMT_EXEC;;34146\n");
yyss1 = yyss;
      printf("\nSTMT_EXEC;;34147\n");
size = (int)((yyssp - yyss) + 1L);
      printf("\nSTMT_EXEC;;34148\n");
if (yystacksize >= 10000)
      {
        {
          printf("\nSTMT_EXEC;;34151\n");
yyerror((char *)"parser stack overflow");
        }
        printf("\nSTMT_EXEC;;34153\n");
if (yyfree_stacks)
        {
          {
            printf("\nSTMT_EXEC;;34156\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyss);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;34157\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyvs);printf("\nFUNC_RETURN;;\n");

          }
        }
        printf("\nSTMT_EXEC;;34160\n");
printf("\nFUNC_RETURN;;\n");
return (2);
      }
      printf("\nSTMT_EXEC;;34162\n");
yystacksize *= 2;
      printf("\nSTMT_EXEC;;34163\n");
if (yystacksize > 10000)
      {
        printf("\nSTMT_EXEC;;34165\n");
yystacksize = 10000;
      }
      {
        printf("\nSTMT_EXEC;;34168\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp = __builtin_alloca((unsigned long)yystacksize * sizeof(*yyssp));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34169\n");
yyss = (short *)tmp;
        printf("\nSTMT_EXEC;;34170\n");
printf("\nFUNC_CALL;__builtin_memcpy(void *,const void *,unsigned long);\n");
__builtin_memcpy((void *)((char *)yyss), (void const *)((char *)yyss1), (unsigned long)((unsigned int)size * (unsigned int)sizeof(*yyssp)));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34171\n");
printf("\nFUNC_CALL;__builtin_alloca(unsigned long);\n");
tmp___0 = __builtin_alloca((unsigned long)yystacksize * sizeof(*yyvsp));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34172\n");
yyvs = (YYSTYPE *)tmp___0;
        printf("\nSTMT_EXEC;;34173\n");
printf("\nFUNC_CALL;__builtin_memcpy(void *,const void *,unsigned long);\n");
__builtin_memcpy((void *)((char *)yyvs), (void const *)((char *)yyvs1), (unsigned long)((unsigned int)size * (unsigned int)sizeof(*yyvsp)));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34174\n");
yyssp = (yyss + size) - 1;
        printf("\nSTMT_EXEC;;34175\n");
yyvsp = (yyvs + size) - 1;
      }
      printf("\nSTMT_EXEC;;34177\n");
if ((unsigned long)yyssp >= (unsigned long)((yyss + yystacksize) - 1))
      {
        printf("\nSTMT_EXEC;;34179\n");
goto yyabortlab;
      }
    }
    printf("\nSTMT_EXEC;;34182\n");
goto yybackup;
  yybackup:
    {
printf("\nSTMT_EXEC;;34184\n");
yyn = (int)yypact[yystate];
}

    printf("\nSTMT_EXEC;;34185\n");
if (yyn == -32768)
    {
      printf("\nSTMT_EXEC;;34187\n");
goto yydefault;
    }
    printf("\nSTMT_EXEC;;34189\n");
if (yychar == -2)
    {
      {
        printf("\nSTMT_EXEC;;34192\n");
yychar = yylex(&yylval, (parser_control *)parm);
      }
    }
    printf("\nSTMT_EXEC;;34195\n");
if (yychar <= 0)
    {
      printf("\nSTMT_EXEC;;34197\n");
yychar1 = 0;
      printf("\nSTMT_EXEC;;34198\n");
yychar = 0;
    }
    else
    {
      printf("\nSTMT_EXEC;;34202\n");
if ((unsigned int)yychar <= 274U)
      {
        printf("\nSTMT_EXEC;;34204\n");
tmp___1 = (int const)yytranslate[yychar];
      }
      else
      {
        printf("\nSTMT_EXEC;;34208\n");
tmp___1 = (int const)41;
      }
      printf("\nSTMT_EXEC;;34210\n");
yychar1 = (int)tmp___1;
    }
    printf("\nSTMT_EXEC;;34212\n");
yyn += yychar1;
    printf("\nSTMT_EXEC;;34213\n");
if (yyn < 0)
    {
      printf("\nSTMT_EXEC;;34215\n");
goto yydefault;
    }
    else
    {
      printf("\nSTMT_EXEC;;34219\n");
if (yyn > 70)
      {
        printf("\nSTMT_EXEC;;34221\n");
goto yydefault;
      }
      else
      {
        printf("\nSTMT_EXEC;;34225\n");
if ((int const)yycheck[yyn] != (int const)yychar1)
        {
          printf("\nSTMT_EXEC;;34227\n");
goto yydefault;
        }
      }
    }
    printf("\nSTMT_EXEC;;34231\n");
yyn = (int)yytable[yyn];
    printf("\nSTMT_EXEC;;34232\n");
if (yyn < 0)
    {
      printf("\nSTMT_EXEC;;34234\n");
if (yyn == -32768)
      {
        printf("\nSTMT_EXEC;;34236\n");
goto yyerrlab;
      }
      printf("\nSTMT_EXEC;;34238\n");
yyn = -yyn;
      printf("\nSTMT_EXEC;;34239\n");
goto yyreduce;
    }
    else
    {
      printf("\nSTMT_EXEC;;34243\n");
if (yyn == 0)
      {
        printf("\nSTMT_EXEC;;34245\n");
goto yyerrlab;
      }
    }
    printf("\nSTMT_EXEC;;34248\n");
if (yyn == 80)
    {
      printf("\nSTMT_EXEC;;34250\n");
goto yyacceptlab;
    }
    printf("\nSTMT_EXEC;;34252\n");
if (yychar != 0)
    {
      printf("\nSTMT_EXEC;;34254\n");
yychar = -2;
    }
    printf("\nSTMT_EXEC;;34256\n");
yyvsp++;
    printf("\nSTMT_EXEC;;34257\n");
*yyvsp = yylval;
    printf("\nSTMT_EXEC;;34258\n");
if (yyerrstatus)
    {
      printf("\nSTMT_EXEC;;34260\n");
yyerrstatus--;
    }
    printf("\nSTMT_EXEC;;34262\n");
yystate = yyn;
    printf("\nSTMT_EXEC;;34263\n");
goto yynewstate;
  yydefault:
    {
printf("\nSTMT_EXEC;;34265\n");
yyn = (int)yydefact[yystate];
}

    printf("\nSTMT_EXEC;;34266\n");
if (yyn == 0)
    {
      printf("\nSTMT_EXEC;;34268\n");
goto yyerrlab;
    }
  yyreduce:
    {
printf("\nSTMT_EXEC;;34271\n");
yylen = (int)yyr2[yyn];
}

    printf("\nSTMT_EXEC;;34272\n");
if (yylen > 0)
    {
      printf("\nSTMT_EXEC;;34274\n");
yyval = *(yyvsp + (1 - yylen));
    }
    {
      printf("\nSTMT_EXEC;;34277\n");
if (yyn == 3)
      {
        printf("\nSTMT_EXEC;;34279\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;34281\n");
if (yyn == 6)
      {
        printf("\nSTMT_EXEC;;34283\n");
goto case_6;
      }
      printf("\nSTMT_EXEC;;34285\n");
if (yyn == 7)
      {
        printf("\nSTMT_EXEC;;34287\n");
goto case_7;
      }
      printf("\nSTMT_EXEC;;34289\n");
if (yyn == 8)
      {
        printf("\nSTMT_EXEC;;34291\n");
goto case_8;
      }
      printf("\nSTMT_EXEC;;34293\n");
if (yyn == 9)
      {
        printf("\nSTMT_EXEC;;34295\n");
goto case_9;
      }
      printf("\nSTMT_EXEC;;34297\n");
if (yyn == 10)
      {
        printf("\nSTMT_EXEC;;34299\n");
goto case_10;
      }
      printf("\nSTMT_EXEC;;34301\n");
if (yyn == 11)
      {
        printf("\nSTMT_EXEC;;34303\n");
goto case_11;
      }
      printf("\nSTMT_EXEC;;34305\n");
if (yyn == 13)
      {
        printf("\nSTMT_EXEC;;34307\n");
goto case_13;
      }
      printf("\nSTMT_EXEC;;34309\n");
if (yyn == 14)
      {
        printf("\nSTMT_EXEC;;34311\n");
goto case_14;
      }
      printf("\nSTMT_EXEC;;34313\n");
if (yyn == 15)
      {
        printf("\nSTMT_EXEC;;34315\n");
goto case_15;
      }
      printf("\nSTMT_EXEC;;34317\n");
if (yyn == 16)
      {
        printf("\nSTMT_EXEC;;34319\n");
goto case_16;
      }
      printf("\nSTMT_EXEC;;34321\n");
if (yyn == 17)
      {
        printf("\nSTMT_EXEC;;34323\n");
goto case_17;
      }
      printf("\nSTMT_EXEC;;34325\n");
if (yyn == 18)
      {
        printf("\nSTMT_EXEC;;34327\n");
goto case_18;
      }
      printf("\nSTMT_EXEC;;34329\n");
if (yyn == 19)
      {
        printf("\nSTMT_EXEC;;34331\n");
goto case_19;
      }
      printf("\nSTMT_EXEC;;34333\n");
if (yyn == 20)
      {
        printf("\nSTMT_EXEC;;34335\n");
goto case_20;
      }
      printf("\nSTMT_EXEC;;34337\n");
if (yyn == 21)
      {
        printf("\nSTMT_EXEC;;34339\n");
goto case_21;
      }
      printf("\nSTMT_EXEC;;34341\n");
if (yyn == 22)
      {
        printf("\nSTMT_EXEC;;34343\n");
goto case_22;
      }
      printf("\nSTMT_EXEC;;34345\n");
if (yyn == 23)
      {
        printf("\nSTMT_EXEC;;34347\n");
goto case_23;
      }
      printf("\nSTMT_EXEC;;34349\n");
if (yyn == 24)
      {
        printf("\nSTMT_EXEC;;34351\n");
goto case_24;
      }
      printf("\nSTMT_EXEC;;34353\n");
if (yyn == 25)
      {
        printf("\nSTMT_EXEC;;34355\n");
goto case_25;
      }
      printf("\nSTMT_EXEC;;34357\n");
if (yyn == 26)
      {
        printf("\nSTMT_EXEC;;34359\n");
goto case_26;
      }
      printf("\nSTMT_EXEC;;34361\n");
if (yyn == 27)
      {
        printf("\nSTMT_EXEC;;34363\n");
goto case_27;
      }
      printf("\nSTMT_EXEC;;34365\n");
if (yyn == 28)
      {
        printf("\nSTMT_EXEC;;34367\n");
goto case_28;
      }
      printf("\nSTMT_EXEC;;34369\n");
if (yyn == 29)
      {
        printf("\nSTMT_EXEC;;34371\n");
goto case_29;
      }
      printf("\nSTMT_EXEC;;34373\n");
if (yyn == 30)
      {
        printf("\nSTMT_EXEC;;34375\n");
goto case_30;
      }
      printf("\nSTMT_EXEC;;34377\n");
if (yyn == 31)
      {
        printf("\nSTMT_EXEC;;34379\n");
goto case_31;
      }
      printf("\nSTMT_EXEC;;34381\n");
if (yyn == 32)
      {
        printf("\nSTMT_EXEC;;34383\n");
goto case_32;
      }
      printf("\nSTMT_EXEC;;34385\n");
if (yyn == 33)
      {
        printf("\nSTMT_EXEC;;34387\n");
goto case_33;
      }
      printf("\nSTMT_EXEC;;34389\n");
if (yyn == 34)
      {
        printf("\nSTMT_EXEC;;34391\n");
goto case_34;
      }
      printf("\nSTMT_EXEC;;34393\n");
if (yyn == 35)
      {
        printf("\nSTMT_EXEC;;34395\n");
goto case_35;
      }
      printf("\nSTMT_EXEC;;34397\n");
if (yyn == 37)
      {
        printf("\nSTMT_EXEC;;34399\n");
goto case_37;
      }
      printf("\nSTMT_EXEC;;34401\n");
if (yyn == 38)
      {
        printf("\nSTMT_EXEC;;34403\n");
goto case_38;
      }
      printf("\nSTMT_EXEC;;34405\n");
if (yyn == 39)
      {
        printf("\nSTMT_EXEC;;34407\n");
goto case_39;
      }
      printf("\nSTMT_EXEC;;34409\n");
if (yyn == 40)
      {
        printf("\nSTMT_EXEC;;34411\n");
goto case_40;
      }
      printf("\nSTMT_EXEC;;34413\n");
if (yyn == 41)
      {
        printf("\nSTMT_EXEC;;34415\n");
goto case_41;
      }
      printf("\nSTMT_EXEC;;34417\n");
if (yyn == 42)
      {
        printf("\nSTMT_EXEC;;34419\n");
goto case_42;
      }
      printf("\nSTMT_EXEC;;34421\n");
if (yyn == 43)
      {
        printf("\nSTMT_EXEC;;34423\n");
goto case_43;
      }
      printf("\nSTMT_EXEC;;34425\n");
if (yyn == 44)
      {
        printf("\nSTMT_EXEC;;34427\n");
goto case_44;
      }
      printf("\nSTMT_EXEC;;34429\n");
if (yyn == 45)
      {
        printf("\nSTMT_EXEC;;34431\n");
goto case_45;
      }
      printf("\nSTMT_EXEC;;34433\n");
if (yyn == 46)
      {
        printf("\nSTMT_EXEC;;34435\n");
goto case_46;
      }
      printf("\nSTMT_EXEC;;34437\n");
if (yyn == 47)
      {
        printf("\nSTMT_EXEC;;34439\n");
goto case_47;
      }
      printf("\nSTMT_EXEC;;34441\n");
if (yyn == 48)
      {
        printf("\nSTMT_EXEC;;34443\n");
goto case_48;
      }
      printf("\nSTMT_EXEC;;34445\n");
if (yyn == 49)
      {
        printf("\nSTMT_EXEC;;34447\n");
goto case_49;
      }
      printf("\nSTMT_EXEC;;34449\n");
if (yyn == 50)
      {
        printf("\nSTMT_EXEC;;34451\n");
goto case_50;
      }
      printf("\nSTMT_EXEC;;34453\n");
if (yyn == 51)
      {
        printf("\nSTMT_EXEC;;34455\n");
goto case_51;
      }
      printf("\nSTMT_EXEC;;34457\n");
if (yyn == 52)
      {
        printf("\nSTMT_EXEC;;34459\n");
goto case_52;
      }
      printf("\nSTMT_EXEC;;34461\n");
if (yyn == 53)
      {
        printf("\nSTMT_EXEC;;34463\n");
goto case_53;
      }
      printf("\nSTMT_EXEC;;34465\n");
if (yyn == 54)
      {
        printf("\nSTMT_EXEC;;34467\n");
goto case_54;
      }
      printf("\nSTMT_EXEC;;34469\n");
if (yyn == 55)
      {
        printf("\nSTMT_EXEC;;34471\n");
goto case_55;
      }
      printf("\nSTMT_EXEC;;34473\n");
if (yyn == 56)
      {
        printf("\nSTMT_EXEC;;34475\n");
goto case_56;
      }
      printf("\nSTMT_EXEC;;34477\n");
if (yyn == 60)
      {
        printf("\nSTMT_EXEC;;34479\n");
goto case_60;
      }
      printf("\nSTMT_EXEC;;34481\n");
if (yyn == 62)
      {
        printf("\nSTMT_EXEC;;34483\n");
goto case_62;
      }
      printf("\nSTMT_EXEC;;34485\n");
if (yyn == 63)
      {
        printf("\nSTMT_EXEC;;34487\n");
goto case_63;
      }
      printf("\nSTMT_EXEC;;34489\n");
if (yyn == 64)
      {
        printf("\nSTMT_EXEC;;34491\n");
goto case_64;
      }
      printf("\nSTMT_EXEC;;34493\n");
if (yyn == 65)
      {
        printf("\nSTMT_EXEC;;34495\n");
goto case_65;
      }
      printf("\nSTMT_EXEC;;34497\n");
goto switch_break;
    case_3: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34499\n");
((parser_control *)parm)->seconds = (yyvsp + 0)->timespec;
}

      printf("\nSTMT_EXEC;;34500\n");
((parser_control *)parm)->timespec_seen = (_Bool)1;
      printf("\nSTMT_EXEC;;34501\n");
goto switch_break;
    case_6: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34503\n");
(((parser_control *)parm)->times_seen)++;
}

      printf("\nSTMT_EXEC;;34504\n");
goto switch_break;
    case_7: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34506\n");
(((parser_control *)parm)->local_zones_seen)++;
}

      printf("\nSTMT_EXEC;;34507\n");
goto switch_break;
    case_8: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34509\n");
(((parser_control *)parm)->zones_seen)++;
}

      printf("\nSTMT_EXEC;;34510\n");
goto switch_break;
    case_9: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34512\n");
(((parser_control *)parm)->dates_seen)++;
}

      printf("\nSTMT_EXEC;;34513\n");
goto switch_break;
    case_10: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34515\n");
(((parser_control *)parm)->days_seen)++;
}

      printf("\nSTMT_EXEC;;34516\n");
goto switch_break;
    case_11: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34518\n");
(((parser_control *)parm)->rels_seen)++;
}

      printf("\nSTMT_EXEC;;34519\n");
goto switch_break;
    case_13: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34521\n");
((parser_control *)parm)->hour = (yyvsp + -1)->textintval.value;
}

      printf("\nSTMT_EXEC;;34522\n");
((parser_control *)parm)->minutes = 0L;
      printf("\nSTMT_EXEC;;34523\n");
((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
      printf("\nSTMT_EXEC;;34524\n");
((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
      printf("\nSTMT_EXEC;;34525\n");
((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34526\n");
goto switch_break;
    case_14: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34528\n");
((parser_control *)parm)->hour = (yyvsp + -3)->textintval.value;
}

      printf("\nSTMT_EXEC;;34529\n");
((parser_control *)parm)->minutes = (yyvsp + -1)->textintval.value;
      printf("\nSTMT_EXEC;;34530\n");
((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
      printf("\nSTMT_EXEC;;34531\n");
((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
      printf("\nSTMT_EXEC;;34532\n");
((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34533\n");
goto switch_break;
    case_15: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34535\n");
((parser_control *)parm)->hour = (yyvsp + -3)->textintval.value;
}

      printf("\nSTMT_EXEC;;34536\n");
((parser_control *)parm)->minutes = (yyvsp + -1)->textintval.value;
      printf("\nSTMT_EXEC;;34537\n");
((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
      printf("\nSTMT_EXEC;;34538\n");
((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
      printf("\nSTMT_EXEC;;34539\n");
((parser_control *)parm)->meridian = 2;
      printf("\nSTMT_EXEC;;34540\n");
(((parser_control *)parm)->zones_seen)++;
      printf("\nSTMT_EXEC;;34541\n");
((parser_control *)parm)->time_zone = (yyvsp + 0)->textintval.value % 100L + ((yyvsp + 0)->textintval.value / 100L) * 60L;
      printf("\nSTMT_EXEC;;34542\n");
goto switch_break;
    case_16: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34544\n");
((parser_control *)parm)->hour = (yyvsp + -5)->textintval.value;
}

      printf("\nSTMT_EXEC;;34545\n");
((parser_control *)parm)->minutes = (yyvsp + -3)->textintval.value;
      printf("\nSTMT_EXEC;;34546\n");
((parser_control *)parm)->seconds = (yyvsp + -1)->timespec;
      printf("\nSTMT_EXEC;;34547\n");
((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34548\n");
goto switch_break;
    case_17: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34550\n");
((parser_control *)parm)->hour = (yyvsp + -5)->textintval.value;
}

      printf("\nSTMT_EXEC;;34551\n");
((parser_control *)parm)->minutes = (yyvsp + -3)->textintval.value;
      printf("\nSTMT_EXEC;;34552\n");
((parser_control *)parm)->seconds = (yyvsp + -1)->timespec;
      printf("\nSTMT_EXEC;;34553\n");
((parser_control *)parm)->meridian = 2;
      printf("\nSTMT_EXEC;;34554\n");
(((parser_control *)parm)->zones_seen)++;
      printf("\nSTMT_EXEC;;34555\n");
((parser_control *)parm)->time_zone = (yyvsp + 0)->textintval.value % 100L + ((yyvsp + 0)->textintval.value / 100L) * 60L;
      printf("\nSTMT_EXEC;;34556\n");
goto switch_break;
    case_18: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34558\n");
((parser_control *)parm)->local_isdst = (int)(yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34559\n");
goto switch_break;
    case_19: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34561\n");
if ((yyvsp + -1)->intval < 0L)
      {
        printf("\nSTMT_EXEC;;34563\n");
tmp___2 = 1L;
      }
      else
      {
        printf("\nSTMT_EXEC;;34567\n");
tmp___2 = (yyvsp + -1)->intval + 1L;
      }
}

      printf("\nSTMT_EXEC;;34569\n");
((parser_control *)parm)->local_isdst = (int)tmp___2;
      printf("\nSTMT_EXEC;;34570\n");
goto switch_break;
    case_20: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34572\n");
((parser_control *)parm)->time_zone = (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34573\n");
goto switch_break;
    case_21: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34575\n");
((parser_control *)parm)->time_zone = (yyvsp + 0)->intval + 60L;
}

      printf("\nSTMT_EXEC;;34576\n");
goto switch_break;
    case_22: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34578\n");
((parser_control *)parm)->time_zone = (yyvsp + -1)->intval + 60L;
}

      printf("\nSTMT_EXEC;;34579\n");
goto switch_break;
    case_23: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34581\n");
((parser_control *)parm)->day_ordinal = 1L;
}

      printf("\nSTMT_EXEC;;34582\n");
((parser_control *)parm)->day_number = (int)(yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34583\n");
goto switch_break;
    case_24: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34585\n");
((parser_control *)parm)->day_ordinal = 1L;
}

      printf("\nSTMT_EXEC;;34586\n");
((parser_control *)parm)->day_number = (int)(yyvsp + -1)->intval;
      printf("\nSTMT_EXEC;;34587\n");
goto switch_break;
    case_25: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34589\n");
((parser_control *)parm)->day_ordinal = (yyvsp + -1)->textintval.value;
}

      printf("\nSTMT_EXEC;;34590\n");
((parser_control *)parm)->day_number = (int)(yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34591\n");
goto switch_break;
    case_26: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34593\n");
((parser_control *)parm)->month = (yyvsp + -2)->textintval.value;
}

      printf("\nSTMT_EXEC;;34594\n");
((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
      printf("\nSTMT_EXEC;;34595\n");
goto switch_break;
    case_27: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34597\n");
if (4UL <= (yyvsp + -4)->textintval.digits)
      {
        printf("\nSTMT_EXEC;;34599\n");
((parser_control *)parm)->year = (yyvsp + -4)->textintval;
        printf("\nSTMT_EXEC;;34600\n");
((parser_control *)parm)->month = (yyvsp + -2)->textintval.value;
        printf("\nSTMT_EXEC;;34601\n");
((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
      }
      else
      {
        printf("\nSTMT_EXEC;;34605\n");
((parser_control *)parm)->month = (yyvsp + -4)->textintval.value;
        printf("\nSTMT_EXEC;;34606\n");
((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
        printf("\nSTMT_EXEC;;34607\n");
((parser_control *)parm)->year = (yyvsp + 0)->textintval;
      }
}

      printf("\nSTMT_EXEC;;34609\n");
goto switch_break;
    case_28: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34611\n");
((parser_control *)parm)->year = (yyvsp + -2)->textintval;
}

      printf("\nSTMT_EXEC;;34612\n");
((parser_control *)parm)->month = -(yyvsp + -1)->textintval.value;
      printf("\nSTMT_EXEC;;34613\n");
((parser_control *)parm)->day = -(yyvsp + 0)->textintval.value;
      printf("\nSTMT_EXEC;;34614\n");
goto switch_break;
    case_29: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34616\n");
((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
}

      printf("\nSTMT_EXEC;;34617\n");
((parser_control *)parm)->month = (yyvsp + -1)->intval;
      printf("\nSTMT_EXEC;;34618\n");
((parser_control *)parm)->year.value = -(yyvsp + 0)->textintval.value;
      printf("\nSTMT_EXEC;;34619\n");
((parser_control *)parm)->year.digits = (yyvsp + 0)->textintval.digits;
      printf("\nSTMT_EXEC;;34620\n");
goto switch_break;
    case_30: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34622\n");
((parser_control *)parm)->month = (yyvsp + -2)->intval;
}

      printf("\nSTMT_EXEC;;34623\n");
((parser_control *)parm)->day = -(yyvsp + -1)->textintval.value;
      printf("\nSTMT_EXEC;;34624\n");
((parser_control *)parm)->year.value = -(yyvsp + 0)->textintval.value;
      printf("\nSTMT_EXEC;;34625\n");
((parser_control *)parm)->year.digits = (yyvsp + 0)->textintval.digits;
      printf("\nSTMT_EXEC;;34626\n");
goto switch_break;
    case_31: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34628\n");
((parser_control *)parm)->month = (yyvsp + -1)->intval;
}

      printf("\nSTMT_EXEC;;34629\n");
((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
      printf("\nSTMT_EXEC;;34630\n");
goto switch_break;
    case_32: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34632\n");
((parser_control *)parm)->month = (yyvsp + -3)->intval;
}

      printf("\nSTMT_EXEC;;34633\n");
((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
      printf("\nSTMT_EXEC;;34634\n");
((parser_control *)parm)->year = (yyvsp + 0)->textintval;
      printf("\nSTMT_EXEC;;34635\n");
goto switch_break;
    case_33: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34637\n");
((parser_control *)parm)->day = (yyvsp + -1)->textintval.value;
}

      printf("\nSTMT_EXEC;;34638\n");
((parser_control *)parm)->month = (yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34639\n");
goto switch_break;
    case_34: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34641\n");
((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
}

      printf("\nSTMT_EXEC;;34642\n");
((parser_control *)parm)->month = (yyvsp + -1)->intval;
      printf("\nSTMT_EXEC;;34643\n");
((parser_control *)parm)->year = (yyvsp + 0)->textintval;
      printf("\nSTMT_EXEC;;34644\n");
goto switch_break;
    case_35: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34646\n");
((parser_control *)parm)->rel_ns = -((parser_control *)parm)->rel_ns;
}

      printf("\nSTMT_EXEC;;34647\n");
((parser_control *)parm)->rel_seconds = -((parser_control *)parm)->rel_seconds;
      printf("\nSTMT_EXEC;;34648\n");
((parser_control *)parm)->rel_minutes = -((parser_control *)parm)->rel_minutes;
      printf("\nSTMT_EXEC;;34649\n");
((parser_control *)parm)->rel_hour = -((parser_control *)parm)->rel_hour;
      printf("\nSTMT_EXEC;;34650\n");
((parser_control *)parm)->rel_day = -((parser_control *)parm)->rel_day;
      printf("\nSTMT_EXEC;;34651\n");
((parser_control *)parm)->rel_month = -((parser_control *)parm)->rel_month;
      printf("\nSTMT_EXEC;;34652\n");
((parser_control *)parm)->rel_year = -((parser_control *)parm)->rel_year;
      printf("\nSTMT_EXEC;;34653\n");
goto switch_break;
    case_37: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34655\n");
((parser_control *)parm)->rel_year += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34656\n");
goto switch_break;
    case_38: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34658\n");
((parser_control *)parm)->rel_year += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34659\n");
goto switch_break;
    case_39: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34661\n");
((parser_control *)parm)->rel_year += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34662\n");
goto switch_break;
    case_40: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34664\n");
((parser_control *)parm)->rel_month += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34665\n");
goto switch_break;
    case_41: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34667\n");
((parser_control *)parm)->rel_month += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34668\n");
goto switch_break;
    case_42: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34670\n");
((parser_control *)parm)->rel_month += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34671\n");
goto switch_break;
    case_43: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34673\n");
((parser_control *)parm)->rel_day += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34674\n");
goto switch_break;
    case_44: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34676\n");
((parser_control *)parm)->rel_day += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34677\n");
goto switch_break;
    case_45: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34679\n");
((parser_control *)parm)->rel_day += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34680\n");
goto switch_break;
    case_46: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34682\n");
((parser_control *)parm)->rel_hour += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34683\n");
goto switch_break;
    case_47: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34685\n");
((parser_control *)parm)->rel_hour += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34686\n");
goto switch_break;
    case_48: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34688\n");
((parser_control *)parm)->rel_hour += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34689\n");
goto switch_break;
    case_49: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34691\n");
((parser_control *)parm)->rel_minutes += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34692\n");
goto switch_break;
    case_50: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34694\n");
((parser_control *)parm)->rel_minutes += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34695\n");
goto switch_break;
    case_51: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34697\n");
((parser_control *)parm)->rel_minutes += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34698\n");
goto switch_break;
    case_52: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34700\n");
((parser_control *)parm)->rel_seconds += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34701\n");
goto switch_break;
    case_53: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34703\n");
((parser_control *)parm)->rel_seconds += (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34704\n");
goto switch_break;
    case_54: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34706\n");
((parser_control *)parm)->rel_seconds += (yyvsp + -1)->timespec.tv_sec * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34707\n");
((parser_control *)parm)->rel_ns += (yyvsp + -1)->timespec.tv_nsec * (yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34708\n");
goto switch_break;
    case_55: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34710\n");
((parser_control *)parm)->rel_seconds += (yyvsp + -1)->timespec.tv_sec * (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34711\n");
((parser_control *)parm)->rel_ns += (yyvsp + -1)->timespec.tv_nsec * (yyvsp + 0)->intval;
      printf("\nSTMT_EXEC;;34712\n");
goto switch_break;
    case_56: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34714\n");
((parser_control *)parm)->rel_seconds += (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34715\n");
goto switch_break;
    case_60: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34717\n");
yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
}

      printf("\nSTMT_EXEC;;34718\n");
yyval.timespec.tv_nsec = (__syscall_slong_t)0;
      printf("\nSTMT_EXEC;;34719\n");
goto switch_break;
    case_62: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34721\n");
yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
}

      printf("\nSTMT_EXEC;;34722\n");
yyval.timespec.tv_nsec = (__syscall_slong_t)0;
      printf("\nSTMT_EXEC;;34723\n");
goto switch_break;
    case_63: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34725\n");
if (((parser_control *)parm)->dates_seen)
      {
        printf("\nSTMT_EXEC;;34727\n");
if (!((parser_control *)parm)->rels_seen)
        {
          printf("\nSTMT_EXEC;;34729\n");
if (((parser_control *)parm)->times_seen)
          {
            printf("\nSTMT_EXEC;;34731\n");
((parser_control *)parm)->year = (yyvsp + 0)->textintval;
          }
          else
          {
            printf("\nSTMT_EXEC;;34735\n");
if (2UL < (yyvsp + 0)->textintval.digits)
            {
              printf("\nSTMT_EXEC;;34737\n");
((parser_control *)parm)->year = (yyvsp + 0)->textintval;
            }
            else
            {
              printf("\nSTMT_EXEC;;34741\n");
goto _L___4;
            }
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;34747\n");
goto _L___4;
        }
      }
      else
      {
      _L___4: /* CIL Label */
        {
printf("\nSTMT_EXEC;;34753\n");
if (4UL < (yyvsp + 0)->textintval.digits)
        {
          printf("\nSTMT_EXEC;;34755\n");
(((parser_control *)parm)->dates_seen)++;
          printf("\nSTMT_EXEC;;34756\n");
((parser_control *)parm)->day = (yyvsp + 0)->textintval.value % 100L;
          printf("\nSTMT_EXEC;;34757\n");
((parser_control *)parm)->month = ((yyvsp + 0)->textintval.value / 100L) % 100L;
          printf("\nSTMT_EXEC;;34758\n");
((parser_control *)parm)->year.value = (yyvsp + 0)->textintval.value / 10000L;
          printf("\nSTMT_EXEC;;34759\n");
((parser_control *)parm)->year.digits = (yyvsp + 0)->textintval.digits - 4UL;
        }
        else
        {
          printf("\nSTMT_EXEC;;34763\n");
(((parser_control *)parm)->times_seen)++;
          printf("\nSTMT_EXEC;;34764\n");
if ((yyvsp + 0)->textintval.digits <= 2UL)
          {
            printf("\nSTMT_EXEC;;34766\n");
((parser_control *)parm)->hour = (yyvsp + 0)->textintval.value;
            printf("\nSTMT_EXEC;;34767\n");
((parser_control *)parm)->minutes = 0L;
          }
          else
          {
            printf("\nSTMT_EXEC;;34771\n");
((parser_control *)parm)->hour = (yyvsp + 0)->textintval.value / 100L;
            printf("\nSTMT_EXEC;;34772\n");
((parser_control *)parm)->minutes = (yyvsp + 0)->textintval.value % 100L;
          }
          printf("\nSTMT_EXEC;;34774\n");
((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
          printf("\nSTMT_EXEC;;34775\n");
((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
          printf("\nSTMT_EXEC;;34776\n");
((parser_control *)parm)->meridian = 2;
        }
}

      }
}

      printf("\nSTMT_EXEC;;34779\n");
goto switch_break;
    case_64: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34781\n");
yyval.intval = 2L;
}

      printf("\nSTMT_EXEC;;34782\n");
goto switch_break;
    case_65: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34784\n");
yyval.intval = (yyvsp + 0)->intval;
}

      printf("\nSTMT_EXEC;;34785\n");
goto switch_break;
    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;34788\n");
yyvsp -= yylen;
    printf("\nSTMT_EXEC;;34789\n");
yyssp -= yylen;
    printf("\nSTMT_EXEC;;34790\n");
yyvsp++;
    printf("\nSTMT_EXEC;;34791\n");
*yyvsp = yyval;
    printf("\nSTMT_EXEC;;34792\n");
yyn = (int)yyr1[yyn];
    printf("\nSTMT_EXEC;;34793\n");
yystate = (int)((int const)yypgoto[yyn - 25] + (int const) * yyssp);
    printf("\nSTMT_EXEC;;34794\n");
if (yystate >= 0)
    {
      printf("\nSTMT_EXEC;;34796\n");
if (yystate <= 70)
      {
        printf("\nSTMT_EXEC;;34798\n");
if ((int const)yycheck[yystate] == (int const) * yyssp)
        {
          printf("\nSTMT_EXEC;;34800\n");
yystate = (int)yytable[yystate];
        }
        else
        {
          printf("\nSTMT_EXEC;;34804\n");
yystate = (int)yydefgoto[yyn - 25];
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;34809\n");
yystate = (int)yydefgoto[yyn - 25];
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;34814\n");
yystate = (int)yydefgoto[yyn - 25];
    }
    printf("\nSTMT_EXEC;;34816\n");
goto yynewstate;
  yyerrlab:
    {
printf("\nSTMT_EXEC;;34818\n");
if (!yyerrstatus)
    {
      {
        printf("\nSTMT_EXEC;;34821\n");
yynerrs++;
        printf("\nSTMT_EXEC;;34822\n");
yyerror((char *)"parse error");
      }
    }
}

    printf("\nSTMT_EXEC;;34825\n");
goto yyerrlab1;
  yyerrlab1:
    {
printf("\nSTMT_EXEC;;34827\n");
if (yyerrstatus == 3)
    {
      printf("\nSTMT_EXEC;;34829\n");
if (yychar == 0)
      {
        printf("\nSTMT_EXEC;;34831\n");
goto yyabortlab;
      }
      printf("\nSTMT_EXEC;;34833\n");
yychar = -2;
    }
}

    printf("\nSTMT_EXEC;;34835\n");
yyerrstatus = 3;
    printf("\nSTMT_EXEC;;34836\n");
goto yyerrhandle;
  yyerrdefault:
    {
printf("\nSTMT_EXEC;;34838\n");
if ((unsigned long)yyssp == (unsigned long)yyss)
    {
      printf("\nSTMT_EXEC;;34840\n");
goto yyabortlab;
    }
}

    printf("\nSTMT_EXEC;;34842\n");
yyvsp--;
    printf("\nSTMT_EXEC;;34843\n");
yyssp--;
    printf("\nSTMT_EXEC;;34844\n");
yystate = (int)*yyssp;
  yyerrhandle:
    {
printf("\nSTMT_EXEC;;34846\n");
yyn = (int)yypact[yystate];
}

    printf("\nSTMT_EXEC;;34847\n");
if (yyn == -32768)
    {
      printf("\nSTMT_EXEC;;34849\n");
goto yyerrdefault;
    }
    printf("\nSTMT_EXEC;;34851\n");
yyn++;
    printf("\nSTMT_EXEC;;34852\n");
if (yyn < 0)
    {
      printf("\nSTMT_EXEC;;34854\n");
goto yyerrdefault;
    }
    else
    {
      printf("\nSTMT_EXEC;;34858\n");
if (yyn > 70)
      {
        printf("\nSTMT_EXEC;;34860\n");
goto yyerrdefault;
      }
      else
      {
        printf("\nSTMT_EXEC;;34864\n");
if ((int const)yycheck[yyn] != 1)
        {
          printf("\nSTMT_EXEC;;34866\n");
goto yyerrdefault;
        }
      }
    }
    printf("\nSTMT_EXEC;;34870\n");
yyn = (int)yytable[yyn];
    printf("\nSTMT_EXEC;;34871\n");
if (yyn < 0)
    {
      printf("\nSTMT_EXEC;;34873\n");
if (yyn == -32768)
      {
        printf("\nSTMT_EXEC;;34875\n");
goto yyerrdefault;
      }
      printf("\nSTMT_EXEC;;34877\n");
yyn = -yyn;
      printf("\nSTMT_EXEC;;34878\n");
goto yyreduce;
    }
    else
    {
      printf("\nSTMT_EXEC;;34882\n");
if (yyn == 0)
      {
        printf("\nSTMT_EXEC;;34884\n");
goto yyerrdefault;
      }
    }
    printf("\nSTMT_EXEC;;34887\n");
if (yyn == 80)
    {
      printf("\nSTMT_EXEC;;34889\n");
goto yyacceptlab;
    }
    printf("\nSTMT_EXEC;;34891\n");
yyvsp++;
    printf("\nSTMT_EXEC;;34892\n");
*yyvsp = yylval;
    printf("\nSTMT_EXEC;;34893\n");
yystate = yyn;
    printf("\nSTMT_EXEC;;34894\n");
goto yynewstate;
  yyacceptlab:
    {
printf("\nSTMT_EXEC;;34896\n");
if (yyfree_stacks)
    {
      {
        printf("\nSTMT_EXEC;;34899\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyss);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34900\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyvs);printf("\nFUNC_RETURN;;\n");

      }
    }
}

    printf("\nSTMT_EXEC;;34903\n");
printf("\nFUNC_RETURN;;\n");
return (0);
  yyabortlab:
    {
printf("\nSTMT_EXEC;;34905\n");
if (yyfree_stacks)
    {
      {
        printf("\nSTMT_EXEC;;34908\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyss);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;34909\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)yyvs);printf("\nFUNC_RETURN;;\n");

      }
    }
}

    printf("\nSTMT_EXEC;;34912\n");
printf("\nFUNC_RETURN;;\n");
return (1);
  }
printf("\nFUNC_RETURN;;\n");
}
static table const meridian_table[5] = {{"AM", 264, 0}, {"A.M.", 264, 0}, {"PM", 264, 1}, {"P.M.", 264, 1}, {(char const *)0, 0, 0}};
static table const dst_table[1] = {{"DST", 258, 0}};
static table const month_and_day_table[25] = {{"JANUARY", 266, 1}, {"FEBRUARY", 266, 2}, {"MARCH", 266, 3}, {"APRIL", 266, 4}, {"MAY", 266, 5}, {"JUNE", 266, 6}, {"JULY", 266, 7}, {"AUGUST", 266, 8}, {"SEPTEMBER", 266, 9}, {"SEPT", 266, 9}, {"OCTOBER", 266, 10}, {"NOVEMBER", 266, 11}, {"DECEMBER", 266, 12}, {"SUNDAY", 259, 0}, {"MONDAY", 259, 1}, {"TUESDAY", 259, 2}, {"TUES", 259, 2}, {"WEDNESDAY", 259, 3}, {"WEDNES", 259, 3}, {"THURSDAY", 259, 4}, {"THUR", 259, 4}, {"THURS", 259, 4}, {"FRIDAY", 259, 5}, {"SATURDAY", 259, 6}, {(char const *)0, 0, 0}};
static table const time_units_table[11] = {{"YEAR", 269, 1}, {"MONTH", 267, 1}, {"FORTNIGHT", 260, 14}, {"WEEK", 260, 7}, {"DAY", 260, 1}, {"HOUR", 262, 1}, {"MINUTE", 265, 1}, {"MIN", 265, 1}, {"SECOND", 268, 1}, {"SEC", 268, 1}, {(char const *)0, 0, 0}};
static table const relative_time_table[20] = {{"TOMORROW", 260, 1}, {"YESTERDAY", 260, -1}, {"TODAY", 260, 0}, {"NOW", 260, 0}, {"LAST", 272, -1}, {"THIS", 272, 0}, {"NEXT", 272, 1}, {"FIRST", 272, 1}, {"THIRD", 272, 3}, {"FOURTH", 272, 4}, {"FIFTH", 272, 5}, {"SIXTH", 272, 6}, {"SEVENTH", 272, 7}, {"EIGHTH", 272, 8}, {"NINTH", 272, 9}, {"TENTH", 272, 10}, {"ELEVENTH", 272, 11}, {"TWELFTH", 272, 12}, {"AGO", 257, 1}, {(char const *)0, 0, 0}};
static table const time_zone_table[51] = {{"GMT", 270, 0}, {"UT", 270, 0}, {"UTC", 270, 0}, {"WET", 270, 0}, {"WEST", 261, 0}, {"BST", 261, 0}, {"ART", 270, -180}, {"BRT", 270, -180}, {"BRST", 261, -180}, {"NST", 270, -210}, {"NDT", 261, -210}, {"AST", 270, -240}, {"ADT", 261, -240}, {"CLT", 270, -240}, {"CLST", 261, -240}, {"EST", 270, -300}, {"EDT", 261, -300}, {"CST", 270, -360}, {"CDT", 261, -360}, {"MST", 270, -420}, {"MDT", 261, -420}, {"PST", 270, -480}, {"PDT", 261, -480}, {"AKST", 270, -540}, {"AKDT", 261, -540}, {"HST", 270, -600}, {"HAST", 270, -600}, {"HADT", 261, -600}, {"SST", 270, -720}, {"WAT", 270, 60}, {"CET", 270, 60}, {"CEST", 261, 60}, {"MET", 270, 60}, {"MEZ", 270, 60}, {"MEST", 261, 60}, {"MESZ", 261, 60}, {"EET", 270, 120}, {"EEST", 261, 120}, {"CAT", 270, 120}, {"SAST", 270, 120}, {"EAT", 270, 180}, {"MSK", 270, 180}, {"MSD", 261, 180}, {"IST", 270, 330}, {"SGT", 270, 480}, {"KST", 270, 540}, {"JST", 270, 540}, {"GST", 270, 600}, {"NZST", 270, 720}, {"NZDT", 261, 720}, {(char const *)0, 0, 0}};
static table const military_table[26] = {{"A", 270, -60}, {"B", 270, -120}, {"C", 270, -180}, {"D", 270, -240}, {"E", 270, -300}, {"F", 270, -360}, {"G", 270, -420}, {"H", 270, -480}, {"I", 270, -540}, {"K", 270, -600}, {"L", 270, -660}, {"M", 270, -720}, {"N", 270, 60}, {"O", 270, 120}, {"P", 270, 180}, {"Q", 270, 240}, {"R", 270, 300}, {"S", 270, 360}, {"T", 270, 420}, {"U", 270, 480}, {"V", 270, 540}, {"W", 270, 600}, {"X", 270, 660}, {"Y", 270, 720}, {"Z", 270, 0}, {(char const *)0, 0, 0}};
static int to_hour(long hours, int meridian)
{
  printf("\nFUNC_CALL;to_hour(long,int);\n");
printf("\nSTMT_EXEC;;34924\n");
long tmp;
  printf("\nSTMT_EXEC;;34925\n");
int tmp___0;
  printf("\nSTMT_EXEC;;34926\n");
long tmp___1;
  printf("\nSTMT_EXEC;;34927\n");
int tmp___2;
  printf("\nSTMT_EXEC;;34928\n");
long tmp___3;

  {
    {
      printf("\nSTMT_EXEC;;34932\n");
if (meridian == 2)
      {
        printf("\nSTMT_EXEC;;34934\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;34936\n");
if (meridian == 0)
      {
        printf("\nSTMT_EXEC;;34938\n");
goto case_0;
      }
      printf("\nSTMT_EXEC;;34940\n");
if (meridian == 1)
      {
        printf("\nSTMT_EXEC;;34942\n");
goto case_1;
      }
      printf("\nSTMT_EXEC;;34944\n");
goto switch_default;
    case_2: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34946\n");
if (0L <= hours)
      {
        printf("\nSTMT_EXEC;;34948\n");
if (hours < 24L)
        {
          printf("\nSTMT_EXEC;;34950\n");
tmp = hours;
        }
        else
        {
          printf("\nSTMT_EXEC;;34954\n");
tmp = -1L;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;34959\n");
tmp = -1L;
      }
}

      printf("\nSTMT_EXEC;;34961\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp);
    case_0: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34963\n");
if (0L < hours)
      {
        printf("\nSTMT_EXEC;;34965\n");
if (hours < 12L)
        {
          printf("\nSTMT_EXEC;;34967\n");
tmp___1 = hours;
        }
        else
        {
          printf("\nSTMT_EXEC;;34971\n");
goto _L___3;
        }
      }
      else
      {
      _L___3: /* CIL Label */
        {
printf("\nSTMT_EXEC;;34977\n");
if (hours == 12L)
        {
          printf("\nSTMT_EXEC;;34979\n");
tmp___0 = 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;34983\n");
tmp___0 = -1;
        }
}

        printf("\nSTMT_EXEC;;34985\n");
tmp___1 = (long)tmp___0;
      }
}

      printf("\nSTMT_EXEC;;34987\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp___1);
    case_1: /* CIL Label */
      {
printf("\nSTMT_EXEC;;34989\n");
if (0L < hours)
      {
        printf("\nSTMT_EXEC;;34991\n");
if (hours < 12L)
        {
          printf("\nSTMT_EXEC;;34993\n");
tmp___3 = hours + 12L;
        }
        else
        {
          printf("\nSTMT_EXEC;;34997\n");
goto _L___4;
        }
      }
      else
      {
      _L___4: /* CIL Label */
        {
printf("\nSTMT_EXEC;;35003\n");
if (hours == 12L)
        {
          printf("\nSTMT_EXEC;;35005\n");
tmp___2 = 12;
        }
        else
        {
          printf("\nSTMT_EXEC;;35009\n");
tmp___2 = -1;
        }
}

        printf("\nSTMT_EXEC;;35011\n");
tmp___3 = (long)tmp___2;
      }
}

      printf("\nSTMT_EXEC;;35013\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tmp___3);
    switch_default: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;35016\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }
    switch_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static long to_year(textint textyear)
{
  printf("\nFUNC_CALL;to_year(textint);\n");
printf("\nSTMT_EXEC;;35024\n");
long year;
  printf("\nSTMT_EXEC;;35025\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;35028\n");
year = textyear.value;
    printf("\nSTMT_EXEC;;35029\n");
if (year < 0L)
    {
      printf("\nSTMT_EXEC;;35031\n");
year = -year;
    }
    else
    {
      printf("\nSTMT_EXEC;;35035\n");
if (textyear.digits == 2UL)
      {
        printf("\nSTMT_EXEC;;35037\n");
if (year < 69L)
        {
          printf("\nSTMT_EXEC;;35039\n");
tmp = 2000;
        }
        else
        {
          printf("\nSTMT_EXEC;;35043\n");
tmp = 1900;
        }
        printf("\nSTMT_EXEC;;35045\n");
year += (long)tmp;
      }
    }
    printf("\nSTMT_EXEC;;35048\n");
printf("\nFUNC_RETURN;;\n");
return (year);
  }
printf("\nFUNC_RETURN;;\n");
}
static table const *lookup_zone(parser_control const *pc, char const *name)
{
  printf("\nFUNC_CALL;lookup_zone(const parser_control *,const char *);\n");
printf("\nSTMT_EXEC;;35053\n");
table const *tp;
  printf("\nSTMT_EXEC;;35054\n");
int tmp;
  printf("\nSTMT_EXEC;;35055\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;35058\n");
tp = (table const *)(pc->local_time_zone_table);
    {
      printf("\nSTMT_EXEC;;35060\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;35063\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35065\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;35068\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp = strcmp(name, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35070\n");
if (tmp == 0)
        {
          printf("\nSTMT_EXEC;;35072\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35074\n");
tp++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35078\n");
tp = time_zone_table;
    {
      printf("\nSTMT_EXEC;;35080\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;35083\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35085\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;35088\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___0 = strcmp(name, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35090\n");
if (tmp___0 == 0)
        {
          printf("\nSTMT_EXEC;;35092\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35094\n");
tp++;
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35098\n");
printf("\nFUNC_RETURN;;\n");
return ((table const *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static table const *lookup_word(parser_control const *pc, char *word)
{
  printf("\nFUNC_CALL;lookup_word(const parser_control *,char *);\n");
printf("\nSTMT_EXEC;;35103\n");
char *p;
  printf("\nSTMT_EXEC;;35104\n");
char *q;
  printf("\nSTMT_EXEC;;35105\n");
size_t wordlen;
  printf("\nSTMT_EXEC;;35106\n");
table const *tp;
  printf("\nSTMT_EXEC;;35107\n");
_Bool period_found;
  printf("\nSTMT_EXEC;;35108\n");
_Bool abbrev;
  printf("\nSTMT_EXEC;;35109\n");
int tmp;
  printf("\nSTMT_EXEC;;35110\n");
unsigned short const **tmp___0;
  printf("\nSTMT_EXEC;;35111\n");
int tmp___1;
  printf("\nSTMT_EXEC;;35112\n");
int tmp___2;
  printf("\nSTMT_EXEC;;35113\n");
int tmp___3;
  printf("\nSTMT_EXEC;;35114\n");
int tmp___4;
  printf("\nSTMT_EXEC;;35115\n");
int tmp___5;
  printf("\nSTMT_EXEC;;35116\n");
int tmp___6;
  printf("\nSTMT_EXEC;;35117\n");
int tmp___7;
  printf("\nSTMT_EXEC;;35118\n");
int tmp___8;
  printf("\nSTMT_EXEC;;35119\n");
char tmp___9;
  printf("\nSTMT_EXEC;;35120\n");
int tmp___10;

  {
    printf("\nSTMT_EXEC;;35123\n");
p = word;
    {
      printf("\nSTMT_EXEC;;35125\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;35128\n");
if (!*p)
        {
          printf("\nSTMT_EXEC;;35130\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;35133\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___0 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35135\n");
if ((int const) * (*tmp___0 + (int)((unsigned char)*p)) & 512)
        {
          {
            printf("\nSTMT_EXEC;;35138\n");
printf("\nFUNC_CALL;toupper(int);\n");
tmp = toupper((int)((unsigned char)*p));printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;35139\n");
*p = (char)tmp;
          }
        }
        printf("\nSTMT_EXEC;;35142\n");
p++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35146\n");
tp = meridian_table;
    {
      printf("\nSTMT_EXEC;;35148\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;35151\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35153\n");
goto while_break___0;
        }
        {
          printf("\nSTMT_EXEC;;35156\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___1 = strcmp((char const *)word, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35158\n");
if (tmp___1 == 0)
        {
          printf("\nSTMT_EXEC;;35160\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35162\n");
tp++;
      }
    while_break___0: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;35167\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
wordlen = strlen((char const *)word);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;35169\n");
if (wordlen == 3UL)
    {
      printf("\nSTMT_EXEC;;35171\n");
tmp___10 = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;35175\n");
if (wordlen == 4UL)
      {
        printf("\nSTMT_EXEC;;35177\n");
if ((int)*(word + 3) == 46)
        {
          printf("\nSTMT_EXEC;;35179\n");
tmp___10 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;35183\n");
tmp___10 = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;35188\n");
tmp___10 = 0;
      }
    }
    printf("\nSTMT_EXEC;;35191\n");
abbrev = (_Bool)tmp___10;
    printf("\nSTMT_EXEC;;35192\n");
tp = month_and_day_table;
    {
      printf("\nSTMT_EXEC;;35194\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        printf("\nSTMT_EXEC;;35197\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35199\n");
goto while_break___1;
        }
        printf("\nSTMT_EXEC;;35201\n");
if (abbrev)
        {
          {
            printf("\nSTMT_EXEC;;35204\n");
printf("\nFUNC_CALL;strncmp(const char *,const char *,size_t);\n");
tmp___2 = strncmp((char const *)word, (char const *)tp->name, (size_t)3);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;35205\n");
tmp___4 = tmp___2;
          }
        }
        else
        {
          {
            printf("\nSTMT_EXEC;;35211\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___3 = strcmp((char const *)word, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;35212\n");
tmp___4 = tmp___3;
          }
        }
        printf("\nSTMT_EXEC;;35215\n");
if (tmp___4 == 0)
        {
          printf("\nSTMT_EXEC;;35217\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35219\n");
tp++;
      }
    while_break___1: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;35224\n");
tp = lookup_zone(pc, (char const *)word);
    }
    printf("\nSTMT_EXEC;;35226\n");
if (tp)
    {
      printf("\nSTMT_EXEC;;35228\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
    }
    {
      printf("\nSTMT_EXEC;;35231\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___5 = strcmp((char const *)word, (char const *)dst_table[0].name);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;35233\n");
if (tmp___5 == 0)
    {
      printf("\nSTMT_EXEC;;35235\n");
printf("\nFUNC_RETURN;;\n");
return (dst_table);
    }
    printf("\nSTMT_EXEC;;35237\n");
tp = time_units_table;
    {
      printf("\nSTMT_EXEC;;35239\n");
while (1)
      {
      while_continue___2: /* CIL Label */;
        printf("\nSTMT_EXEC;;35242\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35244\n");
goto while_break___2;
        }
        {
          printf("\nSTMT_EXEC;;35247\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___6 = strcmp((char const *)word, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35249\n");
if (tmp___6 == 0)
        {
          printf("\nSTMT_EXEC;;35251\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35253\n");
tp++;
      }
    while_break___2: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35257\n");
if ((int)*(word + (wordlen - 1UL)) == 83)
    {
      printf("\nSTMT_EXEC;;35259\n");
*(word + (wordlen - 1UL)) = (char)'\000';
      printf("\nSTMT_EXEC;;35260\n");
tp = time_units_table;
      {
        printf("\nSTMT_EXEC;;35262\n");
while (1)
        {
        while_continue___3: /* CIL Label */;
          printf("\nSTMT_EXEC;;35265\n");
if (!tp->name)
          {
            printf("\nSTMT_EXEC;;35267\n");
goto while_break___3;
          }
          {
            printf("\nSTMT_EXEC;;35270\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___7 = strcmp((char const *)word, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;35272\n");
if (tmp___7 == 0)
          {
            printf("\nSTMT_EXEC;;35274\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
          }
          printf("\nSTMT_EXEC;;35276\n");
tp++;
        }
      while_break___3: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;35280\n");
*(word + (wordlen - 1UL)) = (char)'S';
    }
    printf("\nSTMT_EXEC;;35282\n");
tp = relative_time_table;
    {
      printf("\nSTMT_EXEC;;35284\n");
while (1)
      {
      while_continue___4: /* CIL Label */;
        printf("\nSTMT_EXEC;;35287\n");
if (!tp->name)
        {
          printf("\nSTMT_EXEC;;35289\n");
goto while_break___4;
        }
        {
          printf("\nSTMT_EXEC;;35292\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___8 = strcmp((char const *)word, (char const *)tp->name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35294\n");
if (tmp___8 == 0)
        {
          printf("\nSTMT_EXEC;;35296\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
        }
        printf("\nSTMT_EXEC;;35298\n");
tp++;
      }
    while_break___4: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35302\n");
if (wordlen == 1UL)
    {
      printf("\nSTMT_EXEC;;35304\n");
tp = military_table;
      {
        printf("\nSTMT_EXEC;;35306\n");
while (1)
        {
        while_continue___5: /* CIL Label */;
          printf("\nSTMT_EXEC;;35309\n");
if (!tp->name)
          {
            printf("\nSTMT_EXEC;;35311\n");
goto while_break___5;
          }
          printf("\nSTMT_EXEC;;35313\n");
if ((int)*(word + 0) == (int)*(tp->name + 0))
          {
            printf("\nSTMT_EXEC;;35315\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
          }
          printf("\nSTMT_EXEC;;35317\n");
tp++;
        }
      while_break___5: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;35322\n");
period_found = (_Bool)0;
    printf("\nSTMT_EXEC;;35323\n");
q = word;
    printf("\nSTMT_EXEC;;35324\n");
p = q;
    {
      printf("\nSTMT_EXEC;;35326\n");
while (1)
      {
      while_continue___6: /* CIL Label */;
        printf("\nSTMT_EXEC;;35329\n");
tmp___9 = *q;
        printf("\nSTMT_EXEC;;35330\n");
*p = tmp___9;
        printf("\nSTMT_EXEC;;35331\n");
if (!tmp___9)
        {
          printf("\nSTMT_EXEC;;35333\n");
goto while_break___6;
        }
        printf("\nSTMT_EXEC;;35335\n");
if ((int)*q == 46)
        {
          printf("\nSTMT_EXEC;;35337\n");
period_found = (_Bool)1;
        }
        else
        {
          printf("\nSTMT_EXEC;;35341\n");
p++;
        }
        printf("\nSTMT_EXEC;;35343\n");
q++;
      }
    while_break___6: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35347\n");
if (period_found)
    {
      {
        printf("\nSTMT_EXEC;;35350\n");
tp = lookup_zone(pc, (char const *)word);
      }
      printf("\nSTMT_EXEC;;35352\n");
if (tp)
      {
        printf("\nSTMT_EXEC;;35354\n");
printf("\nFUNC_RETURN;;\n");
return (tp);
      }
    }
    printf("\nSTMT_EXEC;;35357\n");
printf("\nFUNC_RETURN;;\n");
return ((table const *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static int yylex(YYSTYPE *lvalp, parser_control *pc)
{
  printf("\nFUNC_CALL;yylex(YYSTYPE *,parser_control *);\n");
printf("\nSTMT_EXEC;;35362\n");
unsigned char c;
  printf("\nSTMT_EXEC;;35363\n");
size_t count;
  printf("\nSTMT_EXEC;;35364\n");
unsigned short const **tmp;
  printf("\nSTMT_EXEC;;35365\n");
char const *p;
  printf("\nSTMT_EXEC;;35366\n");
int sign;
  printf("\nSTMT_EXEC;;35367\n");
unsigned long value;
  printf("\nSTMT_EXEC;;35368\n");
unsigned long value1;
  printf("\nSTMT_EXEC;;35369\n");
time_t s;
  printf("\nSTMT_EXEC;;35370\n");
int ns;
  printf("\nSTMT_EXEC;;35371\n");
int digits;
  printf("\nSTMT_EXEC;;35372\n");
unsigned long value1___0;
  printf("\nSTMT_EXEC;;35373\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;35374\n");
char const *tmp___1;
  printf("\nSTMT_EXEC;;35375\n");
char buff[20];
  printf("\nSTMT_EXEC;;35376\n");
char *p___0;
  printf("\nSTMT_EXEC;;35377\n");
table const *tp;
  printf("\nSTMT_EXEC;;35378\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;35379\n");
unsigned short const **tmp___3;
  printf("\nSTMT_EXEC;;35380\n");
unsigned short const **tmp___4;
  printf("\nSTMT_EXEC;;35381\n");
char const *tmp___5;
  printf("\nSTMT_EXEC;;35382\n");
char const *tmp___6;
  printf("\nSTMT_EXEC;;35383\n");
int tmp___7;
  printf("\nSTMT_EXEC;;35384\n");
int tmp___8;
  printf("\nSTMT_EXEC;;35385\n");
void *__cil_tmp26;

  {
    {
      printf("\nSTMT_EXEC;;35389\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;35393\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            {
              printf("\nSTMT_EXEC;;35397\n");
c = (unsigned char)*(pc->input);
              printf("\nSTMT_EXEC;;35398\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;35400\n");
if (!(((int const) * (*tmp + (int)c) & 8192) != 0))
            {
              printf("\nSTMT_EXEC;;35402\n");
goto while_break___0;
            }
            printf("\nSTMT_EXEC;;35404\n");
(pc->input)++;
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;35408\n");
if ((unsigned int)c - 48U <= 9U)
        {
          printf("\nSTMT_EXEC;;35410\n");
goto _L___6;
        }
        else
        {
          printf("\nSTMT_EXEC;;35414\n");
if ((int)c == 45)
          {
            printf("\nSTMT_EXEC;;35416\n");
goto _L___6;
          }
          else
          {
            printf("\nSTMT_EXEC;;35420\n");
if ((int)c == 43)
            {
            _L___6: /* CIL Label */
              {
printf("\nSTMT_EXEC;;35423\n");
if ((int)c == 45)
              {
                printf("\nSTMT_EXEC;;35425\n");
goto _L___3;
              }
              else
              {
                printf("\nSTMT_EXEC;;35429\n");
if ((int)c == 43)
                {
                _L___3: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;35432\n");
if ((int)c == 45)
                  {
                    printf("\nSTMT_EXEC;;35434\n");
sign = -1;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;35438\n");
sign = 1;
                  }
}

                  printf("\nSTMT_EXEC;;35440\n");
(pc->input)++;
                  printf("\nSTMT_EXEC;;35441\n");
c = (unsigned char)*(pc->input);
                  printf("\nSTMT_EXEC;;35442\n");
if (!((unsigned int)c - 48U <= 9U))
                  {
                    printf("\nSTMT_EXEC;;35444\n");
goto __Cont;
                  }
                }
                else
                {
                  printf("\nSTMT_EXEC;;35449\n");
sign = 0;
                }
              }
}

              printf("\nSTMT_EXEC;;35452\n");
p = pc->input;
              printf("\nSTMT_EXEC;;35453\n");
value = 0UL;
              {
                printf("\nSTMT_EXEC;;35455\n");
while (1)
                {
                while_continue___1: /* CIL Label */;
                  printf("\nSTMT_EXEC;;35458\n");
value1 = value + (unsigned long)((int)c - 48);
                  printf("\nSTMT_EXEC;;35459\n");
if (value1 < value)
                  {
                    printf("\nSTMT_EXEC;;35461\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                  }
                  printf("\nSTMT_EXEC;;35463\n");
value = value1;
                  printf("\nSTMT_EXEC;;35464\n");
p++;
                  printf("\nSTMT_EXEC;;35465\n");
c = (unsigned char)*p;
                  printf("\nSTMT_EXEC;;35466\n");
if (!((unsigned int)c - 48U <= 9U))
                  {
                    printf("\nSTMT_EXEC;;35468\n");
goto while_break___1;
                  }
                  printf("\nSTMT_EXEC;;35470\n");
if (1844674407370955161UL < value)
                  {
                    printf("\nSTMT_EXEC;;35472\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                  }
                  printf("\nSTMT_EXEC;;35474\n");
value *= 10UL;
                }
              while_break___1: /* CIL Label */;
              }
              printf("\nSTMT_EXEC;;35478\n");
if ((int)c == 46)
              {
                printf("\nSTMT_EXEC;;35480\n");
goto _L___5;
              }
              else
              {
                printf("\nSTMT_EXEC;;35484\n");
if ((int)c == 44)
                {
                _L___5: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;35487\n");
if ((unsigned int)*(p + 1) - 48U <= 9U)
                  {
                    printf("\nSTMT_EXEC;;35489\n");
if (sign < 0)
                    {
                      printf("\nSTMT_EXEC;;35491\n");
s = (time_t)(-value);
                      printf("\nSTMT_EXEC;;35492\n");
if (0L < s)
                      {
                        printf("\nSTMT_EXEC;;35494\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                      }
                      printf("\nSTMT_EXEC;;35496\n");
value1___0 = (unsigned long)(-s);
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;35500\n");
s = (time_t)value;
                      printf("\nSTMT_EXEC;;35501\n");
if (s < 0L)
                      {
                        printf("\nSTMT_EXEC;;35503\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                      }
                      printf("\nSTMT_EXEC;;35505\n");
value1___0 = (unsigned long)s;
                    }
                    printf("\nSTMT_EXEC;;35507\n");
if (value != value1___0)
                    {
                      printf("\nSTMT_EXEC;;35509\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                    }
                    printf("\nSTMT_EXEC;;35511\n");
p++;
                    printf("\nSTMT_EXEC;;35512\n");
tmp___0 = p;
                    printf("\nSTMT_EXEC;;35513\n");
p++;
                    printf("\nSTMT_EXEC;;35514\n");
ns = (int)((int const) * tmp___0 - 48);
                    printf("\nSTMT_EXEC;;35515\n");
digits = 2;
                    {
                      printf("\nSTMT_EXEC;;35517\n");
while (1)
                      {
                      while_continue___2: /* CIL Label */;
                        printf("\nSTMT_EXEC;;35520\n");
if (!(digits <= 9))
                        {
                          printf("\nSTMT_EXEC;;35522\n");
goto while_break___2;
                        }
                        printf("\nSTMT_EXEC;;35524\n");
ns *= 10;
                        printf("\nSTMT_EXEC;;35525\n");
if ((unsigned int)*p - 48U <= 9U)
                        {
                          printf("\nSTMT_EXEC;;35527\n");
tmp___1 = p;
                          printf("\nSTMT_EXEC;;35528\n");
p++;
                          printf("\nSTMT_EXEC;;35529\n");
ns += (int)((int const) * tmp___1 - 48);
                        }
                        printf("\nSTMT_EXEC;;35531\n");
digits++;
                      }
                    while_break___2: /* CIL Label */;
                    }
                    printf("\nSTMT_EXEC;;35535\n");
if (sign < 0)
                    {
                      {
                        printf("\nSTMT_EXEC;;35538\n");
while (1)
                        {
                        while_continue___3: /* CIL Label */;
                          printf("\nSTMT_EXEC;;35541\n");
if (!((unsigned int)*p - 48U <= 9U))
                          {
                            printf("\nSTMT_EXEC;;35543\n");
goto while_break___3;
                          }
                          printf("\nSTMT_EXEC;;35545\n");
if ((int const) * p != 48)
                          {
                            printf("\nSTMT_EXEC;;35547\n");
ns++;
                            printf("\nSTMT_EXEC;;35548\n");
goto while_break___3;
                          }
                          printf("\nSTMT_EXEC;;35550\n");
p++;
                        }
                      while_break___3: /* CIL Label */;
                      }
                    }
                    {
                      printf("\nSTMT_EXEC;;35556\n");
while (1)
                      {
                      while_continue___4: /* CIL Label */;
                        printf("\nSTMT_EXEC;;35559\n");
if (!((unsigned int)*p - 48U <= 9U))
                        {
                          printf("\nSTMT_EXEC;;35561\n");
goto while_break___4;
                        }
                        printf("\nSTMT_EXEC;;35563\n");
p++;
                      }
                    while_break___4: /* CIL Label */;
                    }
                    printf("\nSTMT_EXEC;;35567\n");
if (sign < 0)
                    {
                      printf("\nSTMT_EXEC;;35569\n");
if (ns)
                      {
                        printf("\nSTMT_EXEC;;35571\n");
s--;
                        printf("\nSTMT_EXEC;;35572\n");
if (!(s < 0L))
                        {
                          printf("\nSTMT_EXEC;;35574\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                        }
                        printf("\nSTMT_EXEC;;35576\n");
ns = 1000000000 - ns;
                      }
                    }
                    printf("\nSTMT_EXEC;;35579\n");
lvalp->timespec.tv_sec = s;
                    printf("\nSTMT_EXEC;;35580\n");
lvalp->timespec.tv_nsec = (__syscall_slong_t)ns;
                    printf("\nSTMT_EXEC;;35581\n");
pc->input = p;
                    printf("\nSTMT_EXEC;;35582\n");
if (sign)
                    {
                      printf("\nSTMT_EXEC;;35584\n");
tmp___7 = 273;
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;35588\n");
tmp___7 = 274;
                    }
                    printf("\nSTMT_EXEC;;35590\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___7);
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;35594\n");
goto _L___4;
                  }
}

                }
                else
                {
                _L___4: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;35600\n");
if (sign < 0)
                  {
                    printf("\nSTMT_EXEC;;35602\n");
lvalp->textintval.value = (long)(-value);
                    printf("\nSTMT_EXEC;;35603\n");
if (0L < lvalp->textintval.value)
                    {
                      printf("\nSTMT_EXEC;;35605\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                    }
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;35610\n");
lvalp->textintval.value = (long)value;
                    printf("\nSTMT_EXEC;;35611\n");
if (lvalp->textintval.value < 0L)
                    {
                      printf("\nSTMT_EXEC;;35613\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
                    }
                  }
}

                  printf("\nSTMT_EXEC;;35616\n");
lvalp->textintval.digits = (size_t)(p - pc->input);
                  printf("\nSTMT_EXEC;;35617\n");
pc->input = p;
                  printf("\nSTMT_EXEC;;35618\n");
if (sign)
                  {
                    printf("\nSTMT_EXEC;;35620\n");
tmp___8 = 271;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;35624\n");
tmp___8 = 272;
                  }
                  printf("\nSTMT_EXEC;;35626\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___8);
                }
              }
            }
          }
        }
        {
          printf("\nSTMT_EXEC;;35633\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___4 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35635\n");
if ((int const) * (*tmp___4 + (int)c) & 1024)
        {
          printf("\nSTMT_EXEC;;35637\n");
p___0 = buff;
          {
            printf("\nSTMT_EXEC;;35639\n");
while (1)
            {
            while_continue___5: /* CIL Label */;
              printf("\nSTMT_EXEC;;35642\n");
if ((unsigned long)p___0 < (unsigned long)((buff + sizeof(buff)) - 1))
              {
                printf("\nSTMT_EXEC;;35644\n");
tmp___2 = p___0;
                printf("\nSTMT_EXEC;;35645\n");
p___0++;
                printf("\nSTMT_EXEC;;35646\n");
*tmp___2 = (char)c;
              }
              {
                printf("\nSTMT_EXEC;;35649\n");
(pc->input)++;
                printf("\nSTMT_EXEC;;35650\n");
c = (unsigned char)*(pc->input);
                printf("\nSTMT_EXEC;;35651\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___3 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;35653\n");
if (!((int const) * (*tmp___3 + (int)c) & 1024))
              {
                printf("\nSTMT_EXEC;;35655\n");
if (!((int)c == 46))
                {
                  printf("\nSTMT_EXEC;;35657\n");
goto while_break___5;
                }
              }
            }
          while_break___5: /* CIL Label */;
          }
          {
            printf("\nSTMT_EXEC;;35664\n");
*p___0 = (char)'\000';
            printf("\nSTMT_EXEC;;35665\n");
tp = lookup_word((parser_control const *)pc, buff);
          }
          printf("\nSTMT_EXEC;;35667\n");
if (!tp)
          {
            printf("\nSTMT_EXEC;;35669\n");
printf("\nFUNC_RETURN;;\n");
return ('?');
          }
          printf("\nSTMT_EXEC;;35671\n");
lvalp->intval = (long)tp->value;
          printf("\nSTMT_EXEC;;35672\n");
printf("\nFUNC_RETURN;;\n");
return ((int)tp->type);
        }
        printf("\nSTMT_EXEC;;35674\n");
if ((int)c != 40)
        {
          printf("\nSTMT_EXEC;;35676\n");
tmp___5 = pc->input;
          printf("\nSTMT_EXEC;;35677\n");
(pc->input)++;
          printf("\nSTMT_EXEC;;35678\n");
printf("\nFUNC_RETURN;;\n");
return ((int)*tmp___5);
        }
        printf("\nSTMT_EXEC;;35680\n");
count = (size_t)0;
        {
          printf("\nSTMT_EXEC;;35682\n");
while (1)
          {
          while_continue___6: /* CIL Label */;
            printf("\nSTMT_EXEC;;35685\n");
tmp___6 = pc->input;
            printf("\nSTMT_EXEC;;35686\n");
(pc->input)++;
            printf("\nSTMT_EXEC;;35687\n");
c = (unsigned char)*tmp___6;
            printf("\nSTMT_EXEC;;35688\n");
if ((int)c == 0)
            {
              printf("\nSTMT_EXEC;;35690\n");
printf("\nFUNC_RETURN;;\n");
return ((int)c);
            }
            printf("\nSTMT_EXEC;;35692\n");
if ((int)c == 40)
            {
              printf("\nSTMT_EXEC;;35694\n");
count++;
            }
            else
            {
              printf("\nSTMT_EXEC;;35698\n");
if ((int)c == 41)
              {
                printf("\nSTMT_EXEC;;35700\n");
count--;
              }
            }
            printf("\nSTMT_EXEC;;35703\n");
if (!(count != 0UL))
            {
              printf("\nSTMT_EXEC;;35705\n");
goto while_break___6;
            }
          }
        while_break___6: /* CIL Label */;
        }
      __Cont:;
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
static int yyerror(char *s __attribute__((__unused__)))
{

  printf("\nFUNC_CALL;yyerror(char *);\n");
{
    printf("\nSTMT_EXEC;;35720\n");
printf("\nFUNC_RETURN;;\n");
return (0);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool get_date(struct timespec *result, char const *p, struct timespec const *now)
{
  printf("\nFUNC_CALL;get_date(struct timespec *,const char *,const struct timespec *);\n");
printf("\nSTMT_EXEC;;35725\n");
time_t Start;
  printf("\nSTMT_EXEC;;35726\n");
long Start_ns;
  printf("\nSTMT_EXEC;;35727\n");
struct tm const *tmp;
  printf("\nSTMT_EXEC;;35728\n");
struct tm tm;
  printf("\nSTMT_EXEC;;35729\n");
struct tm tm0;
  printf("\nSTMT_EXEC;;35730\n");
parser_control pc;
  printf("\nSTMT_EXEC;;35731\n");
struct timespec gettime_buffer;
  printf("\nSTMT_EXEC;;35732\n");
int tmp___0;
  printf("\nSTMT_EXEC;;35733\n");
struct tm *tmp___1;
  printf("\nSTMT_EXEC;;35734\n");
int quarter;
  printf("\nSTMT_EXEC;;35735\n");
time_t probe;
  printf("\nSTMT_EXEC;;35736\n");
struct tm const *probe_tm;
  printf("\nSTMT_EXEC;;35737\n");
struct tm *tmp___2;
  printf("\nSTMT_EXEC;;35738\n");
int tmp___3;
  printf("\nSTMT_EXEC;;35739\n");
int tmp___4;
  printf("\nSTMT_EXEC;;35740\n");
long tmp___5;
  printf("\nSTMT_EXEC;;35741\n");
long delta;
  printf("\nSTMT_EXEC;;35742\n");
time_t t1;
  printf("\nSTMT_EXEC;;35743\n");
long sum_ns;
  printf("\nSTMT_EXEC;;35744\n");
long normalized_ns;
  printf("\nSTMT_EXEC;;35745\n");
time_t t0;
  printf("\nSTMT_EXEC;;35746\n");
long d1;
  printf("\nSTMT_EXEC;;35747\n");
time_t t1___0;
  printf("\nSTMT_EXEC;;35748\n");
long d2;
  printf("\nSTMT_EXEC;;35749\n");
time_t t2;
  printf("\nSTMT_EXEC;;35750\n");
long d3;
  printf("\nSTMT_EXEC;;35751\n");
time_t t3;
  printf("\nSTMT_EXEC;;35752\n");
long d4;
  printf("\nSTMT_EXEC;;35753\n");
time_t t4;
  printf("\nSTMT_EXEC;;35754\n");
void *__cil_tmp33;
  printf("\nSTMT_EXEC;;35755\n");
int __cil_tmp34;

  {
    printf("\nSTMT_EXEC;;35758\n");
if (!now)
    {
      {
        printf("\nSTMT_EXEC;;35761\n");
tmp___0 = gettime(&gettime_buffer);
      }
      printf("\nSTMT_EXEC;;35763\n");
if (tmp___0 != 0)
      {
        printf("\nSTMT_EXEC;;35765\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
      printf("\nSTMT_EXEC;;35767\n");
now = (struct timespec const *)(&gettime_buffer);
    }
    {
      printf("\nSTMT_EXEC;;35770\n");
Start = (time_t)now->tv_sec;
      printf("\nSTMT_EXEC;;35771\n");
Start_ns = (long)now->tv_nsec;
      printf("\nSTMT_EXEC;;35772\n");
printf("\nFUNC_CALL;localtime(const time_t *);\n");
tmp___1 = localtime(&now->tv_sec);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;35773\n");
tmp = (struct tm const *)tmp___1;
    }
    printf("\nSTMT_EXEC;;35775\n");
if (!tmp)
    {
      printf("\nSTMT_EXEC;;35777\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;35779\n");
pc.input = p;
    printf("\nSTMT_EXEC;;35780\n");
pc.year.value = (long)tmp->tm_year;
    printf("\nSTMT_EXEC;;35781\n");
pc.year.value += 1900L;
    printf("\nSTMT_EXEC;;35782\n");
pc.year.digits = (size_t)4;
    printf("\nSTMT_EXEC;;35783\n");
pc.month = (long)(tmp->tm_mon + 1);
    printf("\nSTMT_EXEC;;35784\n");
pc.day = (long)tmp->tm_mday;
    printf("\nSTMT_EXEC;;35785\n");
pc.hour = (long)tmp->tm_hour;
    printf("\nSTMT_EXEC;;35786\n");
pc.minutes = (long)tmp->tm_min;
    printf("\nSTMT_EXEC;;35787\n");
pc.seconds.tv_sec = (__time_t)tmp->tm_sec;
    printf("\nSTMT_EXEC;;35788\n");
pc.seconds.tv_nsec = Start_ns;
    printf("\nSTMT_EXEC;;35789\n");
tm.tm_isdst = (int)tmp->tm_isdst;
    printf("\nSTMT_EXEC;;35790\n");
pc.meridian = 2;
    printf("\nSTMT_EXEC;;35791\n");
pc.rel_ns = 0L;
    printf("\nSTMT_EXEC;;35792\n");
pc.rel_seconds = 0L;
    printf("\nSTMT_EXEC;;35793\n");
pc.rel_minutes = 0L;
    printf("\nSTMT_EXEC;;35794\n");
pc.rel_hour = 0L;
    printf("\nSTMT_EXEC;;35795\n");
pc.rel_day = 0L;
    printf("\nSTMT_EXEC;;35796\n");
pc.rel_month = 0L;
    printf("\nSTMT_EXEC;;35797\n");
pc.rel_year = 0L;
    printf("\nSTMT_EXEC;;35798\n");
pc.timespec_seen = (_Bool)0;
    printf("\nSTMT_EXEC;;35799\n");
pc.dates_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35800\n");
pc.days_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35801\n");
pc.rels_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35802\n");
pc.times_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35803\n");
pc.local_zones_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35804\n");
pc.zones_seen = (size_t)0;
    printf("\nSTMT_EXEC;;35805\n");
pc.local_time_zone_table[0].name = (char const *)tmp->tm_zone;
    printf("\nSTMT_EXEC;;35806\n");
pc.local_time_zone_table[0].type = 263;
    printf("\nSTMT_EXEC;;35807\n");
pc.local_time_zone_table[0].value = (int)tmp->tm_isdst;
    printf("\nSTMT_EXEC;;35808\n");
pc.local_time_zone_table[1].name = (char const *)0;
    printf("\nSTMT_EXEC;;35809\n");
quarter = 1;
    {
      printf("\nSTMT_EXEC;;35811\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;35814\n");
if (!(quarter <= 3))
        {
          printf("\nSTMT_EXEC;;35816\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;35819\n");
probe = Start + (time_t)(quarter * 7776000);
          printf("\nSTMT_EXEC;;35820\n");
printf("\nFUNC_CALL;localtime(const time_t *);\n");
tmp___2 = localtime((time_t const *)(&probe));printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;35821\n");
probe_tm = (struct tm const *)tmp___2;
        }
        printf("\nSTMT_EXEC;;35823\n");
if (probe_tm)
        {
          printf("\nSTMT_EXEC;;35825\n");
if (probe_tm->tm_zone)
          {
            printf("\nSTMT_EXEC;;35827\n");
if (probe_tm->tm_isdst != (int const)pc.local_time_zone_table[0].value)
            {
              printf("\nSTMT_EXEC;;35829\n");
pc.local_time_zone_table[1].name = (char const *)probe_tm->tm_zone;
              printf("\nSTMT_EXEC;;35830\n");
pc.local_time_zone_table[1].type = 263;
              printf("\nSTMT_EXEC;;35831\n");
pc.local_time_zone_table[1].value = (int)probe_tm->tm_isdst;
              printf("\nSTMT_EXEC;;35832\n");
pc.local_time_zone_table[2].name = (char const *)0;
              printf("\nSTMT_EXEC;;35833\n");
goto while_break;
            }
          }
        }
        printf("\nSTMT_EXEC;;35837\n");
quarter++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;35841\n");
if (pc.local_time_zone_table[0].name)
    {
      printf("\nSTMT_EXEC;;35843\n");
if (pc.local_time_zone_table[1].name)
      {
        {
          printf("\nSTMT_EXEC;;35846\n");
printf("\nFUNC_CALL;strcmp(const char *,const char *);\n");
tmp___3 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;35848\n");
if (!tmp___3)
        {
          printf("\nSTMT_EXEC;;35850\n");
pc.local_time_zone_table[0].value = -1;
          printf("\nSTMT_EXEC;;35851\n");
pc.local_time_zone_table[1].name = (char const *)0;
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;35856\n");
tmp___4 = yyparse((void *)(&pc));
    }
    printf("\nSTMT_EXEC;;35858\n");
if (tmp___4 != 0)
    {
      printf("\nSTMT_EXEC;;35860\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;35862\n");
if (pc.timespec_seen)
    {
      printf("\nSTMT_EXEC;;35864\n");
*result = pc.seconds;
      printf("\nSTMT_EXEC;;35865\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
    }
    printf("\nSTMT_EXEC;;35867\n");
if (1UL < pc.times_seen)
    {
      printf("\nSTMT_EXEC;;35869\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    else
    {
      printf("\nSTMT_EXEC;;35873\n");
if (1UL < pc.dates_seen)
      {
        printf("\nSTMT_EXEC;;35875\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
      else
      {
        printf("\nSTMT_EXEC;;35879\n");
if (1UL < pc.days_seen)
        {
          printf("\nSTMT_EXEC;;35881\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
        else
        {
          printf("\nSTMT_EXEC;;35885\n");
if (1UL < pc.local_zones_seen + pc.zones_seen)
          {
            printf("\nSTMT_EXEC;;35887\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
          }
          else
          {
            printf("\nSTMT_EXEC;;35891\n");
if (pc.local_zones_seen)
            {
              printf("\nSTMT_EXEC;;35893\n");
if (1 < pc.local_isdst)
              {
                printf("\nSTMT_EXEC;;35895\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
              }
            }
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;35903\n");
tmp___5 = to_year(pc.year);
      printf("\nSTMT_EXEC;;35904\n");
tm.tm_year = (int)((tmp___5 - 1900L) + pc.rel_year);
      printf("\nSTMT_EXEC;;35905\n");
tm.tm_mon = (int)((pc.month - 1L) + pc.rel_month);
      printf("\nSTMT_EXEC;;35906\n");
tm.tm_mday = (int)(pc.day + pc.rel_day);
    }
    printf("\nSTMT_EXEC;;35908\n");
if (pc.times_seen)
    {
      printf("\nSTMT_EXEC;;35910\n");
goto _L___3;
    }
    else
    {
      printf("\nSTMT_EXEC;;35914\n");
if (pc.rels_seen)
      {
        printf("\nSTMT_EXEC;;35916\n");
if (!pc.dates_seen)
        {
          printf("\nSTMT_EXEC;;35918\n");
if (!pc.days_seen)
          {
          _L___3: /* CIL Label */
          {
            printf("\nSTMT_EXEC;;35922\n");
tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
            printf("\nSTMT_EXEC;;35924\n");
if (tm.tm_hour < 0)
            {
              printf("\nSTMT_EXEC;;35926\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
            }
            printf("\nSTMT_EXEC;;35928\n");
tm.tm_min = (int)pc.minutes;
            printf("\nSTMT_EXEC;;35929\n");
tm.tm_sec = (int)pc.seconds.tv_sec;
          }
          else
          {
            printf("\nSTMT_EXEC;;35933\n");
tm.tm_sec = 0;
            printf("\nSTMT_EXEC;;35934\n");
tm.tm_min = tm.tm_sec;
            printf("\nSTMT_EXEC;;35935\n");
tm.tm_hour = tm.tm_min;
            printf("\nSTMT_EXEC;;35936\n");
pc.seconds.tv_nsec = (__syscall_slong_t)0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;35941\n");
tm.tm_sec = 0;
          printf("\nSTMT_EXEC;;35942\n");
tm.tm_min = tm.tm_sec;
          printf("\nSTMT_EXEC;;35943\n");
tm.tm_hour = tm.tm_min;
          printf("\nSTMT_EXEC;;35944\n");
pc.seconds.tv_nsec = (__syscall_slong_t)0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;35949\n");
tm.tm_sec = 0;
        printf("\nSTMT_EXEC;;35950\n");
tm.tm_min = tm.tm_sec;
        printf("\nSTMT_EXEC;;35951\n");
tm.tm_hour = tm.tm_min;
        printf("\nSTMT_EXEC;;35952\n");
pc.seconds.tv_nsec = (__syscall_slong_t)0;
      }
    }
    printf("\nSTMT_EXEC;;35955\n");
if (((((pc.dates_seen | pc.days_seen) | pc.times_seen) | (unsigned long)pc.rel_day) | (unsigned long)pc.rel_month) | (unsigned long)pc.rel_year)
    {
      printf("\nSTMT_EXEC;;35957\n");
tm.tm_isdst = -1;
    }
    printf("\nSTMT_EXEC;;35959\n");
if (pc.local_zones_seen)
    {
      printf("\nSTMT_EXEC;;35961\n");
tm.tm_isdst = pc.local_isdst;
    }
    {
      printf("\nSTMT_EXEC;;35964\n");
tm0 = tm;
      printf("\nSTMT_EXEC;;35965\n");
Start = rpl_mktime(&tm);
    }
    printf("\nSTMT_EXEC;;35967\n");
if (Start == -1L)
    {
      printf("\nSTMT_EXEC;;35969\n");
if (pc.zones_seen)
      {
        printf("\nSTMT_EXEC;;35971\n");
tm = tm0;
        printf("\nSTMT_EXEC;;35972\n");
if (tm.tm_year <= 70)
        {
          printf("\nSTMT_EXEC;;35974\n");
(tm.tm_mday)++;
          printf("\nSTMT_EXEC;;35975\n");
pc.time_zone += 1440L;
        }
        else
        {
          printf("\nSTMT_EXEC;;35979\n");
(tm.tm_mday)--;
          printf("\nSTMT_EXEC;;35980\n");
pc.time_zone -= 1440L;
        }
        {
          printf("\nSTMT_EXEC;;35983\n");
Start = rpl_mktime(&tm);
        }
      }
      printf("\nSTMT_EXEC;;35986\n");
if (Start == -1L)
      {
        printf("\nSTMT_EXEC;;35988\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
    }
    printf("\nSTMT_EXEC;;35991\n");
if (pc.days_seen)
    {
      printf("\nSTMT_EXEC;;35993\n");
if (!pc.dates_seen)
      {
        {
          printf("\nSTMT_EXEC;;35996\n");
tm.tm_mday = (int)((long)tm.tm_mday + ((long)(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long)(0L < pc.day_ordinal))));
          printf("\nSTMT_EXEC;;35997\n");
tm.tm_isdst = -1;
          printf("\nSTMT_EXEC;;35998\n");
Start = rpl_mktime(&tm);
        }
        printf("\nSTMT_EXEC;;36000\n");
if (Start == -1L)
        {
          printf("\nSTMT_EXEC;;36002\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
        }
      }
    }
    printf("\nSTMT_EXEC;;36006\n");
if (pc.zones_seen)
    {
      printf("\nSTMT_EXEC;;36008\n");
delta = pc.time_zone * 60L;
      printf("\nSTMT_EXEC;;36009\n");
delta -= tm.tm_gmtoff;
      printf("\nSTMT_EXEC;;36010\n");
t1 = Start - delta;
      printf("\nSTMT_EXEC;;36011\n");
if ((Start < t1) != (delta < 0L))
      {
        printf("\nSTMT_EXEC;;36013\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
      }
      printf("\nSTMT_EXEC;;36015\n");
Start = t1;
    }
    printf("\nSTMT_EXEC;;36017\n");
sum_ns = pc.seconds.tv_nsec + pc.rel_ns;
    printf("\nSTMT_EXEC;;36018\n");
normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
    printf("\nSTMT_EXEC;;36019\n");
t0 = Start;
    printf("\nSTMT_EXEC;;36020\n");
d1 = 3600L * pc.rel_hour;
    printf("\nSTMT_EXEC;;36021\n");
t1___0 = t0 + d1;
    printf("\nSTMT_EXEC;;36022\n");
d2 = 60L * pc.rel_minutes;
    printf("\nSTMT_EXEC;;36023\n");
t2 = t1___0 + d2;
    printf("\nSTMT_EXEC;;36024\n");
d3 = pc.rel_seconds;
    printf("\nSTMT_EXEC;;36025\n");
t3 = t2 + d3;
    printf("\nSTMT_EXEC;;36026\n");
d4 = (sum_ns - normalized_ns) / 1000000000L;
    printf("\nSTMT_EXEC;;36027\n");
t4 = t3 + d4;
    printf("\nSTMT_EXEC;;36028\n");
if ((((((d1 / 3600L ^ pc.rel_hour) | (d2 / 60L ^ pc.rel_minutes)) | (long)((t1___0 < t0) ^ (d1 < 0L))) | (long)((t2 < t1___0) ^ (d2 < 0L))) | (long)((t3 < t2) ^ (d3 < 0L))) | (long)((t4 < t3) ^ (d4 < 0L)))
    {
      printf("\nSTMT_EXEC;;36030\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;36032\n");
result->tv_sec = t4;
    printf("\nSTMT_EXEC;;36033\n");
result->tv_nsec = normalized_ns;
    printf("\nSTMT_EXEC;;36034\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","01a.getopt1.o.i","") */
/* #pragma merger("0","01b.getopt.o.i","") */
/* #pragma merger("0","01c.gettime.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval *__restrict __tv, __timezone_ptr_t __tz);
int gettime(struct timespec *ts)
{
  printf("\nFUNC_CALL;gettime(struct timespec *);\n");
printf("\nSTMT_EXEC;;36043\n");
int tmp;
  printf("\nSTMT_EXEC;;36044\n");
struct timeval tv;
  printf("\nSTMT_EXEC;;36045\n");
int r;
  printf("\nSTMT_EXEC;;36046\n");
int tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;36050\n");
printf("\nFUNC_CALL;clock_gettime(clockid_t,struct timespec *);\n");
tmp = clock_gettime(0, ts);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;36052\n");
if (tmp == 0)
    {
      printf("\nSTMT_EXEC;;36054\n");
printf("\nFUNC_RETURN;;\n");
return (0);
    }
    {
      printf("\nSTMT_EXEC;;36057\n");
printf("\nFUNC_CALL;gettimeofday(struct timeval *__restrict,__timezone_ptr_t);\n");
tmp___0 = gettimeofday((struct timeval * /* __restrict  */)(&tv), (__timezone_ptr_t)0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36058\n");
r = tmp___0;
    }
    printf("\nSTMT_EXEC;;36060\n");
if (r == 0)
    {
      printf("\nSTMT_EXEC;;36062\n");
ts->tv_sec = tv.tv_sec;
      printf("\nSTMT_EXEC;;36063\n");
ts->tv_nsec = tv.tv_usec * 1000L;
    }
    printf("\nSTMT_EXEC;;36065\n");
printf("\nFUNC_RETURN;;\n");
return (r);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","01d.hash.o.i","") */
_Bool hash_rehash(Hash_table *table___0, size_t candidate);
static struct hash_tuning const default_tuning = {(float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0};
void *hash_lookup(Hash_table const *table___0, void const *entry)
{
  printf("\nFUNC_CALL;hash_lookup(const Hash_table *,const void *);\n");
printf("\nSTMT_EXEC;;36073\n");
struct hash_entry const *bucket;
  printf("\nSTMT_EXEC;;36074\n");
size_t tmp;
  printf("\nSTMT_EXEC;;36075\n");
struct hash_entry const *cursor;
  printf("\nSTMT_EXEC;;36076\n");
_Bool tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;36080\n");
tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
      printf("\nSTMT_EXEC;;36081\n");
bucket = (struct hash_entry const *)(table___0->bucket + tmp);
    }
    printf("\nSTMT_EXEC;;36083\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
    {
      {
        printf("\nSTMT_EXEC;;36086\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;36089\n");
if ((unsigned long)bucket->data == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36091\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
    }
    printf("\nSTMT_EXEC;;36093\n");
cursor = bucket;
    {
      printf("\nSTMT_EXEC;;36095\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36098\n");
if (!cursor)
        {
          printf("\nSTMT_EXEC;;36100\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;36103\n");
tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
        }
        printf("\nSTMT_EXEC;;36105\n");
if (tmp___0)
        {
          printf("\nSTMT_EXEC;;36107\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)cursor->data);
        }
        printf("\nSTMT_EXEC;;36109\n");
cursor = (struct hash_entry const *)cursor->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36113\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
void *hash_get_first(Hash_table const *table___0)
{
  printf("\nFUNC_CALL;hash_get_first(const Hash_table *);\n");
printf("\nSTMT_EXEC;;36118\n");
struct hash_entry const *bucket;

  {
    printf("\nSTMT_EXEC;;36121\n");
if (table___0->n_entries == 0UL)
    {
      printf("\nSTMT_EXEC;;36123\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
    }
    printf("\nSTMT_EXEC;;36125\n");
bucket = (struct hash_entry const *)table___0->bucket;
    {
      printf("\nSTMT_EXEC;;36127\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36130\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
        {
          {
            printf("\nSTMT_EXEC;;36133\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

          }
        }
        else
        {
          printf("\nSTMT_EXEC;;36138\n");
if (bucket->data)
          {
            printf("\nSTMT_EXEC;;36140\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)bucket->data);
          }
        }
        printf("\nSTMT_EXEC;;36143\n");
bucket++;
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void *hash_get_next(Hash_table const *table___0, void const *entry)
{
  printf("\nFUNC_CALL;hash_get_next(const Hash_table *,const void *);\n");
printf("\nSTMT_EXEC;;36151\n");
struct hash_entry const *bucket;
  printf("\nSTMT_EXEC;;36152\n");
size_t tmp;
  printf("\nSTMT_EXEC;;36153\n");
struct hash_entry const *cursor;

  {
    {
      printf("\nSTMT_EXEC;;36157\n");
tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
      printf("\nSTMT_EXEC;;36158\n");
bucket = (struct hash_entry const *)(table___0->bucket + tmp);
    }
    printf("\nSTMT_EXEC;;36160\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
    {
      {
        printf("\nSTMT_EXEC;;36163\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;36166\n");
cursor = bucket;
    {
      printf("\nSTMT_EXEC;;36168\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36171\n");
if (!cursor)
        {
          printf("\nSTMT_EXEC;;36173\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36175\n");
if ((unsigned long)cursor->data == (unsigned long)entry)
        {
          printf("\nSTMT_EXEC;;36177\n");
if (cursor->next)
          {
            printf("\nSTMT_EXEC;;36179\n");
printf("\nFUNC_RETURN;;\n");
return ((cursor->next)->data);
          }
        }
        printf("\nSTMT_EXEC;;36182\n");
cursor = (struct hash_entry const *)cursor->next;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;36187\n");
while (1)
      {
      while_continue___0: /* CIL Label */;
        printf("\nSTMT_EXEC;;36190\n");
bucket++;
        printf("\nSTMT_EXEC;;36191\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
        {
          printf("\nSTMT_EXEC;;36193\n");
goto while_break___0;
        }
        printf("\nSTMT_EXEC;;36195\n");
if (bucket->data)
        {
          printf("\nSTMT_EXEC;;36197\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)bucket->data);
        }
      }
    while_break___0: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36202\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t hash_do_for_each(Hash_table const *table___0, _Bool (*processor)(void *, void *), void *processor_data)
{
  printf("\nFUNC_CALL;hash_do_for_each(const Hash_table *,_Bool (*)(void *, void *),void *);\n");
printf("\nSTMT_EXEC;;36207\n");
size_t counter;
  printf("\nSTMT_EXEC;;36208\n");
struct hash_entry const *bucket;
  printf("\nSTMT_EXEC;;36209\n");
struct hash_entry const *cursor;
  printf("\nSTMT_EXEC;;36210\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;36213\n");
counter = (size_t)0;
    printf("\nSTMT_EXEC;;36214\n");
bucket = (struct hash_entry const *)table___0->bucket;
    {
      printf("\nSTMT_EXEC;;36216\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36219\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
        {
          printf("\nSTMT_EXEC;;36221\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36223\n");
if (bucket->data)
        {
          printf("\nSTMT_EXEC;;36225\n");
cursor = bucket;
          {
            printf("\nSTMT_EXEC;;36227\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;36230\n");
if (!cursor)
              {
                printf("\nSTMT_EXEC;;36232\n");
goto while_break___0;
              }
              {
                printf("\nSTMT_EXEC;;36235\n");
tmp = (*processor)((void *)cursor->data, processor_data);
              }
              printf("\nSTMT_EXEC;;36237\n");
if (!tmp)
              {
                printf("\nSTMT_EXEC;;36239\n");
printf("\nFUNC_RETURN;;\n");
return (counter);
              }
              printf("\nSTMT_EXEC;;36241\n");
counter++;
              printf("\nSTMT_EXEC;;36242\n");
cursor = (struct hash_entry const *)cursor->next;
            }
          while_break___0: /* CIL Label */;
          }
        }
        printf("\nSTMT_EXEC;;36247\n");
bucket++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36251\n");
printf("\nFUNC_RETURN;;\n");
return (counter);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t hash_string(char const *string, size_t n_buckets)
{
  printf("\nFUNC_CALL;hash_string(const char *,size_t);\n");
printf("\nSTMT_EXEC;;36256\n");
size_t value;
  printf("\nSTMT_EXEC;;36257\n");
char const *tmp;

  {
    printf("\nSTMT_EXEC;;36260\n");
value = (size_t)0;
    {
      printf("\nSTMT_EXEC;;36262\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36265\n");
if (!*string)
        {
          printf("\nSTMT_EXEC;;36267\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36269\n");
tmp = string;
        printf("\nSTMT_EXEC;;36270\n");
string++;
        printf("\nSTMT_EXEC;;36271\n");
value = (value * 31UL + (size_t)((unsigned char)*tmp)) % n_buckets;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36275\n");
printf("\nFUNC_RETURN;;\n");
return (value);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool is_prime(size_t candidate)
{
  printf("\nFUNC_CALL;is_prime(size_t);\n");
printf("\nSTMT_EXEC;;36280\n");
size_t divisor;
  printf("\nSTMT_EXEC;;36281\n");
size_t square;
  printf("\nSTMT_EXEC;;36282\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;36285\n");
divisor = (size_t)3;
    printf("\nSTMT_EXEC;;36286\n");
square = divisor * divisor;
    {
      printf("\nSTMT_EXEC;;36288\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36291\n");
if (square < candidate)
        {
          printf("\nSTMT_EXEC;;36293\n");
if (!(candidate % divisor))
          {
            printf("\nSTMT_EXEC;;36295\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;36300\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36302\n");
divisor++;
        printf("\nSTMT_EXEC;;36303\n");
square += 4UL * divisor;
        printf("\nSTMT_EXEC;;36304\n");
divisor++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36308\n");
if (candidate % divisor)
    {
      printf("\nSTMT_EXEC;;36310\n");
tmp = 1;
    }
    else
    {
      printf("\nSTMT_EXEC;;36314\n");
tmp = 0;
    }
    printf("\nSTMT_EXEC;;36316\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static size_t next_prime(size_t candidate)
{
  printf("\nFUNC_CALL;next_prime(size_t);\n");
printf("\nSTMT_EXEC;;36321\n");
_Bool tmp;

  {
    printf("\nSTMT_EXEC;;36324\n");
if (candidate < 10UL)
    {
      printf("\nSTMT_EXEC;;36326\n");
candidate = (size_t)10;
    }
    printf("\nSTMT_EXEC;;36328\n");
candidate |= 1UL;
    {
      printf("\nSTMT_EXEC;;36330\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;36334\n");
tmp = is_prime(candidate);
        }
        printf("\nSTMT_EXEC;;36336\n");
if (tmp)
        {
          printf("\nSTMT_EXEC;;36338\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36340\n");
candidate += 2UL;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36344\n");
printf("\nFUNC_RETURN;;\n");
return (candidate);
  }
printf("\nFUNC_RETURN;;\n");
}
static _Bool check_tuning(Hash_table *table___0)
{
  printf("\nFUNC_CALL;check_tuning(Hash_table *);\n");
printf("\nSTMT_EXEC;;36349\n");
Hash_tuning const *tuning;
  printf("\nSTMT_EXEC;;36350\n");
float epsilon;

  {
    printf("\nSTMT_EXEC;;36353\n");
tuning = table___0->tuning;
    printf("\nSTMT_EXEC;;36354\n");
epsilon = 0.1f;
    printf("\nSTMT_EXEC;;36355\n");
if (epsilon < (float)tuning->growth_threshold)
    {
      printf("\nSTMT_EXEC;;36357\n");
if (tuning->growth_threshold < (float const)((float)1 - epsilon))
      {
        printf("\nSTMT_EXEC;;36359\n");
if ((float)1 + epsilon < (float)tuning->growth_factor)
        {
          printf("\nSTMT_EXEC;;36361\n");
if ((float const)0 <= tuning->shrink_threshold)
          {
            printf("\nSTMT_EXEC;;36363\n");
if (tuning->shrink_threshold + (float const)epsilon < tuning->shrink_factor)
            {
              printf("\nSTMT_EXEC;;36365\n");
if (tuning->shrink_factor <= (float const)1)
              {
                printf("\nSTMT_EXEC;;36367\n");
if (tuning->shrink_threshold + (float const)epsilon < tuning->growth_threshold)
                {
                  printf("\nSTMT_EXEC;;36369\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
                }
              }
            }
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;36377\n");
table___0->tuning = &default_tuning;
    printf("\nSTMT_EXEC;;36378\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
  }
printf("\nFUNC_RETURN;;\n");
}
Hash_table *hash_initialize(size_t candidate, Hash_tuning const *tuning, size_t (*hasher)(void const *, size_t), _Bool (*comparator)(void const *, void const *), void (*data_freer)(void *))
{
  printf("\nFUNC_CALL;hash_initialize(size_t,const Hash_tuning *,size_t (*)(const void *, size_t),_Bool (*)(const void *, const void *),void (*)(void *));\n");
printf("\nSTMT_EXEC;;36383\n");
Hash_table *table___0;
  printf("\nSTMT_EXEC;;36384\n");
void *tmp;
  printf("\nSTMT_EXEC;;36385\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;36386\n");
float new_candidate;
  printf("\nSTMT_EXEC;;36387\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;36388\n");
int tmp___2;
  printf("\nSTMT_EXEC;;36389\n");
int tmp___3;

  {
    printf("\nSTMT_EXEC;;36392\n");
if ((unsigned long)hasher == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36394\n");
printf("\nFUNC_RETURN;;\n");
return ((Hash_table *)((void *)0));
    }
    else
    {
      printf("\nSTMT_EXEC;;36398\n");
if ((unsigned long)comparator == (unsigned long)((void *)0))
      {
        printf("\nSTMT_EXEC;;36400\n");
printf("\nFUNC_RETURN;;\n");
return ((Hash_table *)((void *)0));
      }
    }
    {
      printf("\nSTMT_EXEC;;36404\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
tmp = malloc(sizeof(*table___0));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36405\n");
table___0 = (Hash_table *)tmp;
    }
    printf("\nSTMT_EXEC;;36407\n");
if ((unsigned long)table___0 == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36409\n");
printf("\nFUNC_RETURN;;\n");
return ((Hash_table *)((void *)0));
    }
    printf("\nSTMT_EXEC;;36411\n");
if (!tuning)
    {
      printf("\nSTMT_EXEC;;36413\n");
tuning = &default_tuning;
    }
    {
      printf("\nSTMT_EXEC;;36416\n");
table___0->tuning = tuning;
      printf("\nSTMT_EXEC;;36417\n");
tmp___0 = check_tuning(table___0);
    }
    printf("\nSTMT_EXEC;;36419\n");
if (!tmp___0)
    {
      printf("\nSTMT_EXEC;;36421\n");
goto fail;
    }
    printf("\nSTMT_EXEC;;36423\n");
if (!tuning->is_n_buckets)
    {
      printf("\nSTMT_EXEC;;36425\n");
new_candidate = (float)((float const)candidate / tuning->growth_threshold);
      printf("\nSTMT_EXEC;;36426\n");
if ((float)0xffffffffffffffffUL <= new_candidate)
      {
        printf("\nSTMT_EXEC;;36428\n");
goto fail;
      }
      printf("\nSTMT_EXEC;;36430\n");
candidate = (size_t)new_candidate;
    }
    printf("\nSTMT_EXEC;;36432\n");
if (sizeof(ptrdiff_t) <= sizeof(size_t))
    {
      printf("\nSTMT_EXEC;;36434\n");
tmp___2 = -1;
    }
    else
    {
      printf("\nSTMT_EXEC;;36438\n");
tmp___2 = -2;
    }
    printf("\nSTMT_EXEC;;36440\n");
if ((size_t)tmp___2 / sizeof(*(table___0->bucket)) < candidate)
    {
      printf("\nSTMT_EXEC;;36442\n");
goto fail;
    }
    {
      printf("\nSTMT_EXEC;;36445\n");
table___0->n_buckets = next_prime(candidate);
    }
    printf("\nSTMT_EXEC;;36447\n");
if (sizeof(ptrdiff_t) <= sizeof(size_t))
    {
      printf("\nSTMT_EXEC;;36449\n");
tmp___3 = -1;
    }
    else
    {
      printf("\nSTMT_EXEC;;36453\n");
tmp___3 = -2;
    }
    printf("\nSTMT_EXEC;;36455\n");
if ((size_t)tmp___3 / sizeof(*(table___0->bucket)) < table___0->n_buckets)
    {
      printf("\nSTMT_EXEC;;36457\n");
goto fail;
    }
    {
      printf("\nSTMT_EXEC;;36460\n");
printf("\nFUNC_CALL;calloc(size_t,size_t);\n");
tmp___1 = calloc(table___0->n_buckets, sizeof(*(table___0->bucket)));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36461\n");
table___0->bucket = (struct hash_entry *)tmp___1;
      printf("\nSTMT_EXEC;;36462\n");
table___0->bucket_limit = (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
      printf("\nSTMT_EXEC;;36463\n");
table___0->n_buckets_used = (size_t)0;
      printf("\nSTMT_EXEC;;36464\n");
table___0->n_entries = (size_t)0;
      printf("\nSTMT_EXEC;;36465\n");
table___0->hasher = hasher;
      printf("\nSTMT_EXEC;;36466\n");
table___0->comparator = comparator;
      printf("\nSTMT_EXEC;;36467\n");
table___0->data_freer = data_freer;
      printf("\nSTMT_EXEC;;36468\n");
table___0->free_entry_list = (struct hash_entry *)((void *)0);
    }
    printf("\nSTMT_EXEC;;36470\n");
printf("\nFUNC_RETURN;;\n");
return (table___0);
  fail:
  {
    printf("\nSTMT_EXEC;;36473\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)table___0);printf("\nFUNC_RETURN;;\n");

  }
    printf("\nSTMT_EXEC;;36475\n");
printf("\nFUNC_RETURN;;\n");
return ((Hash_table *)((void *)0));
  }
printf("\nFUNC_RETURN;;\n");
}
static struct hash_entry *allocate_entry(Hash_table *table___0)
{
  printf("\nFUNC_CALL;allocate_entry(Hash_table *);\n");
printf("\nSTMT_EXEC;;36480\n");
struct hash_entry *new;
  printf("\nSTMT_EXEC;;36481\n");
void *tmp;

  {
    printf("\nSTMT_EXEC;;36484\n");
if (table___0->free_entry_list)
    {
      printf("\nSTMT_EXEC;;36486\n");
new = table___0->free_entry_list;
      printf("\nSTMT_EXEC;;36487\n");
table___0->free_entry_list = new->next;
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;36492\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
tmp = malloc(sizeof(*new));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;36493\n");
new = (struct hash_entry *)tmp;
      }
    }
    printf("\nSTMT_EXEC;;36496\n");
printf("\nFUNC_RETURN;;\n");
return (new);
  }
printf("\nFUNC_RETURN;;\n");
}
static void free_entry(Hash_table *table___0, struct hash_entry *entry)
{

  printf("\nFUNC_CALL;free_entry(Hash_table *,struct hash_entry *);\n");
{
    printf("\nSTMT_EXEC;;36503\n");
entry->data = (void *)0;
    printf("\nSTMT_EXEC;;36504\n");
entry->next = table___0->free_entry_list;
    printf("\nSTMT_EXEC;;36505\n");
table___0->free_entry_list = entry;
    printf("\nSTMT_EXEC;;36506\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
static void *hash_find_entry(Hash_table *table___0, void const *entry, struct hash_entry **bucket_head, _Bool delete)
{
  printf("\nFUNC_CALL;hash_find_entry(Hash_table *,const void *,struct hash_entry **,_Bool);\n");
printf("\nSTMT_EXEC;;36511\n");
struct hash_entry *bucket;
  printf("\nSTMT_EXEC;;36512\n");
size_t tmp;
  printf("\nSTMT_EXEC;;36513\n");
struct hash_entry *cursor;
  printf("\nSTMT_EXEC;;36514\n");
void *data;
  printf("\nSTMT_EXEC;;36515\n");
struct hash_entry *next;
  printf("\nSTMT_EXEC;;36516\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;36517\n");
void *data___0;
  printf("\nSTMT_EXEC;;36518\n");
struct hash_entry *next___0;
  printf("\nSTMT_EXEC;;36519\n");
_Bool tmp___1;

  {
    {
      printf("\nSTMT_EXEC;;36523\n");
tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
      printf("\nSTMT_EXEC;;36524\n");
bucket = table___0->bucket + tmp;
    }
    printf("\nSTMT_EXEC;;36526\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
    {
      {
        printf("\nSTMT_EXEC;;36529\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;36532\n");
*bucket_head = bucket;
    printf("\nSTMT_EXEC;;36533\n");
if ((unsigned long)bucket->data == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36535\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
    }
    {
      printf("\nSTMT_EXEC;;36538\n");
tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
    }
    printf("\nSTMT_EXEC;;36540\n");
if (tmp___0)
    {
      printf("\nSTMT_EXEC;;36542\n");
data = bucket->data;
      printf("\nSTMT_EXEC;;36543\n");
if (delete)
      {
        printf("\nSTMT_EXEC;;36545\n");
if (bucket->next)
        {
          {
            printf("\nSTMT_EXEC;;36548\n");
next = bucket->next;
            printf("\nSTMT_EXEC;;36549\n");
*bucket = *next;
            printf("\nSTMT_EXEC;;36550\n");
free_entry(table___0, next);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;36555\n");
bucket->data = (void *)0;
        }
      }
      printf("\nSTMT_EXEC;;36558\n");
printf("\nFUNC_RETURN;;\n");
return (data);
    }
    printf("\nSTMT_EXEC;;36560\n");
cursor = bucket;
    {
      printf("\nSTMT_EXEC;;36562\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36565\n");
if (!cursor->next)
        {
          printf("\nSTMT_EXEC;;36567\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;36570\n");
tmp___1 = (*(table___0->comparator))(entry, (void const *)(cursor->next)->data);
        }
        printf("\nSTMT_EXEC;;36572\n");
if (tmp___1)
        {
          printf("\nSTMT_EXEC;;36574\n");
data___0 = (cursor->next)->data;
          printf("\nSTMT_EXEC;;36575\n");
if (delete)
          {
            {
              printf("\nSTMT_EXEC;;36578\n");
next___0 = cursor->next;
              printf("\nSTMT_EXEC;;36579\n");
cursor->next = next___0->next;
              printf("\nSTMT_EXEC;;36580\n");
free_entry(table___0, next___0);
            }
          }
          printf("\nSTMT_EXEC;;36583\n");
printf("\nFUNC_RETURN;;\n");
return (data___0);
        }
        printf("\nSTMT_EXEC;;36585\n");
cursor = cursor->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;36589\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
_Bool hash_rehash(Hash_table *table___0, size_t candidate)
{
  printf("\nFUNC_CALL;hash_rehash(Hash_table *,size_t);\n");
printf("\nSTMT_EXEC;;36594\n");
Hash_table *new_table;
  printf("\nSTMT_EXEC;;36595\n");
struct hash_entry *bucket;
  printf("\nSTMT_EXEC;;36596\n");
struct hash_entry *cursor;
  printf("\nSTMT_EXEC;;36597\n");
struct hash_entry *next;
  printf("\nSTMT_EXEC;;36598\n");
void *data;
  printf("\nSTMT_EXEC;;36599\n");
struct hash_entry *new_bucket;
  printf("\nSTMT_EXEC;;36600\n");
size_t tmp;
  printf("\nSTMT_EXEC;;36601\n");
struct hash_entry *new_entry;
  printf("\nSTMT_EXEC;;36602\n");
struct hash_entry *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;36606\n");
new_table = hash_initialize(candidate, table___0->tuning, table___0->hasher, table___0->comparator, table___0->data_freer);
    }
    printf("\nSTMT_EXEC;;36608\n");
if ((unsigned long)new_table == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36610\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
    }
    printf("\nSTMT_EXEC;;36612\n");
new_table->free_entry_list = table___0->free_entry_list;
    printf("\nSTMT_EXEC;;36613\n");
bucket = table___0->bucket;
    {
      printf("\nSTMT_EXEC;;36615\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36618\n");
if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit))
        {
          printf("\nSTMT_EXEC;;36620\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;36622\n");
if (bucket->data)
        {
          printf("\nSTMT_EXEC;;36624\n");
cursor = bucket;
          {
            printf("\nSTMT_EXEC;;36626\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;36629\n");
if (!cursor)
              {
                printf("\nSTMT_EXEC;;36631\n");
goto while_break___0;
              }
              {
                printf("\nSTMT_EXEC;;36634\n");
data = cursor->data;
                printf("\nSTMT_EXEC;;36635\n");
tmp = (*(new_table->hasher))((void const *)data, new_table->n_buckets);
                printf("\nSTMT_EXEC;;36636\n");
new_bucket = new_table->bucket + tmp;
              }
              printf("\nSTMT_EXEC;;36638\n");
if (!((unsigned long)new_bucket < (unsigned long)new_table->bucket_limit))
              {
                {
                  printf("\nSTMT_EXEC;;36641\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

                }
              }
              printf("\nSTMT_EXEC;;36644\n");
next = cursor->next;
              printf("\nSTMT_EXEC;;36645\n");
if (new_bucket->data)
              {
                printf("\nSTMT_EXEC;;36647\n");
if ((unsigned long)cursor == (unsigned long)bucket)
                {
                  {
                    printf("\nSTMT_EXEC;;36650\n");
tmp___0 = allocate_entry(new_table);
                    printf("\nSTMT_EXEC;;36651\n");
new_entry = tmp___0;
                  }
                  printf("\nSTMT_EXEC;;36653\n");
if ((unsigned long)new_entry == (unsigned long)((void *)0))
                  {
                    printf("\nSTMT_EXEC;;36655\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)0);
                  }
                  printf("\nSTMT_EXEC;;36657\n");
new_entry->data = data;
                  printf("\nSTMT_EXEC;;36658\n");
new_entry->next = new_bucket->next;
                  printf("\nSTMT_EXEC;;36659\n");
new_bucket->next = new_entry;
                }
                else
                {
                  printf("\nSTMT_EXEC;;36663\n");
cursor->next = new_bucket->next;
                  printf("\nSTMT_EXEC;;36664\n");
new_bucket->next = cursor;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;36669\n");
new_bucket->data = data;
                printf("\nSTMT_EXEC;;36670\n");
(new_table->n_buckets_used)++;
                printf("\nSTMT_EXEC;;36671\n");
if ((unsigned long)cursor != (unsigned long)bucket)
                {
                  {
                    printf("\nSTMT_EXEC;;36674\n");
free_entry(new_table, cursor);
                  }
                }
              }
              printf("\nSTMT_EXEC;;36678\n");
cursor = next;
            }
          while_break___0: /* CIL Label */;
          }
        }
        printf("\nSTMT_EXEC;;36683\n");
bucket++;
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;36688\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)table___0->bucket);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36689\n");
table___0->bucket = new_table->bucket;
      printf("\nSTMT_EXEC;;36690\n");
table___0->bucket_limit = new_table->bucket_limit;
      printf("\nSTMT_EXEC;;36691\n");
table___0->n_buckets = new_table->n_buckets;
      printf("\nSTMT_EXEC;;36692\n");
table___0->n_buckets_used = new_table->n_buckets_used;
      printf("\nSTMT_EXEC;;36693\n");
table___0->free_entry_list = new_table->free_entry_list;
      printf("\nSTMT_EXEC;;36694\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)new_table);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;36696\n");
printf("\nFUNC_RETURN;;\n");
return ((_Bool)1);
  }
printf("\nFUNC_RETURN;;\n");
}
void *hash_insert(Hash_table *table___0, void const *entry)
{
  printf("\nFUNC_CALL;hash_insert(Hash_table *,const void *);\n");
printf("\nSTMT_EXEC;;36701\n");
void *data;
  printf("\nSTMT_EXEC;;36702\n");
struct hash_entry *bucket;
  printf("\nSTMT_EXEC;;36703\n");
struct hash_entry *new_entry;
  printf("\nSTMT_EXEC;;36704\n");
struct hash_entry *tmp;
  printf("\nSTMT_EXEC;;36705\n");
Hash_tuning const *tuning;
  printf("\nSTMT_EXEC;;36706\n");
float candidate;
  printf("\nSTMT_EXEC;;36707\n");
_Bool tmp___0;
  printf("\nSTMT_EXEC;;36708\n");
float tmp___1;

  {
    printf("\nSTMT_EXEC;;36711\n");
if (!entry)
    {
      {
        printf("\nSTMT_EXEC;;36714\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    {
      printf("\nSTMT_EXEC;;36718\n");
data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
    }
    printf("\nSTMT_EXEC;;36720\n");
if ((unsigned long)data != (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;36722\n");
printf("\nFUNC_RETURN;;\n");
return (data);
    }
    printf("\nSTMT_EXEC;;36724\n");
if (bucket->data)
    {
      {
        printf("\nSTMT_EXEC;;36727\n");
tmp = allocate_entry(table___0);
        printf("\nSTMT_EXEC;;36728\n");
new_entry = tmp;
      }
      printf("\nSTMT_EXEC;;36730\n");
if ((unsigned long)new_entry == (unsigned long)((void *)0))
      {
        printf("\nSTMT_EXEC;;36732\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
      }
      printf("\nSTMT_EXEC;;36734\n");
new_entry->data = (void *)entry;
      printf("\nSTMT_EXEC;;36735\n");
new_entry->next = bucket->next;
      printf("\nSTMT_EXEC;;36736\n");
bucket->next = new_entry;
      printf("\nSTMT_EXEC;;36737\n");
(table___0->n_entries)++;
      printf("\nSTMT_EXEC;;36738\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)entry);
    }
    printf("\nSTMT_EXEC;;36740\n");
bucket->data = (void *)entry;
    printf("\nSTMT_EXEC;;36741\n");
(table___0->n_entries)++;
    printf("\nSTMT_EXEC;;36742\n");
(table___0->n_buckets_used)++;
    printf("\nSTMT_EXEC;;36743\n");
if ((float const)table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const)table___0->n_buckets)
    {
      {
        printf("\nSTMT_EXEC;;36746\n");
check_tuning(table___0);
      }
      printf("\nSTMT_EXEC;;36748\n");
if ((float const)table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const)table___0->n_buckets)
      {
        printf("\nSTMT_EXEC;;36750\n");
tuning = table___0->tuning;
        printf("\nSTMT_EXEC;;36751\n");
if (tuning->is_n_buckets)
        {
          printf("\nSTMT_EXEC;;36753\n");
tmp___1 = (float const)table___0->n_buckets * tuning->growth_factor;
        }
        else
        {
          printf("\nSTMT_EXEC;;36757\n");
tmp___1 = ((float const)table___0->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
        }
        printf("\nSTMT_EXEC;;36759\n");
candidate = (float)tmp___1;
        printf("\nSTMT_EXEC;;36760\n");
if ((float)0xffffffffffffffffUL <= candidate)
        {
          printf("\nSTMT_EXEC;;36762\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)0);
        }
        {
          printf("\nSTMT_EXEC;;36765\n");
tmp___0 = hash_rehash(table___0, (size_t)candidate);
        }
        printf("\nSTMT_EXEC;;36767\n");
if (!tmp___0)
        {
          printf("\nSTMT_EXEC;;36769\n");
entry = (void const *)((void *)0);
        }
      }
    }
    printf("\nSTMT_EXEC;;36773\n");
printf("\nFUNC_RETURN;;\n");
return ((void *)entry);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","01e.human.o.i","") */
extern __attribute__((__nothrow__)) struct lconv *(__attribute__((__leaf__)) localeconv)(void);
extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2), __leaf__)) memmove)(void *__dest, void const *__src, size_t __n);
static char const power_letter[9] = {(char const)0, (char const)'K', (char const)'M', (char const)'G', (char const)'T', (char const)'P', (char const)'E', (char const)'Z', (char const)'Y'};
static long double adjust_value(int inexact_style, long double value)
{
  printf("\nFUNC_CALL;adjust_value(int,long double);\n");
printf("\nSTMT_EXEC;;36782\n");
uintmax_t u;
  printf("\nSTMT_EXEC;;36783\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;36786\n");
if (inexact_style != 1)
    {
      printf("\nSTMT_EXEC;;36788\n");
if (value < (long double)0xffffffffffffffffUL)
      {
        printf("\nSTMT_EXEC;;36790\n");
u = (uintmax_t)value;
        printf("\nSTMT_EXEC;;36791\n");
if (inexact_style == 0)
        {
          printf("\nSTMT_EXEC;;36793\n");
if ((long double)u != value)
          {
            printf("\nSTMT_EXEC;;36795\n");
tmp = 1;
          }
          else
          {
            printf("\nSTMT_EXEC;;36799\n");
tmp = 0;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;36804\n");
tmp = 0;
        }
        printf("\nSTMT_EXEC;;36806\n");
value = (long double)(u + (uintmax_t)tmp);
      }
    }
    printf("\nSTMT_EXEC;;36809\n");
printf("\nFUNC_RETURN;;\n");
return (value);
  }
printf("\nFUNC_RETURN;;\n");
}
static char *group_number(char *number, size_t numberlen, char const *grouping, char const *thousands_sep)
{
  printf("\nFUNC_CALL;group_number(char *,size_t,const char *,const char *);\n");
printf("\nSTMT_EXEC;;36814\n");
register char *d;
  printf("\nSTMT_EXEC;;36815\n");
size_t grouplen;
  printf("\nSTMT_EXEC;;36816\n");
size_t thousands_seplen;
  printf("\nSTMT_EXEC;;36817\n");
size_t tmp;
  printf("\nSTMT_EXEC;;36818\n");
size_t i;
  printf("\nSTMT_EXEC;;36819\n");
char buf[(((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL];
  printf("\nSTMT_EXEC;;36820\n");
unsigned char g;
  printf("\nSTMT_EXEC;;36821\n");
void *__cil_tmp12;

  {
    {
      printf("\nSTMT_EXEC;;36825\n");
grouplen = 0xffffffffffffffffUL;
      printf("\nSTMT_EXEC;;36826\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(thousands_sep);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36827\n");
thousands_seplen = tmp;
      printf("\nSTMT_EXEC;;36828\n");
i = numberlen;
      printf("\nSTMT_EXEC;;36829\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(buf), (void const * /* __restrict  */)number, numberlen);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36830\n");
d = number + numberlen;
    }
    {
      printf("\nSTMT_EXEC;;36833\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;36836\n");
g = (unsigned char)*grouping;
        printf("\nSTMT_EXEC;;36837\n");
if (g)
        {
          printf("\nSTMT_EXEC;;36839\n");
if ((int)g < 127)
          {
            printf("\nSTMT_EXEC;;36841\n");
grouplen = (size_t)g;
          }
          else
          {
            printf("\nSTMT_EXEC;;36845\n");
grouplen = i;
          }
          printf("\nSTMT_EXEC;;36847\n");
grouping++;
        }
        printf("\nSTMT_EXEC;;36849\n");
if (i < grouplen)
        {
          printf("\nSTMT_EXEC;;36851\n");
grouplen = i;
        }
        {
          printf("\nSTMT_EXEC;;36854\n");
d -= grouplen;
          printf("\nSTMT_EXEC;;36855\n");
i -= grouplen;
          printf("\nSTMT_EXEC;;36856\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)d, (void const * /* __restrict  */)(buf + i), grouplen);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;36858\n");
if (i == 0UL)
        {
          printf("\nSTMT_EXEC;;36860\n");
printf("\nFUNC_RETURN;;\n");
return (d);
        }
        {
          printf("\nSTMT_EXEC;;36863\n");
d -= thousands_seplen;
          printf("\nSTMT_EXEC;;36864\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)d, (void const * /* __restrict  */)thousands_sep, thousands_seplen);printf("\nFUNC_RETURN;;\n");

        }
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
char *human_readable(uintmax_t n, char *buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size)
{
  printf("\nFUNC_CALL;human_readable(uintmax_t,char *,int,uintmax_t,uintmax_t);\n");
printf("\nSTMT_EXEC;;36873\n");
int inexact_style;
  printf("\nSTMT_EXEC;;36874\n");
unsigned int base;
  printf("\nSTMT_EXEC;;36875\n");
uintmax_t amt;
  printf("\nSTMT_EXEC;;36876\n");
int tenths;
  printf("\nSTMT_EXEC;;36877\n");
int exponent;
  printf("\nSTMT_EXEC;;36878\n");
int exponent_max;
  printf("\nSTMT_EXEC;;36879\n");
char *p;
  printf("\nSTMT_EXEC;;36880\n");
char *psuffix;
  printf("\nSTMT_EXEC;;36881\n");
char const *integerlim;
  printf("\nSTMT_EXEC;;36882\n");
int rounding;
  printf("\nSTMT_EXEC;;36883\n");
char const *decimal_point;
  printf("\nSTMT_EXEC;;36884\n");
size_t decimal_pointlen;
  printf("\nSTMT_EXEC;;36885\n");
char const *grouping;
  printf("\nSTMT_EXEC;;36886\n");
char const *thousands_sep;
  printf("\nSTMT_EXEC;;36887\n");
struct lconv const *l;
  printf("\nSTMT_EXEC;;36888\n");
struct lconv *tmp;
  printf("\nSTMT_EXEC;;36889\n");
size_t pointlen;
  printf("\nSTMT_EXEC;;36890\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;36891\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;36892\n");
uintmax_t multiplier;
  printf("\nSTMT_EXEC;;36893\n");
uintmax_t divisor;
  printf("\nSTMT_EXEC;;36894\n");
uintmax_t r10;
  printf("\nSTMT_EXEC;;36895\n");
uintmax_t r2;
  printf("\nSTMT_EXEC;;36896\n");
long double dto_block_size;
  printf("\nSTMT_EXEC;;36897\n");
long double damt;
  printf("\nSTMT_EXEC;;36898\n");
size_t buflen;
  printf("\nSTMT_EXEC;;36899\n");
size_t nonintegerlen;
  printf("\nSTMT_EXEC;;36900\n");
long double tmp___2;
  printf("\nSTMT_EXEC;;36901\n");
long double e;
  printf("\nSTMT_EXEC;;36902\n");
long double tmp___3;
  printf("\nSTMT_EXEC;;36903\n");
long double tmp___4;
  printf("\nSTMT_EXEC;;36904\n");
unsigned int r10___0;
  printf("\nSTMT_EXEC;;36905\n");
unsigned int r2___0;
  printf("\nSTMT_EXEC;;36906\n");
int digit;
  printf("\nSTMT_EXEC;;36907\n");
uintmax_t power;
  printf("\nSTMT_EXEC;;36908\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;36909\n");
char *tmp___6;
  printf("\nSTMT_EXEC;;36910\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;36911\n");
int tmp___8;
  printf("\nSTMT_EXEC;;36912\n");
int tmp___9;
  printf("\nSTMT_EXEC;;36913\n");
int tmp___10;
  printf("\nSTMT_EXEC;;36914\n");
int tmp___11;
  printf("\nSTMT_EXEC;;36915\n");
int tmp___12;
  printf("\nSTMT_EXEC;;36916\n");
int tmp___13;
  printf("\nSTMT_EXEC;;36917\n");
char *__cil_tmp50;
  printf("\nSTMT_EXEC;;36918\n");
char *__cil_tmp51;
  printf("\nSTMT_EXEC;;36919\n");
char *__cil_tmp52;
  printf("\nSTMT_EXEC;;36920\n");
char *__cil_tmp53;
  printf("\nSTMT_EXEC;;36921\n");
char *__cil_tmp54;
  printf("\nSTMT_EXEC;;36922\n");
char *__cil_tmp55;
  printf("\nSTMT_EXEC;;36923\n");
char *__cil_tmp56;

  {
    printf("\nSTMT_EXEC;;36926\n");
inexact_style = opts & 3;
    printf("\nSTMT_EXEC;;36927\n");
if (opts & 32)
    {
      printf("\nSTMT_EXEC;;36929\n");
tmp___8 = 1024;
    }
    else
    {
      printf("\nSTMT_EXEC;;36933\n");
tmp___8 = 1000;
    }
    {
      printf("\nSTMT_EXEC;;36936\n");
base = (unsigned int)tmp___8;
      printf("\nSTMT_EXEC;;36937\n");
exponent = -1;
      printf("\nSTMT_EXEC;;36938\n");
exponent_max = (int)(sizeof(power_letter) - 1UL);
      printf("\nSTMT_EXEC;;36939\n");
decimal_point = ".";
      printf("\nSTMT_EXEC;;36940\n");
decimal_pointlen = (size_t)1;
      printf("\nSTMT_EXEC;;36941\n");
grouping = "";
      printf("\nSTMT_EXEC;;36942\n");
thousands_sep = "";
      printf("\nSTMT_EXEC;;36943\n");
printf("\nFUNC_CALL;localeconv();\n");
tmp = localeconv();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36944\n");
l = (struct lconv const *)tmp;
      printf("\nSTMT_EXEC;;36945\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___0 = strlen((char const *)l->decimal_point);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;36946\n");
pointlen = tmp___0;
    }
    printf("\nSTMT_EXEC;;36948\n");
if (0UL < pointlen)
    {
      printf("\nSTMT_EXEC;;36950\n");
if (pointlen <= 16UL)
      {
        printf("\nSTMT_EXEC;;36952\n");
decimal_point = (char const *)l->decimal_point;
        printf("\nSTMT_EXEC;;36953\n");
decimal_pointlen = pointlen;
      }
    }
    {
      printf("\nSTMT_EXEC;;36957\n");
grouping = (char const *)l->grouping;
      printf("\nSTMT_EXEC;;36958\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen((char const *)l->thousands_sep);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;36960\n");
if (tmp___1 <= 16UL)
    {
      printf("\nSTMT_EXEC;;36962\n");
thousands_sep = (char const *)l->thousands_sep;
    }
    printf("\nSTMT_EXEC;;36964\n");
psuffix = (buf + ((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) * 17UL - 16UL) + 3UL)) - 3;
    printf("\nSTMT_EXEC;;36965\n");
p = psuffix;
    printf("\nSTMT_EXEC;;36966\n");
if (to_block_size <= from_block_size)
    {
      printf("\nSTMT_EXEC;;36968\n");
if (from_block_size % to_block_size == 0UL)
      {
        printf("\nSTMT_EXEC;;36970\n");
multiplier = from_block_size / to_block_size;
        printf("\nSTMT_EXEC;;36971\n");
amt = n * multiplier;
        printf("\nSTMT_EXEC;;36972\n");
if (amt / multiplier == n)
        {
          printf("\nSTMT_EXEC;;36974\n");
tenths = 0;
          printf("\nSTMT_EXEC;;36975\n");
rounding = 0;
          printf("\nSTMT_EXEC;;36976\n");
goto use_integer_arithmetic;
        }
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;36982\n");
if (from_block_size != 0UL)
      {
        printf("\nSTMT_EXEC;;36984\n");
if (to_block_size % from_block_size == 0UL)
        {
          printf("\nSTMT_EXEC;;36986\n");
divisor = to_block_size / from_block_size;
          printf("\nSTMT_EXEC;;36987\n");
r10 = (n % divisor) * 10UL;
          printf("\nSTMT_EXEC;;36988\n");
r2 = (r10 % divisor) * 2UL;
          printf("\nSTMT_EXEC;;36989\n");
amt = n / divisor;
          printf("\nSTMT_EXEC;;36990\n");
tenths = (int)(r10 / divisor);
          printf("\nSTMT_EXEC;;36991\n");
if (r2 < divisor)
          {
            printf("\nSTMT_EXEC;;36993\n");
rounding = 0UL < r2;
          }
          else
          {
            printf("\nSTMT_EXEC;;36997\n");
rounding = 2 + (divisor < r2);
          }
          printf("\nSTMT_EXEC;;36999\n");
goto use_integer_arithmetic;
        }
      }
    }
    printf("\nSTMT_EXEC;;37003\n");
dto_block_size = (long double)to_block_size;
    printf("\nSTMT_EXEC;;37004\n");
damt = (long double)n * ((long double)from_block_size / dto_block_size);
    printf("\nSTMT_EXEC;;37005\n");
if (!(opts & 16))
    {
      {
        printf("\nSTMT_EXEC;;37008\n");
tmp___2 = adjust_value(inexact_style, damt);
        printf("\nSTMT_EXEC;;37009\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)buf, (char const * /* __restrict  */) "%.0Lf", tmp___2);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;37010\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
buflen = strlen((char const *)buf);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;37011\n");
nonintegerlen = (size_t)0;
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;37016\n");
e = (long double)1;
      printf("\nSTMT_EXEC;;37017\n");
exponent = 0;
      {
        printf("\nSTMT_EXEC;;37019\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;37022\n");
e *= (long double)base;
          printf("\nSTMT_EXEC;;37023\n");
exponent++;
          printf("\nSTMT_EXEC;;37024\n");
if (e * (long double)base <= damt)
          {
            printf("\nSTMT_EXEC;;37026\n");
if (!(exponent < exponent_max))
            {
              printf("\nSTMT_EXEC;;37028\n");
goto while_break;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;37033\n");
goto while_break;
          }
        }
      while_break: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;37039\n");
damt /= e;
        printf("\nSTMT_EXEC;;37040\n");
tmp___3 = adjust_value(inexact_style, damt);
        printf("\nSTMT_EXEC;;37041\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)buf, (char const * /* __restrict  */) "%.1Lf", tmp___3);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;37042\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
buflen = strlen((char const *)buf);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;37043\n");
nonintegerlen = decimal_pointlen + 1UL;
      }
      printf("\nSTMT_EXEC;;37045\n");
if ((1UL + nonintegerlen) + (size_t)(!(opts & 32)) < buflen)
      {
        {
          printf("\nSTMT_EXEC;;37048\n");
tmp___4 = adjust_value(inexact_style, damt * (long double)10);
          printf("\nSTMT_EXEC;;37049\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)buf, (char const * /* __restrict  */) "%.0Lf", tmp___4 / (long double)10);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;37050\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
buflen = strlen((char const *)buf);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;37051\n");
nonintegerlen = (size_t)0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;37056\n");
if (opts & 8)
        {
          printf("\nSTMT_EXEC;;37058\n");
if ((int)*(buf + (buflen - 1UL)) == 48)
          {
            {
              printf("\nSTMT_EXEC;;37061\n");
tmp___4 = adjust_value(inexact_style, damt * (long double)10);
              printf("\nSTMT_EXEC;;37062\n");
printf("\nFUNC_CALL;sprintf(char *__restrict,const char *__restrict);\n");
sprintf((char * /* __restrict  */)buf, (char const * /* __restrict  */) "%.0Lf", tmp___4 / (long double)10);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;37063\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
buflen = strlen((char const *)buf);printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;37064\n");
nonintegerlen = (size_t)0;
            }
          }
        }
      }
    }
    {
      printf("\nSTMT_EXEC;;37071\n");
p = psuffix - buflen;
      printf("\nSTMT_EXEC;;37072\n");
printf("\nFUNC_CALL;memmove(void *,const void *,size_t);\n");
memmove((void *)p, (void const *)buf, buflen);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;37073\n");
integerlim = (char const *)((p + buflen) - nonintegerlen);
    }
    printf("\nSTMT_EXEC;;37075\n");
goto do_grouping;
  use_integer_arithmetic:
    {
printf("\nSTMT_EXEC;;37077\n");
if (opts & 16)
    {
      printf("\nSTMT_EXEC;;37079\n");
exponent = 0;
      printf("\nSTMT_EXEC;;37080\n");
if ((uintmax_t)base <= amt)
      {
        {
          printf("\nSTMT_EXEC;;37083\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            printf("\nSTMT_EXEC;;37086\n");
r10___0 = (unsigned int)((amt % (unsigned long)base) * 10UL + (unsigned long)tenths);
            printf("\nSTMT_EXEC;;37087\n");
r2___0 = (r10___0 % base) * 2U + (unsigned int)(rounding >> 1);
            printf("\nSTMT_EXEC;;37088\n");
amt /= (uintmax_t)base;
            printf("\nSTMT_EXEC;;37089\n");
tenths = (int)(r10___0 / base);
            printf("\nSTMT_EXEC;;37090\n");
if (r2___0 < base)
            {
              printf("\nSTMT_EXEC;;37092\n");
rounding = r2___0 + (unsigned int)rounding != 0U;
            }
            else
            {
              printf("\nSTMT_EXEC;;37096\n");
rounding = 2 + (base < r2___0 + (unsigned int)rounding);
            }
            printf("\nSTMT_EXEC;;37098\n");
exponent++;
            printf("\nSTMT_EXEC;;37099\n");
if ((uintmax_t)base <= amt)
            {
              printf("\nSTMT_EXEC;;37101\n");
if (!(exponent < exponent_max))
              {
                printf("\nSTMT_EXEC;;37103\n");
goto while_break___0;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;37108\n");
goto while_break___0;
            }
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;37113\n");
if (amt < 10UL)
        {
          printf("\nSTMT_EXEC;;37115\n");
if (inexact_style == 1)
          {
            printf("\nSTMT_EXEC;;37117\n");
tmp___10 = 2 < rounding + (tenths & 1);
          }
          else
          {
            printf("\nSTMT_EXEC;;37121\n");
if (inexact_style == 0)
            {
              printf("\nSTMT_EXEC;;37123\n");
if (0 < rounding)
              {
                printf("\nSTMT_EXEC;;37125\n");
tmp___9 = 1;
              }
              else
              {
                printf("\nSTMT_EXEC;;37129\n");
tmp___9 = 0;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;37134\n");
tmp___9 = 0;
            }
            printf("\nSTMT_EXEC;;37136\n");
tmp___10 = tmp___9;
          }
          printf("\nSTMT_EXEC;;37138\n");
if (tmp___10)
          {
            printf("\nSTMT_EXEC;;37140\n");
tenths++;
            printf("\nSTMT_EXEC;;37141\n");
rounding = 0;
            printf("\nSTMT_EXEC;;37142\n");
if (tenths == 10)
            {
              printf("\nSTMT_EXEC;;37144\n");
amt++;
              printf("\nSTMT_EXEC;;37145\n");
tenths = 0;
            }
          }
          printf("\nSTMT_EXEC;;37148\n");
if (amt < 10UL)
          {
            printf("\nSTMT_EXEC;;37150\n");
if (tenths)
            {
              printf("\nSTMT_EXEC;;37152\n");
goto _L___3;
            }
            else
            {
              printf("\nSTMT_EXEC;;37156\n");
if (!(opts & 8))
              {
              _L___3: /* CIL Label */
              {
                printf("\nSTMT_EXEC;;37160\n");
p--;
                printf("\nSTMT_EXEC;;37161\n");
*p = (char)(48 + tenths);
                printf("\nSTMT_EXEC;;37162\n");
p -= decimal_pointlen;
                printf("\nSTMT_EXEC;;37163\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)p, (void const * /* __restrict  */)decimal_point, decimal_pointlen);printf("\nFUNC_RETURN;;\n");

                printf("\nSTMT_EXEC;;37164\n");
rounding = 0;
                printf("\nSTMT_EXEC;;37165\n");
tenths = rounding;
              }
              }
            }
          }
        }
      }
    }
}

    printf("\nSTMT_EXEC;;37173\n");
if (inexact_style == 1)
    {
      printf("\nSTMT_EXEC;;37175\n");
tmp___12 = 5 < tenths + (0UL < (unsigned long)rounding + (amt & 1UL));
    }
    else
    {
      printf("\nSTMT_EXEC;;37179\n");
if (inexact_style == 0)
      {
        printf("\nSTMT_EXEC;;37181\n");
if (0 < tenths + rounding)
        {
          printf("\nSTMT_EXEC;;37183\n");
tmp___11 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;37187\n");
tmp___11 = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;37192\n");
tmp___11 = 0;
      }
      printf("\nSTMT_EXEC;;37194\n");
tmp___12 = tmp___11;
    }
    printf("\nSTMT_EXEC;;37196\n");
if (tmp___12)
    {
      printf("\nSTMT_EXEC;;37198\n");
amt++;
      printf("\nSTMT_EXEC;;37199\n");
if (opts & 16)
      {
        printf("\nSTMT_EXEC;;37201\n");
if (amt == (uintmax_t)base)
        {
          printf("\nSTMT_EXEC;;37203\n");
if (exponent < exponent_max)
          {
            printf("\nSTMT_EXEC;;37205\n");
exponent++;
            printf("\nSTMT_EXEC;;37206\n");
if (!(opts & 8))
            {
              {
                printf("\nSTMT_EXEC;;37209\n");
p--;
                printf("\nSTMT_EXEC;;37210\n");
*p = (char)'0';
                printf("\nSTMT_EXEC;;37211\n");
p -= decimal_pointlen;
                printf("\nSTMT_EXEC;;37212\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)p, (void const * /* __restrict  */)decimal_point, decimal_pointlen);printf("\nFUNC_RETURN;;\n");

              }
            }
            printf("\nSTMT_EXEC;;37215\n");
amt = (uintmax_t)1;
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;37220\n");
integerlim = (char const *)p;
    {
      printf("\nSTMT_EXEC;;37222\n");
while (1)
      {
      while_continue___1: /* CIL Label */;
        printf("\nSTMT_EXEC;;37225\n");
digit = (int)(amt % 10UL);
        printf("\nSTMT_EXEC;;37226\n");
p--;
        printf("\nSTMT_EXEC;;37227\n");
*p = (char)(digit + 48);
        printf("\nSTMT_EXEC;;37228\n");
amt /= 10UL;
        printf("\nSTMT_EXEC;;37229\n");
if (!(amt != 0UL))
        {
          printf("\nSTMT_EXEC;;37231\n");
goto while_break___1;
        }
      }
    while_break___1: /* CIL Label */;
    }
  do_grouping:
    {
printf("\nSTMT_EXEC;;37237\n");
if (opts & 4)
    {
      {
        printf("\nSTMT_EXEC;;37240\n");
p = group_number(p, (size_t)(integerlim - (char const *)p), grouping, thousands_sep);
      }
    }
}

    printf("\nSTMT_EXEC;;37243\n");
if (opts & 64)
    {
      printf("\nSTMT_EXEC;;37245\n");
if (exponent < 0)
      {
        printf("\nSTMT_EXEC;;37247\n");
exponent = 0;
        printf("\nSTMT_EXEC;;37248\n");
power = (uintmax_t)1;
        {
          printf("\nSTMT_EXEC;;37250\n");
while (1)
          {
          while_continue___2: /* CIL Label */;
            printf("\nSTMT_EXEC;;37253\n");
if (!(power < to_block_size))
            {
              printf("\nSTMT_EXEC;;37255\n");
goto while_break___2;
            }
            printf("\nSTMT_EXEC;;37257\n");
exponent++;
            printf("\nSTMT_EXEC;;37258\n");
if (exponent == exponent_max)
            {
              printf("\nSTMT_EXEC;;37260\n");
goto while_break___2;
            }
            printf("\nSTMT_EXEC;;37262\n");
power *= (uintmax_t)base;
          }
        while_break___2: /* CIL Label */;
        }
      }
      printf("\nSTMT_EXEC;;37267\n");
if (exponent)
      {
        printf("\nSTMT_EXEC;;37269\n");
tmp___5 = psuffix;
        printf("\nSTMT_EXEC;;37270\n");
psuffix++;
        printf("\nSTMT_EXEC;;37271\n");
if (!(opts & 32))
        {
          printf("\nSTMT_EXEC;;37273\n");
if (exponent == 1)
          {
            printf("\nSTMT_EXEC;;37275\n");
tmp___13 = 'k';
          }
          else
          {
            printf("\nSTMT_EXEC;;37279\n");
tmp___13 = (int)power_letter[exponent];
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;37284\n");
tmp___13 = (int)power_letter[exponent];
        }
        printf("\nSTMT_EXEC;;37286\n");
*tmp___5 = (char)tmp___13;
      }
      printf("\nSTMT_EXEC;;37288\n");
if (opts & 128)
      {
        printf("\nSTMT_EXEC;;37290\n");
if (opts & 32)
        {
          printf("\nSTMT_EXEC;;37292\n");
if (exponent)
          {
            printf("\nSTMT_EXEC;;37294\n");
tmp___6 = psuffix;
            printf("\nSTMT_EXEC;;37295\n");
psuffix++;
            printf("\nSTMT_EXEC;;37296\n");
*tmp___6 = (char)'i';
          }
        }
        printf("\nSTMT_EXEC;;37299\n");
tmp___7 = psuffix;
        printf("\nSTMT_EXEC;;37300\n");
psuffix++;
        printf("\nSTMT_EXEC;;37301\n");
*tmp___7 = (char)'B';
      }
    }
    printf("\nSTMT_EXEC;;37304\n");
*psuffix = (char)'\000';
    printf("\nSTMT_EXEC;;37305\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }
printf("\nFUNC_RETURN;;\n");
}
static char const *const block_size_args[3] = {(char const * /* const  */) "human-readable", (char const * /* const  */) "si", (char const * /* const  */)0};
static int const block_size_opts[2] = {(int const)112, (int const)80};
/* #pragma merger("0","01f.mktime.o.i","") */
extern __attribute__((__nothrow__)) struct tm *(__attribute__((__leaf__)) localtime_r)(time_t const *__restrict __timer, struct tm *__restrict __tp);
__inline static int leapyear(int year)
{
  printf("\nFUNC_CALL;leapyear(int);\n");
printf("\nSTMT_EXEC;;37314\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;37317\n");
if ((year & 3) == 0)
    {
      printf("\nSTMT_EXEC;;37319\n");
if (year % 100 != 0)
      {
        printf("\nSTMT_EXEC;;37321\n");
tmp = 1;
      }
      else
      {
        printf("\nSTMT_EXEC;;37325\n");
if ((year / 100 & 3) == 1)
        {
          printf("\nSTMT_EXEC;;37327\n");
tmp = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;37331\n");
tmp = 0;
        }
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;37337\n");
tmp = 0;
    }
    printf("\nSTMT_EXEC;;37339\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static unsigned short const __mon_yday[2][13] = {{(unsigned short const)0, (unsigned short const)31, (unsigned short const)59, (unsigned short const)90, (unsigned short const)120, (unsigned short const)151, (unsigned short const)181, (unsigned short const)212, (unsigned short const)243, (unsigned short const)273, (unsigned short const)304, (unsigned short const)334, (unsigned short const)365}, {(unsigned short const)0, (unsigned short const)31, (unsigned short const)60, (unsigned short const)91, (unsigned short const)121, (unsigned short const)152, (unsigned short const)182, (unsigned short const)213, (unsigned short const)244, (unsigned short const)274, (unsigned short const)305, (unsigned short const)335, (unsigned short const)366}};
__inline static time_t ydhms_diff(long year1, long yday1, int hour1, int min1, int sec1, int year0, int yday0, int hour0, int min0, int sec0)
{
  printf("\nFUNC_CALL;ydhms_diff(long,long,int,int,int,int,int,int,int,int);\n");
printf("\nSTMT_EXEC;;37345\n");
int a4;
  printf("\nSTMT_EXEC;;37346\n");
int b4;
  printf("\nSTMT_EXEC;;37347\n");
int a100;
  printf("\nSTMT_EXEC;;37348\n");
int b100;
  printf("\nSTMT_EXEC;;37349\n");
int a400;
  printf("\nSTMT_EXEC;;37350\n");
int b400;
  printf("\nSTMT_EXEC;;37351\n");
int intervening_leap_days;
  printf("\nSTMT_EXEC;;37352\n");
time_t tyear1;
  printf("\nSTMT_EXEC;;37353\n");
time_t years;
  printf("\nSTMT_EXEC;;37354\n");
time_t days;
  printf("\nSTMT_EXEC;;37355\n");
time_t hours;
  printf("\nSTMT_EXEC;;37356\n");
time_t minutes;
  printf("\nSTMT_EXEC;;37357\n");
time_t seconds;

  {
    printf("\nSTMT_EXEC;;37360\n");
a4 = (int)(((year1 >> 2) + (long)(1900 >> 2)) - (long)(!(year1 & 3L)));
    printf("\nSTMT_EXEC;;37361\n");
b4 = ((year0 >> 2) + (1900 >> 2)) - !(year0 & 3);
    printf("\nSTMT_EXEC;;37362\n");
a100 = a4 / 25 - (a4 % 25 < 0);
    printf("\nSTMT_EXEC;;37363\n");
b100 = b4 / 25 - (b4 % 25 < 0);
    printf("\nSTMT_EXEC;;37364\n");
a400 = a100 >> 2;
    printf("\nSTMT_EXEC;;37365\n");
b400 = b100 >> 2;
    printf("\nSTMT_EXEC;;37366\n");
intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
    printf("\nSTMT_EXEC;;37367\n");
tyear1 = year1;
    printf("\nSTMT_EXEC;;37368\n");
years = tyear1 - (time_t)year0;
    printf("\nSTMT_EXEC;;37369\n");
days = ((365L * years + yday1) - (time_t)yday0) + (time_t)intervening_leap_days;
    printf("\nSTMT_EXEC;;37370\n");
hours = (24L * days + (time_t)hour1) - (time_t)hour0;
    printf("\nSTMT_EXEC;;37371\n");
minutes = (60L * hours + (time_t)min1) - (time_t)min0;
    printf("\nSTMT_EXEC;;37372\n");
seconds = (60L * minutes + (time_t)sec1) - (time_t)sec0;
    printf("\nSTMT_EXEC;;37373\n");
printf("\nFUNC_RETURN;;\n");
return (seconds);
  }
printf("\nFUNC_RETURN;;\n");
}
static time_t guess_time_tm(long year, long yday, int hour, int min, int sec, time_t const *t, struct tm const *tp)
{
  printf("\nFUNC_CALL;guess_time_tm(long,long,int,int,int,const time_t *,const struct tm *);\n");
printf("\nSTMT_EXEC;;37378\n");
time_t d;
  printf("\nSTMT_EXEC;;37379\n");
time_t tmp;
  printf("\nSTMT_EXEC;;37380\n");
time_t t1;
  printf("\nSTMT_EXEC;;37381\n");
long tmp___0;

  {
    printf("\nSTMT_EXEC;;37384\n");
if (tp)
    {
      {
        printf("\nSTMT_EXEC;;37387\n");
tmp = ydhms_diff(year, yday, hour, min, sec, (int)tp->tm_year, (int)tp->tm_yday, (int)tp->tm_hour, (int)tp->tm_min, (int)tp->tm_sec);
        printf("\nSTMT_EXEC;;37388\n");
d = tmp;
        printf("\nSTMT_EXEC;;37389\n");
t1 = (time_t)(*t + (time_t const)d);
      }
      printf("\nSTMT_EXEC;;37391\n");
if ((t1 < (time_t)*t) == (d < 0L))
      {
        printf("\nSTMT_EXEC;;37393\n");
printf("\nFUNC_RETURN;;\n");
return (t1);
      }
    }
    printf("\nSTMT_EXEC;;37396\n");
if (*t < (time_t const)((((-1L << (sizeof(time_t) * 8UL - 1UL)) + (-1L - (-1L << (sizeof(time_t) * 8UL - 1UL)))) >> 1) + 1L))
    {
      printf("\nSTMT_EXEC;;37398\n");
tmp___0 = (-1L << (sizeof(time_t) * 8UL - 1UL)) + (time_t)(*t == (time_t const)(-1L << (sizeof(time_t) * 8UL - 1UL)));
    }
    else
    {
      printf("\nSTMT_EXEC;;37402\n");
tmp___0 = (-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))) - (time_t)(*t == (time_t const)(-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))));
    }
    printf("\nSTMT_EXEC;;37404\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct tm *ranged_convert(struct tm *(*convert)(time_t const *, struct tm *), time_t *t, struct tm *tp)
{
  printf("\nFUNC_CALL;ranged_convert(struct tm *(*)(const time_t *, struct tm *),time_t *,struct tm *);\n");
printf("\nSTMT_EXEC;;37409\n");
struct tm *r;
  printf("\nSTMT_EXEC;;37410\n");
time_t bad;
  printf("\nSTMT_EXEC;;37411\n");
time_t ok;
  printf("\nSTMT_EXEC;;37412\n");
struct tm tm;
  printf("\nSTMT_EXEC;;37413\n");
time_t mid;
  printf("\nSTMT_EXEC;;37414\n");
time_t tmp;
  printf("\nSTMT_EXEC;;37415\n");
int tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;37419\n");
r = (*convert)((time_t const *)t, tp);
    }
    printf("\nSTMT_EXEC;;37421\n");
if (!r)
    {
      printf("\nSTMT_EXEC;;37423\n");
if (*t)
      {
        printf("\nSTMT_EXEC;;37425\n");
bad = *t;
        printf("\nSTMT_EXEC;;37426\n");
ok = (time_t)0;
        {
          printf("\nSTMT_EXEC;;37428\n");
while (1)
          {
          while_continue: /* CIL Label */;
            printf("\nSTMT_EXEC;;37431\n");
if (bad < 0L)
            {
              printf("\nSTMT_EXEC;;37433\n");
tmp___0 = -1;
            }
            else
            {
              printf("\nSTMT_EXEC;;37437\n");
tmp___0 = 1;
            }
            printf("\nSTMT_EXEC;;37439\n");
if (!(bad != ok + (time_t)tmp___0))
            {
              printf("\nSTMT_EXEC;;37441\n");
goto while_break;
            }
            printf("\nSTMT_EXEC;;37443\n");
if (bad < 0L)
            {
              printf("\nSTMT_EXEC;;37445\n");
tmp = bad + ((ok - bad) >> 1);
            }
            else
            {
              printf("\nSTMT_EXEC;;37449\n");
tmp = ok + ((bad - ok) >> 1);
            }
            {
              printf("\nSTMT_EXEC;;37452\n");
*t = tmp;
              printf("\nSTMT_EXEC;;37453\n");
mid = tmp;
              printf("\nSTMT_EXEC;;37454\n");
r = (*convert)((time_t const *)t, tp);
            }
            printf("\nSTMT_EXEC;;37456\n");
if (r)
            {
              printf("\nSTMT_EXEC;;37458\n");
tm = *r;
              printf("\nSTMT_EXEC;;37459\n");
ok = mid;
            }
            else
            {
              printf("\nSTMT_EXEC;;37463\n");
bad = mid;
            }
          }
        while_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;37468\n");
if (!r)
        {
          printf("\nSTMT_EXEC;;37470\n");
if (ok)
          {
            printf("\nSTMT_EXEC;;37472\n");
*t = ok;
            printf("\nSTMT_EXEC;;37473\n");
*tp = tm;
            printf("\nSTMT_EXEC;;37474\n");
r = tp;
          }
        }
      }
    }
    printf("\nSTMT_EXEC;;37479\n");
printf("\nFUNC_RETURN;;\n");
return (r);
  }
printf("\nFUNC_RETURN;;\n");
}
time_t mktime_internal(struct tm *tp, struct tm *(*convert)(time_t const *, struct tm *), time_t *offset)
{
  printf("\nFUNC_CALL;mktime_internal(struct tm *,struct tm *(*)(const time_t *, struct tm *),time_t *);\n");
printf("\nSTMT_EXEC;;37484\n");
time_t t;
  printf("\nSTMT_EXEC;;37485\n");
time_t gt;
  printf("\nSTMT_EXEC;;37486\n");
time_t t0;
  printf("\nSTMT_EXEC;;37487\n");
time_t t1;
  printf("\nSTMT_EXEC;;37488\n");
time_t t2;
  printf("\nSTMT_EXEC;;37489\n");
struct tm tm;
  printf("\nSTMT_EXEC;;37490\n");
int remaining_probes;
  printf("\nSTMT_EXEC;;37491\n");
int sec;
  printf("\nSTMT_EXEC;;37492\n");
int min;
  printf("\nSTMT_EXEC;;37493\n");
int hour;
  printf("\nSTMT_EXEC;;37494\n");
int mday;
  printf("\nSTMT_EXEC;;37495\n");
int mon;
  printf("\nSTMT_EXEC;;37496\n");
int year_requested;
  printf("\nSTMT_EXEC;;37497\n");
int isdst;
  printf("\nSTMT_EXEC;;37498\n");
int dst2;
  printf("\nSTMT_EXEC;;37499\n");
int mon_remainder;
  printf("\nSTMT_EXEC;;37500\n");
int negative_mon_remainder;
  printf("\nSTMT_EXEC;;37501\n");
int mon_years;
  printf("\nSTMT_EXEC;;37502\n");
long lyear_requested;
  printf("\nSTMT_EXEC;;37503\n");
long year;
  printf("\nSTMT_EXEC;;37504\n");
int mon_yday;
  printf("\nSTMT_EXEC;;37505\n");
int tmp;
  printf("\nSTMT_EXEC;;37506\n");
long lmday;
  printf("\nSTMT_EXEC;;37507\n");
long yday;
  printf("\nSTMT_EXEC;;37508\n");
time_t guessed_offset;
  printf("\nSTMT_EXEC;;37509\n");
int sec_requested;
  printf("\nSTMT_EXEC;;37510\n");
int ALOG2_SECONDS_PER_BIENNIUM;
  printf("\nSTMT_EXEC;;37511\n");
int ALOG2_MINUTES_PER_BIENNIUM;
  printf("\nSTMT_EXEC;;37512\n");
int ALOG2_HOURS_PER_BIENNIUM;
  printf("\nSTMT_EXEC;;37513\n");
int ALOG2_DAYS_PER_BIENNIUM;
  printf("\nSTMT_EXEC;;37514\n");
int LOG2_YEARS_PER_BIENNIUM;
  printf("\nSTMT_EXEC;;37515\n");
int approx_requested_biennia;
  printf("\nSTMT_EXEC;;37516\n");
int approx_biennia;
  printf("\nSTMT_EXEC;;37517\n");
int diff;
  printf("\nSTMT_EXEC;;37518\n");
int abs_diff;
  printf("\nSTMT_EXEC;;37519\n");
time_t time_t_max;
  printf("\nSTMT_EXEC;;37520\n");
time_t time_t_min;
  printf("\nSTMT_EXEC;;37521\n");
time_t overflow_threshold;
  printf("\nSTMT_EXEC;;37522\n");
time_t repaired_t0;
  printf("\nSTMT_EXEC;;37523\n");
struct tm *tmp___0;
  printf("\nSTMT_EXEC;;37524\n");
int stride;
  printf("\nSTMT_EXEC;;37525\n");
int duration_max;
  printf("\nSTMT_EXEC;;37526\n");
int delta_bound;
  printf("\nSTMT_EXEC;;37527\n");
int delta;
  printf("\nSTMT_EXEC;;37528\n");
int direction;
  printf("\nSTMT_EXEC;;37529\n");
time_t ot;
  printf("\nSTMT_EXEC;;37530\n");
struct tm otm;
  printf("\nSTMT_EXEC;;37531\n");
int sec_adjustment;
  printf("\nSTMT_EXEC;;37532\n");
struct tm *tmp___1;
  printf("\nSTMT_EXEC;;37533\n");
int tmp___2;
  printf("\nSTMT_EXEC;;37534\n");
int tmp___3;
  printf("\nSTMT_EXEC;;37535\n");
int tmp___4;

  {
    {
      printf("\nSTMT_EXEC;;37539\n");
remaining_probes = 6;
      printf("\nSTMT_EXEC;;37540\n");
sec = tp->tm_sec;
      printf("\nSTMT_EXEC;;37541\n");
min = tp->tm_min;
      printf("\nSTMT_EXEC;;37542\n");
hour = tp->tm_hour;
      printf("\nSTMT_EXEC;;37543\n");
mday = tp->tm_mday;
      printf("\nSTMT_EXEC;;37544\n");
mon = tp->tm_mon;
      printf("\nSTMT_EXEC;;37545\n");
year_requested = tp->tm_year;
      printf("\nSTMT_EXEC;;37546\n");
isdst = tp->tm_isdst;
      printf("\nSTMT_EXEC;;37547\n");
mon_remainder = mon % 12;
      printf("\nSTMT_EXEC;;37548\n");
negative_mon_remainder = mon_remainder < 0;
      printf("\nSTMT_EXEC;;37549\n");
mon_years = mon / 12 - negative_mon_remainder;
      printf("\nSTMT_EXEC;;37550\n");
lyear_requested = (long)year_requested;
      printf("\nSTMT_EXEC;;37551\n");
year = lyear_requested + (long)mon_years;
      printf("\nSTMT_EXEC;;37552\n");
tmp = leapyear((int)year);
      printf("\nSTMT_EXEC;;37553\n");
mon_yday = (int)((int const)__mon_yday[tmp][mon_remainder + 12 * negative_mon_remainder] - 1);
      printf("\nSTMT_EXEC;;37554\n");
lmday = (long)mday;
      printf("\nSTMT_EXEC;;37555\n");
yday = (long)mon_yday + lmday;
      printf("\nSTMT_EXEC;;37556\n");
guessed_offset = *offset;
      printf("\nSTMT_EXEC;;37557\n");
sec_requested = sec;
    }
    printf("\nSTMT_EXEC;;37559\n");
if (sec < 0)
    {
      printf("\nSTMT_EXEC;;37561\n");
sec = 0;
    }
    printf("\nSTMT_EXEC;;37563\n");
if (59 < sec)
    {
      printf("\nSTMT_EXEC;;37565\n");
sec = 59;
    }
    {
      printf("\nSTMT_EXEC;;37568\n");
t0 = ydhms_diff(year, yday, hour, min, sec, 70, 0, 0, 0, (int)(-guessed_offset));
    }
    printf("\nSTMT_EXEC;;37570\n");
if ((((((-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))) / 2147483647L) / 366L) / 24L) / 60L) / 60L < 3L)
    {
      printf("\nSTMT_EXEC;;37572\n");
ALOG2_SECONDS_PER_BIENNIUM = 26;
      printf("\nSTMT_EXEC;;37573\n");
ALOG2_MINUTES_PER_BIENNIUM = 20;
      printf("\nSTMT_EXEC;;37574\n");
ALOG2_HOURS_PER_BIENNIUM = 14;
      printf("\nSTMT_EXEC;;37575\n");
ALOG2_DAYS_PER_BIENNIUM = 10;
      printf("\nSTMT_EXEC;;37576\n");
LOG2_YEARS_PER_BIENNIUM = 1;
      printf("\nSTMT_EXEC;;37577\n");
approx_requested_biennia = ((((year_requested >> LOG2_YEARS_PER_BIENNIUM) - (70 >> LOG2_YEARS_PER_BIENNIUM)) + (mday >> ALOG2_DAYS_PER_BIENNIUM)) + (hour >> ALOG2_HOURS_PER_BIENNIUM)) + (min >> ALOG2_MINUTES_PER_BIENNIUM);
      printf("\nSTMT_EXEC;;37578\n");
approx_biennia = (int)(t0 >> ALOG2_SECONDS_PER_BIENNIUM);
      printf("\nSTMT_EXEC;;37579\n");
diff = approx_biennia - approx_requested_biennia;
      printf("\nSTMT_EXEC;;37580\n");
if (diff < 0)
      {
        printf("\nSTMT_EXEC;;37582\n");
abs_diff = -diff;
      }
      else
      {
        printf("\nSTMT_EXEC;;37586\n");
abs_diff = diff;
      }
      printf("\nSTMT_EXEC;;37588\n");
time_t_max = -1L - (-1L << (sizeof(time_t) * 8UL - 1UL));
      printf("\nSTMT_EXEC;;37589\n");
time_t_min = -1L << (sizeof(time_t) * 8UL - 1UL);
      printf("\nSTMT_EXEC;;37590\n");
overflow_threshold = (time_t_max / 3L - time_t_min / 3L) >> ALOG2_SECONDS_PER_BIENNIUM;
      printf("\nSTMT_EXEC;;37591\n");
if (overflow_threshold < (time_t)abs_diff)
      {
        printf("\nSTMT_EXEC;;37593\n");
repaired_t0 = -1L - t0;
        printf("\nSTMT_EXEC;;37594\n");
approx_biennia = (int)(repaired_t0 >> ALOG2_SECONDS_PER_BIENNIUM);
        printf("\nSTMT_EXEC;;37595\n");
diff = approx_biennia - approx_requested_biennia;
        printf("\nSTMT_EXEC;;37596\n");
if (diff < 0)
        {
          printf("\nSTMT_EXEC;;37598\n");
abs_diff = -diff;
        }
        else
        {
          printf("\nSTMT_EXEC;;37602\n");
abs_diff = diff;
        }
        printf("\nSTMT_EXEC;;37604\n");
if (overflow_threshold < (time_t)abs_diff)
        {
          printf("\nSTMT_EXEC;;37606\n");
printf("\nFUNC_RETURN;;\n");
return ((time_t)-1);
        }
        printf("\nSTMT_EXEC;;37608\n");
guessed_offset += repaired_t0 - t0;
        printf("\nSTMT_EXEC;;37609\n");
t0 = repaired_t0;
      }
    }
    printf("\nSTMT_EXEC;;37612\n");
t2 = t0;
    printf("\nSTMT_EXEC;;37613\n");
t1 = t2;
    printf("\nSTMT_EXEC;;37614\n");
t = t1;
    printf("\nSTMT_EXEC;;37615\n");
dst2 = 0;
    {
      printf("\nSTMT_EXEC;;37617\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;37621\n");
tmp___0 = ranged_convert(convert, &t, &tm);
          printf("\nSTMT_EXEC;;37622\n");
gt = guess_time_tm(year, yday, hour, min, sec, (time_t const *)(&t), (struct tm const *)tmp___0);
        }
        printf("\nSTMT_EXEC;;37624\n");
if (!(t != gt))
        {
          printf("\nSTMT_EXEC;;37626\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;37628\n");
if (t == t1)
        {
          printf("\nSTMT_EXEC;;37630\n");
if (t != t2)
          {
            printf("\nSTMT_EXEC;;37632\n");
if (tm.tm_isdst < 0)
            {
              printf("\nSTMT_EXEC;;37634\n");
goto offset_found;
            }
            else
            {
              printf("\nSTMT_EXEC;;37638\n");
if (isdst < 0)
              {
                printf("\nSTMT_EXEC;;37640\n");
tmp___3 = dst2 <= (tm.tm_isdst != 0);
              }
              else
              {
                printf("\nSTMT_EXEC;;37644\n");
tmp___3 = (isdst != 0) != (tm.tm_isdst != 0);
              }
              printf("\nSTMT_EXEC;;37646\n");
if (tmp___3)
              {
                printf("\nSTMT_EXEC;;37648\n");
goto offset_found;
              }
              else
              {
                printf("\nSTMT_EXEC;;37652\n");
goto _L___4;
              }
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;37658\n");
goto _L___4;
          }
        }
        else
        {
        _L___4: /* CIL Label */
          {
printf("\nSTMT_EXEC;;37664\n");
remaining_probes--;
}

          printf("\nSTMT_EXEC;;37665\n");
if (remaining_probes == 0)
          {
            printf("\nSTMT_EXEC;;37667\n");
printf("\nFUNC_RETURN;;\n");
return ((time_t)-1);
          }
        }
        printf("\nSTMT_EXEC;;37670\n");
t1 = t2;
        printf("\nSTMT_EXEC;;37671\n");
t2 = t;
        printf("\nSTMT_EXEC;;37672\n");
t = gt;
        printf("\nSTMT_EXEC;;37673\n");
dst2 = tm.tm_isdst != 0;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;37677\n");
if (isdst != tm.tm_isdst)
    {
      printf("\nSTMT_EXEC;;37679\n");
if (0 <= isdst)
      {
        printf("\nSTMT_EXEC;;37681\n");
if (0 <= tm.tm_isdst)
        {
          printf("\nSTMT_EXEC;;37683\n");
stride = 601200;
          printf("\nSTMT_EXEC;;37684\n");
duration_max = 536454000;
          printf("\nSTMT_EXEC;;37685\n");
delta_bound = duration_max / 2 + stride;
          printf("\nSTMT_EXEC;;37686\n");
delta = stride;
          {
            printf("\nSTMT_EXEC;;37688\n");
while (1)
            {
            while_continue___0: /* CIL Label */;
              printf("\nSTMT_EXEC;;37691\n");
if (!(delta < delta_bound))
              {
                printf("\nSTMT_EXEC;;37693\n");
goto while_break___0;
              }
              printf("\nSTMT_EXEC;;37695\n");
direction = -1;
              {
                printf("\nSTMT_EXEC;;37697\n");
while (1)
                {
                while_continue___1: /* CIL Label */;
                  printf("\nSTMT_EXEC;;37700\n");
if (!(direction <= 1))
                  {
                    printf("\nSTMT_EXEC;;37702\n");
goto while_break___1;
                  }
                  printf("\nSTMT_EXEC;;37704\n");
ot = t + (time_t)(delta * direction);
                  printf("\nSTMT_EXEC;;37705\n");
if ((ot < t) == (direction < 0))
                  {
                    {
                      printf("\nSTMT_EXEC;;37708\n");
ranged_convert(convert, &ot, &otm);
                    }
                    printf("\nSTMT_EXEC;;37710\n");
if (otm.tm_isdst == isdst)
                    {
                      {
                        printf("\nSTMT_EXEC;;37713\n");
t = guess_time_tm(year, yday, hour, min, sec, (time_t const *)(&ot), (struct tm const *)(&otm));
                        printf("\nSTMT_EXEC;;37714\n");
ranged_convert(convert, &t, &tm);
                      }
                      printf("\nSTMT_EXEC;;37716\n");
goto offset_found;
                    }
                  }
                  printf("\nSTMT_EXEC;;37719\n");
direction += 2;
                }
              while_break___1: /* CIL Label */;
              }
              printf("\nSTMT_EXEC;;37723\n");
delta += stride;
            }
          while_break___0: /* CIL Label */;
          }
        }
      }
    }
  offset_found:
    {
printf("\nSTMT_EXEC;;37731\n");
*offset = (guessed_offset + t) - t0;
}

    printf("\nSTMT_EXEC;;37732\n");
if (sec_requested != tm.tm_sec)
    {
      printf("\nSTMT_EXEC;;37734\n");
if (sec == 0)
      {
        printf("\nSTMT_EXEC;;37736\n");
if (tm.tm_sec == 60)
        {
          printf("\nSTMT_EXEC;;37738\n");
tmp___4 = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;37742\n");
tmp___4 = 0;
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;37747\n");
tmp___4 = 0;
      }
      {
        printf("\nSTMT_EXEC;;37750\n");
sec_adjustment = tmp___4 - sec;
        printf("\nSTMT_EXEC;;37751\n");
t1 = t + (time_t)sec_requested;
        printf("\nSTMT_EXEC;;37752\n");
t2 = t1 + (time_t)sec_adjustment;
        printf("\nSTMT_EXEC;;37753\n");
tmp___1 = (*convert)((time_t const *)(&t), &tm);
      }
      printf("\nSTMT_EXEC;;37755\n");
if (tmp___1)
      {
        printf("\nSTMT_EXEC;;37757\n");
tmp___2 = 0;
      }
      else
      {
        printf("\nSTMT_EXEC;;37761\n");
tmp___2 = 1;
      }
      printf("\nSTMT_EXEC;;37763\n");
if ((((t1 < t) != (sec_requested < 0)) | ((t2 < t1) != (sec_adjustment < 0))) | tmp___2)
      {
        printf("\nSTMT_EXEC;;37765\n");
printf("\nFUNC_RETURN;;\n");
return ((time_t)-1);
      }
    }
    printf("\nSTMT_EXEC;;37768\n");
*tp = tm;
    printf("\nSTMT_EXEC;;37769\n");
printf("\nFUNC_RETURN;;\n");
return (t);
  }
printf("\nFUNC_RETURN;;\n");
}
static time_t localtime_offset;
__attribute__((__nothrow__)) time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp);
time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp)
{
  printf("\nFUNC_CALL;rpl_mktime(struct tm *);\n");
printf("\nSTMT_EXEC;;37776\n");
time_t tmp;

  {
    {
      printf("\nSTMT_EXEC;;37780\n");
tmp = mktime_internal(tp, (struct tm * (*)(time_t const *, struct tm *))(&localtime_r), &localtime_offset);
    }
    printf("\nSTMT_EXEC;;37782\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","020.modechange.o.i","") */
void mode_free(struct mode_change *changes);
strtol_error xstrtoul(char const *s, char **ptr, int strtol_base, unsigned long *val, char const *valid_suffixes);
static struct mode_change *make_node_op_equals(mode_t new_mode)
{
  printf("\nFUNC_CALL;make_node_op_equals(mode_t);\n");
printf("\nSTMT_EXEC;;37790\n");
struct mode_change *p;
  printf("\nSTMT_EXEC;;37791\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;37795\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
tmp = malloc(sizeof(struct mode_change));printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;37796\n");
p = (struct mode_change *)tmp;
    }
    printf("\nSTMT_EXEC;;37798\n");
if ((unsigned long)p == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;37800\n");
printf("\nFUNC_RETURN;;\n");
return (p);
    }
    printf("\nSTMT_EXEC;;37802\n");
p->next = (struct mode_change *)((void *)0);
    printf("\nSTMT_EXEC;;37803\n");
p->op = (char)'=';
    printf("\nSTMT_EXEC;;37804\n");
p->flags = (char)0;
    printf("\nSTMT_EXEC;;37805\n");
p->value = new_mode;
    printf("\nSTMT_EXEC;;37806\n");
p->affected = (mode_t)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
    printf("\nSTMT_EXEC;;37807\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }
printf("\nFUNC_RETURN;;\n");
}
static void mode_append_entry(struct mode_change **head, struct mode_change **tail, struct mode_change *e)
{
  printf("\nFUNC_CALL;mode_append_entry(struct mode_change **,struct mode_change **,struct mode_change *);\n");
printf("\nSTMT_EXEC;;37812\n");
struct mode_change *tmp;

  {
    printf("\nSTMT_EXEC;;37815\n");
if ((unsigned long)*head == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;37817\n");
tmp = e;
      printf("\nSTMT_EXEC;;37818\n");
*tail = tmp;
      printf("\nSTMT_EXEC;;37819\n");
*head = tmp;
    }
    else
    {
      printf("\nSTMT_EXEC;;37823\n");
(*tail)->next = e;
      printf("\nSTMT_EXEC;;37824\n");
*tail = e;
    }
    printf("\nSTMT_EXEC;;37826\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
struct mode_change *mode_compile(char const *mode_string, unsigned int masked_ops)
{
  printf("\nFUNC_CALL;mode_compile(const char *,unsigned int);\n");
printf("\nSTMT_EXEC;;37831\n");
struct mode_change *head;
  printf("\nSTMT_EXEC;;37832\n");
struct mode_change *tail;
  printf("\nSTMT_EXEC;;37833\n");
unsigned long octal_value;
  printf("\nSTMT_EXEC;;37834\n");
mode_t umask_value;
  printf("\nSTMT_EXEC;;37835\n");
struct mode_change *p;
  printf("\nSTMT_EXEC;;37836\n");
mode_t mode;
  printf("\nSTMT_EXEC;;37837\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;37838\n");
mode_t affected_bits;
  printf("\nSTMT_EXEC;;37839\n");
mode_t affected_masked;
  printf("\nSTMT_EXEC;;37840\n");
unsigned int ops_to_mask;
  printf("\nSTMT_EXEC;;37841\n");
int who_specified_p;
  printf("\nSTMT_EXEC;;37842\n");
struct mode_change *change;
  printf("\nSTMT_EXEC;;37843\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;37844\n");
struct mode_change *p___0;
  printf("\nSTMT_EXEC;;37845\n");
struct mode_change *tmp___1;
  printf("\nSTMT_EXEC;;37846\n");
int tmp___2;
  printf("\nSTMT_EXEC;;37847\n");
int tmp___3;
  printf("\nSTMT_EXEC;;37848\n");
int tmp___4;
  printf("\nSTMT_EXEC;;37849\n");
int tmp___5;
  printf("\nSTMT_EXEC;;37850\n");
int tmp___6;
  printf("\nSTMT_EXEC;;37851\n");
int tmp___7;
  printf("\nSTMT_EXEC;;37852\n");
int tmp___8;
  printf("\nSTMT_EXEC;;37853\n");
int tmp___9;
  printf("\nSTMT_EXEC;;37854\n");
int tmp___10;
  printf("\nSTMT_EXEC;;37855\n");
int tmp___11;
  printf("\nSTMT_EXEC;;37856\n");
int tmp___12;
  printf("\nSTMT_EXEC;;37857\n");
int tmp___13;
  printf("\nSTMT_EXEC;;37858\n");
unsigned long tmp___14;
  printf("\nSTMT_EXEC;;37859\n");
int tmp___15;
  printf("\nSTMT_EXEC;;37860\n");
int tmp___16;
  printf("\nSTMT_EXEC;;37861\n");
int tmp___17;
  printf("\nSTMT_EXEC;;37862\n");
char *__cil_tmp34;

  {
    {
      printf("\nSTMT_EXEC;;37866\n");
head = (struct mode_change *)((void *)0);
      printf("\nSTMT_EXEC;;37867\n");
tmp = xstrtoul(mode_string, (char **)((void *)0), 8, &octal_value, "");
    }
    printf("\nSTMT_EXEC;;37869\n");
if ((unsigned int)tmp == 0U)
    {
      printf("\nSTMT_EXEC;;37871\n");
if (octal_value != (octal_value & 4095UL))
      {
        printf("\nSTMT_EXEC;;37873\n");
printf("\nFUNC_RETURN;;\n");
return ((struct mode_change *)0);
      }
      printf("\nSTMT_EXEC;;37875\n");
if (256 >> 3 == 32)
      {
        printf("\nSTMT_EXEC;;37877\n");
if (128 >> 3 == 16)
        {
          printf("\nSTMT_EXEC;;37879\n");
if (64 >> 3 == 8)
          {
            printf("\nSTMT_EXEC;;37881\n");
if ((256 >> 3) >> 3 == 4)
            {
              printf("\nSTMT_EXEC;;37883\n");
if ((128 >> 3) >> 3 == 2)
              {
                printf("\nSTMT_EXEC;;37885\n");
if ((64 >> 3) >> 3 == 1)
                {
                  printf("\nSTMT_EXEC;;37887\n");
tmp___14 = octal_value;
                }
                else
                {
                  printf("\nSTMT_EXEC;;37891\n");
goto _L___7;
                }
              }
              else
              {
                printf("\nSTMT_EXEC;;37896\n");
goto _L___7;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;37901\n");
goto _L___7;
            }
          }
          else
          {
            printf("\nSTMT_EXEC;;37906\n");
goto _L___7;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;37911\n");
goto _L___7;
        }
      }
      else
      {
      _L___7: /* CIL Label */
        {
printf("\nSTMT_EXEC;;37917\n");
if (octal_value & 2048UL)
        {
          printf("\nSTMT_EXEC;;37919\n");
tmp___2 = 2048;
        }
        else
        {
          printf("\nSTMT_EXEC;;37923\n");
tmp___2 = 0;
        }
}

        printf("\nSTMT_EXEC;;37925\n");
if (octal_value & 1024UL)
        {
          printf("\nSTMT_EXEC;;37927\n");
tmp___3 = 1024;
        }
        else
        {
          printf("\nSTMT_EXEC;;37931\n");
tmp___3 = 0;
        }
        printf("\nSTMT_EXEC;;37933\n");
if (octal_value & 512UL)
        {
          printf("\nSTMT_EXEC;;37935\n");
tmp___4 = 512;
        }
        else
        {
          printf("\nSTMT_EXEC;;37939\n");
tmp___4 = 0;
        }
        printf("\nSTMT_EXEC;;37941\n");
if (octal_value & 256UL)
        {
          printf("\nSTMT_EXEC;;37943\n");
tmp___5 = 256;
        }
        else
        {
          printf("\nSTMT_EXEC;;37947\n");
tmp___5 = 0;
        }
        printf("\nSTMT_EXEC;;37949\n");
if (octal_value & 128UL)
        {
          printf("\nSTMT_EXEC;;37951\n");
tmp___6 = 128;
        }
        else
        {
          printf("\nSTMT_EXEC;;37955\n");
tmp___6 = 0;
        }
        printf("\nSTMT_EXEC;;37957\n");
if (octal_value & 64UL)
        {
          printf("\nSTMT_EXEC;;37959\n");
tmp___7 = 64;
        }
        else
        {
          printf("\nSTMT_EXEC;;37963\n");
tmp___7 = 0;
        }
        printf("\nSTMT_EXEC;;37965\n");
if (octal_value & 32UL)
        {
          printf("\nSTMT_EXEC;;37967\n");
tmp___8 = 256 >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;37971\n");
tmp___8 = 0;
        }
        printf("\nSTMT_EXEC;;37973\n");
if (octal_value & 16UL)
        {
          printf("\nSTMT_EXEC;;37975\n");
tmp___9 = 128 >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;37979\n");
tmp___9 = 0;
        }
        printf("\nSTMT_EXEC;;37981\n");
if (octal_value & 8UL)
        {
          printf("\nSTMT_EXEC;;37983\n");
tmp___10 = 64 >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;37987\n");
tmp___10 = 0;
        }
        printf("\nSTMT_EXEC;;37989\n");
if (octal_value & 4UL)
        {
          printf("\nSTMT_EXEC;;37991\n");
tmp___11 = (256 >> 3) >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;37995\n");
tmp___11 = 0;
        }
        printf("\nSTMT_EXEC;;37997\n");
if (octal_value & 2UL)
        {
          printf("\nSTMT_EXEC;;37999\n");
tmp___12 = (128 >> 3) >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;38003\n");
tmp___12 = 0;
        }
        printf("\nSTMT_EXEC;;38005\n");
if (octal_value & 1UL)
        {
          printf("\nSTMT_EXEC;;38007\n");
tmp___13 = (64 >> 3) >> 3;
        }
        else
        {
          printf("\nSTMT_EXEC;;38011\n");
tmp___13 = 0;
        }
        printf("\nSTMT_EXEC;;38013\n");
tmp___14 = (unsigned long)((mode_t)(((((((((((tmp___2 | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10) | tmp___11) | tmp___12) | tmp___13));
      }
      {
        printf("\nSTMT_EXEC;;38016\n");
mode = (mode_t)tmp___14;
        printf("\nSTMT_EXEC;;38017\n");
p = make_node_op_equals(mode);
      }
      printf("\nSTMT_EXEC;;38019\n");
if ((unsigned long)p == (unsigned long)((void *)0))
      {
        printf("\nSTMT_EXEC;;38021\n");
printf("\nFUNC_RETURN;;\n");
return ((struct mode_change *)1);
      }
      {
        printf("\nSTMT_EXEC;;38024\n");
mode_append_entry(&head, &tail, p);
      }
      printf("\nSTMT_EXEC;;38026\n");
printf("\nFUNC_RETURN;;\n");
return (head);
    }
    {
      printf("\nSTMT_EXEC;;38029\n");
printf("\nFUNC_CALL;umask(__mode_t);\n");
umask_value = umask((__mode_t)0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38030\n");
printf("\nFUNC_CALL;umask(__mode_t);\n");
umask(umask_value);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38031\n");
mode_string--;
    }
    {
      printf("\nSTMT_EXEC;;38034\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;38037\n");
affected_bits = (mode_t)0;
        printf("\nSTMT_EXEC;;38038\n");
ops_to_mask = 0U;
        printf("\nSTMT_EXEC;;38039\n");
affected_bits = (mode_t)0;
        printf("\nSTMT_EXEC;;38040\n");
ops_to_mask = 0U;
        printf("\nSTMT_EXEC;;38041\n");
mode_string++;
        {
          printf("\nSTMT_EXEC;;38043\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            {
              printf("\nSTMT_EXEC;;38047\n");
if ((int const) * mode_string == 117)
              {
                printf("\nSTMT_EXEC;;38049\n");
goto case_117;
              }
              printf("\nSTMT_EXEC;;38051\n");
if ((int const) * mode_string == 103)
              {
                printf("\nSTMT_EXEC;;38053\n");
goto case_103;
              }
              printf("\nSTMT_EXEC;;38055\n");
if ((int const) * mode_string == 111)
              {
                printf("\nSTMT_EXEC;;38057\n");
goto case_111;
              }
              printf("\nSTMT_EXEC;;38059\n");
if ((int const) * mode_string == 97)
              {
                printf("\nSTMT_EXEC;;38061\n");
goto case_97;
              }
              printf("\nSTMT_EXEC;;38063\n");
goto switch_default;
            case_117: /* CIL Label */
              {
printf("\nSTMT_EXEC;;38065\n");
affected_bits |= 2496U;
}

              printf("\nSTMT_EXEC;;38066\n");
goto switch_break;
            case_103: /* CIL Label */
              {
printf("\nSTMT_EXEC;;38068\n");
affected_bits |= (unsigned int)(1024 | (448 >> 3));
}

              printf("\nSTMT_EXEC;;38069\n");
goto switch_break;
            case_111: /* CIL Label */
              {
printf("\nSTMT_EXEC;;38071\n");
affected_bits |= (unsigned int)(512 | ((448 >> 3) >> 3));
}

              printf("\nSTMT_EXEC;;38072\n");
goto switch_break;
            case_97: /* CIL Label */
              {
printf("\nSTMT_EXEC;;38074\n");
affected_bits |= (unsigned int)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
}

              printf("\nSTMT_EXEC;;38075\n");
goto switch_break;
            switch_default: /* CIL Label */
              {
printf("\nSTMT_EXEC;;38077\n");
goto no_more_affected;
}

            switch_break: /* CIL Label */;
            }
            printf("\nSTMT_EXEC;;38080\n");
mode_string++;
          }
        while_break___0: /* CIL Label */;
        }
      no_more_affected:
        {
printf("\nSTMT_EXEC;;38085\n");
if (affected_bits)
        {
          printf("\nSTMT_EXEC;;38087\n");
who_specified_p = 1;
        }
        else
        {
          printf("\nSTMT_EXEC;;38091\n");
who_specified_p = 0;
          printf("\nSTMT_EXEC;;38092\n");
affected_bits = (mode_t)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
          printf("\nSTMT_EXEC;;38093\n");
ops_to_mask = masked_ops;
        }
}

        {
          printf("\nSTMT_EXEC;;38096\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;38099\n");
if (!((int const) * mode_string == 61))
            {
              printf("\nSTMT_EXEC;;38101\n");
if (!((int const) * mode_string == 43))
              {
                printf("\nSTMT_EXEC;;38103\n");
if (!((int const) * mode_string == 45))
                {
                  printf("\nSTMT_EXEC;;38105\n");
goto while_break___1;
                }
              }
            }
            {
              printf("\nSTMT_EXEC;;38110\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
tmp___0 = malloc(sizeof(struct mode_change));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;38111\n");
change = (struct mode_change *)tmp___0;
            }
            printf("\nSTMT_EXEC;;38113\n");
if ((unsigned long)change == (unsigned long)((void *)0))
            {
              {
                printf("\nSTMT_EXEC;;38116\n");
mode_free(head);
              }
              printf("\nSTMT_EXEC;;38118\n");
printf("\nFUNC_RETURN;;\n");
return ((struct mode_change *)1);
            }
            printf("\nSTMT_EXEC;;38120\n");
change->next = (struct mode_change *)((void *)0);
            printf("\nSTMT_EXEC;;38121\n");
change->op = (char)*mode_string;
            printf("\nSTMT_EXEC;;38122\n");
affected_masked = affected_bits;
            printf("\nSTMT_EXEC;;38123\n");
if (!who_specified_p)
            {
              printf("\nSTMT_EXEC;;38125\n");
if ((int const) * mode_string == 61)
              {
                printf("\nSTMT_EXEC;;38127\n");
tmp___15 = 1;
              }
              else
              {
                printf("\nSTMT_EXEC;;38131\n");
tmp___15 = 0;
              }
              printf("\nSTMT_EXEC;;38133\n");
if (ops_to_mask & (unsigned int)tmp___15)
              {
                {
                  printf("\nSTMT_EXEC;;38136\n");
tmp___1 = make_node_op_equals((mode_t)0);
                  printf("\nSTMT_EXEC;;38137\n");
p___0 = tmp___1;
                }
                printf("\nSTMT_EXEC;;38139\n");
if ((unsigned long)p___0 == (unsigned long)((void *)0))
                {
                  printf("\nSTMT_EXEC;;38141\n");
printf("\nFUNC_RETURN;;\n");
return ((struct mode_change *)1);
                }
                {
                  printf("\nSTMT_EXEC;;38144\n");
mode_append_entry(&head, &tail, p___0);
                }
              }
            }
            printf("\nSTMT_EXEC;;38148\n");
if ((int const) * mode_string == 61)
            {
              printf("\nSTMT_EXEC;;38150\n");
tmp___17 = 1;
            }
            else
            {
              printf("\nSTMT_EXEC;;38154\n");
if ((int const) * mode_string == 43)
              {
                printf("\nSTMT_EXEC;;38156\n");
tmp___16 = 2;
              }
              else
              {
                printf("\nSTMT_EXEC;;38160\n");
tmp___16 = 4;
              }
              printf("\nSTMT_EXEC;;38162\n");
tmp___17 = tmp___16;
            }
            printf("\nSTMT_EXEC;;38164\n");
if (ops_to_mask & (unsigned int)tmp___17)
            {
              printf("\nSTMT_EXEC;;38166\n");
affected_masked &= ~umask_value;
            }
            {
              printf("\nSTMT_EXEC;;38169\n");
change->affected = affected_masked;
              printf("\nSTMT_EXEC;;38170\n");
change->value = (mode_t)0;
              printf("\nSTMT_EXEC;;38171\n");
change->flags = (char)0;
              printf("\nSTMT_EXEC;;38172\n");
mode_append_entry(&head, &tail, change);
              printf("\nSTMT_EXEC;;38173\n");
mode_string++;
            }
            {
              printf("\nSTMT_EXEC;;38176\n");
while (1)
              {
              while_continue___2: /* CIL Label */;
                {
                  printf("\nSTMT_EXEC;;38180\n");
if ((int const) * mode_string == 114)
                  {
                    printf("\nSTMT_EXEC;;38182\n");
goto case_114;
                  }
                  printf("\nSTMT_EXEC;;38184\n");
if ((int const) * mode_string == 119)
                  {
                    printf("\nSTMT_EXEC;;38186\n");
goto case_119;
                  }
                  printf("\nSTMT_EXEC;;38188\n");
if ((int const) * mode_string == 88)
                  {
                    printf("\nSTMT_EXEC;;38190\n");
goto case_88;
                  }
                  printf("\nSTMT_EXEC;;38192\n");
if ((int const) * mode_string == 120)
                  {
                    printf("\nSTMT_EXEC;;38194\n");
goto case_120;
                  }
                  printf("\nSTMT_EXEC;;38196\n");
if ((int const) * mode_string == 115)
                  {
                    printf("\nSTMT_EXEC;;38198\n");
goto case_115;
                  }
                  printf("\nSTMT_EXEC;;38200\n");
if ((int const) * mode_string == 116)
                  {
                    printf("\nSTMT_EXEC;;38202\n");
goto case_116;
                  }
                  printf("\nSTMT_EXEC;;38204\n");
if ((int const) * mode_string == 117)
                  {
                    printf("\nSTMT_EXEC;;38206\n");
goto case_117___0;
                  }
                  printf("\nSTMT_EXEC;;38208\n");
if ((int const) * mode_string == 103)
                  {
                    printf("\nSTMT_EXEC;;38210\n");
goto case_103___0;
                  }
                  printf("\nSTMT_EXEC;;38212\n");
if ((int const) * mode_string == 111)
                  {
                    printf("\nSTMT_EXEC;;38214\n");
goto case_111___0;
                  }
                  printf("\nSTMT_EXEC;;38216\n");
goto switch_default___0;
                case_114: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38218\n");
change->value |= (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3)) & affected_masked;
}

                  printf("\nSTMT_EXEC;;38219\n");
goto switch_break___0;
                case_119: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38221\n");
change->value |= (unsigned int)((128 | (128 >> 3)) | ((128 >> 3) >> 3)) & affected_masked;
}

                  printf("\nSTMT_EXEC;;38222\n");
goto switch_break___0;
                case_88: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38224\n");
change->flags = (char)((int)change->flags | 1);
}

                case_120: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38226\n");
change->value |= (unsigned int)((64 | (64 >> 3)) | ((64 >> 3) >> 3)) & affected_masked;
}

                  printf("\nSTMT_EXEC;;38227\n");
goto switch_break___0;
                case_115: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38229\n");
change->value |= 3072U & affected_masked;
}

                  printf("\nSTMT_EXEC;;38230\n");
goto switch_break___0;
                case_116: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38232\n");
change->value |= 512U & affected_masked;
}

                  printf("\nSTMT_EXEC;;38233\n");
goto switch_break___0;
                case_117___0: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38235\n");
if (change->value)
                  {
                    printf("\nSTMT_EXEC;;38237\n");
goto invalid;
                  }
}

                  printf("\nSTMT_EXEC;;38239\n");
change->value = (mode_t)448;
                  printf("\nSTMT_EXEC;;38240\n");
change->flags = (char)((int)change->flags | 2);
                  printf("\nSTMT_EXEC;;38241\n");
goto switch_break___0;
                case_103___0: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38243\n");
if (change->value)
                  {
                    printf("\nSTMT_EXEC;;38245\n");
goto invalid;
                  }
}

                  printf("\nSTMT_EXEC;;38247\n");
change->value = (mode_t)(448 >> 3);
                  printf("\nSTMT_EXEC;;38248\n");
change->flags = (char)((int)change->flags | 2);
                  printf("\nSTMT_EXEC;;38249\n");
goto switch_break___0;
                case_111___0: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38251\n");
if (change->value)
                  {
                    printf("\nSTMT_EXEC;;38253\n");
goto invalid;
                  }
}

                  printf("\nSTMT_EXEC;;38255\n");
change->value = (mode_t)((448 >> 3) >> 3);
                  printf("\nSTMT_EXEC;;38256\n");
change->flags = (char)((int)change->flags | 2);
                  printf("\nSTMT_EXEC;;38257\n");
goto switch_break___0;
                switch_default___0: /* CIL Label */
                  {
printf("\nSTMT_EXEC;;38259\n");
goto no_more_values;
}

                switch_break___0: /* CIL Label */;
                }
                printf("\nSTMT_EXEC;;38262\n");
mode_string++;
              }
            while_break___2: /* CIL Label */;
            }
          no_more_values:;
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;38270\n");
if (!((int const) * mode_string == 44))
        {
          printf("\nSTMT_EXEC;;38272\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;38277\n");
if ((int const) * mode_string == 0)
    {
      printf("\nSTMT_EXEC;;38279\n");
printf("\nFUNC_RETURN;;\n");
return (head);
    }
  invalid:
  {
    printf("\nSTMT_EXEC;;38283\n");
mode_free(head);
  }
    printf("\nSTMT_EXEC;;38285\n");
printf("\nFUNC_RETURN;;\n");
return ((struct mode_change *)0);
  }
printf("\nFUNC_RETURN;;\n");
}
mode_t mode_adjust(mode_t oldmode, struct mode_change const *changes)
{
  printf("\nFUNC_CALL;mode_adjust(mode_t,const struct mode_change *);\n");
printf("\nSTMT_EXEC;;38290\n");
mode_t newmode;
  printf("\nSTMT_EXEC;;38291\n");
mode_t value;
  printf("\nSTMT_EXEC;;38292\n");
int tmp;
  printf("\nSTMT_EXEC;;38293\n");
int tmp___0;
  printf("\nSTMT_EXEC;;38294\n");
int tmp___1;
  printf("\nSTMT_EXEC;;38295\n");
int tmp___2;
  printf("\nSTMT_EXEC;;38296\n");
int tmp___3;
  printf("\nSTMT_EXEC;;38297\n");
int tmp___4;
  printf("\nSTMT_EXEC;;38298\n");
int tmp___5;
  printf("\nSTMT_EXEC;;38299\n");
int tmp___6;
  printf("\nSTMT_EXEC;;38300\n");
int tmp___7;

  {
    printf("\nSTMT_EXEC;;38303\n");
newmode = oldmode & (unsigned int)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
    {
      printf("\nSTMT_EXEC;;38305\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;38308\n");
if (!changes)
        {
          printf("\nSTMT_EXEC;;38310\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;38312\n");
if ((int const)changes->flags & 2)
        {
          printf("\nSTMT_EXEC;;38314\n");
value = newmode & (unsigned int)changes->value;
          printf("\nSTMT_EXEC;;38315\n");
if (changes->value & 448U)
          {
            printf("\nSTMT_EXEC;;38317\n");
if (value & 256U)
            {
              printf("\nSTMT_EXEC;;38319\n");
tmp = (256 >> 3) | ((256 >> 3) >> 3);
            }
            else
            {
              printf("\nSTMT_EXEC;;38323\n");
tmp = 0;
            }
            printf("\nSTMT_EXEC;;38325\n");
if (value & 128U)
            {
              printf("\nSTMT_EXEC;;38327\n");
tmp___0 = (128 >> 3) | ((128 >> 3) >> 3);
            }
            else
            {
              printf("\nSTMT_EXEC;;38331\n");
tmp___0 = 0;
            }
            printf("\nSTMT_EXEC;;38333\n");
if (value & 64U)
            {
              printf("\nSTMT_EXEC;;38335\n");
tmp___1 = (64 >> 3) | ((64 >> 3) >> 3);
            }
            else
            {
              printf("\nSTMT_EXEC;;38339\n");
tmp___1 = 0;
            }
            printf("\nSTMT_EXEC;;38341\n");
value |= (unsigned int)((tmp | tmp___0) | tmp___1);
          }
          else
          {
            printf("\nSTMT_EXEC;;38345\n");
if (changes->value & (unsigned int const)(448 >> 3))
            {
              printf("\nSTMT_EXEC;;38347\n");
if (value & (unsigned int)(256 >> 3))
              {
                printf("\nSTMT_EXEC;;38349\n");
tmp___2 = 256 | ((256 >> 3) >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38353\n");
tmp___2 = 0;
              }
              printf("\nSTMT_EXEC;;38355\n");
if (value & (unsigned int)(128 >> 3))
              {
                printf("\nSTMT_EXEC;;38357\n");
tmp___3 = 128 | ((128 >> 3) >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38361\n");
tmp___3 = 0;
              }
              printf("\nSTMT_EXEC;;38363\n");
if (value & (unsigned int)(64 >> 3))
              {
                printf("\nSTMT_EXEC;;38365\n");
tmp___4 = 64 | ((64 >> 3) >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38369\n");
tmp___4 = 0;
              }
              printf("\nSTMT_EXEC;;38371\n");
value |= (unsigned int)((tmp___2 | tmp___3) | tmp___4);
            }
            else
            {
              printf("\nSTMT_EXEC;;38375\n");
if (value & (unsigned int)((256 >> 3) >> 3))
              {
                printf("\nSTMT_EXEC;;38377\n");
tmp___5 = 256 | (256 >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38381\n");
tmp___5 = 0;
              }
              printf("\nSTMT_EXEC;;38383\n");
if (value & (unsigned int)((128 >> 3) >> 3))
              {
                printf("\nSTMT_EXEC;;38385\n");
tmp___6 = 128 | (128 >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38389\n");
tmp___6 = 0;
              }
              printf("\nSTMT_EXEC;;38391\n");
if (value & (unsigned int)((64 >> 3) >> 3))
              {
                printf("\nSTMT_EXEC;;38393\n");
tmp___7 = 64 | (64 >> 3);
              }
              else
              {
                printf("\nSTMT_EXEC;;38397\n");
tmp___7 = 0;
              }
              printf("\nSTMT_EXEC;;38399\n");
value |= (unsigned int)((tmp___5 | tmp___6) | tmp___7);
            }
          }
          printf("\nSTMT_EXEC;;38402\n");
value &= (unsigned int)changes->affected;
        }
        else
        {
          printf("\nSTMT_EXEC;;38406\n");
value = (mode_t)changes->value;
          printf("\nSTMT_EXEC;;38407\n");
if ((int const)changes->flags & 1)
          {
            printf("\nSTMT_EXEC;;38409\n");
if (!((oldmode & 61440U) == 16384U))
            {
              printf("\nSTMT_EXEC;;38411\n");
if ((newmode & (unsigned int)((64 | (64 >> 3)) | ((64 >> 3) >> 3))) == 0U)
              {
                printf("\nSTMT_EXEC;;38413\n");
value &= (unsigned int)(~((64 | (64 >> 3)) | ((64 >> 3) >> 3)));
              }
            }
          }
        }
        {
          printf("\nSTMT_EXEC;;38419\n");
if ((int const)changes->op == 61)
          {
            printf("\nSTMT_EXEC;;38421\n");
goto case_61;
          }
          printf("\nSTMT_EXEC;;38423\n");
if ((int const)changes->op == 43)
          {
            printf("\nSTMT_EXEC;;38425\n");
goto case_43;
          }
          printf("\nSTMT_EXEC;;38427\n");
if ((int const)changes->op == 45)
          {
            printf("\nSTMT_EXEC;;38429\n");
goto case_45;
          }
          printf("\nSTMT_EXEC;;38431\n");
goto switch_break;
        case_61: /* CIL Label */
          {
printf("\nSTMT_EXEC;;38433\n");
newmode = (newmode & (unsigned int)(~changes->affected)) | value;
}

          printf("\nSTMT_EXEC;;38434\n");
goto switch_break;
        case_43: /* CIL Label */
          {
printf("\nSTMT_EXEC;;38436\n");
newmode |= value;
}

          printf("\nSTMT_EXEC;;38437\n");
goto switch_break;
        case_45: /* CIL Label */
          {
printf("\nSTMT_EXEC;;38439\n");
newmode &= ~value;
}

          printf("\nSTMT_EXEC;;38440\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;38443\n");
changes = (struct mode_change const *)changes->next;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;38447\n");
printf("\nFUNC_RETURN;;\n");
return (newmode);
  }
printf("\nFUNC_RETURN;;\n");
}
void mode_free(struct mode_change *changes)
{
  printf("\nFUNC_CALL;mode_free(struct mode_change *);\n");
printf("\nSTMT_EXEC;;38452\n");
register struct mode_change *next;

  {
    {
      printf("\nSTMT_EXEC;;38456\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;38459\n");
if (!changes)
        {
          printf("\nSTMT_EXEC;;38461\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;38464\n");
next = changes->next;
          printf("\nSTMT_EXEC;;38465\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)changes);printf("\nFUNC_RETURN;;\n");

          printf("\nSTMT_EXEC;;38466\n");
changes = next;
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;38471\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","021.prepargs.o.i","") */
static int prepend_args(char const *options, char *buf, char **argv)
{
  printf("\nFUNC_CALL;prepend_args(const char *,char *,char **);\n");
printf("\nSTMT_EXEC;;38477\n");
char const *o___0;
  printf("\nSTMT_EXEC;;38478\n");
char *b;
  printf("\nSTMT_EXEC;;38479\n");
int n;
  printf("\nSTMT_EXEC;;38480\n");
unsigned short const **tmp;
  printf("\nSTMT_EXEC;;38481\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;38482\n");
char *tmp___1;
  printf("\nSTMT_EXEC;;38483\n");
char tmp___2;
  printf("\nSTMT_EXEC;;38484\n");
char const *tmp___3;
  printf("\nSTMT_EXEC;;38485\n");
unsigned short const **tmp___4;
  printf("\nSTMT_EXEC;;38486\n");
char *tmp___5;

  {
    printf("\nSTMT_EXEC;;38489\n");
o___0 = options;
    printf("\nSTMT_EXEC;;38490\n");
b = buf;
    printf("\nSTMT_EXEC;;38491\n");
n = 0;
    {
      printf("\nSTMT_EXEC;;38493\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;38497\n");
while (1)
          {
          while_continue___0: /* CIL Label */;
            {
              printf("\nSTMT_EXEC;;38501\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

            }
            printf("\nSTMT_EXEC;;38503\n");
if (!((int const) * (*tmp + (int)((unsigned char)*o___0)) & 8192))
            {
              printf("\nSTMT_EXEC;;38505\n");
goto while_break___0;
            }
            printf("\nSTMT_EXEC;;38507\n");
o___0++;
          }
        while_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;38511\n");
if (!*o___0)
        {
          printf("\nSTMT_EXEC;;38513\n");
printf("\nFUNC_RETURN;;\n");
return (n);
        }
        printf("\nSTMT_EXEC;;38515\n");
if (argv)
        {
          printf("\nSTMT_EXEC;;38517\n");
*(argv + n) = b;
        }
        printf("\nSTMT_EXEC;;38519\n");
n++;
        {
          printf("\nSTMT_EXEC;;38521\n");
while (1)
          {
          while_continue___1: /* CIL Label */;
            printf("\nSTMT_EXEC;;38524\n");
tmp___1 = b;
            printf("\nSTMT_EXEC;;38525\n");
b++;
            printf("\nSTMT_EXEC;;38526\n");
tmp___3 = o___0;
            printf("\nSTMT_EXEC;;38527\n");
o___0++;
            printf("\nSTMT_EXEC;;38528\n");
tmp___2 = (char)*tmp___3;
            printf("\nSTMT_EXEC;;38529\n");
*tmp___1 = tmp___2;
            printf("\nSTMT_EXEC;;38530\n");
if ((int)tmp___2 == 92)
            {
              printf("\nSTMT_EXEC;;38532\n");
if (*o___0)
              {
                printf("\nSTMT_EXEC;;38534\n");
tmp___0 = o___0;
                printf("\nSTMT_EXEC;;38535\n");
o___0++;
                printf("\nSTMT_EXEC;;38536\n");
*(b + -1) = (char)*tmp___0;
              }
            }
            printf("\nSTMT_EXEC;;38539\n");
if (*o___0)
            {
              {
                printf("\nSTMT_EXEC;;38542\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___4 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;38544\n");
if ((int const) * (*tmp___4 + (int)((unsigned char)*o___0)) & 8192)
              {
                printf("\nSTMT_EXEC;;38546\n");
goto while_break___1;
              }
            }
            else
            {
              printf("\nSTMT_EXEC;;38551\n");
goto while_break___1;
            }
          }
        while_break___1: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;38556\n");
tmp___5 = b;
        printf("\nSTMT_EXEC;;38557\n");
b++;
        printf("\nSTMT_EXEC;;38558\n");
*tmp___5 = (char)'\000';
      }
    while_break: /* CIL Label */;
    }
  }
printf("\nFUNC_RETURN;;\n");
}
void prepend_default_options(char const *options, int *pargc, char ***pargv)
{
  printf("\nFUNC_CALL;prepend_default_options(const char *,int *,char ***);\n");
printf("\nSTMT_EXEC;;38566\n");
char *buf;
  printf("\nSTMT_EXEC;;38567\n");
size_t tmp;
  printf("\nSTMT_EXEC;;38568\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;38569\n");
int prepended;
  printf("\nSTMT_EXEC;;38570\n");
int tmp___1;
  printf("\nSTMT_EXEC;;38571\n");
int argc;
  printf("\nSTMT_EXEC;;38572\n");
char *const *argv;
  printf("\nSTMT_EXEC;;38573\n");
char **pp;
  printf("\nSTMT_EXEC;;38574\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;38575\n");
char **tmp___3;
  printf("\nSTMT_EXEC;;38576\n");
char *const *tmp___4;
  printf("\nSTMT_EXEC;;38577\n");
int tmp___5;
  printf("\nSTMT_EXEC;;38578\n");
char **tmp___6;
  printf("\nSTMT_EXEC;;38579\n");
char *tmp___7;
  printf("\nSTMT_EXEC;;38580\n");
char *const *tmp___8;

  {
    printf("\nSTMT_EXEC;;38583\n");
if (options)
    {
      {
        printf("\nSTMT_EXEC;;38586\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(options);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;38587\n");
tmp___0 = xmalloc(tmp + 1UL);
        printf("\nSTMT_EXEC;;38588\n");
buf = (char *)tmp___0;
        printf("\nSTMT_EXEC;;38589\n");
tmp___1 = prepend_args(options, buf, (char **)0);
        printf("\nSTMT_EXEC;;38590\n");
prepended = tmp___1;
        printf("\nSTMT_EXEC;;38591\n");
argc = *pargc;
        printf("\nSTMT_EXEC;;38592\n");
argv = (char *const *)*pargv;
        printf("\nSTMT_EXEC;;38593\n");
tmp___2 = xmalloc((unsigned long)((prepended + argc) + 1) * sizeof(*pp));
        printf("\nSTMT_EXEC;;38594\n");
pp = (char **)tmp___2;
        printf("\nSTMT_EXEC;;38595\n");
*pargc = prepended + argc;
        printf("\nSTMT_EXEC;;38596\n");
*pargv = pp;
        printf("\nSTMT_EXEC;;38597\n");
tmp___3 = pp;
        printf("\nSTMT_EXEC;;38598\n");
pp++;
        printf("\nSTMT_EXEC;;38599\n");
tmp___4 = argv;
        printf("\nSTMT_EXEC;;38600\n");
argv++;
        printf("\nSTMT_EXEC;;38601\n");
*tmp___3 = (char *)*tmp___4;
        printf("\nSTMT_EXEC;;38602\n");
tmp___5 = prepend_args(options, buf, pp);
        printf("\nSTMT_EXEC;;38603\n");
pp += tmp___5;
      }
      {
        printf("\nSTMT_EXEC;;38606\n");
while (1)
        {
        while_continue: /* CIL Label */;
          printf("\nSTMT_EXEC;;38609\n");
tmp___6 = pp;
          printf("\nSTMT_EXEC;;38610\n");
pp++;
          printf("\nSTMT_EXEC;;38611\n");
tmp___8 = argv;
          printf("\nSTMT_EXEC;;38612\n");
argv++;
          printf("\nSTMT_EXEC;;38613\n");
tmp___7 = (char *)*tmp___8;
          printf("\nSTMT_EXEC;;38614\n");
*tmp___6 = tmp___7;
          printf("\nSTMT_EXEC;;38615\n");
if (!tmp___7)
          {
            printf("\nSTMT_EXEC;;38617\n");
goto while_break;
          }
          printf("\nSTMT_EXEC;;38619\n");
goto while_continue;
        }
      while_break: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;38624\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","022.quotearg.o.i","") */
char const *const quoting_style_args[8];
enum quoting_style const quoting_style_vals[7];
int set_char_quoting(struct quoting_options *o___0, char c, int i);
char *quotearg_n(int n, char const *arg);
char *quotearg_char(char const *arg, char ch);
extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) mbsinit)(mbstate_t const *__ps) __attribute__((__pure__));
extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) mbrtowc)(wchar_t *__restrict __pwc, char const *__restrict __s, size_t __n, mbstate_t *__restrict __p);
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswprint)(wint_t __wc);
char const *const quoting_style_args[8] = {(char const * /* const  */) "literal", (char const * /* const  */) "shell", (char const * /* const  */) "shell-always", (char const * /* const  */) "c", (char const * /* const  */) "escape", (char const * /* const  */) "locale", (char const * /* const  */) "clocale", (char const * /* const  */)0};
enum quoting_style const quoting_style_vals[7] = {(enum quoting_style const)0, (enum quoting_style const)1, (enum quoting_style const)2, (enum quoting_style const)3, (enum quoting_style const)4, (enum quoting_style const)5, (enum quoting_style const)6};
static struct quoting_options default_quoting_options;
struct quoting_options *clone_quoting_options(struct quoting_options *o___0)
{
  printf("\nFUNC_CALL;clone_quoting_options(struct quoting_options *);\n");
printf("\nSTMT_EXEC;;38642\n");
int e;
  printf("\nSTMT_EXEC;;38643\n");
int *tmp;
  printf("\nSTMT_EXEC;;38644\n");
struct quoting_options *p;
  printf("\nSTMT_EXEC;;38645\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;38646\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;38647\n");
struct quoting_options *tmp___2;

  {
    {
      printf("\nSTMT_EXEC;;38651\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38652\n");
e = *tmp;
      printf("\nSTMT_EXEC;;38653\n");
tmp___0 = xmalloc(sizeof(*p));
      printf("\nSTMT_EXEC;;38654\n");
p = (struct quoting_options *)tmp___0;
    }
    printf("\nSTMT_EXEC;;38656\n");
if (o___0)
    {
      printf("\nSTMT_EXEC;;38658\n");
tmp___2 = o___0;
    }
    else
    {
      printf("\nSTMT_EXEC;;38662\n");
tmp___2 = &default_quoting_options;
    }
    {
      printf("\nSTMT_EXEC;;38665\n");
*p = *tmp___2;
      printf("\nSTMT_EXEC;;38666\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38667\n");
*tmp___1 = e;
    }
    printf("\nSTMT_EXEC;;38669\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }
printf("\nFUNC_RETURN;;\n");
}
void set_quoting_style(struct quoting_options *o___0, enum quoting_style s)
{
  printf("\nFUNC_CALL;set_quoting_style(struct quoting_options *,enum quoting_style);\n");
printf("\nSTMT_EXEC;;38674\n");
struct quoting_options *tmp;

  {
    printf("\nSTMT_EXEC;;38677\n");
if (o___0)
    {
      printf("\nSTMT_EXEC;;38679\n");
tmp = o___0;
    }
    else
    {
      printf("\nSTMT_EXEC;;38683\n");
tmp = &default_quoting_options;
    }
    printf("\nSTMT_EXEC;;38685\n");
tmp->style = s;
    printf("\nSTMT_EXEC;;38686\n");
printf("\nFUNC_RETURN;;\n");
return;
  }
printf("\nFUNC_RETURN;;\n");
}
int set_char_quoting(struct quoting_options *o___0, char c, int i)
{
  printf("\nFUNC_CALL;set_char_quoting(struct quoting_options *,char,int);\n");
printf("\nSTMT_EXEC;;38691\n");
unsigned char uc;
  printf("\nSTMT_EXEC;;38692\n");
int *p;
  printf("\nSTMT_EXEC;;38693\n");
int shift;
  printf("\nSTMT_EXEC;;38694\n");
int r;
  printf("\nSTMT_EXEC;;38695\n");
struct quoting_options *tmp;

  {
    printf("\nSTMT_EXEC;;38698\n");
uc = (unsigned char)c;
    printf("\nSTMT_EXEC;;38699\n");
if (o___0)
    {
      printf("\nSTMT_EXEC;;38701\n");
tmp = o___0;
    }
    else
    {
      printf("\nSTMT_EXEC;;38705\n");
tmp = &default_quoting_options;
    }
    printf("\nSTMT_EXEC;;38707\n");
p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
    printf("\nSTMT_EXEC;;38708\n");
shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
    printf("\nSTMT_EXEC;;38709\n");
r = (*p >> shift) & 1;
    printf("\nSTMT_EXEC;;38710\n");
*p ^= ((i & 1) ^ r) << shift;
    printf("\nSTMT_EXEC;;38711\n");
printf("\nFUNC_RETURN;;\n");
return (r);
  }
printf("\nFUNC_RETURN;;\n");
}
static char const *gettext_quote(char const *msgid, enum quoting_style s)
{
  printf("\nFUNC_CALL;gettext_quote(const char *,enum quoting_style);\n");
printf("\nSTMT_EXEC;;38716\n");
char const *translation;
  printf("\nSTMT_EXEC;;38717\n");
char *tmp;
  printf("\nSTMT_EXEC;;38718\n");
char *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;38722\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext(msgid);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38723\n");
translation = (char const *)tmp;
    }
    printf("\nSTMT_EXEC;;38725\n");
if ((unsigned long)translation == (unsigned long)msgid)
    {
      printf("\nSTMT_EXEC;;38727\n");
if ((unsigned int)s == 6U)
      {
        printf("\nSTMT_EXEC;;38729\n");
translation = "\"";
      }
    }
    printf("\nSTMT_EXEC;;38732\n");
printf("\nFUNC_RETURN;;\n");
return (translation);
  }
printf("\nFUNC_RETURN;;\n");
}
static size_t quotearg_buffer_restyled(char *buffer___2, size_t buffersize, char const *arg, size_t argsize, enum quoting_style quoting_style, struct quoting_options const *o___0)
{
  printf("\nFUNC_CALL;quotearg_buffer_restyled(char *,size_t,const char *,size_t,enum quoting_style,const struct quoting_options *);\n");
printf("\nSTMT_EXEC;;38737\n");
size_t i;
  printf("\nSTMT_EXEC;;38738\n");
size_t len;
  printf("\nSTMT_EXEC;;38739\n");
char const *quote_string;
  printf("\nSTMT_EXEC;;38740\n");
size_t quote_string_len;
  printf("\nSTMT_EXEC;;38741\n");
int backslash_escapes;
  printf("\nSTMT_EXEC;;38742\n");
int unibyte_locale;
  printf("\nSTMT_EXEC;;38743\n");
size_t tmp;
  printf("\nSTMT_EXEC;;38744\n");
char const *left;
  printf("\nSTMT_EXEC;;38745\n");
char const *tmp___0;
  printf("\nSTMT_EXEC;;38746\n");
char const *right;
  printf("\nSTMT_EXEC;;38747\n");
char const *tmp___1;
  printf("\nSTMT_EXEC;;38748\n");
unsigned char c;
  printf("\nSTMT_EXEC;;38749\n");
unsigned char esc;
  printf("\nSTMT_EXEC;;38750\n");
int tmp___2;
  printf("\nSTMT_EXEC;;38751\n");
size_t m;
  printf("\nSTMT_EXEC;;38752\n");
int printable;
  printf("\nSTMT_EXEC;;38753\n");
unsigned short const **tmp___3;
  printf("\nSTMT_EXEC;;38754\n");
mbstate_t mbstate;
  printf("\nSTMT_EXEC;;38755\n");
wchar_t w;
  printf("\nSTMT_EXEC;;38756\n");
size_t bytes;
  printf("\nSTMT_EXEC;;38757\n");
size_t tmp___4;
  printf("\nSTMT_EXEC;;38758\n");
size_t j;
  printf("\nSTMT_EXEC;;38759\n");
int tmp___5;
  printf("\nSTMT_EXEC;;38760\n");
int tmp___6;
  printf("\nSTMT_EXEC;;38761\n");
size_t ilim;
  printf("\nSTMT_EXEC;;38762\n");
size_t tmp___7;
  printf("\nSTMT_EXEC;;38763\n");
int tmp___8;
  printf("\nSTMT_EXEC;;38764\n");
int tmp___9;
  printf("\nSTMT_EXEC;;38765\n");
void *__cil_tmp35;
  printf("\nSTMT_EXEC;;38766\n");
char *__cil_tmp36;
  printf("\nSTMT_EXEC;;38767\n");
char *__cil_tmp37;
  printf("\nSTMT_EXEC;;38768\n");
char *__cil_tmp38;
  printf("\nSTMT_EXEC;;38769\n");
char *__cil_tmp39;

  {
    {
      printf("\nSTMT_EXEC;;38773\n");
len = (size_t)0;
      printf("\nSTMT_EXEC;;38774\n");
quote_string = (char const *)0;
      printf("\nSTMT_EXEC;;38775\n");
quote_string_len = (size_t)0;
      printf("\nSTMT_EXEC;;38776\n");
backslash_escapes = 0;
      printf("\nSTMT_EXEC;;38777\n");
printf("\nFUNC_CALL;__ctype_get_mb_cur_max();\n");
tmp = __ctype_get_mb_cur_max();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;38778\n");
unibyte_locale = tmp == 1UL;
    }
    {
      printf("\nSTMT_EXEC;;38781\n");
if ((unsigned int)quoting_style == 3U)
      {
        printf("\nSTMT_EXEC;;38783\n");
goto case_3;
      }
      printf("\nSTMT_EXEC;;38785\n");
if ((unsigned int)quoting_style == 4U)
      {
        printf("\nSTMT_EXEC;;38787\n");
goto case_4;
      }
      printf("\nSTMT_EXEC;;38789\n");
if ((unsigned int)quoting_style == 5U)
      {
        printf("\nSTMT_EXEC;;38791\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;38793\n");
if ((unsigned int)quoting_style == 6U)
      {
        printf("\nSTMT_EXEC;;38795\n");
goto case_5;
      }
      printf("\nSTMT_EXEC;;38797\n");
if ((unsigned int)quoting_style == 2U)
      {
        printf("\nSTMT_EXEC;;38799\n");
goto case_2;
      }
      printf("\nSTMT_EXEC;;38801\n");
goto switch_default;
    case_3: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;38804\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;38807\n");
if (len < buffersize)
        {
          printf("\nSTMT_EXEC;;38809\n");
*(buffer___2 + len) = (char)'\"';
        }
        printf("\nSTMT_EXEC;;38811\n");
len++;
        printf("\nSTMT_EXEC;;38812\n");
goto while_break;
      }
    while_break: /* CIL Label */;
    }
      printf("\nSTMT_EXEC;;38816\n");
backslash_escapes = 1;
      printf("\nSTMT_EXEC;;38817\n");
quote_string = "\"";
      printf("\nSTMT_EXEC;;38818\n");
quote_string_len = (size_t)1;
      printf("\nSTMT_EXEC;;38819\n");
goto switch_break;
    case_4: /* CIL Label */
      {
printf("\nSTMT_EXEC;;38821\n");
backslash_escapes = 1;
}

      printf("\nSTMT_EXEC;;38822\n");
goto switch_break;
    case_5: /* CIL Label */
    case_6: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;38826\n");
tmp___0 = gettext_quote("`", quoting_style);
      printf("\nSTMT_EXEC;;38827\n");
left = tmp___0;
      printf("\nSTMT_EXEC;;38828\n");
tmp___1 = gettext_quote("\'", quoting_style);
      printf("\nSTMT_EXEC;;38829\n");
right = tmp___1;
      printf("\nSTMT_EXEC;;38830\n");
quote_string = left;
    }
      {
        printf("\nSTMT_EXEC;;38833\n");
while (1)
        {
        while_continue___0: /* CIL Label */;
          printf("\nSTMT_EXEC;;38836\n");
if (!*quote_string)
          {
            printf("\nSTMT_EXEC;;38838\n");
goto while_break___0;
          }
          {
            printf("\nSTMT_EXEC;;38841\n");
while (1)
            {
            while_continue___1: /* CIL Label */;
              printf("\nSTMT_EXEC;;38844\n");
if (len < buffersize)
              {
                printf("\nSTMT_EXEC;;38846\n");
*(buffer___2 + len) = (char)*quote_string;
              }
              printf("\nSTMT_EXEC;;38848\n");
len++;
              printf("\nSTMT_EXEC;;38849\n");
goto while_break___1;
            }
          while_break___1: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;38853\n");
quote_string++;
        }
      while_break___0: /* CIL Label */;
      }
      {
        printf("\nSTMT_EXEC;;38858\n");
backslash_escapes = 1;
        printf("\nSTMT_EXEC;;38859\n");
quote_string = right;
        printf("\nSTMT_EXEC;;38860\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
quote_string_len = strlen(quote_string);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;38862\n");
goto switch_break;
    case_2: /* CIL Label */
    {
      printf("\nSTMT_EXEC;;38865\n");
while (1)
      {
      while_continue___2: /* CIL Label */;
        printf("\nSTMT_EXEC;;38868\n");
if (len < buffersize)
        {
          printf("\nSTMT_EXEC;;38870\n");
*(buffer___2 + len) = (char)'\'';
        }
        printf("\nSTMT_EXEC;;38872\n");
len++;
        printf("\nSTMT_EXEC;;38873\n");
goto while_break___2;
      }
    while_break___2: /* CIL Label */;
    }
      printf("\nSTMT_EXEC;;38877\n");
quote_string = "\'";
      printf("\nSTMT_EXEC;;38878\n");
quote_string_len = (size_t)1;
      printf("\nSTMT_EXEC;;38879\n");
goto switch_break;
    switch_default: /* CIL Label */
      {
printf("\nSTMT_EXEC;;38881\n");
goto switch_break;
}

    switch_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;38884\n");
i = (size_t)0;
    {
      printf("\nSTMT_EXEC;;38886\n");
while (1)
      {
      while_continue___3: /* CIL Label */;
        printf("\nSTMT_EXEC;;38889\n");
if (argsize == 0xffffffffffffffffUL)
        {
          printf("\nSTMT_EXEC;;38891\n");
tmp___9 = (int const) * (arg + i) == 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;38895\n");
tmp___9 = i == argsize;
        }
        printf("\nSTMT_EXEC;;38897\n");
if (tmp___9)
        {
          printf("\nSTMT_EXEC;;38899\n");
goto while_break___3;
        }
        printf("\nSTMT_EXEC;;38901\n");
if (backslash_escapes)
        {
          printf("\nSTMT_EXEC;;38903\n");
if (quote_string_len)
          {
            printf("\nSTMT_EXEC;;38905\n");
if (i + quote_string_len <= argsize)
            {
              {
                printf("\nSTMT_EXEC;;38908\n");
printf("\nFUNC_CALL;memcmp(const void *,const void *,size_t);\n");
tmp___2 = memcmp((void const *)(arg + i), (void const *)quote_string, quote_string_len);printf("\nFUNC_RETURN;;\n");

              }
              printf("\nSTMT_EXEC;;38910\n");
if (tmp___2 == 0)
              {
                {
                  printf("\nSTMT_EXEC;;38913\n");
while (1)
                  {
                  while_continue___4: /* CIL Label */;
                    printf("\nSTMT_EXEC;;38916\n");
if (len < buffersize)
                    {
                      printf("\nSTMT_EXEC;;38918\n");
*(buffer___2 + len) = (char)'\\';
                    }
                    printf("\nSTMT_EXEC;;38920\n");
len++;
                    printf("\nSTMT_EXEC;;38921\n");
goto while_break___4;
                  }
                while_break___4: /* CIL Label */;
                }
              }
            }
          }
        }
        printf("\nSTMT_EXEC;;38929\n");
c = (unsigned char)*(arg + i);
        {
          printf("\nSTMT_EXEC;;38931\n");
if ((int)c == 0)
          {
            printf("\nSTMT_EXEC;;38933\n");
goto case_0;
          }
          printf("\nSTMT_EXEC;;38935\n");
if ((int)c == 63)
          {
            printf("\nSTMT_EXEC;;38937\n");
goto case_63;
          }
          printf("\nSTMT_EXEC;;38939\n");
if ((int)c == 7)
          {
            printf("\nSTMT_EXEC;;38941\n");
goto case_7;
          }
          printf("\nSTMT_EXEC;;38943\n");
if ((int)c == 8)
          {
            printf("\nSTMT_EXEC;;38945\n");
goto case_8;
          }
          printf("\nSTMT_EXEC;;38947\n");
if ((int)c == 12)
          {
            printf("\nSTMT_EXEC;;38949\n");
goto case_12;
          }
          printf("\nSTMT_EXEC;;38951\n");
if ((int)c == 10)
          {
            printf("\nSTMT_EXEC;;38953\n");
goto case_10;
          }
          printf("\nSTMT_EXEC;;38955\n");
if ((int)c == 13)
          {
            printf("\nSTMT_EXEC;;38957\n");
goto case_13;
          }
          printf("\nSTMT_EXEC;;38959\n");
if ((int)c == 9)
          {
            printf("\nSTMT_EXEC;;38961\n");
goto case_9;
          }
          printf("\nSTMT_EXEC;;38963\n");
if ((int)c == 11)
          {
            printf("\nSTMT_EXEC;;38965\n");
goto case_11;
          }
          printf("\nSTMT_EXEC;;38967\n");
if ((int)c == 92)
          {
            printf("\nSTMT_EXEC;;38969\n");
goto case_92;
          }
          printf("\nSTMT_EXEC;;38971\n");
if ((int)c == 123)
          {
            printf("\nSTMT_EXEC;;38973\n");
goto case_123;
          }
          printf("\nSTMT_EXEC;;38975\n");
if ((int)c == 125)
          {
            printf("\nSTMT_EXEC;;38977\n");
goto case_123;
          }
          printf("\nSTMT_EXEC;;38979\n");
if ((int)c == 35)
          {
            printf("\nSTMT_EXEC;;38981\n");
goto case_35;
          }
          printf("\nSTMT_EXEC;;38983\n");
if ((int)c == 126)
          {
            printf("\nSTMT_EXEC;;38985\n");
goto case_35;
          }
          printf("\nSTMT_EXEC;;38987\n");
if ((int)c == 32)
          {
            printf("\nSTMT_EXEC;;38989\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;38991\n");
if ((int)c == 33)
          {
            printf("\nSTMT_EXEC;;38993\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;38995\n");
if ((int)c == 34)
          {
            printf("\nSTMT_EXEC;;38997\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;38999\n");
if ((int)c == 36)
          {
            printf("\nSTMT_EXEC;;39001\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39003\n");
if ((int)c == 38)
          {
            printf("\nSTMT_EXEC;;39005\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39007\n");
if ((int)c == 40)
          {
            printf("\nSTMT_EXEC;;39009\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39011\n");
if ((int)c == 41)
          {
            printf("\nSTMT_EXEC;;39013\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39015\n");
if ((int)c == 42)
          {
            printf("\nSTMT_EXEC;;39017\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39019\n");
if ((int)c == 59)
          {
            printf("\nSTMT_EXEC;;39021\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39023\n");
if ((int)c == 60)
          {
            printf("\nSTMT_EXEC;;39025\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39027\n");
if ((int)c == 61)
          {
            printf("\nSTMT_EXEC;;39029\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39031\n");
if ((int)c == 62)
          {
            printf("\nSTMT_EXEC;;39033\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39035\n");
if ((int)c == 91)
          {
            printf("\nSTMT_EXEC;;39037\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39039\n");
if ((int)c == 94)
          {
            printf("\nSTMT_EXEC;;39041\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39043\n");
if ((int)c == 96)
          {
            printf("\nSTMT_EXEC;;39045\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39047\n");
if ((int)c == 124)
          {
            printf("\nSTMT_EXEC;;39049\n");
goto case_32;
          }
          printf("\nSTMT_EXEC;;39051\n");
if ((int)c == 39)
          {
            printf("\nSTMT_EXEC;;39053\n");
goto case_39___0;
          }
          printf("\nSTMT_EXEC;;39055\n");
if ((int)c == 37)
          {
            printf("\nSTMT_EXEC;;39057\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39059\n");
if ((int)c == 43)
          {
            printf("\nSTMT_EXEC;;39061\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39063\n");
if ((int)c == 44)
          {
            printf("\nSTMT_EXEC;;39065\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39067\n");
if ((int)c == 45)
          {
            printf("\nSTMT_EXEC;;39069\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39071\n");
if ((int)c == 46)
          {
            printf("\nSTMT_EXEC;;39073\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39075\n");
if ((int)c == 47)
          {
            printf("\nSTMT_EXEC;;39077\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39079\n");
if ((int)c == 48)
          {
            printf("\nSTMT_EXEC;;39081\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39083\n");
if ((int)c == 49)
          {
            printf("\nSTMT_EXEC;;39085\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39087\n");
if ((int)c == 50)
          {
            printf("\nSTMT_EXEC;;39089\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39091\n");
if ((int)c == 51)
          {
            printf("\nSTMT_EXEC;;39093\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39095\n");
if ((int)c == 52)
          {
            printf("\nSTMT_EXEC;;39097\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39099\n");
if ((int)c == 53)
          {
            printf("\nSTMT_EXEC;;39101\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39103\n");
if ((int)c == 54)
          {
            printf("\nSTMT_EXEC;;39105\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39107\n");
if ((int)c == 55)
          {
            printf("\nSTMT_EXEC;;39109\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39111\n");
if ((int)c == 56)
          {
            printf("\nSTMT_EXEC;;39113\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39115\n");
if ((int)c == 57)
          {
            printf("\nSTMT_EXEC;;39117\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39119\n");
if ((int)c == 58)
          {
            printf("\nSTMT_EXEC;;39121\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39123\n");
if ((int)c == 65)
          {
            printf("\nSTMT_EXEC;;39125\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39127\n");
if ((int)c == 66)
          {
            printf("\nSTMT_EXEC;;39129\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39131\n");
if ((int)c == 67)
          {
            printf("\nSTMT_EXEC;;39133\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39135\n");
if ((int)c == 68)
          {
            printf("\nSTMT_EXEC;;39137\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39139\n");
if ((int)c == 69)
          {
            printf("\nSTMT_EXEC;;39141\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39143\n");
if ((int)c == 70)
          {
            printf("\nSTMT_EXEC;;39145\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39147\n");
if ((int)c == 71)
          {
            printf("\nSTMT_EXEC;;39149\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39151\n");
if ((int)c == 72)
          {
            printf("\nSTMT_EXEC;;39153\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39155\n");
if ((int)c == 73)
          {
            printf("\nSTMT_EXEC;;39157\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39159\n");
if ((int)c == 74)
          {
            printf("\nSTMT_EXEC;;39161\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39163\n");
if ((int)c == 75)
          {
            printf("\nSTMT_EXEC;;39165\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39167\n");
if ((int)c == 76)
          {
            printf("\nSTMT_EXEC;;39169\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39171\n");
if ((int)c == 77)
          {
            printf("\nSTMT_EXEC;;39173\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39175\n");
if ((int)c == 78)
          {
            printf("\nSTMT_EXEC;;39177\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39179\n");
if ((int)c == 79)
          {
            printf("\nSTMT_EXEC;;39181\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39183\n");
if ((int)c == 80)
          {
            printf("\nSTMT_EXEC;;39185\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39187\n");
if ((int)c == 81)
          {
            printf("\nSTMT_EXEC;;39189\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39191\n");
if ((int)c == 82)
          {
            printf("\nSTMT_EXEC;;39193\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39195\n");
if ((int)c == 83)
          {
            printf("\nSTMT_EXEC;;39197\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39199\n");
if ((int)c == 84)
          {
            printf("\nSTMT_EXEC;;39201\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39203\n");
if ((int)c == 85)
          {
            printf("\nSTMT_EXEC;;39205\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39207\n");
if ((int)c == 86)
          {
            printf("\nSTMT_EXEC;;39209\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39211\n");
if ((int)c == 87)
          {
            printf("\nSTMT_EXEC;;39213\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39215\n");
if ((int)c == 88)
          {
            printf("\nSTMT_EXEC;;39217\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39219\n");
if ((int)c == 89)
          {
            printf("\nSTMT_EXEC;;39221\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39223\n");
if ((int)c == 90)
          {
            printf("\nSTMT_EXEC;;39225\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39227\n");
if ((int)c == 93)
          {
            printf("\nSTMT_EXEC;;39229\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39231\n");
if ((int)c == 95)
          {
            printf("\nSTMT_EXEC;;39233\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39235\n");
if ((int)c == 97)
          {
            printf("\nSTMT_EXEC;;39237\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39239\n");
if ((int)c == 98)
          {
            printf("\nSTMT_EXEC;;39241\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39243\n");
if ((int)c == 99)
          {
            printf("\nSTMT_EXEC;;39245\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39247\n");
if ((int)c == 100)
          {
            printf("\nSTMT_EXEC;;39249\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39251\n");
if ((int)c == 101)
          {
            printf("\nSTMT_EXEC;;39253\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39255\n");
if ((int)c == 102)
          {
            printf("\nSTMT_EXEC;;39257\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39259\n");
if ((int)c == 103)
          {
            printf("\nSTMT_EXEC;;39261\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39263\n");
if ((int)c == 104)
          {
            printf("\nSTMT_EXEC;;39265\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39267\n");
if ((int)c == 105)
          {
            printf("\nSTMT_EXEC;;39269\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39271\n");
if ((int)c == 106)
          {
            printf("\nSTMT_EXEC;;39273\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39275\n");
if ((int)c == 107)
          {
            printf("\nSTMT_EXEC;;39277\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39279\n");
if ((int)c == 108)
          {
            printf("\nSTMT_EXEC;;39281\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39283\n");
if ((int)c == 109)
          {
            printf("\nSTMT_EXEC;;39285\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39287\n");
if ((int)c == 110)
          {
            printf("\nSTMT_EXEC;;39289\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39291\n");
if ((int)c == 111)
          {
            printf("\nSTMT_EXEC;;39293\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39295\n");
if ((int)c == 112)
          {
            printf("\nSTMT_EXEC;;39297\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39299\n");
if ((int)c == 113)
          {
            printf("\nSTMT_EXEC;;39301\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39303\n");
if ((int)c == 114)
          {
            printf("\nSTMT_EXEC;;39305\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39307\n");
if ((int)c == 115)
          {
            printf("\nSTMT_EXEC;;39309\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39311\n");
if ((int)c == 116)
          {
            printf("\nSTMT_EXEC;;39313\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39315\n");
if ((int)c == 117)
          {
            printf("\nSTMT_EXEC;;39317\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39319\n");
if ((int)c == 118)
          {
            printf("\nSTMT_EXEC;;39321\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39323\n");
if ((int)c == 119)
          {
            printf("\nSTMT_EXEC;;39325\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39327\n");
if ((int)c == 120)
          {
            printf("\nSTMT_EXEC;;39329\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39331\n");
if ((int)c == 121)
          {
            printf("\nSTMT_EXEC;;39333\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39335\n");
if ((int)c == 122)
          {
            printf("\nSTMT_EXEC;;39337\n");
goto case_37;
          }
          printf("\nSTMT_EXEC;;39339\n");
goto switch_default___2;
        case_0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39341\n");
if (backslash_escapes)
          {
            {
              printf("\nSTMT_EXEC;;39344\n");
while (1)
              {
              while_continue___5: /* CIL Label */;
                printf("\nSTMT_EXEC;;39347\n");
if (len < buffersize)
                {
                  printf("\nSTMT_EXEC;;39349\n");
*(buffer___2 + len) = (char)'\\';
                }
                printf("\nSTMT_EXEC;;39351\n");
len++;
                printf("\nSTMT_EXEC;;39352\n");
goto while_break___5;
              }
            while_break___5: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;39357\n");
while (1)
              {
              while_continue___6: /* CIL Label */;
                printf("\nSTMT_EXEC;;39360\n");
if (len < buffersize)
                {
                  printf("\nSTMT_EXEC;;39362\n");
*(buffer___2 + len) = (char)'0';
                }
                printf("\nSTMT_EXEC;;39364\n");
len++;
                printf("\nSTMT_EXEC;;39365\n");
goto while_break___6;
              }
            while_break___6: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;39370\n");
while (1)
              {
              while_continue___7: /* CIL Label */;
                printf("\nSTMT_EXEC;;39373\n");
if (len < buffersize)
                {
                  printf("\nSTMT_EXEC;;39375\n");
*(buffer___2 + len) = (char)'0';
                }
                printf("\nSTMT_EXEC;;39377\n");
len++;
                printf("\nSTMT_EXEC;;39378\n");
goto while_break___7;
              }
            while_break___7: /* CIL Label */;
            }
            printf("\nSTMT_EXEC;;39382\n");
c = (unsigned char)'0';
          }
}

          printf("\nSTMT_EXEC;;39384\n");
goto switch_break___0;
        case_63: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;39387\n");
if ((unsigned int)quoting_style == 1U)
          {
            printf("\nSTMT_EXEC;;39389\n");
goto case_1;
          }
          printf("\nSTMT_EXEC;;39391\n");
if ((unsigned int)quoting_style == 3U)
          {
            printf("\nSTMT_EXEC;;39393\n");
goto case_3___0;
          }
          printf("\nSTMT_EXEC;;39395\n");
goto switch_default___0;
        case_1: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39397\n");
goto use_shell_always_quoting_style;
}

        case_3___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39399\n");
if (i + 2UL < argsize)
          {
            printf("\nSTMT_EXEC;;39401\n");
if ((int const) * (arg + (i + 1UL)) == 63)
            {
              {
                printf("\nSTMT_EXEC;;39404\n");
if ((int const) * (arg + (i + 2UL)) == 33)
                {
                  printf("\nSTMT_EXEC;;39406\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39408\n");
if ((int const) * (arg + (i + 2UL)) == 39)
                {
                  printf("\nSTMT_EXEC;;39410\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39412\n");
if ((int const) * (arg + (i + 2UL)) == 40)
                {
                  printf("\nSTMT_EXEC;;39414\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39416\n");
if ((int const) * (arg + (i + 2UL)) == 41)
                {
                  printf("\nSTMT_EXEC;;39418\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39420\n");
if ((int const) * (arg + (i + 2UL)) == 45)
                {
                  printf("\nSTMT_EXEC;;39422\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39424\n");
if ((int const) * (arg + (i + 2UL)) == 47)
                {
                  printf("\nSTMT_EXEC;;39426\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39428\n");
if ((int const) * (arg + (i + 2UL)) == 60)
                {
                  printf("\nSTMT_EXEC;;39430\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39432\n");
if ((int const) * (arg + (i + 2UL)) == 61)
                {
                  printf("\nSTMT_EXEC;;39434\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39436\n");
if ((int const) * (arg + (i + 2UL)) == 62)
                {
                  printf("\nSTMT_EXEC;;39438\n");
goto case_33;
                }
                printf("\nSTMT_EXEC;;39440\n");
goto switch_break___2;
              case_33: /* CIL Label */
              case_39: /* CIL Label */
              case_40: /* CIL Label */
              case_41: /* CIL Label */
              case_45: /* CIL Label */
              case_47: /* CIL Label */
              case_60: /* CIL Label */
              case_61: /* CIL Label */
              case_62: /* CIL Label */
                {
printf("\nSTMT_EXEC;;39450\n");
c = (unsigned char)*(arg + (i + 2UL));
}

                printf("\nSTMT_EXEC;;39451\n");
i += 2UL;
                {
                  printf("\nSTMT_EXEC;;39453\n");
while (1)
                  {
                  while_continue___8: /* CIL Label */;
                    printf("\nSTMT_EXEC;;39456\n");
if (len < buffersize)
                    {
                      printf("\nSTMT_EXEC;;39458\n");
*(buffer___2 + len) = (char)'?';
                    }
                    printf("\nSTMT_EXEC;;39460\n");
len++;
                    printf("\nSTMT_EXEC;;39461\n");
goto while_break___8;
                  }
                while_break___8: /* CIL Label */;
                }
                {
                  printf("\nSTMT_EXEC;;39466\n");
while (1)
                  {
                  while_continue___9: /* CIL Label */;
                    printf("\nSTMT_EXEC;;39469\n");
if (len < buffersize)
                    {
                      printf("\nSTMT_EXEC;;39471\n");
*(buffer___2 + len) = (char)'\\';
                    }
                    printf("\nSTMT_EXEC;;39473\n");
len++;
                    printf("\nSTMT_EXEC;;39474\n");
goto while_break___9;
                  }
                while_break___9: /* CIL Label */;
                }
                {
                  printf("\nSTMT_EXEC;;39479\n");
while (1)
                  {
                  while_continue___10: /* CIL Label */;
                    printf("\nSTMT_EXEC;;39482\n");
if (len < buffersize)
                    {
                      printf("\nSTMT_EXEC;;39484\n");
*(buffer___2 + len) = (char)'?';
                    }
                    printf("\nSTMT_EXEC;;39486\n");
len++;
                    printf("\nSTMT_EXEC;;39487\n");
goto while_break___10;
                  }
                while_break___10: /* CIL Label */;
                }
                printf("\nSTMT_EXEC;;39491\n");
goto switch_break___2;
              switch_break___2: /* CIL Label */;
              }
            }
          }
}

          printf("\nSTMT_EXEC;;39496\n");
goto switch_break___1;
        switch_default___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39498\n");
goto switch_break___1;
}

        switch_break___1: /* CIL Label */;
        }
          printf("\nSTMT_EXEC;;39501\n");
goto switch_break___0;
        case_7: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39503\n");
esc = (unsigned char)'a';
}

          printf("\nSTMT_EXEC;;39504\n");
goto c_escape;
        case_8: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39506\n");
esc = (unsigned char)'b';
}

          printf("\nSTMT_EXEC;;39507\n");
goto c_escape;
        case_12: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39509\n");
esc = (unsigned char)'f';
}

          printf("\nSTMT_EXEC;;39510\n");
goto c_escape;
        case_10: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39512\n");
esc = (unsigned char)'n';
}

          printf("\nSTMT_EXEC;;39513\n");
goto c_and_shell_escape;
        case_13: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39515\n");
esc = (unsigned char)'r';
}

          printf("\nSTMT_EXEC;;39516\n");
goto c_and_shell_escape;
        case_9: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39518\n");
esc = (unsigned char)'t';
}

          printf("\nSTMT_EXEC;;39519\n");
goto c_and_shell_escape;
        case_11: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39521\n");
esc = (unsigned char)'v';
}

          printf("\nSTMT_EXEC;;39522\n");
goto c_escape;
        case_92: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39524\n");
esc = c;
}

          printf("\nSTMT_EXEC;;39525\n");
goto c_and_shell_escape;
        c_and_shell_escape:
          {
printf("\nSTMT_EXEC;;39527\n");
if ((unsigned int)quoting_style == 1U)
          {
            printf("\nSTMT_EXEC;;39529\n");
goto use_shell_always_quoting_style;
          }
}

        c_escape:
          {
printf("\nSTMT_EXEC;;39532\n");
if (backslash_escapes)
          {
            printf("\nSTMT_EXEC;;39534\n");
c = esc;
            printf("\nSTMT_EXEC;;39535\n");
goto store_escape;
          }
}

          printf("\nSTMT_EXEC;;39537\n");
goto switch_break___0;
        case_123: /* CIL Label */
        case_125: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39540\n");
if (argsize == 0xffffffffffffffffUL)
          {
            printf("\nSTMT_EXEC;;39542\n");
tmp___8 = (int const) * (arg + 1) == 0;
          }
          else
          {
            printf("\nSTMT_EXEC;;39546\n");
tmp___8 = argsize == 1UL;
          }
}

          printf("\nSTMT_EXEC;;39548\n");
if (!tmp___8)
          {
            printf("\nSTMT_EXEC;;39550\n");
goto switch_break___0;
          }
        case_35:  /* CIL Label */
        case_126: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39554\n");
if (i != 0UL)
          {
            printf("\nSTMT_EXEC;;39556\n");
goto switch_break___0;
          }
}

        case_32:     /* CIL Label */
        case_33___0: /* CIL Label */
        case_34:     /* CIL Label */
        case_36:     /* CIL Label */
        case_38:     /* CIL Label */
        case_40___0: /* CIL Label */
        case_41___0: /* CIL Label */
        case_42:     /* CIL Label */
        case_59:     /* CIL Label */
        case_60___0: /* CIL Label */
        case_61___0: /* CIL Label */
        case_62___0: /* CIL Label */
        case_91:     /* CIL Label */
        case_94:     /* CIL Label */
        case_96:     /* CIL Label */
        case_124:    /* CIL Label */
          {
printf("\nSTMT_EXEC;;39574\n");
if ((unsigned int)quoting_style == 1U)
          {
            printf("\nSTMT_EXEC;;39576\n");
goto use_shell_always_quoting_style;
          }
}

          printf("\nSTMT_EXEC;;39578\n");
goto switch_break___0;
        case_39___0: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;39581\n");
if ((unsigned int)quoting_style == 1U)
          {
            printf("\nSTMT_EXEC;;39583\n");
goto case_1___0;
          }
          printf("\nSTMT_EXEC;;39585\n");
if ((unsigned int)quoting_style == 2U)
          {
            printf("\nSTMT_EXEC;;39587\n");
goto case_2___0;
          }
          printf("\nSTMT_EXEC;;39589\n");
goto switch_default___1;
        case_1___0: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39591\n");
goto use_shell_always_quoting_style;
}

        case_2___0: /* CIL Label */
        {
          printf("\nSTMT_EXEC;;39594\n");
while (1)
          {
          while_continue___11: /* CIL Label */;
            printf("\nSTMT_EXEC;;39597\n");
if (len < buffersize)
            {
              printf("\nSTMT_EXEC;;39599\n");
*(buffer___2 + len) = (char)'\'';
            }
            printf("\nSTMT_EXEC;;39601\n");
len++;
            printf("\nSTMT_EXEC;;39602\n");
goto while_break___11;
          }
        while_break___11: /* CIL Label */;
        }
          {
            printf("\nSTMT_EXEC;;39607\n");
while (1)
            {
            while_continue___12: /* CIL Label */;
              printf("\nSTMT_EXEC;;39610\n");
if (len < buffersize)
              {
                printf("\nSTMT_EXEC;;39612\n");
*(buffer___2 + len) = (char)'\\';
              }
              printf("\nSTMT_EXEC;;39614\n");
len++;
              printf("\nSTMT_EXEC;;39615\n");
goto while_break___12;
            }
          while_break___12: /* CIL Label */;
          }
          {
            printf("\nSTMT_EXEC;;39620\n");
while (1)
            {
            while_continue___13: /* CIL Label */;
              printf("\nSTMT_EXEC;;39623\n");
if (len < buffersize)
              {
                printf("\nSTMT_EXEC;;39625\n");
*(buffer___2 + len) = (char)'\'';
              }
              printf("\nSTMT_EXEC;;39627\n");
len++;
              printf("\nSTMT_EXEC;;39628\n");
goto while_break___13;
            }
          while_break___13: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;39632\n");
goto switch_break___3;
        switch_default___1: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39634\n");
goto switch_break___3;
}

        switch_break___3: /* CIL Label */;
        }
          printf("\nSTMT_EXEC;;39637\n");
goto switch_break___0;
        case_37:     /* CIL Label */
        case_43:     /* CIL Label */
        case_44:     /* CIL Label */
        case_45___0: /* CIL Label */
        case_46:     /* CIL Label */
        case_47___0: /* CIL Label */
        case_48:     /* CIL Label */
        case_49:     /* CIL Label */
        case_50:     /* CIL Label */
        case_51:     /* CIL Label */
        case_52:     /* CIL Label */
        case_53:     /* CIL Label */
        case_54:     /* CIL Label */
        case_55:     /* CIL Label */
        case_56:     /* CIL Label */
        case_57:     /* CIL Label */
        case_58:     /* CIL Label */
        case_65:     /* CIL Label */
        case_66:     /* CIL Label */
        case_67:     /* CIL Label */
        case_68:     /* CIL Label */
        case_69:     /* CIL Label */
        case_70:     /* CIL Label */
        case_71:     /* CIL Label */
        case_72:     /* CIL Label */
        case_73:     /* CIL Label */
        case_74:     /* CIL Label */
        case_75:     /* CIL Label */
        case_76:     /* CIL Label */
        case_77:     /* CIL Label */
        case_78:     /* CIL Label */
        case_79:     /* CIL Label */
        case_80:     /* CIL Label */
        case_81:     /* CIL Label */
        case_82:     /* CIL Label */
        case_83:     /* CIL Label */
        case_84:     /* CIL Label */
        case_85:     /* CIL Label */
        case_86:     /* CIL Label */
        case_87:     /* CIL Label */
        case_88:     /* CIL Label */
        case_89:     /* CIL Label */
        case_90:     /* CIL Label */
        case_93:     /* CIL Label */
        case_95:     /* CIL Label */
        case_97:     /* CIL Label */
        case_98:     /* CIL Label */
        case_99:     /* CIL Label */
        case_100:    /* CIL Label */
        case_101:    /* CIL Label */
        case_102:    /* CIL Label */
        case_103:    /* CIL Label */
        case_104:    /* CIL Label */
        case_105:    /* CIL Label */
        case_106:    /* CIL Label */
        case_107:    /* CIL Label */
        case_108:    /* CIL Label */
        case_109:    /* CIL Label */
        case_110:    /* CIL Label */
        case_111:    /* CIL Label */
        case_112:    /* CIL Label */
        case_113:    /* CIL Label */
        case_114:    /* CIL Label */
        case_115:    /* CIL Label */
        case_116:    /* CIL Label */
        case_117:    /* CIL Label */
        case_118:    /* CIL Label */
        case_119:    /* CIL Label */
        case_120:    /* CIL Label */
        case_121:    /* CIL Label */
        case_122:    /* CIL Label */
          {
printf("\nSTMT_EXEC;;39709\n");
goto switch_break___0;
}

        switch_default___2: /* CIL Label */
          {
printf("\nSTMT_EXEC;;39711\n");
if (unibyte_locale)
          {
            {
              printf("\nSTMT_EXEC;;39714\n");
m = (size_t)1;
              printf("\nSTMT_EXEC;;39715\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___3 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;39716\n");
printable = (int)((int const) * (*tmp___3 + (int)c) & 16384);
            }
          }
          else
          {
            {
              printf("\nSTMT_EXEC;;39722\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(&mbstate), 0, sizeof(mbstate));printf("\nFUNC_RETURN;;\n");

              printf("\nSTMT_EXEC;;39723\n");
m = (size_t)0;
              printf("\nSTMT_EXEC;;39724\n");
printable = 1;
            }
            printf("\nSTMT_EXEC;;39726\n");
if (argsize == 0xffffffffffffffffUL)
            {
              {
                printf("\nSTMT_EXEC;;39729\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
argsize = strlen(arg);printf("\nFUNC_RETURN;;\n");

              }
            }
            {
              printf("\nSTMT_EXEC;;39733\n");
while (1)
              {
              while_continue___14: /* CIL Label */;
                {
                  printf("\nSTMT_EXEC;;39737\n");
printf("\nFUNC_CALL;mbrtowc(wchar_t *__restrict,const char *__restrict,size_t,mbstate_t *__restrict);\n");
tmp___4 = mbrtowc((wchar_t * /* __restrict  */)(&w), (char const * /* __restrict  */)(arg + (i + m)), argsize - (i + m), (mbstate_t * /* __restrict  */)(&mbstate));printf("\nFUNC_RETURN;;\n");

                  printf("\nSTMT_EXEC;;39738\n");
bytes = tmp___4;
                }
                printf("\nSTMT_EXEC;;39740\n");
if (bytes == 0UL)
                {
                  printf("\nSTMT_EXEC;;39742\n");
goto while_break___14;
                }
                else
                {
                  printf("\nSTMT_EXEC;;39746\n");
if (bytes == 0xffffffffffffffffUL)
                  {
                    printf("\nSTMT_EXEC;;39748\n");
printable = 0;
                    printf("\nSTMT_EXEC;;39749\n");
goto while_break___14;
                  }
                  else
                  {
                    printf("\nSTMT_EXEC;;39753\n");
if (bytes == 0xfffffffffffffffeUL)
                    {
                      printf("\nSTMT_EXEC;;39755\n");
printable = 0;
                      {
                        printf("\nSTMT_EXEC;;39757\n");
while (1)
                        {
                        while_continue___15: /* CIL Label */;
                          printf("\nSTMT_EXEC;;39760\n");
if (i + m < argsize)
                          {
                            printf("\nSTMT_EXEC;;39762\n");
if (!*(arg + (i + m)))
                            {
                              printf("\nSTMT_EXEC;;39764\n");
goto while_break___15;
                            }
                          }
                          else
                          {
                            printf("\nSTMT_EXEC;;39769\n");
goto while_break___15;
                          }
                          printf("\nSTMT_EXEC;;39771\n");
m++;
                        }
                      while_break___15: /* CIL Label */;
                      }
                      printf("\nSTMT_EXEC;;39775\n");
goto while_break___14;
                    }
                    else
                    {
                      printf("\nSTMT_EXEC;;39779\n");
if ((unsigned int)quoting_style == 1U)
                      {
                        printf("\nSTMT_EXEC;;39781\n");
j = (size_t)1;
                        {
                          printf("\nSTMT_EXEC;;39783\n");
while (1)
                          {
                          while_continue___16: /* CIL Label */;
                            printf("\nSTMT_EXEC;;39786\n");
if (!(j < bytes))
                            {
                              printf("\nSTMT_EXEC;;39788\n");
goto while_break___16;
                            }
                            {
                              printf("\nSTMT_EXEC;;39791\n");
if ((int const) * (arg + ((i + m) + j)) == 91)
                              {
                                printf("\nSTMT_EXEC;;39793\n");
goto case_91___0;
                              }
                              printf("\nSTMT_EXEC;;39795\n");
if ((int const) * (arg + ((i + m) + j)) == 92)
                              {
                                printf("\nSTMT_EXEC;;39797\n");
goto case_91___0;
                              }
                              printf("\nSTMT_EXEC;;39799\n");
if ((int const) * (arg + ((i + m) + j)) == 94)
                              {
                                printf("\nSTMT_EXEC;;39801\n");
goto case_91___0;
                              }
                              printf("\nSTMT_EXEC;;39803\n");
if ((int const) * (arg + ((i + m) + j)) == 96)
                              {
                                printf("\nSTMT_EXEC;;39805\n");
goto case_91___0;
                              }
                              printf("\nSTMT_EXEC;;39807\n");
if ((int const) * (arg + ((i + m) + j)) == 124)
                              {
                                printf("\nSTMT_EXEC;;39809\n");
goto case_91___0;
                              }
                              printf("\nSTMT_EXEC;;39811\n");
goto switch_break___4;
                            case_91___0:  /* CIL Label */
                            case_92___0:  /* CIL Label */
                            case_94___0:  /* CIL Label */
                            case_96___0:  /* CIL Label */
                            case_124___0: /* CIL Label */
                              {
printf("\nSTMT_EXEC;;39817\n");
goto use_shell_always_quoting_style;
}

                            switch_break___4: /* CIL Label */;
                            }
                            printf("\nSTMT_EXEC;;39820\n");
j++;
                          }
                        while_break___16: /* CIL Label */;
                        }
                      }
                      {
                        printf("\nSTMT_EXEC;;39826\n");
printf("\nFUNC_CALL;iswprint(wint_t);\n");
tmp___5 = iswprint((wint_t)w);printf("\nFUNC_RETURN;;\n");

                      }
                      printf("\nSTMT_EXEC;;39828\n");
if (!tmp___5)
                      {
                        printf("\nSTMT_EXEC;;39830\n");
printable = 0;
                      }
                      printf("\nSTMT_EXEC;;39832\n");
m += bytes;
                    }
                  }
                }
                {
                  printf("\nSTMT_EXEC;;39837\n");
printf("\nFUNC_CALL;mbsinit(const mbstate_t *);\n");
tmp___6 = mbsinit((mbstate_t const *)(&mbstate));printf("\nFUNC_RETURN;;\n");

                }
                printf("\nSTMT_EXEC;;39839\n");
if (tmp___6)
                {
                  printf("\nSTMT_EXEC;;39841\n");
goto while_break___14;
                }
              }
            while_break___14: /* CIL Label */;
            }
          }
}

          printf("\nSTMT_EXEC;;39847\n");
if (1UL < m)
          {
            printf("\nSTMT_EXEC;;39849\n");
goto _L___3;
          }
          else
          {
            printf("\nSTMT_EXEC;;39853\n");
if (backslash_escapes)
            {
              printf("\nSTMT_EXEC;;39855\n");
if (!printable)
              {
              _L___3: /* CIL Label */
                {
printf("\nSTMT_EXEC;;39858\n");
ilim = i + m;
}

                {
                  printf("\nSTMT_EXEC;;39860\n");
while (1)
                  {
                  while_continue___17: /* CIL Label */;
                    printf("\nSTMT_EXEC;;39863\n");
if (backslash_escapes)
                    {
                      printf("\nSTMT_EXEC;;39865\n");
if (!printable)
                      {
                        {
                          printf("\nSTMT_EXEC;;39868\n");
while (1)
                          {
                          while_continue___18: /* CIL Label */;
                            printf("\nSTMT_EXEC;;39871\n");
if (len < buffersize)
                            {
                              printf("\nSTMT_EXEC;;39873\n");
*(buffer___2 + len) = (char)'\\';
                            }
                            printf("\nSTMT_EXEC;;39875\n");
len++;
                            printf("\nSTMT_EXEC;;39876\n");
goto while_break___18;
                          }
                        while_break___18: /* CIL Label */;
                        }
                        {
                          printf("\nSTMT_EXEC;;39881\n");
while (1)
                          {
                          while_continue___19: /* CIL Label */;
                            printf("\nSTMT_EXEC;;39884\n");
if (len < buffersize)
                            {
                              printf("\nSTMT_EXEC;;39886\n");
*(buffer___2 + len) = (char)(48 + ((int)c >> 6));
                            }
                            printf("\nSTMT_EXEC;;39888\n");
len++;
                            printf("\nSTMT_EXEC;;39889\n");
goto while_break___19;
                          }
                        while_break___19: /* CIL Label */;
                        }
                        {
                          printf("\nSTMT_EXEC;;39894\n");
while (1)
                          {
                          while_continue___20: /* CIL Label */;
                            printf("\nSTMT_EXEC;;39897\n");
if (len < buffersize)
                            {
                              printf("\nSTMT_EXEC;;39899\n");
*(buffer___2 + len) = (char)(48 + (((int)c >> 3) & 7));
                            }
                            printf("\nSTMT_EXEC;;39901\n");
len++;
                            printf("\nSTMT_EXEC;;39902\n");
goto while_break___20;
                          }
                        while_break___20: /* CIL Label */;
                        }
                        printf("\nSTMT_EXEC;;39906\n");
c = (unsigned char)(48 + ((int)c & 7));
                      }
                    }
                    printf("\nSTMT_EXEC;;39909\n");
if (ilim <= i + 1UL)
                    {
                      printf("\nSTMT_EXEC;;39911\n");
goto while_break___17;
                    }
                    {
                      printf("\nSTMT_EXEC;;39914\n");
while (1)
                      {
                      while_continue___21: /* CIL Label */;
                        printf("\nSTMT_EXEC;;39917\n");
if (len < buffersize)
                        {
                          printf("\nSTMT_EXEC;;39919\n");
*(buffer___2 + len) = (char)c;
                        }
                        printf("\nSTMT_EXEC;;39921\n");
len++;
                        printf("\nSTMT_EXEC;;39922\n");
goto while_break___21;
                      }
                    while_break___21: /* CIL Label */;
                    }
                    printf("\nSTMT_EXEC;;39926\n");
i++;
                    printf("\nSTMT_EXEC;;39927\n");
c = (unsigned char)*(arg + i);
                  }
                while_break___17: /* CIL Label */;
                }
                printf("\nSTMT_EXEC;;39931\n");
goto store_c;
              }
            }
          }
        switch_break___0: /* CIL Label */;
        }
        printf("\nSTMT_EXEC;;39937\n");
if (backslash_escapes)
        {
          printf("\nSTMT_EXEC;;39939\n");
if (!(o___0->quote_these_too[(unsigned long)c / (sizeof(int) * 8UL)] & (1 << (unsigned long)c % (sizeof(int) * 8UL))))
          {
            printf("\nSTMT_EXEC;;39941\n");
goto store_c;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;39946\n");
goto store_c;
        }
      store_escape:
      {
        printf("\nSTMT_EXEC;;39950\n");
while (1)
        {
        while_continue___22: /* CIL Label */;
          printf("\nSTMT_EXEC;;39953\n");
if (len < buffersize)
          {
            printf("\nSTMT_EXEC;;39955\n");
*(buffer___2 + len) = (char)'\\';
          }
          printf("\nSTMT_EXEC;;39957\n");
len++;
          printf("\nSTMT_EXEC;;39958\n");
goto while_break___22;
        }
      while_break___22: /* CIL Label */;
      }
      store_c:
      {
        printf("\nSTMT_EXEC;;39964\n");
while (1)
        {
        while_continue___23: /* CIL Label */;
          printf("\nSTMT_EXEC;;39967\n");
if (len < buffersize)
          {
            printf("\nSTMT_EXEC;;39969\n");
*(buffer___2 + len) = (char)c;
          }
          printf("\nSTMT_EXEC;;39971\n");
len++;
          printf("\nSTMT_EXEC;;39972\n");
goto while_break___23;
        }
      while_break___23: /* CIL Label */;
      }
        printf("\nSTMT_EXEC;;39976\n");
i++;
      }
    while_break___3: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;39980\n");
if (i == 0UL)
    {
      printf("\nSTMT_EXEC;;39982\n");
if ((unsigned int)quoting_style == 1U)
      {
        printf("\nSTMT_EXEC;;39984\n");
goto use_shell_always_quoting_style;
      }
    }
    printf("\nSTMT_EXEC;;39987\n");
if (quote_string)
    {
      {
        printf("\nSTMT_EXEC;;39990\n");
while (1)
        {
        while_continue___24: /* CIL Label */;
          printf("\nSTMT_EXEC;;39993\n");
if (!*quote_string)
          {
            printf("\nSTMT_EXEC;;39995\n");
goto while_break___24;
          }
          {
            printf("\nSTMT_EXEC;;39998\n");
while (1)
            {
            while_continue___25: /* CIL Label */;
              printf("\nSTMT_EXEC;;40001\n");
if (len < buffersize)
              {
                printf("\nSTMT_EXEC;;40003\n");
*(buffer___2 + len) = (char)*quote_string;
              }
              printf("\nSTMT_EXEC;;40005\n");
len++;
              printf("\nSTMT_EXEC;;40006\n");
goto while_break___25;
            }
          while_break___25: /* CIL Label */;
          }
          printf("\nSTMT_EXEC;;40010\n");
quote_string++;
        }
      while_break___24: /* CIL Label */;
      }
    }
    printf("\nSTMT_EXEC;;40015\n");
if (len < buffersize)
    {
      printf("\nSTMT_EXEC;;40017\n");
*(buffer___2 + len) = (char)'\000';
    }
    printf("\nSTMT_EXEC;;40019\n");
printf("\nFUNC_RETURN;;\n");
return (len);
  use_shell_always_quoting_style:







  {
    printf("\nSTMT_EXEC;;40029\n");
tmp___7 = quotearg_buffer_restyled(buffer___2, buffersize, arg, argsize, (enum quoting_style)2, o___0);
  }
    printf("\nSTMT_EXEC;;40031\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___7);
  }
printf("\nFUNC_RETURN;;\n");
}
size_t quotearg_buffer(char *buffer___2, size_t buffersize, char const *arg, size_t argsize, struct quoting_options const *o___0)
{
  printf("\nFUNC_CALL;quotearg_buffer(char *,size_t,const char *,size_t,const struct quoting_options *);\n");
printf("\nSTMT_EXEC;;40036\n");
struct quoting_options const *p;
  printf("\nSTMT_EXEC;;40037\n");
int e;
  printf("\nSTMT_EXEC;;40038\n");
int *tmp;
  printf("\nSTMT_EXEC;;40039\n");
size_t r;
  printf("\nSTMT_EXEC;;40040\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;40041\n");
int *tmp___1;

  {
    printf("\nSTMT_EXEC;;40044\n");
if (o___0)
    {
      printf("\nSTMT_EXEC;;40046\n");
p = o___0;
    }
    else
    {
      printf("\nSTMT_EXEC;;40050\n");
p = (struct quoting_options const *)(&default_quoting_options);
    }
    {
      printf("\nSTMT_EXEC;;40053\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;40054\n");
e = *tmp;
      printf("\nSTMT_EXEC;;40055\n");
tmp___0 = quotearg_buffer_restyled(buffer___2, buffersize, arg, argsize, (enum quoting_style)p->style, p);
      printf("\nSTMT_EXEC;;40056\n");
r = tmp___0;
      printf("\nSTMT_EXEC;;40057\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;40058\n");
*tmp___1 = e;
    }
    printf("\nSTMT_EXEC;;40060\n");
printf("\nFUNC_RETURN;;\n");
return (r);
  }
printf("\nFUNC_RETURN;;\n");
}
static char slot0[256];































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static char *quotearg_n_options(int n, char const *arg, size_t argsize, struct quoting_options const *options);
static unsigned int nslots = 1U;
static struct slotvec slotvec0 = {sizeof(slot0), slot0};
static struct slotvec *slotvec = &slotvec0;
static char *quotearg_n_options(int n, char const *arg, size_t argsize, struct quoting_options const *options)
{
  printf("\nFUNC_CALL;quotearg_n_options(int,const char *,size_t,const struct quoting_options *);\n");
printf("\nSTMT_EXEC;;41349\n");
int e;
  printf("\nSTMT_EXEC;;41350\n");
int *tmp;
  printf("\nSTMT_EXEC;;41351\n");
unsigned int n0;
  printf("\nSTMT_EXEC;;41352\n");
unsigned int n1;
  printf("\nSTMT_EXEC;;41353\n");
void *tmp___0;
  printf("\nSTMT_EXEC;;41354\n");
void *tmp___1;
  printf("\nSTMT_EXEC;;41355\n");
size_t size;
  printf("\nSTMT_EXEC;;41356\n");
char *val;
  printf("\nSTMT_EXEC;;41357\n");
size_t qsize;
  printf("\nSTMT_EXEC;;41358\n");
size_t tmp___2;
  printf("\nSTMT_EXEC;;41359\n");
void *tmp___3;
  printf("\nSTMT_EXEC;;41360\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;41361\n");
int tmp___5;

  {
    {
      printf("\nSTMT_EXEC;;41365\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41366\n");
e = *tmp;
      printf("\nSTMT_EXEC;;41367\n");
n0 = (unsigned int)n;
    }
    printf("\nSTMT_EXEC;;41369\n");
if (n < 0)
    {
      {
        printf("\nSTMT_EXEC;;41372\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;41375\n");
if (nslots <= n0)
    {
      printf("\nSTMT_EXEC;;41377\n");
n1 = n0 + 1U;
      printf("\nSTMT_EXEC;;41378\n");
if (sizeof(ptrdiff_t) <= sizeof(size_t))
      {
        printf("\nSTMT_EXEC;;41380\n");
tmp___5 = -1;
      }
      else
      {
        printf("\nSTMT_EXEC;;41384\n");
tmp___5 = -2;
      }
      printf("\nSTMT_EXEC;;41386\n");
if ((size_t)tmp___5 / sizeof(*slotvec) < (size_t)n1)
      {
        {
          printf("\nSTMT_EXEC;;41389\n");
xalloc_die();
        }
      }
      printf("\nSTMT_EXEC;;41392\n");
if ((unsigned long)slotvec == (unsigned long)(&slotvec0))
      {
        {
          printf("\nSTMT_EXEC;;41395\n");
tmp___0 = xmalloc(sizeof(*slotvec));
          printf("\nSTMT_EXEC;;41396\n");
slotvec = (struct slotvec *)tmp___0;
          printf("\nSTMT_EXEC;;41397\n");
*slotvec = slotvec0;
        }
      }
      {
        printf("\nSTMT_EXEC;;41401\n");
tmp___1 = xrealloc((void *)slotvec, (unsigned long)n1 * sizeof(*slotvec));
        printf("\nSTMT_EXEC;;41402\n");
slotvec = (struct slotvec *)tmp___1;
        printf("\nSTMT_EXEC;;41403\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(slotvec + nslots), 0, (unsigned long)(n1 - nslots) * sizeof(*slotvec));printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;41404\n");
nslots = n1;
      }
    }
    {
      printf("\nSTMT_EXEC;;41408\n");
size = (slotvec + n)->size;
      printf("\nSTMT_EXEC;;41409\n");
val = (slotvec + n)->val;
      printf("\nSTMT_EXEC;;41410\n");
tmp___2 = quotearg_buffer(val, size, arg, argsize, options);
      printf("\nSTMT_EXEC;;41411\n");
qsize = tmp___2;
    }
    printf("\nSTMT_EXEC;;41413\n");
if (size <= qsize)
    {
      printf("\nSTMT_EXEC;;41415\n");
size = qsize + 1UL;
      printf("\nSTMT_EXEC;;41416\n");
(slotvec + n)->size = size;
      printf("\nSTMT_EXEC;;41417\n");
if ((unsigned long)val != (unsigned long)(slot0))
      {
        {
          printf("\nSTMT_EXEC;;41420\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)val);printf("\nFUNC_RETURN;;\n");

        }
      }
      {
        printf("\nSTMT_EXEC;;41424\n");
tmp___3 = xmalloc(size);
        printf("\nSTMT_EXEC;;41425\n");
val = (char *)tmp___3;
        printf("\nSTMT_EXEC;;41426\n");
(slotvec + n)->val = val;
        printf("\nSTMT_EXEC;;41427\n");
quotearg_buffer(val, size, arg, argsize, options);
      }
    }
    {
      printf("\nSTMT_EXEC;;41431\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41432\n");
*tmp___4 = e;
    }
    printf("\nSTMT_EXEC;;41434\n");
printf("\nFUNC_RETURN;;\n");
return (val);
  }
printf("\nFUNC_RETURN;;\n");
}
char *quotearg_n(int n, char const *arg)
{
  printf("\nFUNC_CALL;quotearg_n(int,const char *);\n");
printf("\nSTMT_EXEC;;41439\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;41443\n");
tmp = quotearg_n_options(n, arg, (size_t)-1, (struct quoting_options const *)(&default_quoting_options));
    }
    printf("\nSTMT_EXEC;;41445\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
char *quotearg(char const *arg)
{
  printf("\nFUNC_CALL;quotearg(const char *);\n");
printf("\nSTMT_EXEC;;41450\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;41454\n");
tmp = quotearg_n(0, arg);
    }
    printf("\nSTMT_EXEC;;41456\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
static struct quoting_options quoting_options_from_style(enum quoting_style style)
{
  printf("\nFUNC_CALL;quoting_options_from_style(enum quoting_style);\n");
printf("\nSTMT_EXEC;;41461\n");
struct quoting_options o___0;
  printf("\nSTMT_EXEC;;41462\n");
void *__cil_tmp3;

  {
    {
      printf("\nSTMT_EXEC;;41466\n");
o___0.style = style;
      printf("\nSTMT_EXEC;;41467\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
memset((void *)(o___0.quote_these_too), 0, sizeof(o___0.quote_these_too));printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;41469\n");
printf("\nFUNC_RETURN;;\n");
return (o___0);
  }
printf("\nFUNC_RETURN;;\n");
}
char *quotearg_n_style(int n, enum quoting_style s, char const *arg)
{
  printf("\nFUNC_CALL;quotearg_n_style(int,enum quoting_style,const char *);\n");
printf("\nSTMT_EXEC;;41474\n");
struct quoting_options o___0;
  printf("\nSTMT_EXEC;;41475\n");
struct quoting_options tmp;
  printf("\nSTMT_EXEC;;41476\n");
char *tmp___0;
  printf("\nSTMT_EXEC;;41477\n");
void *__cil_tmp7;
  printf("\nSTMT_EXEC;;41478\n");
void *__cil_tmp8;

  {
    {
      printf("\nSTMT_EXEC;;41482\n");
tmp = quoting_options_from_style(s);
      printf("\nSTMT_EXEC;;41483\n");
o___0 = tmp;
      printf("\nSTMT_EXEC;;41484\n");
tmp___0 = quotearg_n_options(n, arg, (size_t)-1, (struct quoting_options const *)(&o___0));
    }
    printf("\nSTMT_EXEC;;41486\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
char *quotearg_char(char const *arg, char ch)
{
  printf("\nFUNC_CALL;quotearg_char(const char *,char);\n");
printf("\nSTMT_EXEC;;41491\n");
struct quoting_options options;
  printf("\nSTMT_EXEC;;41492\n");
char *tmp;
  printf("\nSTMT_EXEC;;41493\n");
void *__cil_tmp5;

  {
    {
      printf("\nSTMT_EXEC;;41497\n");
options = default_quoting_options;
      printf("\nSTMT_EXEC;;41498\n");
set_char_quoting(&options, ch, 1);
      printf("\nSTMT_EXEC;;41499\n");
tmp = quotearg_n_options(0, arg, (size_t)-1, (struct quoting_options const *)(&options));
    }
    printf("\nSTMT_EXEC;;41501\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
char *quotearg_colon(char const *arg)
{
  printf("\nFUNC_CALL;quotearg_colon(const char *);\n");
printf("\nSTMT_EXEC;;41506\n");
char *tmp;

  {
    {
      printf("\nSTMT_EXEC;;41510\n");
tmp = quotearg_char(arg, (char)':');
    }
    printf("\nSTMT_EXEC;;41512\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","023.quote.o.i","") */
/* #pragma merger("0","024.safe-read.o.i","") */
extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
size_t safe_read(int fd, void *buf, size_t count)
{
  printf("\nFUNC_CALL;safe_read(int,void *,size_t);\n");
printf("\nSTMT_EXEC;;41520\n");
ssize_t result;
  printf("\nSTMT_EXEC;;41521\n");
int *tmp;

  {
    printf("\nSTMT_EXEC;;41524\n");
if (count > 2147483647UL)
    {
      printf("\nSTMT_EXEC;;41526\n");
count = (size_t)2147475456;
    }
    {
      printf("\nSTMT_EXEC;;41529\n");
while (1)
      {
      while_continue: /* CIL Label */;



        {
          printf("\nSTMT_EXEC;;41536\n");
result = read(fd, buf, count);
        }
        printf("\nSTMT_EXEC;;41538\n");
if (result < 0L)
        {
          {
            printf("\nSTMT_EXEC;;41541\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;41543\n");
if (!(*tmp == 4))
          {
            printf("\nSTMT_EXEC;;41545\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;41550\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;









    }
    printf("\nSTMT_EXEC;;41564\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)result);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","025.safe-write.o.i","") */
extern ssize_t write(int __fd, void const *__buf, size_t __n);
size_t safe_write(int fd, void const *buf, size_t count)
{
  printf("\nFUNC_CALL;safe_write(int,const void *,size_t);\n");
printf("\nSTMT_EXEC;;41571\n");
ssize_t result;
  printf("\nSTMT_EXEC;;41572\n");
int *tmp;

  {
    printf("\nSTMT_EXEC;;41575\n");
if (count > 2147483647UL)
    {
      printf("\nSTMT_EXEC;;41577\n");
count = (size_t)2147475456;
    }
    {
      printf("\nSTMT_EXEC;;41580\n");
while (1)
      {
      while_continue: /* CIL Label */;



        {
          printf("\nSTMT_EXEC;;41587\n");
printf("\nFUNC_CALL;write(int,const void *,size_t);\n");
result = write(fd, buf, count);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;41589\n");
if (result < 0L)
        {
          {
            printf("\nSTMT_EXEC;;41592\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp = __errno_location();printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;41594\n");
if (!(*tmp == 4))
          {
            printf("\nSTMT_EXEC;;41596\n");
goto while_break;
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;41601\n");
goto while_break;
        }
      }
    while_break: /* CIL Label */;









    }
    printf("\nSTMT_EXEC;;41615\n");
printf("\nFUNC_RETURN;;\n");
return ((size_t)result);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","026.save-cwd.o.i","") */
extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchdir)(int __fd);
char *xgetcwd(void);
static int have_working_fchdir = 1;
int save_cwd(struct saved_cwd *cwd)
{

  printf("\nFUNC_CALL;save_cwd(struct saved_cwd *);\n");
{
    printf("\nSTMT_EXEC;;41626\n");
cwd->desc = -1;
    printf("\nSTMT_EXEC;;41627\n");
cwd->name = (char *)((void *)0);
    printf("\nSTMT_EXEC;;41628\n");
if (have_working_fchdir)
    {
      {
        printf("\nSTMT_EXEC;;41631\n");
printf("\nFUNC_CALL;open(const char *,int);\n");
cwd->desc = open(".", 65536);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41633\n");
if (cwd->desc < 0)
      {
        printf("\nSTMT_EXEC;;41635\n");
printf("\nFUNC_RETURN;;\n");
return (1);
      }
    }
    printf("\nSTMT_EXEC;;41638\n");
if (!have_working_fchdir)
    {
      {
        printf("\nSTMT_EXEC;;41641\n");
cwd->name = xgetcwd();
      }
      printf("\nSTMT_EXEC;;41643\n");
if ((unsigned long)cwd->name == (unsigned long)((void *)0))
      {
        printf("\nSTMT_EXEC;;41645\n");
printf("\nFUNC_RETURN;;\n");
return (1);
      }
    }
    printf("\nSTMT_EXEC;;41648\n");
printf("\nFUNC_RETURN;;\n");
return (0);
  }
printf("\nFUNC_RETURN;;\n");
}
int restore_cwd(struct saved_cwd const *cwd)
{
  printf("\nFUNC_CALL;restore_cwd(const struct saved_cwd *);\n");
printf("\nSTMT_EXEC;;41653\n");
int tmp;
  printf("\nSTMT_EXEC;;41654\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;41657\n");
if (0 <= (int)cwd->desc)
    {
      {
        printf("\nSTMT_EXEC;;41660\n");
printf("\nFUNC_CALL;fchdir(int);\n");
tmp = fchdir((int)cwd->desc);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41662\n");
printf("\nFUNC_RETURN;;\n");
return (tmp < 0);
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;41667\n");
printf("\nFUNC_CALL;chdir(const char *);\n");
tmp___0 = chdir((char const *)cwd->name);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41669\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0 < 0);
    }
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","027.savedir.o.i","") */
char *savedir(char const *dir)
{
  printf("\nFUNC_CALL;savedir(const char *);\n");
printf("\nSTMT_EXEC;;41676\n");
DIR *dirp;
  printf("\nSTMT_EXEC;;41677\n");
struct dirent *dp;
  printf("\nSTMT_EXEC;;41678\n");
char *name_space;
  printf("\nSTMT_EXEC;;41679\n");
size_t allocated;
  printf("\nSTMT_EXEC;;41680\n");
size_t used;
  printf("\nSTMT_EXEC;;41681\n");
int save_errno;
  printf("\nSTMT_EXEC;;41682\n");
void *tmp;
  printf("\nSTMT_EXEC;;41683\n");
int *tmp___0;
  printf("\nSTMT_EXEC;;41684\n");
char const *entry;
  printf("\nSTMT_EXEC;;41685\n");
size_t entry_size;
  printf("\nSTMT_EXEC;;41686\n");
size_t tmp___1;
  printf("\nSTMT_EXEC;;41687\n");
void *tmp___2;
  printf("\nSTMT_EXEC;;41688\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;41689\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;41690\n");
int tmp___5;
  printf("\nSTMT_EXEC;;41691\n");
int *tmp___6;
  printf("\nSTMT_EXEC;;41692\n");
int tmp___7;
  printf("\nSTMT_EXEC;;41693\n");
int tmp___8;

  {
    {
      printf("\nSTMT_EXEC;;41697\n");
allocated = (size_t)512;
      printf("\nSTMT_EXEC;;41698\n");
used = (size_t)0;
      printf("\nSTMT_EXEC;;41699\n");
printf("\nFUNC_CALL;opendir(const char *);\n");
dirp = opendir(dir);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;41701\n");
if ((unsigned long)dirp == (unsigned long)((void *)0))
    {
      printf("\nSTMT_EXEC;;41703\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)((void *)0));
    }
    {
      printf("\nSTMT_EXEC;;41706\n");
tmp = xmalloc(allocated);
      printf("\nSTMT_EXEC;;41707\n");
name_space = (char *)tmp;
      printf("\nSTMT_EXEC;;41708\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41709\n");
*tmp___0 = 0;
    }
    {
      printf("\nSTMT_EXEC;;41712\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;41716\n");
printf("\nFUNC_CALL;readdir(DIR *);\n");
dp = readdir(dirp);printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;41718\n");
if (!((unsigned long)dp != (unsigned long)((void *)0)))
        {
          printf("\nSTMT_EXEC;;41720\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;41722\n");
entry = (char const *)(dp->d_name);
        printf("\nSTMT_EXEC;;41723\n");
if ((int const) * (entry + 0) != 46)
        {
          printf("\nSTMT_EXEC;;41725\n");
tmp___8 = 0;
        }
        else
        {
          printf("\nSTMT_EXEC;;41729\n");
if ((int const) * (entry + 1) != 46)
          {
            printf("\nSTMT_EXEC;;41731\n");
tmp___7 = 1;
          }
          else
          {
            printf("\nSTMT_EXEC;;41735\n");
tmp___7 = 2;
          }
          printf("\nSTMT_EXEC;;41737\n");
tmp___8 = tmp___7;
        }
        printf("\nSTMT_EXEC;;41739\n");
if ((int const) * (entry + tmp___8) != 0)
        {
          {
            printf("\nSTMT_EXEC;;41742\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp___1 = strlen(entry);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;41743\n");
entry_size = tmp___1 + 1UL;
          }
          printf("\nSTMT_EXEC;;41745\n");
if (used + entry_size < used)
          {
            {
              printf("\nSTMT_EXEC;;41748\n");
xalloc_die();
            }
          }
          printf("\nSTMT_EXEC;;41751\n");
if (allocated <= used + entry_size)
          {
            {
              printf("\nSTMT_EXEC;;41754\n");
while (1)
              {
              while_continue___0: /* CIL Label */;
                printf("\nSTMT_EXEC;;41757\n");
if (2UL * allocated < allocated)
                {
                  {
                    printf("\nSTMT_EXEC;;41760\n");
xalloc_die();
                  }
                }
                printf("\nSTMT_EXEC;;41763\n");
allocated *= 2UL;
                printf("\nSTMT_EXEC;;41764\n");
if (!(allocated <= used + entry_size))
                {
                  printf("\nSTMT_EXEC;;41766\n");
goto while_break___0;
                }
              }
            while_break___0: /* CIL Label */;
            }
            {
              printf("\nSTMT_EXEC;;41772\n");
tmp___2 = xrealloc((void *)name_space, allocated);
              printf("\nSTMT_EXEC;;41773\n");
name_space = (char *)tmp___2;
            }
          }
          {
            printf("\nSTMT_EXEC;;41777\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
memcpy((void * /* __restrict  */)(name_space + used), (void const * /* __restrict  */)entry, entry_size);printf("\nFUNC_RETURN;;\n");

            printf("\nSTMT_EXEC;;41778\n");
used += entry_size;
          }
        }
      }
    while_break: /* CIL Label */;
    }
    {
      printf("\nSTMT_EXEC;;41785\n");
*(name_space + used) = (char)'\000';
      printf("\nSTMT_EXEC;;41786\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41787\n");
save_errno = *tmp___3;
      printf("\nSTMT_EXEC;;41788\n");
printf("\nFUNC_CALL;closedir(DIR *);\n");
tmp___5 = closedir(dirp);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;41790\n");
if (tmp___5 != 0)
    {
      {
        printf("\nSTMT_EXEC;;41793\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;41794\n");
save_errno = *tmp___4;
      }
    }
    printf("\nSTMT_EXEC;;41797\n");
if (save_errno != 0)
    {
      {
        printf("\nSTMT_EXEC;;41800\n");
printf("\nFUNC_CALL;free(void *);\n");
free((void *)name_space);printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;41801\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___6 = __errno_location();printf("\nFUNC_RETURN;;\n");

        printf("\nSTMT_EXEC;;41802\n");
*tmp___6 = save_errno;
      }
      printf("\nSTMT_EXEC;;41804\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)((void *)0));
    }
    printf("\nSTMT_EXEC;;41806\n");
printf("\nFUNC_RETURN;;\n");
return (name_space);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","028.stripslash.o.i","") */
int strip_trailing_slashes(char *path)
{
  printf("\nFUNC_CALL;strip_trailing_slashes(char *);\n");
printf("\nSTMT_EXEC;;41812\n");
char *base;
  printf("\nSTMT_EXEC;;41813\n");
char *tmp;
  printf("\nSTMT_EXEC;;41814\n");
char *base_lim;
  printf("\nSTMT_EXEC;;41815\n");
size_t tmp___0;
  printf("\nSTMT_EXEC;;41816\n");
int had_slash;

  {
    {
      printf("\nSTMT_EXEC;;41820\n");
tmp = base_name((char const *)path);
      printf("\nSTMT_EXEC;;41821\n");
base = tmp;
      printf("\nSTMT_EXEC;;41822\n");
tmp___0 = base_len((char const *)base);
      printf("\nSTMT_EXEC;;41823\n");
base_lim = base + tmp___0;
      printf("\nSTMT_EXEC;;41824\n");
had_slash = (int)*base_lim;
      printf("\nSTMT_EXEC;;41825\n");
*base_lim = (char)'\000';
    }
    printf("\nSTMT_EXEC;;41827\n");
printf("\nFUNC_RETURN;;\n");
return (had_slash);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","029.xgetcwd.o.i","") */
extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) getcwd)(char *__buf, size_t __size);
char *xgetcwd(void)
{
  printf("\nFUNC_CALL;xgetcwd();\n");
printf("\nSTMT_EXEC;;41834\n");
char *cwd;
  printf("\nSTMT_EXEC;;41835\n");
char *tmp;
  printf("\nSTMT_EXEC;;41836\n");
int *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;41840\n");
printf("\nFUNC_CALL;getcwd(char *,size_t);\n");
tmp = getcwd((char *)((void *)0), (size_t)0);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41841\n");
cwd = tmp;
    }
    printf("\nSTMT_EXEC;;41843\n");
if (!cwd)
    {
      {
        printf("\nSTMT_EXEC;;41846\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___0 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41848\n");
if (*tmp___0 == 12)
      {
        {
          printf("\nSTMT_EXEC;;41851\n");
xalloc_die();
        }
      }
    }
    printf("\nSTMT_EXEC;;41855\n");
printf("\nFUNC_RETURN;;\n");
return (cwd);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","02a.xmalloc.o.i","") */
char const xalloc_msg_memory_exhausted[17];
void *xclone(void const *p, size_t s);
extern __attribute__((__nothrow__)) void *(__attribute__((__warn_unused_result__, __leaf__)) realloc)(void *__ptr, size_t __size);
void (*xalloc_fail_func)(void) = (void (*)(void))0;
char const xalloc_msg_memory_exhausted[17] = {(char const)'m', (char const)'e', (char const)'m', (char const)'o', (char const)'r', (char const)'y', (char const)' ', (char const)'e', (char const)'x', (char const)'h', (char const)'a', (char const)'u', (char const)'s', (char const)'t', (char const)'e', (char const)'d', (char const)'\000'};
__attribute__((__noreturn__)) void xalloc_die(void);
void xalloc_die(void)
{
  printf("\nFUNC_CALL;xalloc_die();\n");
printf("\nSTMT_EXEC;;41867\n");
char *tmp;

  {
    printf("\nSTMT_EXEC;;41870\n");
if (xalloc_fail_func)
    {
      {
        printf("\nSTMT_EXEC;;41873\n");
(*xalloc_fail_func)();
      }
    }
    {
      printf("\nSTMT_EXEC;;41877\n");
printf("\nFUNC_CALL;gettext(const char *);\n");
tmp = gettext(xalloc_msg_memory_exhausted);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41878\n");
printf("\nFUNC_CALL;error(int,int,const char *);\n");
error((int)exit_failure, 0, "%s", tmp);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;41879\n");
printf("\nFUNC_CALL;abort();\n");
abort();printf("\nFUNC_RETURN;;\n");

    }






  }
printf("\nFUNC_RETURN;;\n");
}
__inline static void *xnmalloc_inline(size_t n, size_t s)
{
  printf("\nFUNC_CALL;xnmalloc_inline(size_t,size_t);\n");
printf("\nSTMT_EXEC;;41891\n");
void *p;
  printf("\nSTMT_EXEC;;41892\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;41895\n");
if (sizeof(ptrdiff_t) <= sizeof(size_t))
    {
      printf("\nSTMT_EXEC;;41897\n");
tmp = -1;
    }
    else
    {
      printf("\nSTMT_EXEC;;41901\n");
tmp = -2;
    }
    printf("\nSTMT_EXEC;;41903\n");
if ((size_t)tmp / s < n)
    {
      {
        printf("\nSTMT_EXEC;;41906\n");
xalloc_die();
      }
    }
    else

    {
      {
        printf("\nSTMT_EXEC;;41913\n");
printf("\nFUNC_CALL;malloc(size_t);\n");
p = malloc(n * s);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41915\n");
if (!p)
      {
        {
          printf("\nSTMT_EXEC;;41918\n");
xalloc_die();
        }















      }
    }
    printf("\nSTMT_EXEC;;41937\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }
printf("\nFUNC_RETURN;;\n");
}
void *xmalloc(size_t n)
{
  printf("\nFUNC_CALL;xmalloc(size_t);\n");
printf("\nSTMT_EXEC;;41942\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;41946\n");
tmp = xnmalloc_inline(n, (size_t)1);
    }
    printf("\nSTMT_EXEC;;41948\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
__inline static void *xnrealloc_inline(void *p, size_t n, size_t s)
{
  printf("\nFUNC_CALL;xnrealloc_inline(void *,size_t,size_t);\n");
printf("\nSTMT_EXEC;;41953\n");
int tmp;

  {
    printf("\nSTMT_EXEC;;41956\n");
if (sizeof(ptrdiff_t) <= sizeof(size_t))
    {
      printf("\nSTMT_EXEC;;41958\n");
tmp = -1;
    }
    else
    {
      printf("\nSTMT_EXEC;;41962\n");
tmp = -2;
    }
    printf("\nSTMT_EXEC;;41964\n");
if ((size_t)tmp / s < n)
    {
      {
        printf("\nSTMT_EXEC;;41967\n");
xalloc_die();
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;41973\n");
printf("\nFUNC_CALL;realloc(void *,size_t);\n");
p = realloc(p, n * s);printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;41975\n");
if (!p)
      {
        {
          printf("\nSTMT_EXEC;;41978\n");
xalloc_die();
        }
      }
    }
    printf("\nSTMT_EXEC;;41982\n");
printf("\nFUNC_RETURN;;\n");
return (p);
  }

























printf("\nFUNC_RETURN;;\n");
}
void *xrealloc(void *p, size_t n)
{
  printf("\nFUNC_CALL;xrealloc(void *,size_t);\n");
printf("\nSTMT_EXEC;;42012\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;42016\n");
tmp = xnrealloc_inline(p, n, (size_t)1);
    }
    printf("\nSTMT_EXEC;;42018\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
__inline static void *x2nrealloc_inline(void *p, size_t *pn, size_t s)
{
  printf("\nFUNC_CALL;x2nrealloc_inline(void *,size_t *,size_t);\n");
printf("\nSTMT_EXEC;;42023\n");
size_t n;
  printf("\nSTMT_EXEC;;42024\n");
void *tmp;

  {
    printf("\nSTMT_EXEC;;42027\n");
n = *pn;
    printf("\nSTMT_EXEC;;42028\n");
if (!p)
    {
      printf("\nSTMT_EXEC;;42030\n");
if (!n)
      {
        printf("\nSTMT_EXEC;;42032\n");
n = 64UL / s;
        printf("\nSTMT_EXEC;;42033\n");
n += (size_t)(!n);
      }
    }
    else
    {
      printf("\nSTMT_EXEC;;42038\n");
if (9223372036854775807UL / s < n)
      {
        {
          printf("\nSTMT_EXEC;;42041\n");
xalloc_die();
        }
      }
      printf("\nSTMT_EXEC;;42044\n");
n *= 2UL;
    }
    {
      printf("\nSTMT_EXEC;;42047\n");
*pn = n;





      printf("\nSTMT_EXEC;;42053\n");
tmp = xrealloc(p, n * s);
    }
    printf("\nSTMT_EXEC;;42055\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
void *x2nrealloc(void *p, size_t *pn, size_t s)
{
  printf("\nFUNC_CALL;x2nrealloc(void *,size_t *,size_t);\n");
printf("\nSTMT_EXEC;;42060\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;42064\n");
tmp = x2nrealloc_inline(p, pn, s);
    }
    printf("\nSTMT_EXEC;;42066\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
void *x2realloc(void *p, size_t *pn)
{
  printf("\nFUNC_CALL;x2realloc(void *,size_t *);\n");
printf("\nSTMT_EXEC;;42071\n");
void *tmp;

  {
    {
      printf("\nSTMT_EXEC;;42075\n");
tmp = x2nrealloc_inline(p, pn, (size_t)1);
    }
    printf("\nSTMT_EXEC;;42077\n");
printf("\nFUNC_RETURN;;\n");
return (tmp);
  }
printf("\nFUNC_RETURN;;\n");
}
void *xzalloc(size_t s)
{
  printf("\nFUNC_CALL;xzalloc(size_t);\n");
printf("\nSTMT_EXEC;;42082\n");
void *tmp;
  printf("\nSTMT_EXEC;;42083\n");
void *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;42087\n");
tmp = xmalloc(s);
      printf("\nSTMT_EXEC;;42088\n");
printf("\nFUNC_CALL;memset(void *,int,size_t);\n");
tmp___0 = memset(tmp, 0, s);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;42090\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
void *xclone(void const *p, size_t s)
{
  printf("\nFUNC_CALL;xclone(const void *,size_t);\n");
printf("\nSTMT_EXEC;;42095\n");
void *tmp;
  printf("\nSTMT_EXEC;;42096\n");
void *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;42100\n");
tmp = xmalloc(s);
      printf("\nSTMT_EXEC;;42101\n");
printf("\nFUNC_CALL;memcpy(void *__restrict,const void *__restrict,size_t);\n");
tmp___0 = memcpy((void * /* __restrict  */)tmp, (void const * /* __restrict  */)p, s);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;42103\n");
printf("\nFUNC_RETURN;;\n");
return (tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","02b.xstrdup.o.i","") */
char *xstrdup(char const *string)
{
  printf("\nFUNC_CALL;xstrdup(const char *);\n");
printf("\nSTMT_EXEC;;42109\n");
size_t tmp;
  printf("\nSTMT_EXEC;;42110\n");
void *tmp___0;

  {
    {
      printf("\nSTMT_EXEC;;42114\n");
printf("\nFUNC_CALL;strlen(const char *);\n");
tmp = strlen(string);printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;42115\n");
tmp___0 = xclone((void const *)string, tmp + 1UL);
    }
    printf("\nSTMT_EXEC;;42117\n");
printf("\nFUNC_RETURN;;\n");
return ((char *)tmp___0);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","02c.xstrtol.o.i","") */
extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__)) __assert_fail)(char const *__assertion, char const *__file, unsigned int __line, char const *__function);
extern __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__)) strtol)(char const *__restrict __nptr, char **__restrict __endptr, int __base);
/* #pragma merger("0","02d.xstrtoul.o.i","") */
static strtol_error bkm_scale___0(unsigned long *x, int scale_factor)
{

  printf("\nFUNC_CALL;bkm_scale___0(unsigned long *,int);\n");
{
    printf("\nSTMT_EXEC;;42128\n");
if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x)
    {
      printf("\nSTMT_EXEC;;42130\n");
*x = 0xffffffffffffffffUL;
      printf("\nSTMT_EXEC;;42131\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)1);
    }
    printf("\nSTMT_EXEC;;42133\n");
*x *= (unsigned long)scale_factor;
    printf("\nSTMT_EXEC;;42134\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static strtol_error bkm_scale_by_power___0(unsigned long *x, int base, int power)
{
  printf("\nFUNC_CALL;bkm_scale_by_power___0(unsigned long *,int,int);\n");
printf("\nSTMT_EXEC;;42139\n");
strtol_error err;
  printf("\nSTMT_EXEC;;42140\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;42141\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;42144\n");
err = (strtol_error)0;
    {
      printf("\nSTMT_EXEC;;42146\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;42149\n");
tmp___0 = power;
        printf("\nSTMT_EXEC;;42150\n");
power--;
        printf("\nSTMT_EXEC;;42151\n");
if (!tmp___0)
        {
          printf("\nSTMT_EXEC;;42153\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;42156\n");
tmp = bkm_scale___0(x, base);
          printf("\nSTMT_EXEC;;42157\n");
err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;42162\n");
printf("\nFUNC_RETURN;;\n");
return (err);
  }
printf("\nFUNC_RETURN;;\n");
}
strtol_error xstrtoul(char const *s, char **ptr, int strtol_base, unsigned long *val, char const *valid_suffixes)
{
  printf("\nFUNC_CALL;xstrtoul(const char *,char **,int,unsigned long *,const char *);\n");
printf("\nSTMT_EXEC;;42167\n");
char *t_ptr;
  printf("\nSTMT_EXEC;;42168\n");
char **p;
  printf("\nSTMT_EXEC;;42169\n");
unsigned long tmp;
  printf("\nSTMT_EXEC;;42170\n");
strtol_error err;
  printf("\nSTMT_EXEC;;42171\n");
char const *q;
  printf("\nSTMT_EXEC;;42172\n");
unsigned short const **tmp___0;
  printf("\nSTMT_EXEC;;42173\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;42174\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;42175\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;42176\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;42177\n");
int base;
  printf("\nSTMT_EXEC;;42178\n");
int suffixes;
  printf("\nSTMT_EXEC;;42179\n");
strtol_error overflow;
  printf("\nSTMT_EXEC;;42180\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;42181\n");
char *tmp___6;

  {
    printf("\nSTMT_EXEC;;42184\n");
err = (strtol_error)0;
    printf("\nSTMT_EXEC;;42185\n");
if (0 <= strtol_base)
    {
      printf("\nSTMT_EXEC;;42187\n");
if (!(strtol_base <= 36))
      {
        {
          printf("\nSTMT_EXEC;;42190\n");
printf("\nFUNC_CALL;__assert_fail(const char *,const char *,unsigned int,const char *);\n");
__assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U, "xstrtoul");printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;42197\n");
printf("\nFUNC_CALL;__assert_fail(const char *,const char *,unsigned int,const char *);\n");
__assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U, "xstrtoul");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;42200\n");
if (ptr)
    {
      printf("\nSTMT_EXEC;;42202\n");
p = ptr;
    }
    else
    {
      printf("\nSTMT_EXEC;;42206\n");
p = &t_ptr;
    }
    printf("\nSTMT_EXEC;;42208\n");
q = s;
    {
      printf("\nSTMT_EXEC;;42210\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;42214\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___0 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;42216\n");
if (!((int const) * (*tmp___0 + (int)((unsigned char)*q)) & 8192))
        {
          printf("\nSTMT_EXEC;;42218\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;42220\n");
q++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;42224\n");
if ((int const) * q == 45)
    {
      printf("\nSTMT_EXEC;;42226\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
    }
    {
      printf("\nSTMT_EXEC;;42229\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;42230\n");
*tmp___1 = 0;
      printf("\nSTMT_EXEC;;42231\n");
printf("\nFUNC_CALL;strtoul(const char *__restrict,char **__restrict,int);\n");
tmp = strtoul((char const * /* __restrict  */)s, (char ** /* __restrict  */)p, strtol_base);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;42233\n");
if ((unsigned long)*p == (unsigned long)s)
    {
      printf("\nSTMT_EXEC;;42235\n");
if (valid_suffixes)
      {
        printf("\nSTMT_EXEC;;42237\n");
if (*(*p))
        {
          {
            printf("\nSTMT_EXEC;;42240\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___2 = strchr(valid_suffixes, (int)*(*p));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;42242\n");
if (tmp___2)
          {
            printf("\nSTMT_EXEC;;42244\n");
tmp = 1UL;
          }
          else
          {
            printf("\nSTMT_EXEC;;42248\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;42253\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;42258\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;42264\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42266\n");
if (*tmp___4 != 0)
      {
        {
          printf("\nSTMT_EXEC;;42269\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;42271\n");
if (*tmp___3 != 34)
        {
          printf("\nSTMT_EXEC;;42273\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
        }
        printf("\nSTMT_EXEC;;42275\n");
err = (strtol_error)1;
      }
    }
    printf("\nSTMT_EXEC;;42278\n");
if (!valid_suffixes)
    {
      printf("\nSTMT_EXEC;;42280\n");
*val = tmp;
      printf("\nSTMT_EXEC;;42281\n");
printf("\nFUNC_RETURN;;\n");
return (err);
    }
    printf("\nSTMT_EXEC;;42283\n");
if ((int)*(*p) != 0)
    {
      {
        printf("\nSTMT_EXEC;;42286\n");
base = 1024;
        printf("\nSTMT_EXEC;;42287\n");
suffixes = 1;
        printf("\nSTMT_EXEC;;42288\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___5 = strchr(valid_suffixes, (int)*(*p));printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42290\n");
if (!tmp___5)
      {
        printf("\nSTMT_EXEC;;42292\n");
*val = tmp;
        printf("\nSTMT_EXEC;;42293\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)((unsigned int)err | 2U));
      }
      {
        printf("\nSTMT_EXEC;;42296\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___6 = strchr(valid_suffixes, '0');printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42298\n");
if (tmp___6)
      {
        {
          printf("\nSTMT_EXEC;;42301\n");
if ((int)*(*(p + 0) + 1) == 105)
          {
            printf("\nSTMT_EXEC;;42303\n");
goto case_105;
          }
          printf("\nSTMT_EXEC;;42305\n");
if ((int)*(*(p + 0) + 1) == 66)
          {
            printf("\nSTMT_EXEC;;42307\n");
goto case_66;
          }
          printf("\nSTMT_EXEC;;42309\n");
if ((int)*(*(p + 0) + 1) == 68)
          {
            printf("\nSTMT_EXEC;;42311\n");
goto case_66;
          }
          printf("\nSTMT_EXEC;;42313\n");
goto switch_break;
        case_105: /* CIL Label */
          {
printf("\nSTMT_EXEC;;42315\n");
if ((int)*(*(p + 0) + 2) == 66)
          {
            printf("\nSTMT_EXEC;;42317\n");
suffixes += 2;
          }
}

          printf("\nSTMT_EXEC;;42319\n");
goto switch_break;
        case_66: /* CIL Label */
        case_68: /* CIL Label */
          {
printf("\nSTMT_EXEC;;42322\n");
base = 1000;
}

          printf("\nSTMT_EXEC;;42323\n");
suffixes++;
          printf("\nSTMT_EXEC;;42324\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
      }
      {
        printf("\nSTMT_EXEC;;42329\n");
if ((int)*(*p) == 98)
        {
          printf("\nSTMT_EXEC;;42331\n");
goto case_98;
        }
        printf("\nSTMT_EXEC;;42333\n");
if ((int)*(*p) == 66)
        {
          printf("\nSTMT_EXEC;;42335\n");
goto case_66___0;
        }
        printf("\nSTMT_EXEC;;42337\n");
if ((int)*(*p) == 99)
        {
          printf("\nSTMT_EXEC;;42339\n");
goto case_99;
        }
        printf("\nSTMT_EXEC;;42341\n");
if ((int)*(*p) == 69)
        {
          printf("\nSTMT_EXEC;;42343\n");
goto case_69;
        }
        printf("\nSTMT_EXEC;;42345\n");
if ((int)*(*p) == 71)
        {
          printf("\nSTMT_EXEC;;42347\n");
goto case_71;
        }
        printf("\nSTMT_EXEC;;42349\n");
if ((int)*(*p) == 103)
        {
          printf("\nSTMT_EXEC;;42351\n");
goto case_71;
        }
        printf("\nSTMT_EXEC;;42353\n");
if ((int)*(*p) == 107)
        {
          printf("\nSTMT_EXEC;;42355\n");
goto case_107;
        }
        printf("\nSTMT_EXEC;;42357\n");
if ((int)*(*p) == 75)
        {
          printf("\nSTMT_EXEC;;42359\n");
goto case_107;
        }
        printf("\nSTMT_EXEC;;42361\n");
if ((int)*(*p) == 77)
        {
          printf("\nSTMT_EXEC;;42363\n");
goto case_77;
        }
        printf("\nSTMT_EXEC;;42365\n");
if ((int)*(*p) == 109)
        {
          printf("\nSTMT_EXEC;;42367\n");
goto case_77;
        }
        printf("\nSTMT_EXEC;;42369\n");
if ((int)*(*p) == 80)
        {
          printf("\nSTMT_EXEC;;42371\n");
goto case_80;
        }
        printf("\nSTMT_EXEC;;42373\n");
if ((int)*(*p) == 84)
        {
          printf("\nSTMT_EXEC;;42375\n");
goto case_84;
        }
        printf("\nSTMT_EXEC;;42377\n");
if ((int)*(*p) == 116)
        {
          printf("\nSTMT_EXEC;;42379\n");
goto case_84;
        }
        printf("\nSTMT_EXEC;;42381\n");
if ((int)*(*p) == 119)
        {
          printf("\nSTMT_EXEC;;42383\n");
goto case_119;
        }
        printf("\nSTMT_EXEC;;42385\n");
if ((int)*(*p) == 89)
        {
          printf("\nSTMT_EXEC;;42387\n");
goto case_89;
        }
        printf("\nSTMT_EXEC;;42389\n");
if ((int)*(*p) == 90)
        {
          printf("\nSTMT_EXEC;;42391\n");
goto case_90;
        }
        printf("\nSTMT_EXEC;;42393\n");
goto switch_default;
      case_98: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42396\n");
overflow = bkm_scale___0(&tmp, 512);
      }
        printf("\nSTMT_EXEC;;42398\n");
goto switch_break___0;
      case_66___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42401\n");
overflow = bkm_scale___0(&tmp, 1024);
      }
        printf("\nSTMT_EXEC;;42403\n");
goto switch_break___0;
      case_99: /* CIL Label */
        {
printf("\nSTMT_EXEC;;42405\n");
overflow = (strtol_error)0;
}

        printf("\nSTMT_EXEC;;42406\n");
goto switch_break___0;
      case_69: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42409\n");
overflow = bkm_scale_by_power___0(&tmp, base, 6);
      }
        printf("\nSTMT_EXEC;;42411\n");
goto switch_break___0;
      case_71:  /* CIL Label */
      case_103: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42415\n");
overflow = bkm_scale_by_power___0(&tmp, base, 3);
      }
        printf("\nSTMT_EXEC;;42417\n");
goto switch_break___0;
      case_107: /* CIL Label */
      case_75:  /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42421\n");
overflow = bkm_scale_by_power___0(&tmp, base, 1);
      }
        printf("\nSTMT_EXEC;;42423\n");
goto switch_break___0;
      case_77:  /* CIL Label */
      case_109: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42427\n");
overflow = bkm_scale_by_power___0(&tmp, base, 2);
      }
        printf("\nSTMT_EXEC;;42429\n");
goto switch_break___0;
      case_80: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42432\n");
overflow = bkm_scale_by_power___0(&tmp, base, 5);
      }
        printf("\nSTMT_EXEC;;42434\n");
goto switch_break___0;
      case_84:  /* CIL Label */
      case_116: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42438\n");
overflow = bkm_scale_by_power___0(&tmp, base, 4);
      }
        printf("\nSTMT_EXEC;;42440\n");
goto switch_break___0;
      case_119: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42443\n");
overflow = bkm_scale___0(&tmp, 2);
      }
        printf("\nSTMT_EXEC;;42445\n");
goto switch_break___0;
      case_89: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42448\n");
overflow = bkm_scale_by_power___0(&tmp, base, 8);
      }
        printf("\nSTMT_EXEC;;42450\n");
goto switch_break___0;
      case_90: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42453\n");
overflow = bkm_scale_by_power___0(&tmp, base, 7);
      }
        printf("\nSTMT_EXEC;;42455\n");
goto switch_break___0;
      switch_default: /* CIL Label */
        {
printf("\nSTMT_EXEC;;42457\n");
*val = tmp;
}

        printf("\nSTMT_EXEC;;42458\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)((unsigned int)err | 2U));
      switch_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;42461\n");
err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
      printf("\nSTMT_EXEC;;42462\n");
*p += suffixes;
      printf("\nSTMT_EXEC;;42463\n");
if (*(*p))
      {
        printf("\nSTMT_EXEC;;42465\n");
err = (strtol_error)((unsigned int)err | 2U);
      }
    }
    printf("\nSTMT_EXEC;;42468\n");
*val = tmp;
    printf("\nSTMT_EXEC;;42469\n");
printf("\nFUNC_RETURN;;\n");
return (err);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","02e.xstrtoumax.o.i","") */
extern __attribute__((__nothrow__)) uintmax_t(__attribute__((__leaf__)) strtoumax)(char const *__restrict __nptr, char **__restrict __endptr, int __base);
static strtol_error bkm_scale___1(uintmax_t *x, int scale_factor)
{

  printf("\nFUNC_CALL;bkm_scale___1(uintmax_t *,int);\n");
{
    printf("\nSTMT_EXEC;;42478\n");
if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x)
    {
      printf("\nSTMT_EXEC;;42480\n");
*x = 0xffffffffffffffffUL;
      printf("\nSTMT_EXEC;;42481\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)1);
    }
    printf("\nSTMT_EXEC;;42483\n");
*x *= (uintmax_t)scale_factor;
    printf("\nSTMT_EXEC;;42484\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)0);
  }
printf("\nFUNC_RETURN;;\n");
}
static strtol_error bkm_scale_by_power___1(uintmax_t *x, int base, int power)
{
  printf("\nFUNC_CALL;bkm_scale_by_power___1(uintmax_t *,int,int);\n");
printf("\nSTMT_EXEC;;42489\n");
strtol_error err;
  printf("\nSTMT_EXEC;;42490\n");
strtol_error tmp;
  printf("\nSTMT_EXEC;;42491\n");
int tmp___0;

  {
    printf("\nSTMT_EXEC;;42494\n");
err = (strtol_error)0;
    {
      printf("\nSTMT_EXEC;;42496\n");
while (1)
      {
      while_continue: /* CIL Label */;
        printf("\nSTMT_EXEC;;42499\n");
tmp___0 = power;
        printf("\nSTMT_EXEC;;42500\n");
power--;
        printf("\nSTMT_EXEC;;42501\n");
if (!tmp___0)
        {
          printf("\nSTMT_EXEC;;42503\n");
goto while_break;
        }
        {
          printf("\nSTMT_EXEC;;42506\n");
tmp = bkm_scale___1(x, base);
          printf("\nSTMT_EXEC;;42507\n");
err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
        }
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;42512\n");
printf("\nFUNC_RETURN;;\n");
return (err);
  }
printf("\nFUNC_RETURN;;\n");
}
strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base, uintmax_t *val, char const *valid_suffixes)
{
  printf("\nFUNC_CALL;xstrtoumax(const char *,char **,int,uintmax_t *,const char *);\n");
printf("\nSTMT_EXEC;;42517\n");
char *t_ptr;
  printf("\nSTMT_EXEC;;42518\n");
char **p;
  printf("\nSTMT_EXEC;;42519\n");
uintmax_t tmp;
  printf("\nSTMT_EXEC;;42520\n");
strtol_error err;
  printf("\nSTMT_EXEC;;42521\n");
char const *q;
  printf("\nSTMT_EXEC;;42522\n");
unsigned short const **tmp___0;
  printf("\nSTMT_EXEC;;42523\n");
int *tmp___1;
  printf("\nSTMT_EXEC;;42524\n");
char *tmp___2;
  printf("\nSTMT_EXEC;;42525\n");
int *tmp___3;
  printf("\nSTMT_EXEC;;42526\n");
int *tmp___4;
  printf("\nSTMT_EXEC;;42527\n");
int base;
  printf("\nSTMT_EXEC;;42528\n");
int suffixes;
  printf("\nSTMT_EXEC;;42529\n");
strtol_error overflow;
  printf("\nSTMT_EXEC;;42530\n");
char *tmp___5;
  printf("\nSTMT_EXEC;;42531\n");
char *tmp___6;

  {
    printf("\nSTMT_EXEC;;42534\n");
err = (strtol_error)0;
    printf("\nSTMT_EXEC;;42535\n");
if (0 <= strtol_base)
    {
      printf("\nSTMT_EXEC;;42537\n");
if (!(strtol_base <= 36))
      {
        {
          printf("\nSTMT_EXEC;;42540\n");
printf("\nFUNC_CALL;__assert_fail(const char *,const char *,unsigned int,const char *);\n");
__assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U, "xstrtoumax");printf("\nFUNC_RETURN;;\n");

        }
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;42547\n");
printf("\nFUNC_CALL;__assert_fail(const char *,const char *,unsigned int,const char *);\n");
__assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U, "xstrtoumax");printf("\nFUNC_RETURN;;\n");

      }
    }
    printf("\nSTMT_EXEC;;42550\n");
if (ptr)
    {
      printf("\nSTMT_EXEC;;42552\n");
p = ptr;
    }
    else
    {
      printf("\nSTMT_EXEC;;42556\n");
p = &t_ptr;
    }
    printf("\nSTMT_EXEC;;42558\n");
q = s;
    {
      printf("\nSTMT_EXEC;;42560\n");
while (1)
      {
      while_continue: /* CIL Label */;
        {
          printf("\nSTMT_EXEC;;42564\n");
printf("\nFUNC_CALL;__ctype_b_loc();\n");
tmp___0 = __ctype_b_loc();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;42566\n");
if (!((int const) * (*tmp___0 + (int)((unsigned char)*q)) & 8192))
        {
          printf("\nSTMT_EXEC;;42568\n");
goto while_break;
        }
        printf("\nSTMT_EXEC;;42570\n");
q++;
      }
    while_break: /* CIL Label */;
    }
    printf("\nSTMT_EXEC;;42574\n");
if ((int const) * q == 45)
    {
      printf("\nSTMT_EXEC;;42576\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
    }
    {
      printf("\nSTMT_EXEC;;42579\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___1 = __errno_location();printf("\nFUNC_RETURN;;\n");

      printf("\nSTMT_EXEC;;42580\n");
*tmp___1 = 0;
      printf("\nSTMT_EXEC;;42581\n");
printf("\nFUNC_CALL;strtoumax(const char *__restrict,char **__restrict,int);\n");
tmp = strtoumax((char const * /* __restrict  */)s, (char ** /* __restrict  */)p, strtol_base);printf("\nFUNC_RETURN;;\n");

    }
    printf("\nSTMT_EXEC;;42583\n");
if ((unsigned long)*p == (unsigned long)s)
    {
      printf("\nSTMT_EXEC;;42585\n");
if (valid_suffixes)
      {
        printf("\nSTMT_EXEC;;42587\n");
if (*(*p))
        {
          {
            printf("\nSTMT_EXEC;;42590\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___2 = strchr(valid_suffixes, (int)*(*p));printf("\nFUNC_RETURN;;\n");

          }
          printf("\nSTMT_EXEC;;42592\n");
if (tmp___2)
          {
            printf("\nSTMT_EXEC;;42594\n");
tmp = (uintmax_t)1;
          }
          else
          {
            printf("\nSTMT_EXEC;;42598\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
          }
        }
        else
        {
          printf("\nSTMT_EXEC;;42603\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
        }
      }
      else
      {
        printf("\nSTMT_EXEC;;42608\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
      }
    }
    else
    {
      {
        printf("\nSTMT_EXEC;;42614\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___4 = __errno_location();printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42616\n");
if (*tmp___4 != 0)
      {
        {
          printf("\nSTMT_EXEC;;42619\n");
printf("\nFUNC_CALL;__errno_location();\n");
tmp___3 = __errno_location();printf("\nFUNC_RETURN;;\n");

        }
        printf("\nSTMT_EXEC;;42621\n");
if (*tmp___3 != 34)
        {
          printf("\nSTMT_EXEC;;42623\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)4);
        }
        printf("\nSTMT_EXEC;;42625\n");
err = (strtol_error)1;
      }
    }
    printf("\nSTMT_EXEC;;42628\n");
if (!valid_suffixes)
    {
      printf("\nSTMT_EXEC;;42630\n");
*val = tmp;
      printf("\nSTMT_EXEC;;42631\n");
printf("\nFUNC_RETURN;;\n");
return (err);
    }
    printf("\nSTMT_EXEC;;42633\n");
if ((int)*(*p) != 0)
    {
      {
        printf("\nSTMT_EXEC;;42636\n");
base = 1024;
        printf("\nSTMT_EXEC;;42637\n");
suffixes = 1;
        printf("\nSTMT_EXEC;;42638\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___5 = strchr(valid_suffixes, (int)*(*p));printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42640\n");
if (!tmp___5)
      {
        printf("\nSTMT_EXEC;;42642\n");
*val = tmp;
        printf("\nSTMT_EXEC;;42643\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)((unsigned int)err | 2U));
      }
      {
        printf("\nSTMT_EXEC;;42646\n");
printf("\nFUNC_CALL;strchr(const char *,int);\n");
tmp___6 = strchr(valid_suffixes, '0');printf("\nFUNC_RETURN;;\n");

      }
      printf("\nSTMT_EXEC;;42648\n");
if (tmp___6)
      {
        {
          printf("\nSTMT_EXEC;;42651\n");
if ((int)*(*(p + 0) + 1) == 105)
          {
            printf("\nSTMT_EXEC;;42653\n");
goto case_105;
          }
          printf("\nSTMT_EXEC;;42655\n");
if ((int)*(*(p + 0) + 1) == 66)
          {
            printf("\nSTMT_EXEC;;42657\n");
goto case_66;
          }
          printf("\nSTMT_EXEC;;42659\n");
if ((int)*(*(p + 0) + 1) == 68)
          {
            printf("\nSTMT_EXEC;;42661\n");
goto case_66;
          }
          printf("\nSTMT_EXEC;;42663\n");
goto switch_break;
        case_105: /* CIL Label */
          {
printf("\nSTMT_EXEC;;42665\n");
if ((int)*(*(p + 0) + 2) == 66)
          {
            printf("\nSTMT_EXEC;;42667\n");
suffixes += 2;
          }
}

          printf("\nSTMT_EXEC;;42669\n");
goto switch_break;
        case_66: /* CIL Label */
        case_68: /* CIL Label */
          {
printf("\nSTMT_EXEC;;42672\n");
base = 1000;
}

          printf("\nSTMT_EXEC;;42673\n");
suffixes++;
          printf("\nSTMT_EXEC;;42674\n");
goto switch_break;
        switch_break: /* CIL Label */;
        }
      }
      {
        printf("\nSTMT_EXEC;;42679\n");
if ((int)*(*p) == 98)
        {
          printf("\nSTMT_EXEC;;42681\n");
goto case_98;
        }
        printf("\nSTMT_EXEC;;42683\n");
if ((int)*(*p) == 66)
        {
          printf("\nSTMT_EXEC;;42685\n");
goto case_66___0;
        }
        printf("\nSTMT_EXEC;;42687\n");
if ((int)*(*p) == 99)
        {
          printf("\nSTMT_EXEC;;42689\n");
goto case_99;
        }
        printf("\nSTMT_EXEC;;42691\n");
if ((int)*(*p) == 69)
        {
          printf("\nSTMT_EXEC;;42693\n");
goto case_69;
        }
        printf("\nSTMT_EXEC;;42695\n");
if ((int)*(*p) == 71)
        {
          printf("\nSTMT_EXEC;;42697\n");
goto case_71;
        }
        printf("\nSTMT_EXEC;;42699\n");
if ((int)*(*p) == 103)
        {
          printf("\nSTMT_EXEC;;42701\n");
goto case_71;
        }
        printf("\nSTMT_EXEC;;42703\n");
if ((int)*(*p) == 107)
        {
          printf("\nSTMT_EXEC;;42705\n");
goto case_107;
        }
        printf("\nSTMT_EXEC;;42707\n");
if ((int)*(*p) == 75)
        {
          printf("\nSTMT_EXEC;;42709\n");
goto case_107;
        }
        printf("\nSTMT_EXEC;;42711\n");
if ((int)*(*p) == 77)
        {
          printf("\nSTMT_EXEC;;42713\n");
goto case_77;
        }
        printf("\nSTMT_EXEC;;42715\n");
if ((int)*(*p) == 109)
        {
          printf("\nSTMT_EXEC;;42717\n");
goto case_77;
        }
        printf("\nSTMT_EXEC;;42719\n");
if ((int)*(*p) == 80)
        {
          printf("\nSTMT_EXEC;;42721\n");
goto case_80;
        }
        printf("\nSTMT_EXEC;;42723\n");
if ((int)*(*p) == 84)
        {
          printf("\nSTMT_EXEC;;42725\n");
goto case_84;
        }
        printf("\nSTMT_EXEC;;42727\n");
if ((int)*(*p) == 116)
        {
          printf("\nSTMT_EXEC;;42729\n");
goto case_84;
        }
        printf("\nSTMT_EXEC;;42731\n");
if ((int)*(*p) == 119)
        {
          printf("\nSTMT_EXEC;;42733\n");
goto case_119;
        }
        printf("\nSTMT_EXEC;;42735\n");
if ((int)*(*p) == 89)
        {
          printf("\nSTMT_EXEC;;42737\n");
goto case_89;
        }
        printf("\nSTMT_EXEC;;42739\n");
if ((int)*(*p) == 90)
        {
          printf("\nSTMT_EXEC;;42741\n");
goto case_90;
        }
        printf("\nSTMT_EXEC;;42743\n");
goto switch_default;
      case_98: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42746\n");
overflow = bkm_scale___1(&tmp, 512);
      }
        printf("\nSTMT_EXEC;;42748\n");
goto switch_break___0;
      case_66___0: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42751\n");
overflow = bkm_scale___1(&tmp, 1024);
      }
        printf("\nSTMT_EXEC;;42753\n");
goto switch_break___0;
      case_99: /* CIL Label */
        {
printf("\nSTMT_EXEC;;42755\n");
overflow = (strtol_error)0;
}

        printf("\nSTMT_EXEC;;42756\n");
goto switch_break___0;
      case_69: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42759\n");
overflow = bkm_scale_by_power___1(&tmp, base, 6);
      }
        printf("\nSTMT_EXEC;;42761\n");
goto switch_break___0;
      case_71:  /* CIL Label */
      case_103: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42765\n");
overflow = bkm_scale_by_power___1(&tmp, base, 3);
      }
        printf("\nSTMT_EXEC;;42767\n");
goto switch_break___0;
      case_107: /* CIL Label */
      case_75:  /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42771\n");
overflow = bkm_scale_by_power___1(&tmp, base, 1);
      }
        printf("\nSTMT_EXEC;;42773\n");
goto switch_break___0;
      case_77:  /* CIL Label */
      case_109: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42777\n");
overflow = bkm_scale_by_power___1(&tmp, base, 2);
      }
        printf("\nSTMT_EXEC;;42779\n");
goto switch_break___0;
      case_80: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42782\n");
overflow = bkm_scale_by_power___1(&tmp, base, 5);
      }
        printf("\nSTMT_EXEC;;42784\n");
goto switch_break___0;
      case_84:  /* CIL Label */
      case_116: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42788\n");
overflow = bkm_scale_by_power___1(&tmp, base, 4);
      }
        printf("\nSTMT_EXEC;;42790\n");
goto switch_break___0;
      case_119: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42793\n");
overflow = bkm_scale___1(&tmp, 2);
      }
        printf("\nSTMT_EXEC;;42795\n");
goto switch_break___0;
      case_89: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42798\n");
overflow = bkm_scale_by_power___1(&tmp, base, 8);
      }
        printf("\nSTMT_EXEC;;42800\n");
goto switch_break___0;
      case_90: /* CIL Label */
      {
        printf("\nSTMT_EXEC;;42803\n");
overflow = bkm_scale_by_power___1(&tmp, base, 7);
      }
        printf("\nSTMT_EXEC;;42805\n");
goto switch_break___0;
      switch_default: /* CIL Label */
        {
printf("\nSTMT_EXEC;;42807\n");
*val = tmp;
}

        printf("\nSTMT_EXEC;;42808\n");
printf("\nFUNC_RETURN;;\n");
return ((strtol_error)((unsigned int)err | 2U));
      switch_break___0: /* CIL Label */;
      }
      printf("\nSTMT_EXEC;;42811\n");
err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
      printf("\nSTMT_EXEC;;42812\n");
*p += suffixes;
      printf("\nSTMT_EXEC;;42813\n");
if (*(*p))
      {
        printf("\nSTMT_EXEC;;42815\n");
err = (strtol_error)((unsigned int)err | 2U);
      }
    }
    printf("\nSTMT_EXEC;;42818\n");
*val = tmp;
    printf("\nSTMT_EXEC;;42819\n");
printf("\nFUNC_RETURN;;\n");
return (err);
  }
printf("\nFUNC_RETURN;;\n");
}
/* #pragma merger("0","../../lib/addext.o.i","") */
/* #pragma merger("0","../../lib/argmatch.o.i","") */
/* #pragma merger("0","../../lib/backupfile.o.i","") */
/* #pragma merger("0","../../lib/basename.o.i","") */
/* #pragma merger("0","../../lib/dirname.o.i","") */
/* #pragma merger("0","../../lib/exclude.o.i","") */
/* #pragma merger("0","../../lib/exitfail.o.i","") */
/* #pragma merger("0","../../lib/full-write.o.i","") */
/* #pragma merger("0","../../lib/getdate.o.i","") */
/* #pragma merger("0","../../lib/getopt1.o.i","") */
/* #pragma merger("0","../../lib/getopt.o.i","") */
/* #pragma merger("0","../../lib/gettime.o.i","") */
/* #pragma merger("0","../../lib/hash.o.i","") */
/* #pragma merger("0","../../lib/human.o.i","") */
/* #pragma merger("0","../../lib/mktime.o.i","") */
/* #pragma merger("0","../../lib/modechange.o.i","") */
/* #pragma merger("0","../../lib/prepargs.o.i","") */
/* #pragma merger("0","../../lib/quotearg.o.i","") */
/* #pragma merger("0","../../lib/quote.o.i","") */
/* #pragma merger("0","../../lib/safe-read.o.i","") */
/* #pragma merger("0","../../lib/safe-write.o.i","") */
/* #pragma merger("0","../../lib/save-cwd.o.i","") */
/* #pragma merger("0","../../lib/savedir.o.i","") */
/* #pragma merger("0","../../lib/stripslash.o.i","") */
/* #pragma merger("0","../../lib/xgetcwd.o.i","") */
/* #pragma merger("0","../../lib/xmalloc.o.i","") */
/* #pragma merger("0","../../lib/xstrdup.o.i","") */
/* #pragma merger("0","../../lib/xstrtol.o.i","") */
/* #pragma merger("0","../../lib/xstrtoul.o.i","") */
/* #pragma merger("0","../../lib/xstrtoumax.o.i","") */